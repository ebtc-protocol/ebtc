<style> code { white-space: pre-wrap; display: block; background-color: #eee; }.executed { background-color: #afa; }.reverted { background-color: #ffa; }.unexecuted { background-color: #faa; }.neutral { background-color: #eee; }</style><b>/mnt/c/Users/Lourens/Documents/Recon-Fuzz/collabs/ebtc/packages/contracts/contracts/ActivePool.sol</b>
<code>
   1 |     | <span class='unexecuted'>// SPDX-License-Identifier: MIT</span>
   2 |     | <span class='neutral'></span>
   3 |     | <span class='neutral'>pragma solidity 0.8.17;</span>
   4 |     | <span class='neutral'></span>
   5 |     | <span class='neutral'>import &quot;./Interfaces/IActivePool.sol&quot;;</span>
   6 |     | <span class='neutral'>import &quot;./Interfaces/ICollSurplusPool.sol&quot;;</span>
   7 |     | <span class='neutral'>import &quot;./Dependencies/ICollateralToken.sol&quot;;</span>
   8 |     | <span class='neutral'>import &quot;./Interfaces/ICdpManagerData.sol&quot;;</span>
   9 |     | <span class='neutral'>import &quot;./Interfaces/IBorrowerOperations.sol&quot;;</span>
  10 |     | <span class='neutral'>import &quot;./Dependencies/ERC3156FlashLender.sol&quot;;</span>
  11 |     | <span class='neutral'>import &quot;./Dependencies/SafeERC20.sol&quot;;</span>
  12 |     | <span class='neutral'>import &quot;./Dependencies/ReentrancyGuard.sol&quot;;</span>
  13 |     | <span class='neutral'>import &quot;./Dependencies/AuthNoOwner.sol&quot;;</span>
  14 |     | <span class='neutral'>import &quot;./Dependencies/BaseMath.sol&quot;;</span>
  15 |     | <span class='neutral'>import &quot;./Dependencies/TwapWeightedObserver.sol&quot;;</span>
  16 |     | <span class='neutral'>import &quot;./Dependencies/EbtcMath.sol&quot;;</span>
  17 |     | <span class='neutral'></span>
  18 |     | <span class='neutral'>/**</span>
  19 |     | <span class='neutral'> * @title The Active Pool holds the collateral and EBTC debt (only accounting but not EBTC tokens) for all active cdps.</span>
  20 |     | <span class='neutral'> *</span>
  21 |     | <span class='neutral'> * @notice When a cdp is liquidated, it&#39;s collateral will be transferred from the Active Pool</span>
  22 |     | <span class='neutral'> * @notice (destination may vary depending on the liquidation conditions).</span>
  23 |     | <span class='neutral'> * @dev ActivePool also allows ERC3156 compatible flashloan of stETH token</span>
  24 |     | <span class='neutral'> */</span>
  25 |     | <span class='unexecuted'>contract ActivePool is</span>
  26 |     | <span class='neutral'>    IActivePool,</span>
  27 |     | <span class='neutral'>    ERC3156FlashLender,</span>
  28 |     | <span class='neutral'>    ReentrancyGuard,</span>
  29 |     | <span class='neutral'>    BaseMath,</span>
  30 |     | <span class='neutral'>    AuthNoOwner,</span>
  31 |     | <span class='neutral'>    TwapWeightedObserver</span>
  32 |     | <span class='neutral'>{</span>
  33 |     | <span class='neutral'>    using SafeERC20 for IERC20;</span>
  34 |     | <span class='unexecuted'>    string public constant NAME = &quot;ActivePool&quot;;</span>
  35 |     | <span class='neutral'></span>
  36 |     | <span class='unexecuted'>    address public immutable borrowerOperationsAddress;</span>
  37 |     | <span class='unexecuted'>    address public immutable cdpManagerAddress;</span>
  38 |     | <span class='unexecuted'>    address public immutable collSurplusPoolAddress;</span>
  39 |     | <span class='unexecuted'>    address public immutable feeRecipientAddress;</span>
  40 |     | <span class='neutral'></span>
  41 |     | <span class='neutral'>    uint256 internal systemCollShares; // deposited collateral tracker</span>
  42 |     | <span class='neutral'>    uint256 internal systemDebt;</span>
  43 |     | <span class='neutral'>    uint256 internal feeRecipientCollShares; // coll shares claimable by fee recipient</span>
  44 |     | <span class='unexecuted'>    ICollateralToken public immutable collateral;</span>
  45 |     | <span class='neutral'></span>
  46 |     | <span class='neutral'>    // --- Contract setters ---</span>
  47 |     | <span class='neutral'></span>
  48 |     | <span class='neutral'>    /// @notice Constructor for the ActivePool contract</span>
  49 |     | <span class='neutral'>    /// @dev Initializes the contract with the borrowerOperationsAddress, cdpManagerAddress, collateral token address, collSurplusAddress, and feeRecipientAddress</span>
  50 |     | <span class='neutral'>    /// @param _borrowerOperationsAddress The address of the Borrower Operations contract</span>
  51 |     | <span class='neutral'>    /// @param _cdpManagerAddress The address of the Cdp Manager contract</span>
  52 |     | <span class='neutral'>    /// @param _collTokenAddress The address of the collateral token</span>
  53 |     | <span class='neutral'>    /// @param _collSurplusAddress The address of the collateral surplus pool</span>
  54 |     | <span class='neutral'></span>
  55 |     | <span class='unexecuted'>    constructor(</span>
  56 |     | <span class='neutral'>        address _borrowerOperationsAddress,</span>
  57 |     | <span class='neutral'>        address _cdpManagerAddress,</span>
  58 |     | <span class='neutral'>        address _collTokenAddress,</span>
  59 |     | <span class='neutral'>        address _collSurplusAddress</span>
  60 |     | <span class='unexecuted'>    ) TwapWeightedObserver(0) {</span>
  61 |     | <span class='unexecuted'>        borrowerOperationsAddress = _borrowerOperationsAddress;</span>
  62 |     | <span class='unexecuted'>        cdpManagerAddress = _cdpManagerAddress;</span>
  63 |     | <span class='unexecuted'>        collateral = ICollateralToken(_collTokenAddress);</span>
  64 |     | <span class='unexecuted'>        collSurplusPoolAddress = _collSurplusAddress;</span>
  65 |     | <span class='unexecuted'>        feeRecipientAddress = IBorrowerOperations(borrowerOperationsAddress).feeRecipientAddress();</span>
  66 |     | <span class='neutral'></span>
  67 |     | <span class='neutral'>        // TEMP: read authority to avoid signature change</span>
  68 |     | <span class='unexecuted'>        address _authorityAddress = address(AuthNoOwner(cdpManagerAddress).authority());</span>
  69 |     | <span class='unexecuted'>        if (_authorityAddress != address(0)) {</span>
  70 |     | <span class='unexecuted'>            _initializeAuthority(_authorityAddress);</span>
  71 |     | <span class='neutral'>        }</span>
  72 |     | <span class='neutral'></span>
  73 |     | <span class='unexecuted'>        require(systemDebt == 0, &quot;ActivePool: systemDebt should be 0 for TWAP initialization&quot;);</span>
  74 |     | <span class='neutral'>    }</span>
  75 |     | <span class='neutral'></span>
  76 |     | <span class='neutral'>    // --- Getters for public variables. Required by IPool interface ---</span>
  77 |     | <span class='neutral'></span>
  78 |     | <span class='neutral'>    /// @notice Amount of stETH collateral shares in the contract</span>
  79 |     | <span class='neutral'>    /// @dev Not necessarily equal to the the contract&#39;s raw systemCollShares balance - tokens can be forcibly sent to contracts</span>
  80 |     | <span class='neutral'>    /// @return uint256 The amount of systemCollShares allocated to the pool</span>
  81 |     | <span class='neutral'></span>
  82 |     | <span class='unexecuted'>    function getSystemCollShares() external view override returns (uint256) {</span>
  83 |     | <span class='unexecuted'>        return systemCollShares;</span>
  84 |     | <span class='neutral'>    }</span>
  85 |     | <span class='neutral'></span>
  86 |     | <span class='neutral'>    /// @notice Returns the systemDebt state variable</span>
  87 |     | <span class='neutral'>    /// @dev The amount of EBTC debt in the pool. Like systemCollShares, this is not necessarily equal to the contract&#39;s EBTC token balance - tokens can be forcibly sent to contracts</span>
  88 |     | <span class='neutral'>    /// @return uint256 The amount of EBTC debt in the pool</span>
  89 |     | <span class='neutral'></span>
  90 |     | <span class='unexecuted'>    function getSystemDebt() external view override returns (uint256) {</span>
  91 |     | <span class='unexecuted'>        return systemDebt;</span>
  92 |     | <span class='neutral'>    }</span>
  93 |     | <span class='neutral'></span>
  94 |     | <span class='neutral'>    /// @notice The amount of stETH collateral shares claimable by the fee recipient</span>
  95 |     | <span class='neutral'>    /// @return uint256 The amount of collateral shares claimable by the fee recipient</span>
  96 |     | <span class='neutral'></span>
  97 |     | <span class='unexecuted'>    function getFeeRecipientClaimableCollShares() external view override returns (uint256) {</span>
  98 |     | <span class='unexecuted'>        return feeRecipientCollShares;</span>
  99 |     | <span class='neutral'>    }</span>
 100 |     | <span class='neutral'></span>
 101 |     | <span class='neutral'>    // --- Pool functionality ---</span>
 102 |     | <span class='neutral'></span>
 103 |     | <span class='neutral'>    /// @notice Sends stETH collateral shares to a specified account</span>
 104 |     | <span class='neutral'>    /// @dev Only for use by system contracts, the caller must be either BorrowerOperations or CdpManager</span>
 105 |     | <span class='neutral'>    /// @param _account The address of the account to send stETH to</span>
 106 |     | <span class='neutral'>    /// @param _shares The amount of stETH shares to send</span>
 107 |     | <span class='neutral'></span>
 108 |     | <span class='unexecuted'>    function transferSystemCollShares(address _account, uint256 _shares) public override {</span>
 109 |     | <span class='unexecuted'>        _requireCallerIsBOorCdpM();</span>
 110 |     | <span class='neutral'></span>
 111 |     | <span class='unexecuted'>        uint256 cachedSystemCollShares = systemCollShares;</span>
 112 |     | <span class='unexecuted'>        require(cachedSystemCollShares &gt;= _shares, &quot;!ActivePoolBal&quot;);</span>
 113 |     | <span class='neutral'>        unchecked {</span>
 114 |     | <span class='neutral'>            // Can use unchecked due to above</span>
 115 |     | <span class='unexecuted'>            cachedSystemCollShares -= _shares; // Updating here avoids an SLOAD</span>
 116 |     | <span class='neutral'>        }</span>
 117 |     | <span class='neutral'></span>
 118 |     | <span class='unexecuted'>        systemCollShares = cachedSystemCollShares;</span>
 119 |     | <span class='neutral'></span>
 120 |     | <span class='unexecuted'>        emit SystemCollSharesUpdated(cachedSystemCollShares);</span>
 121 |     | <span class='unexecuted'>        emit CollSharesTransferred(_account, _shares);</span>
 122 |     | <span class='neutral'></span>
 123 |     | <span class='unexecuted'>        _transferCollSharesWithContractHooks(_account, _shares);</span>
 124 |     | <span class='neutral'>    }</span>
 125 |     | <span class='neutral'></span>
 126 |     | <span class='neutral'>    /// @notice Sends stETH to a specified account, drawing from both core shares and liquidator rewards shares</span>
 127 |     | <span class='neutral'>    /// @notice Liquidator reward shares are not tracked via internal accounting in the active pool and are assumed to be present in expected amount as part of the intended behavior of BorowerOperations and CdpManager</span>
 128 |     | <span class='neutral'>    /// @dev Liquidator reward shares are added when a cdp is opened, and removed when it is closed</span>
 129 |     | <span class='neutral'>    /// @dev closeCdp() or liqudations result in the actor (borrower or liquidator respectively) receiving the liquidator reward shares</span>
 130 |     | <span class='neutral'>    /// @dev Redemptions result in the shares being sent to the coll surplus pool for claiming by the CDP owner</span>
 131 |     | <span class='neutral'>    /// @dev Note that funds in the coll surplus pool, just like liquidator reward shares, are not tracked as part of the system CR or coll of a CDP.</span>
 132 |     | <span class='neutral'>    /// @dev Requires that the caller is either BorrowerOperations or CdpManager</span>
 133 |     | <span class='neutral'>    /// @param _account The address of the account to send systemCollShares and the liquidator reward to</span>
 134 |     | <span class='neutral'>    /// @param _shares The amount of systemCollShares to send</span>
 135 |     | <span class='neutral'>    /// @param _liquidatorRewardShares The amount of the liquidator reward shares to send</span>
 136 |     | <span class='neutral'></span>
 137 |     | <span class='unexecuted'>    function transferSystemCollSharesAndLiquidatorReward(</span>
 138 |     | <span class='neutral'>        address _account,</span>
 139 |     | <span class='neutral'>        uint256 _shares,</span>
 140 |     | <span class='neutral'>        uint256 _liquidatorRewardShares</span>
 141 |     | <span class='unexecuted'>    ) external override {</span>
 142 |     | <span class='unexecuted'>        _requireCallerIsBOorCdpM();</span>
 143 |     | <span class='neutral'></span>
 144 |     | <span class='unexecuted'>        uint256 cachedSystemCollShares = systemCollShares;</span>
 145 |     | <span class='unexecuted'>        require(cachedSystemCollShares &gt;= _shares, &quot;ActivePool: Insufficient collateral shares&quot;);</span>
 146 |     | <span class='unexecuted'>        uint256 totalShares = _shares + _liquidatorRewardShares;</span>
 147 |     | <span class='neutral'>        unchecked {</span>
 148 |     | <span class='neutral'>            // Safe per the check above</span>
 149 |     | <span class='unexecuted'>            cachedSystemCollShares -= _shares;</span>
 150 |     | <span class='neutral'>        }</span>
 151 |     | <span class='unexecuted'>        systemCollShares = cachedSystemCollShares;</span>
 152 |     | <span class='neutral'></span>
 153 |     | <span class='unexecuted'>        emit SystemCollSharesUpdated(cachedSystemCollShares);</span>
 154 |     | <span class='unexecuted'>        emit CollSharesTransferred(_account, totalShares);</span>
 155 |     | <span class='neutral'></span>
 156 |     | <span class='unexecuted'>        _transferCollSharesWithContractHooks(_account, totalShares);</span>
 157 |     | <span class='neutral'>    }</span>
 158 |     | <span class='neutral'></span>
 159 |     | <span class='neutral'>    /// @notice Allocate stETH shares from the system to the fee recipient to claim at-will (pull model)</span>
 160 |     | <span class='neutral'>    /// @dev Requires that the caller is CdpManager</span>
 161 |     | <span class='neutral'>    /// @dev Only the current fee recipient address is able to claim the shares</span>
 162 |     | <span class='neutral'>    /// @dev If the fee recipient address is changed while outstanding claimable coll is available, only the new fee recipient will be able to claim the outstanding coll</span>
 163 |     | <span class='neutral'>    /// @param _shares The amount of systemCollShares to allocate to the fee recipient</span>
 164 |     | <span class='neutral'></span>
 165 |     | <span class='unexecuted'>    function allocateSystemCollSharesToFeeRecipient(uint256 _shares) external override {</span>
 166 |     | <span class='unexecuted'>        _requireCallerIsCdpManager();</span>
 167 |     | <span class='neutral'></span>
 168 |     | <span class='unexecuted'>        uint256 cachedSystemCollShares = systemCollShares;</span>
 169 |     | <span class='neutral'></span>
 170 |     | <span class='unexecuted'>        require(cachedSystemCollShares &gt;= _shares, &quot;ActivePool: Insufficient collateral shares&quot;);</span>
 171 |     | <span class='neutral'>        unchecked {</span>
 172 |     | <span class='neutral'>            // Safe per the check above</span>
 173 |     | <span class='unexecuted'>            cachedSystemCollShares -= _shares;</span>
 174 |     | <span class='neutral'>        }</span>
 175 |     | <span class='neutral'></span>
 176 |     | <span class='unexecuted'>        systemCollShares = cachedSystemCollShares;</span>
 177 |     | <span class='neutral'></span>
 178 |     | <span class='unexecuted'>        uint256 cachedFeeRecipientCollShares = feeRecipientCollShares + _shares;</span>
 179 |     | <span class='unexecuted'>        feeRecipientCollShares = cachedFeeRecipientCollShares;</span>
 180 |     | <span class='neutral'></span>
 181 |     | <span class='unexecuted'>        emit SystemCollSharesUpdated(cachedSystemCollShares);</span>
 182 |     | <span class='unexecuted'>        emit FeeRecipientClaimableCollSharesIncreased(cachedFeeRecipientCollShares, _shares);</span>
 183 |     | <span class='neutral'>    }</span>
 184 |     | <span class='neutral'></span>
 185 |     | <span class='neutral'>    /// @notice Helper function to transfer stETH shares to another address, ensuring to call hooks into other system pools if they are the recipient</span>
 186 |     | <span class='neutral'>    /// @param _account The address to transfer shares to</span>
 187 |     | <span class='neutral'>    /// @param _shares The amount of shares to transfer</span>
 188 |     | <span class='neutral'></span>
 189 |     | <span class='unexecuted'>    function _transferCollSharesWithContractHooks(address _account, uint256 _shares) internal {</span>
 190 |     | <span class='neutral'>        // NOTE: No need for safe transfer if the collateral asset is standard. Make sure this is the case!</span>
 191 |     | <span class='unexecuted'>        collateral.transferShares(_account, _shares);</span>
 192 |     | <span class='neutral'></span>
 193 |     | <span class='unexecuted'>        if (_account == collSurplusPoolAddress) {</span>
 194 |     | <span class='unexecuted'>            ICollSurplusPool(_account).increaseTotalSurplusCollShares(_shares);</span>
 195 |     | <span class='neutral'>        }</span>
 196 |     | <span class='neutral'>    }</span>
 197 |     | <span class='neutral'></span>
 198 |     | <span class='neutral'>    /// @notice Increases the tracked EBTC debt of the system by a specified amount</span>
 199 |     | <span class='neutral'>    /// @dev Managed by system contracts - requires that the caller is either BorrowerOperations or CdpManager</span>
 200 |     | <span class='neutral'>    /// @param _amount: The amount to increase the system EBTC debt by</span>
 201 |     | <span class='neutral'></span>
 202 |     | <span class='unexecuted'>    function increaseSystemDebt(uint256 _amount) external override {</span>
 203 |     | <span class='unexecuted'>        _requireCallerIsBOorCdpM();</span>
 204 |     | <span class='neutral'></span>
 205 |     | <span class='unexecuted'>        uint256 cachedSystemDebt = systemDebt + _amount;</span>
 206 |     | <span class='unexecuted'>        uint128 castedSystemDebt = EbtcMath.toUint128(cachedSystemDebt);</span>
 207 |     | <span class='neutral'></span>
 208 |     | <span class='unexecuted'>        if (!twapDisabled) {</span>
 209 |     | <span class='neutral'>            /// @audit If TWAP fails it should allow transaction to continue. Failure is preferrable to permanent DOS and can practically be mitigated by managing the redemption baseFee.</span>
 210 |     | <span class='unexecuted'>            try this.setValueAndUpdate(castedSystemDebt) {} catch {</span>
 211 |     | <span class='neutral'>                twapDisabled = true;</span>
 212 |     | <span class='neutral'>                emit TwapDisabled();</span>
 213 |     | <span class='neutral'>            }</span>
 214 |     | <span class='neutral'>        }</span>
 215 |     | <span class='neutral'></span>
 216 |     | <span class='neutral'>        /// @audit If above uint128 max, will have reverted in safeCast</span>
 217 |     | <span class='neutral'>        systemDebt = cachedSystemDebt;</span>
 218 |     | <span class='neutral'>        emit ActivePoolEBTCDebtUpdated(cachedSystemDebt);</span>
 219 |     | <span class='neutral'>    }</span>
 220 |     | <span class='neutral'></span>
 221 |     | <span class='neutral'>    /// @notice Decreases the tracked EBTC debt of the system by a specified amount</span>
 222 |     | <span class='neutral'>    /// @dev Managed by system contracts - requires that the caller is either BorrowerOperations or CdpManager</span>
 223 |     | <span class='neutral'>    /// @param _amount: The amount to decrease the system EBTC debt by</span>
 224 |     | <span class='neutral'></span>
 225 |     | <span class='unexecuted'>    function decreaseSystemDebt(uint256 _amount) external override {</span>
 226 |     | <span class='unexecuted'>        _requireCallerIsBOorCdpM();</span>
 227 |     | <span class='neutral'></span>
 228 |     | <span class='unexecuted'>        uint256 cachedSystemDebt = systemDebt - _amount;</span>
 229 |     | <span class='unexecuted'>        uint128 castedSystemDebt = EbtcMath.toUint128(cachedSystemDebt);</span>
 230 |     | <span class='neutral'></span>
 231 |     | <span class='unexecuted'>        if (!twapDisabled) {</span>
 232 |     | <span class='neutral'>            /// @audit If TWAP fails it should allow transaction to continue. Failure is preferrable to permanent DOS and can practically be mitigated by managing the redemption baseFee.</span>
 233 |     | <span class='unexecuted'>            try this.setValueAndUpdate(EbtcMath.toUint128(castedSystemDebt)) {} catch {</span>
 234 |     | <span class='unexecuted'>                twapDisabled = true;</span>
 235 |     | <span class='unexecuted'>                emit TwapDisabled();</span>
 236 |     | <span class='neutral'>            }</span>
 237 |     | <span class='neutral'>        }</span>
 238 |     | <span class='neutral'></span>
 239 |     | <span class='neutral'>        /// @audit If above uint128 max, will have reverted in safeCast</span>
 240 |     | <span class='unexecuted'>        systemDebt = cachedSystemDebt;</span>
 241 |     | <span class='unexecuted'>        emit ActivePoolEBTCDebtUpdated(cachedSystemDebt);</span>
 242 |     | <span class='neutral'>    }</span>
 243 |     | <span class='neutral'></span>
 244 |     | <span class='neutral'>    // --- &#39;require&#39; functions ---</span>
 245 |     | <span class='neutral'></span>
 246 |     | <span class='neutral'>    /// @notice Checks if the caller is BorrowerOperations</span>
 247 |     | <span class='unexecuted'>    function _requireCallerIsBorrowerOperations() internal view {</span>
 248 |     | <span class='unexecuted'>        require(</span>
 249 |     | <span class='unexecuted'>            msg.sender == borrowerOperationsAddress,</span>
 250 |     | <span class='neutral'>            &quot;ActivePool: Caller is not BorrowerOperations&quot;</span>
 251 |     | <span class='neutral'>        );</span>
 252 |     | <span class='neutral'>    }</span>
 253 |     | <span class='neutral'></span>
 254 |     | <span class='neutral'>    /// @notice Checks if the caller is either BorrowerOperations or CdpManager</span>
 255 |     | <span class='unexecuted'>    function _requireCallerIsBOorCdpM() internal view {</span>
 256 |     | <span class='unexecuted'>        require(</span>
 257 |     | <span class='unexecuted'>            msg.sender == borrowerOperationsAddress || msg.sender == cdpManagerAddress,</span>
 258 |     | <span class='neutral'>            &quot;ActivePool: Caller is neither BorrowerOperations nor CdpManager&quot;</span>
 259 |     | <span class='neutral'>        );</span>
 260 |     | <span class='neutral'>    }</span>
 261 |     | <span class='neutral'></span>
 262 |     | <span class='neutral'>    /// @notice Checks if the caller is CdpManager</span>
 263 |     | <span class='unexecuted'>    function _requireCallerIsCdpManager() internal view {</span>
 264 |     | <span class='unexecuted'>        require(msg.sender == cdpManagerAddress, &quot;ActivePool: Caller is not CdpManager&quot;);</span>
 265 |     | <span class='neutral'>    }</span>
 266 |     | <span class='neutral'></span>
 267 |     | <span class='neutral'>    /// @notice Notify that stETH collateral shares have been recieved, updating internal accounting accordingly</span>
 268 |     | <span class='neutral'>    /// @param _value The amount of collateral to receive</span>
 269 |     | <span class='neutral'></span>
 270 |     | <span class='unexecuted'>    function increaseSystemCollShares(uint256 _value) external override {</span>
 271 |     | <span class='unexecuted'>        _requireCallerIsBorrowerOperations();</span>
 272 |     | <span class='neutral'></span>
 273 |     | <span class='unexecuted'>        uint256 cachedSystemCollShares = systemCollShares + _value;</span>
 274 |     | <span class='unexecuted'>        systemCollShares = cachedSystemCollShares;</span>
 275 |     | <span class='unexecuted'>        emit SystemCollSharesUpdated(cachedSystemCollShares);</span>
 276 |     | <span class='neutral'>    }</span>
 277 |     | <span class='neutral'></span>
 278 |     | <span class='neutral'>    // === Flashloans === //</span>
 279 |     | <span class='neutral'></span>
 280 |     | <span class='neutral'>    /// @notice Borrow assets with a flash loan</span>
 281 |     | <span class='neutral'>    /// @dev The Collateral checks may cause reverts if you trigger a fee change big enough</span>
 282 |     | <span class='neutral'>    ///         consider calling `cdpManagerAddress.syncGlobalAccountingAndGracePeriod()`</span>
 283 |     | <span class='neutral'>    /// @param receiver The address to receive the flash loan</span>
 284 |     | <span class='neutral'>    /// @param token The address of the token to loan</span>
 285 |     | <span class='neutral'>    /// @param amount The amount of tokens to loan</span>
 286 |     | <span class='neutral'>    /// @param data Additional data</span>
 287 |     | <span class='neutral'>    /// @return A boolean value indicating whether the operation was successful</span>
 288 |     | <span class='neutral'></span>
 289 |     | <span class='unexecuted'>    function flashLoan(</span>
 290 |     | <span class='neutral'>        IERC3156FlashBorrower receiver,</span>
 291 |     | <span class='neutral'>        address token,</span>
 292 |     | <span class='neutral'>        uint256 amount,</span>
 293 |     | <span class='neutral'>        bytes calldata data</span>
 294 |     | <span class='unexecuted'>    ) external override returns (bool) {</span>
 295 |     | <span class='unexecuted'>        require(amount &gt; 0, &quot;ActivePool: 0 Amount&quot;);</span>
 296 |     | <span class='unexecuted'>        uint256 fee = flashFee(token, amount); // NOTE: Check for `token` is implicit in the requires above // also checks for paused</span>
 297 |     | <span class='unexecuted'>        require(amount &lt;= maxFlashLoan(token), &quot;ActivePool: Too much&quot;);</span>
 298 |     | <span class='neutral'></span>
 299 |     | <span class='unexecuted'>        uint256 amountWithFee = amount + fee;</span>
 300 |     | <span class='unexecuted'>        uint256 oldRate = collateral.getPooledEthByShares(DECIMAL_PRECISION);</span>
 301 |     | <span class='neutral'></span>
 302 |     | <span class='unexecuted'>        collateral.transfer(address(receiver), amount);</span>
 303 |     | <span class='neutral'></span>
 304 |     | <span class='neutral'>        // Callback</span>
 305 |     | <span class='unexecuted'>        require(</span>
 306 |     | <span class='unexecuted'>            receiver.onFlashLoan(msg.sender, token, amount, fee, data) == FLASH_SUCCESS_VALUE,</span>
 307 |     | <span class='neutral'>            &quot;ActivePool: IERC3156: Callback failed&quot;</span>
 308 |     | <span class='neutral'>        );</span>
 309 |     | <span class='neutral'></span>
 310 |     | <span class='neutral'>        // Transfer of (principal + Fee) from flashloan receiver</span>
 311 |     | <span class='unexecuted'>        collateral.transferFrom(address(receiver), address(this), amountWithFee);</span>
 312 |     | <span class='neutral'></span>
 313 |     | <span class='neutral'>        // Send earned fee to designated recipient</span>
 314 |     | <span class='unexecuted'>        collateral.transfer(feeRecipientAddress, fee);</span>
 315 |     | <span class='neutral'></span>
 316 |     | <span class='neutral'>        // Check new balance</span>
 317 |     | <span class='neutral'>        // NOTE: Invariant Check, technically breaks CEI but I think we must use it</span>
 318 |     | <span class='neutral'>        // NOTE: This means any balance &gt; systemCollShares is stuck, this is also present in LUSD as is</span>
 319 |     | <span class='neutral'></span>
 320 |     | <span class='neutral'>        // NOTE: This check effectively prevents running 2 FL at the same time</span>
 321 |     | <span class='neutral'>        //  You technically could, but you&#39;d be having to repay any amount below systemCollShares to get Fl2 to not revert</span>
 322 |     | <span class='unexecuted'>        require(</span>
 323 |     | <span class='unexecuted'>            collateral.balanceOf(address(this)) &gt;= collateral.getPooledEthByShares(systemCollShares),</span>
 324 |     | <span class='neutral'>            &quot;ActivePool: Must repay Balance&quot;</span>
 325 |     | <span class='neutral'>        );</span>
 326 |     | <span class='unexecuted'>        require(</span>
 327 |     | <span class='unexecuted'>            collateral.sharesOf(address(this)) &gt;= systemCollShares,</span>
 328 |     | <span class='neutral'>            &quot;ActivePool: Must repay Share&quot;</span>
 329 |     | <span class='neutral'>        );</span>
 330 |     | <span class='unexecuted'>        require(</span>
 331 |     | <span class='unexecuted'>            collateral.getPooledEthByShares(DECIMAL_PRECISION) == oldRate,</span>
 332 |     | <span class='neutral'>            &quot;ActivePool: Should keep same collateral share rate&quot;</span>
 333 |     | <span class='neutral'>        );</span>
 334 |     | <span class='neutral'></span>
 335 |     | <span class='unexecuted'>        emit FlashLoanSuccess(address(receiver), token, amount, fee);</span>
 336 |     | <span class='neutral'></span>
 337 |     | <span class='unexecuted'>        return true;</span>
 338 |     | <span class='neutral'>    }</span>
 339 |     | <span class='neutral'></span>
 340 |     | <span class='neutral'>    /// @notice Calculate the flash loan fee for a given token and amount loaned</span>
 341 |     | <span class='neutral'>    /// @param token The address of the token to calculate the fee for</span>
 342 |     | <span class='neutral'>    /// @param amount The amount of tokens to calculate the fee for</span>
 343 |     | <span class='neutral'>    /// @return The flashloan fee calcualted for given token and loan amount</span>
 344 |     | <span class='neutral'></span>
 345 |     | <span class='unexecuted'>    function flashFee(address token, uint256 amount) public view override returns (uint256) {</span>
 346 |     | <span class='unexecuted'>        require(token == address(collateral), &quot;ActivePool: collateral Only&quot;);</span>
 347 |     | <span class='unexecuted'>        require(!flashLoansPaused, &quot;ActivePool: Flash Loans Paused&quot;);</span>
 348 |     | <span class='neutral'></span>
 349 |     | <span class='unexecuted'>        return (amount * feeBps) / MAX_BPS;</span>
 350 |     | <span class='neutral'>    }</span>
 351 |     | <span class='neutral'></span>
 352 |     | <span class='neutral'>    /// @notice Get the maximum flash loan amount for a specific token</span>
 353 |     | <span class='neutral'>    /// @dev Exclusively used here for stETH collateral, equal to the current balance of the pool</span>
 354 |     | <span class='neutral'>    /// @param token The address of the token to get the maximum flash loan amount for</span>
 355 |     | <span class='neutral'>    /// @return The maximum available flashloan amount for the token</span>
 356 |     | <span class='unexecuted'>    function maxFlashLoan(address token) public view override returns (uint256) {</span>
 357 |     | <span class='unexecuted'>        if (token != address(collateral)) {</span>
 358 |     | <span class='unexecuted'>            return 0;</span>
 359 |     | <span class='neutral'>        }</span>
 360 |     | <span class='neutral'></span>
 361 |     | <span class='unexecuted'>        if (flashLoansPaused) {</span>
 362 |     | <span class='unexecuted'>            return 0;</span>
 363 |     | <span class='neutral'>        }</span>
 364 |     | <span class='neutral'></span>
 365 |     | <span class='unexecuted'>        return collateral.balanceOf(address(this));</span>
 366 |     | <span class='neutral'>    }</span>
 367 |     | <span class='neutral'></span>
 368 |     | <span class='neutral'>    // === Governed Functions === //</span>
 369 |     | <span class='neutral'></span>
 370 |     | <span class='neutral'>    /// @notice Claim outstanding shares for fee recipient, updating internal accounting and transferring the shares.</span>
 371 |     | <span class='neutral'>    /// @dev Call permissinos are managed via authority for flexibility, rather than gating call to just feeRecipient.</span>
 372 |     | <span class='neutral'>    /// @dev Is likely safe as an open permission though caution should be taken.</span>
 373 |     | <span class='neutral'>    /// @param _shares The amount of shares to claim to feeRecipient</span>
 374 |     | <span class='unexecuted'>    function claimFeeRecipientCollShares(uint256 _shares) external override requiresAuth {</span>
 375 |     | <span class='unexecuted'>        ICdpManagerData(cdpManagerAddress).syncGlobalAccountingAndGracePeriod(); // Calling this increases shares so do it first</span>
 376 |     | <span class='neutral'></span>
 377 |     | <span class='unexecuted'>        uint256 cachedFeeRecipientCollShares = feeRecipientCollShares;</span>
 378 |     | <span class='unexecuted'>        require(</span>
 379 |     | <span class='unexecuted'>            cachedFeeRecipientCollShares &gt;= _shares,</span>
 380 |     | <span class='neutral'>            &quot;ActivePool: Insufficient fee recipient coll&quot;</span>
 381 |     | <span class='neutral'>        );</span>
 382 |     | <span class='neutral'></span>
 383 |     | <span class='neutral'>        unchecked {</span>
 384 |     | <span class='unexecuted'>            cachedFeeRecipientCollShares -= _shares;</span>
 385 |     | <span class='neutral'>        }</span>
 386 |     | <span class='neutral'></span>
 387 |     | <span class='unexecuted'>        feeRecipientCollShares = cachedFeeRecipientCollShares;</span>
 388 |     | <span class='unexecuted'>        emit FeeRecipientClaimableCollSharesDecreased(cachedFeeRecipientCollShares, _shares);</span>
 389 |     | <span class='neutral'></span>
 390 |     | <span class='unexecuted'>        collateral.transferShares(feeRecipientAddress, _shares);</span>
 391 |     | <span class='neutral'>    }</span>
 392 |     | <span class='neutral'></span>
 393 |     | <span class='neutral'>    /// @dev Function to move unintended dust that are not protected</span>
 394 |     | <span class='neutral'>    /// @notice moves given amount of given token (collateral is NOT allowed)</span>
 395 |     | <span class='neutral'>    /// @notice because recipient are fixed, this function is safe to be called by anyone</span>
 396 |     | <span class='neutral'>    /// @param token The token address to be swept</span>
 397 |     | <span class='neutral'>    /// @param amount The token amount to be swept</span>
 398 |     | <span class='neutral'></span>
 399 |     | <span class='unexecuted'>    function sweepToken(address token, uint256 amount) public nonReentrant requiresAuth {</span>
 400 |     | <span class='unexecuted'>        ICdpManagerData(cdpManagerAddress).syncGlobalAccountingAndGracePeriod(); // Accrue State First</span>
 401 |     | <span class='neutral'></span>
 402 |     | <span class='unexecuted'>        require(token != address(collateral), &quot;ActivePool: Cannot Sweep Collateral&quot;);</span>
 403 |     | <span class='neutral'></span>
 404 |     | <span class='unexecuted'>        uint256 balance = IERC20(token).balanceOf(address(this));</span>
 405 |     | <span class='unexecuted'>        require(amount &lt;= balance, &quot;ActivePool: Attempt to sweep more than balance&quot;);</span>
 406 |     | <span class='neutral'></span>
 407 |     | <span class='unexecuted'>        address cachedFeeRecipientAddress = feeRecipientAddress; // Saves an SLOAD</span>
 408 |     | <span class='neutral'></span>
 409 |     | <span class='unexecuted'>        IERC20(token).safeTransfer(cachedFeeRecipientAddress, amount);</span>
 410 |     | <span class='neutral'></span>
 411 |     | <span class='unexecuted'>        emit SweepTokenSuccess(token, amount, cachedFeeRecipientAddress);</span>
 412 |     | <span class='neutral'>    }</span>
 413 |     | <span class='neutral'></span>
 414 |     | <span class='neutral'>    /// @notice Sets new Fee for FlashLoans</span>
 415 |     | <span class='neutral'>    /// @param _newFee The new flashloan fee to be set</span>
 416 |     | <span class='unexecuted'>    function setFeeBps(uint256 _newFee) external requiresAuth {</span>
 417 |     | <span class='unexecuted'>        ICdpManagerData(cdpManagerAddress).syncGlobalAccountingAndGracePeriod(); // Accrue State First</span>
 418 |     | <span class='neutral'></span>
 419 |     | <span class='unexecuted'>        require(_newFee &lt;= MAX_FEE_BPS, &quot;ERC3156FlashLender: _newFee should &lt;= MAX_FEE_BPS&quot;);</span>
 420 |     | <span class='neutral'></span>
 421 |     | <span class='neutral'>        // set new flash fee</span>
 422 |     | <span class='unexecuted'>        uint256 _oldFee = feeBps;</span>
 423 |     | <span class='unexecuted'>        feeBps = uint16(_newFee);</span>
 424 |     | <span class='unexecuted'>        emit FlashFeeSet(msg.sender, _oldFee, _newFee);</span>
 425 |     | <span class='neutral'>    }</span>
 426 |     | <span class='neutral'></span>
 427 |     | <span class='neutral'>    /// @notice Should Flashloans be paused?</span>
 428 |     | <span class='neutral'>    /// @param _paused The flag (true or false) whether flashloan will be paused</span>
 429 |     | <span class='unexecuted'>    function setFlashLoansPaused(bool _paused) external requiresAuth {</span>
 430 |     | <span class='unexecuted'>        ICdpManagerData(cdpManagerAddress).syncGlobalAccountingAndGracePeriod(); // Accrue State First</span>
 431 |     | <span class='neutral'></span>
 432 |     | <span class='unexecuted'>        flashLoansPaused = _paused;</span>
 433 |     | <span class='unexecuted'>        emit FlashLoansPaused(msg.sender, _paused);</span>
 434 |     | <span class='neutral'>    }</span>
 435 |     | <span class='neutral'>}</span>
 436 |     | <span class='neutral'></span>

</code>
<br />

<b>/mnt/c/Users/Lourens/Documents/Recon-Fuzz/collabs/ebtc/packages/contracts/contracts/BorrowerOperations.sol</b>
<code>
    1 |     | <span class='neutral'>// SPDX-License-Identifier: MIT</span>
    2 |     | <span class='neutral'></span>
    3 |     | <span class='neutral'>pragma solidity 0.8.17;</span>
    4 |     | <span class='neutral'></span>
    5 |     | <span class='neutral'>import &quot;./Interfaces/IBorrowerOperations.sol&quot;;</span>
    6 |     | <span class='neutral'>import &quot;./Interfaces/ICdpManager.sol&quot;;</span>
    7 |     | <span class='neutral'>import &quot;./Interfaces/ICdpManagerData.sol&quot;;</span>
    8 |     | <span class='neutral'>import &quot;./Interfaces/IEBTCToken.sol&quot;;</span>
    9 |     | <span class='neutral'>import &quot;./Interfaces/ICollSurplusPool.sol&quot;;</span>
   10 |     | <span class='neutral'>import &quot;./Interfaces/ISortedCdps.sol&quot;;</span>
   11 |     | <span class='neutral'>import &quot;./Dependencies/EbtcBase.sol&quot;;</span>
   12 |     | <span class='neutral'>import &quot;./Dependencies/ReentrancyGuard.sol&quot;;</span>
   13 |     | <span class='neutral'>import &quot;./Dependencies/Ownable.sol&quot;;</span>
   14 |     | <span class='neutral'>import &quot;./Dependencies/AuthNoOwner.sol&quot;;</span>
   15 |     | <span class='neutral'>import &quot;./Dependencies/ERC3156FlashLender.sol&quot;;</span>
   16 |     | <span class='neutral'>import &quot;./Dependencies/PermitNonce.sol&quot;;</span>
   17 |     | <span class='neutral'></span>
   18 |     | <span class='neutral'>/// @title BorrowerOperations is mainly in charge of all end user interactions like Cdp open, adjust, close etc</span>
   19 |     | <span class='neutral'>/// @notice End users could approve delegate via IPositionManagers for authorized actions on their behalf</span>
   20 |     | <span class='neutral'>/// @dev BorrowerOperations also allows ERC3156 compatible flashmint of eBTC token</span>
   21 |     | <span class='unexecuted'>contract BorrowerOperations is</span>
   22 |     | <span class='neutral'>    EbtcBase,</span>
   23 |     | <span class='neutral'>    ReentrancyGuard,</span>
   24 |     | <span class='neutral'>    IBorrowerOperations,</span>
   25 |     | <span class='neutral'>    ERC3156FlashLender,</span>
   26 |     | <span class='neutral'>    AuthNoOwner,</span>
   27 |     | <span class='neutral'>    PermitNonce</span>
   28 |     | <span class='neutral'>{</span>
   29 |     | <span class='unexecuted'>    string public constant NAME = &quot;BorrowerOperations&quot;;</span>
   30 |     | <span class='neutral'></span>
   31 |     | <span class='neutral'>    // keccak256(&quot;permitPositionManagerApproval(address borrower,address positionManager,uint8 status,uint256 nonce,uint256 deadline)&quot;);</span>
   32 |     | <span class='neutral'>    bytes32 private constant _PERMIT_POSITION_MANAGER_TYPEHASH =</span>
   33 |     | <span class='unexecuted'>        keccak256(</span>
   34 |     | <span class='neutral'>            &quot;PermitPositionManagerApproval(address borrower,address positionManager,uint8 status,uint256 nonce,uint256 deadline)&quot;</span>
   35 |     | <span class='neutral'>        );</span>
   36 |     | <span class='neutral'></span>
   37 |     | <span class='neutral'>    // keccak256(&quot;EIP712Domain(string name,string version,uint256 chainId,address verifyingContract)&quot;);</span>
   38 |     | <span class='neutral'>    bytes32 private constant _TYPE_HASH =</span>
   39 |     | <span class='unexecuted'>        0x8b73c3c69bb8fe3d512ecc4cf759cc79239f7b179b0ffacaa9a75d522b39400f;</span>
   40 |     | <span class='neutral'></span>
   41 |     | <span class='neutral'>    string internal constant _VERSION = &quot;1&quot;;</span>
   42 |     | <span class='neutral'></span>
   43 |     | <span class='neutral'>    // Cache the domain separator as an immutable value, but also store the chain id that it corresponds to, in order to</span>
   44 |     | <span class='neutral'>    // invalidate the cached domain separator if the chain id changes.</span>
   45 |     | <span class='neutral'>    bytes32 private immutable _CACHED_DOMAIN_SEPARATOR;</span>
   46 |     | <span class='neutral'>    uint256 private immutable _CACHED_CHAIN_ID;</span>
   47 |     | <span class='neutral'></span>
   48 |     | <span class='neutral'>    bytes32 private immutable _HASHED_NAME;</span>
   49 |     | <span class='neutral'>    bytes32 private immutable _HASHED_VERSION;</span>
   50 |     | <span class='neutral'></span>
   51 |     | <span class='neutral'>    // --- Connected contract declarations ---</span>
   52 |     | <span class='neutral'></span>
   53 |     | <span class='unexecuted'>    ICdpManager public immutable cdpManager;</span>
   54 |     | <span class='neutral'></span>
   55 |     | <span class='unexecuted'>    ICollSurplusPool public immutable collSurplusPool;</span>
   56 |     | <span class='neutral'></span>
   57 |     | <span class='unexecuted'>    address public immutable feeRecipientAddress;</span>
   58 |     | <span class='neutral'></span>
   59 |     | <span class='unexecuted'>    IEBTCToken public immutable ebtcToken;</span>
   60 |     | <span class='neutral'></span>
   61 |     | <span class='neutral'>    // A doubly linked list of Cdps, sorted by their collateral ratios</span>
   62 |     | <span class='unexecuted'>    ISortedCdps public immutable sortedCdps;</span>
   63 |     | <span class='neutral'></span>
   64 |     | <span class='neutral'>    // Mapping of borrowers to approved position managers, by approval status: cdpOwner(borrower) -&gt; positionManager -&gt; PositionManagerApproval (None, OneTime, Persistent)</span>
   65 |     | <span class='unexecuted'>    mapping(address =&gt; mapping(address =&gt; PositionManagerApproval)) public positionManagers;</span>
   66 |     | <span class='neutral'></span>
   67 |     | <span class='neutral'>    /* --- Variable container structs  ---</span>
   68 |     | <span class='neutral'></span>
   69 |     | <span class='neutral'>    Used to hold, return and assign variables inside a function, in order to avoid the error:</span>
   70 |     | <span class='neutral'>    &quot;CompilerError: Stack too deep&quot;. */</span>
   71 |     | <span class='neutral'></span>
   72 |     | <span class='neutral'>    struct AdjustCdpLocals {</span>
   73 |     | <span class='neutral'>        uint256 price;</span>
   74 |     | <span class='neutral'>        uint256 collSharesChange;</span>
   75 |     | <span class='neutral'>        uint256 netDebtChange;</span>
   76 |     | <span class='neutral'>        bool isCollIncrease;</span>
   77 |     | <span class='neutral'>        uint256 debt;</span>
   78 |     | <span class='neutral'>        uint256 collShares;</span>
   79 |     | <span class='neutral'>        uint256 oldICR;</span>
   80 |     | <span class='neutral'>        uint256 newICR;</span>
   81 |     | <span class='neutral'>        uint256 newTCR;</span>
   82 |     | <span class='neutral'>        uint256 newDebt;</span>
   83 |     | <span class='neutral'>        uint256 newCollShares;</span>
   84 |     | <span class='neutral'>        uint256 stake;</span>
   85 |     | <span class='neutral'>    }</span>
   86 |     | <span class='neutral'></span>
   87 |     | <span class='neutral'>    struct OpenCdpLocals {</span>
   88 |     | <span class='neutral'>        uint256 price;</span>
   89 |     | <span class='neutral'>        uint256 debt;</span>
   90 |     | <span class='neutral'>        uint256 netStEthBalance;</span>
   91 |     | <span class='neutral'>        uint256 ICR;</span>
   92 |     | <span class='neutral'>        uint256 NICR;</span>
   93 |     | <span class='neutral'>        uint256 stake;</span>
   94 |     | <span class='neutral'>    }</span>
   95 |     | <span class='neutral'></span>
   96 |     | <span class='neutral'>    struct MoveTokensParams {</span>
   97 |     | <span class='neutral'>        address user;</span>
   98 |     | <span class='neutral'>        uint256 collSharesChange;</span>
   99 |     | <span class='neutral'>        uint256 collAddUnderlying; // ONLY for isCollIncrease=true</span>
  100 |     | <span class='neutral'>        bool isCollIncrease;</span>
  101 |     | <span class='neutral'>        uint256 netDebtChange;</span>
  102 |     | <span class='neutral'>        bool isDebtIncrease;</span>
  103 |     | <span class='neutral'>    }</span>
  104 |     | <span class='neutral'></span>
  105 |     | <span class='neutral'>    // --- Dependency setters ---</span>
  106 |     | <span class='unexecuted'>    constructor(</span>
  107 |     | <span class='neutral'>        address _cdpManagerAddress,</span>
  108 |     | <span class='neutral'>        address _activePoolAddress,</span>
  109 |     | <span class='neutral'>        address _collSurplusPoolAddress,</span>
  110 |     | <span class='neutral'>        address _priceFeedAddress,</span>
  111 |     | <span class='neutral'>        address _sortedCdpsAddress,</span>
  112 |     | <span class='neutral'>        address _ebtcTokenAddress,</span>
  113 |     | <span class='neutral'>        address _feeRecipientAddress,</span>
  114 |     | <span class='neutral'>        address _collTokenAddress</span>
  115 |     | <span class='neutral'>    ) EbtcBase(_activePoolAddress, _priceFeedAddress, _collTokenAddress) {</span>
  116 |     | <span class='unexecuted'>        cdpManager = ICdpManager(_cdpManagerAddress);</span>
  117 |     | <span class='unexecuted'>        collSurplusPool = ICollSurplusPool(_collSurplusPoolAddress);</span>
  118 |     | <span class='unexecuted'>        sortedCdps = ISortedCdps(_sortedCdpsAddress);</span>
  119 |     | <span class='unexecuted'>        ebtcToken = IEBTCToken(_ebtcTokenAddress);</span>
  120 |     | <span class='unexecuted'>        feeRecipientAddress = _feeRecipientAddress;</span>
  121 |     | <span class='neutral'></span>
  122 |     | <span class='unexecuted'>        address _authorityAddress = address(AuthNoOwner(_cdpManagerAddress).authority());</span>
  123 |     | <span class='unexecuted'>        if (_authorityAddress != address(0)) {</span>
  124 |     | <span class='unexecuted'>            _initializeAuthority(_authorityAddress);</span>
  125 |     | <span class='neutral'>        }</span>
  126 |     | <span class='neutral'></span>
  127 |     | <span class='unexecuted'>        bytes32 hashedName = keccak256(bytes(NAME));</span>
  128 |     | <span class='unexecuted'>        bytes32 hashedVersion = keccak256(bytes(_VERSION));</span>
  129 |     | <span class='neutral'></span>
  130 |     | <span class='unexecuted'>        _HASHED_NAME = hashedName;</span>
  131 |     | <span class='unexecuted'>        _HASHED_VERSION = hashedVersion;</span>
  132 |     | <span class='unexecuted'>        _CACHED_CHAIN_ID = _chainID();</span>
  133 |     | <span class='unexecuted'>        _CACHED_DOMAIN_SEPARATOR = _buildDomainSeparator(_TYPE_HASH, hashedName, hashedVersion);</span>
  134 |     | <span class='neutral'>    }</span>
  135 |     | <span class='neutral'></span>
  136 |     | <span class='neutral'>    /**</span>
  137 |     | <span class='neutral'>        @notice BorrowerOperations and CdpManager share reentrancy status by confirming the other&#39;s locked flag before beginning operation</span>
  138 |     | <span class='neutral'>        @dev This is an alternative to the more heavyweight solution of both being able to set the reentrancy flag on a 3rd contract.</span>
  139 |     | <span class='neutral'>        @dev Prevents multi-contract reentrancy between these two contracts</span>
  140 |     | <span class='neutral'>     */</span>
  141 |     | <span class='neutral'>    modifier nonReentrantSelfAndCdpM() {</span>
  142 |     | <span class='unexecuted'>        require(locked == OPEN, &quot;BorrowerOperations: Reentrancy in nonReentrant call&quot;);</span>
  143 |     | <span class='unexecuted'>        require(</span>
  144 |     | <span class='unexecuted'>            ReentrancyGuard(address(cdpManager)).locked() == OPEN,</span>
  145 |     | <span class='neutral'>            &quot;CdpManager: Reentrancy in nonReentrant call&quot;</span>
  146 |     | <span class='neutral'>        );</span>
  147 |     | <span class='neutral'></span>
  148 |     | <span class='unexecuted'>        locked = LOCKED;</span>
  149 |     | <span class='neutral'></span>
  150 |     | <span class='neutral'>        _;</span>
  151 |     | <span class='neutral'></span>
  152 |     | <span class='unexecuted'>        locked = OPEN;</span>
  153 |     | <span class='neutral'>    }</span>
  154 |     | <span class='neutral'></span>
  155 |     | <span class='neutral'>    // --- Borrower Cdp Operations ---</span>
  156 |     | <span class='neutral'></span>
  157 |     | <span class='neutral'>    /// @notice Function that creates a Cdp for the caller with the requested debt, and the stETH received as collateral.</span>
  158 |     | <span class='neutral'>    /// @notice Successful execution is conditional mainly on the resulting collateralization ratio which must exceed minimum requirement, e.g., MCR.</span>
  159 |     | <span class='neutral'>    /// @notice Upon Cdp open, a separate gas stipend (denominated in stETH) will be allocated for possible liquidation.</span>
  160 |     | <span class='neutral'>    /// @param _debt The expected debt for this new Cdp</span>
  161 |     | <span class='neutral'>    /// @param _upperHint The expected CdpId of neighboring higher ICR within SortedCdps, could be simply bytes32(0)</span>
  162 |     | <span class='neutral'>    /// @param _lowerHint The expected CdpId of neighboring lower ICR within SortedCdps, could be simply bytes32(0)</span>
  163 |     | <span class='neutral'>    /// @param _stEthBalance The total stETH collateral amount deposited for the specified Cdp</span>
  164 |     | <span class='neutral'>    /// @return The CdpId for this newly created Cdp</span>
  165 |     | <span class='unexecuted'>    function openCdp(</span>
  166 |     | <span class='neutral'>        uint256 _debt,</span>
  167 |     | <span class='neutral'>        bytes32 _upperHint,</span>
  168 |     | <span class='neutral'>        bytes32 _lowerHint,</span>
  169 |     | <span class='neutral'>        uint256 _stEthBalance</span>
  170 |     | <span class='unexecuted'>    ) external override nonReentrantSelfAndCdpM returns (bytes32) {</span>
  171 |     | <span class='unexecuted'>        return _openCdp(_debt, _upperHint, _lowerHint, _stEthBalance, msg.sender);</span>
  172 |     | <span class='neutral'>    }</span>
  173 |     | <span class='neutral'></span>
  174 |     | <span class='neutral'>    /// @notice Function that creates a Cdp for the specified _borrower by caller with the requested debt, and the stETH received as collateral.</span>
  175 |     | <span class='neutral'>    /// @dev Caller will need approval from _borrower via IPositionManagers if they are different address</span>
  176 |     | <span class='neutral'>    /// @notice Successful execution is conditional mainly on the resulting collateralization ratio which must exceed minimum requirement, e.g., MCR.</span>
  177 |     | <span class='neutral'>    /// @notice Upon Cdp open, a separate gas stipend (denominated in stETH) will be allocated for possible liquidation.</span>
  178 |     | <span class='neutral'>    /// @param _debt The expected debt for this new Cdp</span>
  179 |     | <span class='neutral'>    /// @param _upperHint The expected CdpId of neighboring higher ICR within SortedCdps, could be simply bytes32(0)</span>
  180 |     | <span class='neutral'>    /// @param _lowerHint The expected CdpId of neighboring lower ICR within SortedCdps, could be simply bytes32(0)</span>
  181 |     | <span class='neutral'>    /// @param _stEthBalance The total stETH collateral amount deposited for the specified Cdp</span>
  182 |     | <span class='neutral'>    /// @param _borrower The Cdp owner for this new Cdp.</span>
  183 |     | <span class='neutral'>    /// @return The CdpId for this newly created Cdp</span>
  184 |     | <span class='unexecuted'>    function openCdpFor(</span>
  185 |     | <span class='neutral'>        uint256 _debt,</span>
  186 |     | <span class='neutral'>        bytes32 _upperHint,</span>
  187 |     | <span class='neutral'>        bytes32 _lowerHint,</span>
  188 |     | <span class='neutral'>        uint256 _stEthBalance,</span>
  189 |     | <span class='neutral'>        address _borrower</span>
  190 |     | <span class='unexecuted'>    ) external override nonReentrantSelfAndCdpM returns (bytes32) {</span>
  191 |     | <span class='unexecuted'>        return _openCdp(_debt, _upperHint, _lowerHint, _stEthBalance, _borrower);</span>
  192 |     | <span class='neutral'>    }</span>
  193 |     | <span class='neutral'></span>
  194 |     | <span class='neutral'>    /// @notice Function that adds the received stETH to the specified Cdp.</span>
  195 |     | <span class='neutral'>    /// @dev If caller is different from Cdp owner, it will need approval from Cdp owner for this call</span>
  196 |     | <span class='neutral'>    /// @param _cdpId The CdpId on which this operation is operated</span>
  197 |     | <span class='neutral'>    /// @param _upperHint The expected CdpId of neighboring higher ICR within SortedCdps, could be simply bytes32(0)</span>
  198 |     | <span class='neutral'>    /// @param _lowerHint The expected CdpId of neighboring lower ICR within SortedCdps, could be simply bytes32(0)</span>
  199 |     | <span class='neutral'>    /// @param _stEthBalanceIncrease The total stETH collateral amount deposited (added) for the specified Cdp</span>
  200 |     | <span class='unexecuted'>    function addColl(</span>
  201 |     | <span class='neutral'>        bytes32 _cdpId,</span>
  202 |     | <span class='neutral'>        bytes32 _upperHint,</span>
  203 |     | <span class='neutral'>        bytes32 _lowerHint,</span>
  204 |     | <span class='neutral'>        uint256 _stEthBalanceIncrease</span>
  205 |     | <span class='neutral'>    ) external override nonReentrantSelfAndCdpM {</span>
  206 |     | <span class='unexecuted'>        _adjustCdpInternal(_cdpId, 0, 0, false, _upperHint, _lowerHint, _stEthBalanceIncrease);</span>
  207 |     | <span class='neutral'>    }</span>
  208 |     | <span class='neutral'></span>
  209 |     | <span class='neutral'>    /// @notice Function that withdraws `_stEthBalanceDecrease` amount of collateral from the specified Cdp</span>
  210 |     | <span class='neutral'>    /// @dev If caller is different from Cdp owner, it will need approval from Cdp owner for this call</span>
  211 |     | <span class='neutral'>    /// @notice Successful execution is conditional on whether the withdrawal would bring down the ICR or TCR to the minimum requirement, e.g., MCR or CCR</span>
  212 |     | <span class='neutral'>    /// @param _cdpId The CdpId on which this operation is operated</span>
  213 |     | <span class='neutral'>    /// @param _stEthBalanceDecrease The total stETH collateral amount withdrawn (reduced) for the specified Cdp</span>
  214 |     | <span class='neutral'>    /// @param _upperHint The expected CdpId of neighboring higher ICR within SortedCdps, could be simply bytes32(0)</span>
  215 |     | <span class='neutral'>    /// @param _lowerHint The expected CdpId of neighboring lower ICR within SortedCdps, could be simply bytes32(0)</span>
  216 |     | <span class='unexecuted'>    function withdrawColl(</span>
  217 |     | <span class='neutral'>        bytes32 _cdpId,</span>
  218 |     | <span class='neutral'>        uint256 _stEthBalanceDecrease,</span>
  219 |     | <span class='neutral'>        bytes32 _upperHint,</span>
  220 |     | <span class='neutral'>        bytes32 _lowerHint</span>
  221 |     | <span class='neutral'>    ) external override nonReentrantSelfAndCdpM {</span>
  222 |     | <span class='unexecuted'>        _adjustCdpInternal(_cdpId, _stEthBalanceDecrease, 0, false, _upperHint, _lowerHint, 0);</span>
  223 |     | <span class='neutral'>    }</span>
  224 |     | <span class='neutral'></span>
  225 |     | <span class='neutral'>    /// @notice Function that withdraws `_debt` amount of eBTC token from the specified Cdp, thus increasing its debt accounting</span>
  226 |     | <span class='neutral'>    /// @dev If caller is different from Cdp owner, it will need approval from Cdp owner for this call</span>
  227 |     | <span class='neutral'>    /// @notice Successful execution is conditional on whether the withdrawal would bring down the ICR or TCR to the minimum requirement, e.g., MCR or CCR</span>
  228 |     | <span class='neutral'>    /// @param _cdpId The CdpId on which this operation is operated</span>
  229 |     | <span class='neutral'>    /// @param _debt The total debt collateral amount increased for the specified Cdp</span>
  230 |     | <span class='neutral'>    /// @param _upperHint The expected CdpId of neighboring higher ICR within SortedCdps, could be simply bytes32(0)</span>
  231 |     | <span class='neutral'>    /// @param _lowerHint The expected CdpId of neighboring lower ICR within SortedCdps, could be simply bytes32(0)</span>
  232 |     | <span class='unexecuted'>    function withdrawDebt(</span>
  233 |     | <span class='neutral'>        bytes32 _cdpId,</span>
  234 |     | <span class='neutral'>        uint256 _debt,</span>
  235 |     | <span class='neutral'>        bytes32 _upperHint,</span>
  236 |     | <span class='neutral'>        bytes32 _lowerHint</span>
  237 |     | <span class='neutral'>    ) external override nonReentrantSelfAndCdpM {</span>
  238 |     | <span class='unexecuted'>        _adjustCdpInternal(_cdpId, 0, _debt, true, _upperHint, _lowerHint, 0);</span>
  239 |     | <span class='neutral'>    }</span>
  240 |     | <span class='neutral'></span>
  241 |     | <span class='neutral'>    /// @notice Function that repays the received eBTC token to the specified Cdp, thus reducing its debt accounting.</span>
  242 |     | <span class='neutral'>    /// @dev If caller is different from Cdp owner, it will need approval from Cdp owner for this call</span>
  243 |     | <span class='neutral'>    /// @param _cdpId The CdpId on which this operation is operated</span>
  244 |     | <span class='neutral'>    /// @param _upperHint The expected CdpId of neighboring higher ICR within SortedCdps, could be simply bytes32(0)</span>
  245 |     | <span class='neutral'>    /// @param _lowerHint The expected CdpId of neighboring lower ICR within SortedCdps, could be simply bytes32(0)</span>
  246 |     | <span class='neutral'>    /// @param _debt The total eBTC debt amount repaid for the specified Cdp</span>
  247 |     | <span class='unexecuted'>    function repayDebt(</span>
  248 |     | <span class='neutral'>        bytes32 _cdpId,</span>
  249 |     | <span class='neutral'>        uint256 _debt,</span>
  250 |     | <span class='neutral'>        bytes32 _upperHint,</span>
  251 |     | <span class='neutral'>        bytes32 _lowerHint</span>
  252 |     | <span class='neutral'>    ) external override nonReentrantSelfAndCdpM {</span>
  253 |     | <span class='unexecuted'>        _adjustCdpInternal(_cdpId, 0, _debt, false, _upperHint, _lowerHint, 0);</span>
  254 |     | <span class='neutral'>    }</span>
  255 |     | <span class='neutral'></span>
  256 |     | <span class='neutral'>    /// @notice Function that allows various operations which might change both collateral and debt</span>
  257 |     | <span class='neutral'>    /// @notice like taking more risky position (withdraws eBTC token and reduces stETH collateral)</span>
  258 |     | <span class='neutral'>    /// @notice or holding more safer position (repays eBTC token) with the specified Cdp.</span>
  259 |     | <span class='neutral'>    /// @notice If end user want to add collateral and change debt at the same time, use adjustCdpWithColl() instead</span>
  260 |     | <span class='neutral'>    /// @dev If caller is different from Cdp owner, it will need approval from Cdp owner for this call</span>
  261 |     | <span class='neutral'>    /// @param _cdpId The CdpId on which this operation is operated</span>
  262 |     | <span class='neutral'>    /// @param _stEthBalanceDecrease The total stETH collateral amount withdrawn from the specified Cdp</span>
  263 |     | <span class='neutral'>    /// @param _debtChange The total eBTC debt amount withdrawn or repaid for the specified Cdp</span>
  264 |     | <span class='neutral'>    /// @param _isDebtIncrease The flag (true or false) to indicate whether this is a eBTC token withdrawal (debt increase) or a repayment (debt reduce)</span>
  265 |     | <span class='neutral'>    /// @param _upperHint The expected CdpId of neighboring higher ICR within SortedCdps, could be simply bytes32(0)</span>
  266 |     | <span class='neutral'>    /// @param _lowerHint The expected CdpId of neighboring lower ICR within SortedCdps, could be simply bytes32(0)</span>
  267 |     | <span class='unexecuted'>    function adjustCdp(</span>
  268 |     | <span class='neutral'>        bytes32 _cdpId,</span>
  269 |     | <span class='neutral'>        uint256 _stEthBalanceDecrease,</span>
  270 |     | <span class='neutral'>        uint256 _debtChange,</span>
  271 |     | <span class='neutral'>        bool _isDebtIncrease,</span>
  272 |     | <span class='neutral'>        bytes32 _upperHint,</span>
  273 |     | <span class='neutral'>        bytes32 _lowerHint</span>
  274 |     | <span class='neutral'>    ) external override nonReentrantSelfAndCdpM {</span>
  275 |     | <span class='unexecuted'>        _adjustCdpInternal(</span>
  276 |     | <span class='unexecuted'>            _cdpId,</span>
  277 |     | <span class='unexecuted'>            _stEthBalanceDecrease,</span>
  278 |     | <span class='unexecuted'>            _debtChange,</span>
  279 |     | <span class='unexecuted'>            _isDebtIncrease,</span>
  280 |     | <span class='unexecuted'>            _upperHint,</span>
  281 |     | <span class='unexecuted'>            _lowerHint,</span>
  282 |     | <span class='unexecuted'>            0</span>
  283 |     | <span class='neutral'>        );</span>
  284 |     | <span class='neutral'>    }</span>
  285 |     | <span class='neutral'></span>
  286 |     | <span class='neutral'>    /// @notice Function that allows various operations which might change both collateral and debt</span>
  287 |     | <span class='neutral'>    /// @notice like taking more risky position (withdraws eBTC token and reduces stETH collateral)</span>
  288 |     | <span class='neutral'>    /// @notice or holding more safer position (repays eBTC token and adds stETH collateral) with the specified Cdp.</span>
  289 |     | <span class='neutral'>    /// @dev If caller is different from Cdp owner, it will need approval from Cdp owner for this call</span>
  290 |     | <span class='neutral'>    /// @param _cdpId The CdpId on which this operation is operated</span>
  291 |     | <span class='neutral'>    /// @param _stEthBalanceDecrease The total stETH collateral amount withdrawn from the specified Cdp</span>
  292 |     | <span class='neutral'>    /// @param _debtChange The total eBTC debt amount withdrawn or repaid for the specified Cdp</span>
  293 |     | <span class='neutral'>    /// @param _isDebtIncrease The flag (true or false) to indicate whether this is a eBTC token withdrawal (debt increase) or a repayment (debt reduce)</span>
  294 |     | <span class='neutral'>    /// @param _upperHint The expected CdpId of neighboring higher ICR within SortedCdps, could be simply bytes32(0)</span>
  295 |     | <span class='neutral'>    /// @param _lowerHint The expected CdpId of neighboring lower ICR within SortedCdps, could be simply bytes32(0)</span>
  296 |     | <span class='neutral'>    /// @param _stEthBalanceIncrease The total stETH collateral amount deposited (added) for the specified Cdp</span>
  297 |     | <span class='unexecuted'>    function adjustCdpWithColl(</span>
  298 |     | <span class='neutral'>        bytes32 _cdpId,</span>
  299 |     | <span class='neutral'>        uint256 _stEthBalanceDecrease,</span>
  300 |     | <span class='neutral'>        uint256 _debtChange,</span>
  301 |     | <span class='neutral'>        bool _isDebtIncrease,</span>
  302 |     | <span class='neutral'>        bytes32 _upperHint,</span>
  303 |     | <span class='neutral'>        bytes32 _lowerHint,</span>
  304 |     | <span class='neutral'>        uint256 _stEthBalanceIncrease</span>
  305 |     | <span class='neutral'>    ) external override nonReentrantSelfAndCdpM {</span>
  306 |     | <span class='unexecuted'>        _adjustCdpInternal(</span>
  307 |     | <span class='unexecuted'>            _cdpId,</span>
  308 |     | <span class='unexecuted'>            _stEthBalanceDecrease,</span>
  309 |     | <span class='unexecuted'>            _debtChange,</span>
  310 |     | <span class='unexecuted'>            _isDebtIncrease,</span>
  311 |     | <span class='unexecuted'>            _upperHint,</span>
  312 |     | <span class='unexecuted'>            _lowerHint,</span>
  313 |     | <span class='unexecuted'>            _stEthBalanceIncrease</span>
  314 |     | <span class='neutral'>        );</span>
  315 |     | <span class='neutral'>    }</span>
  316 |     | <span class='neutral'></span>
  317 |     | <span class='neutral'>    /*</span>
  318 |     | <span class='neutral'>     * _adjustCdpInternal(): Alongside a debt change, this function can perform either</span>
  319 |     | <span class='neutral'>     * a collateral top-up or a collateral withdrawal.</span>
  320 |     | <span class='neutral'>     *</span>
  321 |     | <span class='neutral'>     * It therefore expects either a positive _stEthBalanceIncrease, or a positive _stEthBalanceDecrease argument.</span>
  322 |     | <span class='neutral'>     *</span>
  323 |     | <span class='neutral'>     * If both are positive, it will revert.</span>
  324 |     | <span class='neutral'>     */</span>
  325 |     | <span class='unexecuted'>    function _adjustCdpInternal(</span>
  326 |     | <span class='neutral'>        bytes32 _cdpId,</span>
  327 |     | <span class='neutral'>        uint256 _stEthBalanceDecrease,</span>
  328 |     | <span class='neutral'>        uint256 _debtChange,</span>
  329 |     | <span class='neutral'>        bool _isDebtIncrease,</span>
  330 |     | <span class='neutral'>        bytes32 _upperHint,</span>
  331 |     | <span class='neutral'>        bytes32 _lowerHint,</span>
  332 |     | <span class='neutral'>        uint256 _stEthBalanceIncrease</span>
  333 |     | <span class='unexecuted'>    ) internal {</span>
  334 |     | <span class='neutral'>        // Confirm the operation is the borrower or approved position manager adjusting its own cdp</span>
  335 |     | <span class='unexecuted'>        address _borrower = sortedCdps.getOwnerAddress(_cdpId);</span>
  336 |     | <span class='unexecuted'>        _requireBorrowerOrPositionManagerAndUpdateManagerApproval(_borrower);</span>
  337 |     | <span class='neutral'></span>
  338 |     | <span class='unexecuted'>        _requireCdpisActive(cdpManager, _cdpId);</span>
  339 |     | <span class='neutral'></span>
  340 |     | <span class='unexecuted'>        cdpManager.syncAccounting(_cdpId);</span>
  341 |     | <span class='neutral'></span>
  342 |     | <span class='unexecuted'>        AdjustCdpLocals memory vars;</span>
  343 |     | <span class='neutral'></span>
  344 |     | <span class='unexecuted'>        vars.price = priceFeed.fetchPrice();</span>
  345 |     | <span class='neutral'></span>
  346 |     | <span class='unexecuted'>        if (_isDebtIncrease) {</span>
  347 |     | <span class='unexecuted'>            _requireMinDebtChange(_debtChange);</span>
  348 |     | <span class='neutral'>        } else {</span>
  349 |     | <span class='unexecuted'>            _requireZeroOrMinAdjustment(_debtChange);</span>
  350 |     | <span class='neutral'>        }</span>
  351 |     | <span class='neutral'></span>
  352 |     | <span class='unexecuted'>        _requireSingularCollChange(_stEthBalanceIncrease, _stEthBalanceDecrease);</span>
  353 |     | <span class='unexecuted'>        _requireNonZeroAdjustment(_stEthBalanceIncrease, _stEthBalanceDecrease, _debtChange);</span>
  354 |     | <span class='unexecuted'>        _requireZeroOrMinAdjustment(_stEthBalanceIncrease);</span>
  355 |     | <span class='unexecuted'>        _requireZeroOrMinAdjustment(_stEthBalanceDecrease);</span>
  356 |     | <span class='neutral'>        // min debt adjustment checked above</span>
  357 |     | <span class='neutral'></span>
  358 |     | <span class='neutral'>        // Get the collSharesChange based on the collateral value transferred in the transaction</span>
  359 |     | <span class='unexecuted'>        (vars.collSharesChange, vars.isCollIncrease) = _getCollSharesChangeFromStEthChange(</span>
  360 |     | <span class='unexecuted'>            _stEthBalanceIncrease,</span>
  361 |     | <span class='unexecuted'>            _stEthBalanceDecrease</span>
  362 |     | <span class='neutral'>        );</span>
  363 |     | <span class='neutral'></span>
  364 |     | <span class='unexecuted'>        vars.netDebtChange = _debtChange;</span>
  365 |     | <span class='neutral'></span>
  366 |     | <span class='unexecuted'>        vars.debt = cdpManager.getCdpDebt(_cdpId);</span>
  367 |     | <span class='unexecuted'>        vars.collShares = cdpManager.getCdpCollShares(_cdpId);</span>
  368 |     | <span class='neutral'></span>
  369 |     | <span class='neutral'>        // Get the cdp&#39;s old ICR before the adjustment, and what its new ICR will be after the adjustment</span>
  370 |     | <span class='unexecuted'>        uint256 _cdpStEthBalance = collateral.getPooledEthByShares(vars.collShares);</span>
  371 |     | <span class='unexecuted'>        require(</span>
  372 |     | <span class='unexecuted'>            _stEthBalanceDecrease &lt;= _cdpStEthBalance,</span>
  373 |     | <span class='neutral'>            &quot;BorrowerOperations: Cannot withdraw greater stEthBalance than the value in Cdp&quot;</span>
  374 |     | <span class='neutral'>        );</span>
  375 |     | <span class='unexecuted'>        vars.oldICR = EbtcMath._computeCR(_cdpStEthBalance, vars.debt, vars.price);</span>
  376 |     | <span class='unexecuted'>        vars.newICR = _getNewICRFromCdpChange(</span>
  377 |     | <span class='unexecuted'>            vars.collShares,</span>
  378 |     | <span class='unexecuted'>            vars.debt,</span>
  379 |     | <span class='unexecuted'>            vars.collSharesChange,</span>
  380 |     | <span class='unexecuted'>            vars.isCollIncrease,</span>
  381 |     | <span class='unexecuted'>            vars.netDebtChange,</span>
  382 |     | <span class='unexecuted'>            _isDebtIncrease,</span>
  383 |     | <span class='unexecuted'>            vars.price</span>
  384 |     | <span class='neutral'>        );</span>
  385 |     | <span class='neutral'></span>
  386 |     | <span class='neutral'>        // Check the adjustment satisfies all conditions for the current system mode</span>
  387 |     | <span class='unexecuted'>        bool isRecoveryMode = _checkRecoveryModeForTCR(_getCachedTCR(vars.price));</span>
  388 |     | <span class='unexecuted'>        _requireValidAdjustmentInCurrentMode(</span>
  389 |     | <span class='unexecuted'>            isRecoveryMode,</span>
  390 |     | <span class='unexecuted'>            _stEthBalanceDecrease,</span>
  391 |     | <span class='unexecuted'>            _isDebtIncrease,</span>
  392 |     | <span class='unexecuted'>            vars</span>
  393 |     | <span class='neutral'>        );</span>
  394 |     | <span class='neutral'></span>
  395 |     | <span class='neutral'>        // When the adjustment is a debt repayment, check it&#39;s a valid amount, that the caller has enough EBTC, and that the resulting debt is &gt;0</span>
  396 |     | <span class='unexecuted'>        if (!_isDebtIncrease &amp;&amp; _debtChange &gt; 0) {</span>
  397 |     | <span class='unexecuted'>            _requireValidDebtRepayment(vars.debt, vars.netDebtChange);</span>
  398 |     | <span class='unexecuted'>            _requireSufficientEbtcTokenBalance(msg.sender, vars.netDebtChange);</span>
  399 |     | <span class='unexecuted'>            _requireMinDebt(vars.debt - vars.netDebtChange);</span>
  400 |     | <span class='neutral'>        }</span>
  401 |     | <span class='neutral'></span>
  402 |     | <span class='unexecuted'>        (vars.newCollShares, vars.newDebt) = _getNewCdpAmounts(</span>
  403 |     | <span class='unexecuted'>            vars.collShares,</span>
  404 |     | <span class='unexecuted'>            vars.debt,</span>
  405 |     | <span class='unexecuted'>            vars.collSharesChange,</span>
  406 |     | <span class='unexecuted'>            vars.isCollIncrease,</span>
  407 |     | <span class='unexecuted'>            vars.netDebtChange,</span>
  408 |     | <span class='unexecuted'>            _isDebtIncrease</span>
  409 |     | <span class='neutral'>        );</span>
  410 |     | <span class='neutral'></span>
  411 |     | <span class='unexecuted'>        _requireMinDebt(vars.newDebt);</span>
  412 |     | <span class='unexecuted'>        _requireAtLeastMinNetStEthBalance(collateral.getPooledEthByShares(vars.newCollShares));</span>
  413 |     | <span class='neutral'></span>
  414 |     | <span class='unexecuted'>        cdpManager.updateCdp(</span>
  415 |     | <span class='unexecuted'>            _cdpId,</span>
  416 |     | <span class='unexecuted'>            _borrower,</span>
  417 |     | <span class='unexecuted'>            vars.collShares,</span>
  418 |     | <span class='unexecuted'>            vars.debt,</span>
  419 |     | <span class='unexecuted'>            vars.newCollShares,</span>
  420 |     | <span class='unexecuted'>            vars.newDebt</span>
  421 |     | <span class='neutral'>        );</span>
  422 |     | <span class='neutral'></span>
  423 |     | <span class='neutral'>        // Re-insert cdp in to the sorted list</span>
  424 |     | <span class='unexecuted'>        {</span>
  425 |     | <span class='unexecuted'>            uint256 newNICR = _getNewNominalICRFromCdpChange(vars, _isDebtIncrease);</span>
  426 |     | <span class='unexecuted'>            sortedCdps.reInsert(_cdpId, newNICR, _upperHint, _lowerHint);</span>
  427 |     | <span class='neutral'>        }</span>
  428 |     | <span class='neutral'></span>
  429 |     | <span class='neutral'>        // CEI: Process token movements</span>
  430 |     | <span class='unexecuted'>        {</span>
  431 |     | <span class='unexecuted'>            MoveTokensParams memory _varMvTokens = MoveTokensParams(</span>
  432 |     | <span class='unexecuted'>                msg.sender,</span>
  433 |     | <span class='unexecuted'>                vars.collSharesChange,</span>
  434 |     | <span class='unexecuted'>                (vars.isCollIncrease ? _stEthBalanceIncrease : 0),</span>
  435 |     | <span class='unexecuted'>                vars.isCollIncrease,</span>
  436 |     | <span class='unexecuted'>                _debtChange,</span>
  437 |     | <span class='unexecuted'>                _isDebtIncrease</span>
  438 |     | <span class='neutral'>            );</span>
  439 |     | <span class='unexecuted'>            _processTokenMovesFromAdjustment(_varMvTokens);</span>
  440 |     | <span class='neutral'>        }</span>
  441 |     | <span class='neutral'>    }</span>
  442 |     | <span class='neutral'></span>
  443 |     | <span class='unexecuted'>    function _openCdp(</span>
  444 |     | <span class='neutral'>        uint256 _debt,</span>
  445 |     | <span class='neutral'>        bytes32 _upperHint,</span>
  446 |     | <span class='neutral'>        bytes32 _lowerHint,</span>
  447 |     | <span class='neutral'>        uint256 _stEthBalance,</span>
  448 |     | <span class='neutral'>        address _borrower</span>
  449 |     | <span class='unexecuted'>    ) internal returns (bytes32) {</span>
  450 |     | <span class='unexecuted'>        _requireMinDebt(_debt);</span>
  451 |     | <span class='unexecuted'>        _requireBorrowerOrPositionManagerAndUpdateManagerApproval(_borrower);</span>
  452 |     | <span class='neutral'></span>
  453 |     | <span class='unexecuted'>        OpenCdpLocals memory vars;</span>
  454 |     | <span class='neutral'></span>
  455 |     | <span class='neutral'>        // ICR is based on the net stEth balance, i.e. the specified stEth balance amount - fixed liquidator incentive gas comp.</span>
  456 |     | <span class='unexecuted'>        vars.netStEthBalance = _calcNetStEthBalance(_stEthBalance);</span>
  457 |     | <span class='neutral'></span>
  458 |     | <span class='unexecuted'>        _requireAtLeastMinNetStEthBalance(vars.netStEthBalance);</span>
  459 |     | <span class='neutral'></span>
  460 |     | <span class='neutral'>        // Update global pending index before any operations</span>
  461 |     | <span class='unexecuted'>        cdpManager.syncGlobalAccounting();</span>
  462 |     | <span class='neutral'></span>
  463 |     | <span class='unexecuted'>        vars.price = priceFeed.fetchPrice();</span>
  464 |     | <span class='unexecuted'>        vars.debt = _debt;</span>
  465 |     | <span class='neutral'></span>
  466 |     | <span class='neutral'>        // Sanity check</span>
  467 |     | <span class='unexecuted'>        require(vars.netStEthBalance &gt; 0, &quot;BorrowerOperations: zero collateral for openCdp()!&quot;);</span>
  468 |     | <span class='neutral'></span>
  469 |     | <span class='unexecuted'>        uint256 _netCollAsShares = collateral.getSharesByPooledEth(vars.netStEthBalance);</span>
  470 |     | <span class='unexecuted'>        uint256 _liquidatorRewardShares = collateral.getSharesByPooledEth(LIQUIDATOR_REWARD);</span>
  471 |     | <span class='neutral'></span>
  472 |     | <span class='neutral'>        // ICR is based on the net coll, i.e. the requested coll amount - fixed liquidator incentive gas comp.</span>
  473 |     | <span class='unexecuted'>        vars.ICR = EbtcMath._computeCR(vars.netStEthBalance, vars.debt, vars.price);</span>
  474 |     | <span class='neutral'></span>
  475 |     | <span class='neutral'>        // NICR uses shares to normalize NICR across Cdps opened at different pooled ETH / shares ratios</span>
  476 |     | <span class='unexecuted'>        vars.NICR = EbtcMath._computeNominalCR(_netCollAsShares, vars.debt);</span>
  477 |     | <span class='neutral'></span>
  478 |     | <span class='neutral'>        /**</span>
  479 |     | <span class='neutral'>            In recovery move, ICR must be greater than CCR</span>
  480 |     | <span class='neutral'>            CCR &gt; MCR (125% vs 110%)</span>
  481 |     | <span class='neutral'></span>
  482 |     | <span class='neutral'>            In normal mode, ICR must be greater thatn MCR</span>
  483 |     | <span class='neutral'>            Additionally, the new system TCR after the Cdps addition must be &gt;CCR</span>
  484 |     | <span class='neutral'>        */</span>
  485 |     | <span class='unexecuted'>        bool isRecoveryMode = _checkRecoveryModeForTCR(_getCachedTCR(vars.price));</span>
  486 |     | <span class='unexecuted'>        uint256 newTCR = _getNewTCRFromCdpChange(</span>
  487 |     | <span class='unexecuted'>            vars.netStEthBalance,</span>
  488 |     | <span class='unexecuted'>            true,</span>
  489 |     | <span class='unexecuted'>            vars.debt,</span>
  490 |     | <span class='unexecuted'>            true,</span>
  491 |     | <span class='unexecuted'>            vars.price</span>
  492 |     | <span class='neutral'>        );</span>
  493 |     | <span class='unexecuted'>        if (isRecoveryMode) {</span>
  494 |     | <span class='unexecuted'>            _requireICRisNotBelowCCR(vars.ICR);</span>
  495 |     | <span class='neutral'></span>
  496 |     | <span class='neutral'>            // == Grace Period == //</span>
  497 |     | <span class='neutral'>            // We are in RM, Edge case is Depositing Coll could exit RM</span>
  498 |     | <span class='neutral'>            // We check with newTCR</span>
  499 |     | <span class='unexecuted'>            if (newTCR &lt; CCR) {</span>
  500 |     | <span class='neutral'>                // Notify RM</span>
  501 |     | <span class='unexecuted'>                cdpManager.notifyStartGracePeriod(newTCR);</span>
  502 |     | <span class='neutral'>            } else {</span>
  503 |     | <span class='neutral'>                // Notify Back to Normal Mode</span>
  504 |     | <span class='unexecuted'>                cdpManager.notifyEndGracePeriod(newTCR);</span>
  505 |     | <span class='neutral'>            }</span>
  506 |     | <span class='neutral'>        } else {</span>
  507 |     | <span class='unexecuted'>            _requireICRisNotBelowMCR(vars.ICR);</span>
  508 |     | <span class='unexecuted'>            _requireNewTCRisNotBelowCCR(newTCR);</span>
  509 |     | <span class='neutral'></span>
  510 |     | <span class='neutral'>            // == Grace Period == //</span>
  511 |     | <span class='neutral'>            // We are not in RM, no edge case, we always stay above RM</span>
  512 |     | <span class='neutral'>            // Always Notify Back to Normal Mode</span>
  513 |     | <span class='unexecuted'>            cdpManager.notifyEndGracePeriod(newTCR);</span>
  514 |     | <span class='neutral'>        }</span>
  515 |     | <span class='neutral'></span>
  516 |     | <span class='neutral'>        // Set the cdp struct&#39;s properties</span>
  517 |     | <span class='unexecuted'>        bytes32 _cdpId = sortedCdps.insert(_borrower, vars.NICR, _upperHint, _lowerHint);</span>
  518 |     | <span class='neutral'></span>
  519 |     | <span class='neutral'>        // Collision check: collisions should never occur</span>
  520 |     | <span class='neutral'>        // Explicitly prevent it by checking for `nonExistent`</span>
  521 |     | <span class='unexecuted'>        _requireCdpIsNonExistent(_cdpId);</span>
  522 |     | <span class='neutral'></span>
  523 |     | <span class='neutral'>        // Collateral is stored in shares form for normalization</span>
  524 |     | <span class='unexecuted'>        cdpManager.initializeCdp(</span>
  525 |     | <span class='neutral'>            _cdpId,</span>
  526 |     | <span class='unexecuted'>            vars.debt,</span>
  527 |     | <span class='neutral'>            _netCollAsShares,</span>
  528 |     | <span class='neutral'>            _liquidatorRewardShares,</span>
  529 |     | <span class='neutral'>            _borrower</span>
  530 |     | <span class='neutral'>        );</span>
  531 |     | <span class='neutral'></span>
  532 |     | <span class='neutral'>        // CEI: Mint the full debt amount, in eBTC tokens, to the caller</span>
  533 |     | <span class='unexecuted'>        _withdrawDebt(msg.sender, _debt);</span>
  534 |     | <span class='neutral'></span>
  535 |     | <span class='neutral'>        /**</span>
  536 |     | <span class='neutral'>            Note that only NET stEth balance (as shares) is considered part of the Cdp.</span>
  537 |     | <span class='neutral'>            The static liqudiation incentive is stored in the gas pool and can be considered a deposit / voucher to be returned upon Cdp close, to the closer.</span>
  538 |     | <span class='neutral'>            The close can happen from the borrower closing their own Cdp, a full liquidation, or a redemption.</span>
  539 |     | <span class='neutral'>        */</span>
  540 |     | <span class='neutral'></span>
  541 |     | <span class='neutral'>        // CEI: Move the collateral and liquidator gas compensation to the Active Pool. Track only net collateral for TCR purposes.</span>
  542 |     | <span class='unexecuted'>        _activePoolAddColl(_stEthBalance, _netCollAsShares);</span>
  543 |     | <span class='neutral'></span>
  544 |     | <span class='neutral'>        // Invariant check</span>
  545 |     | <span class='unexecuted'>        require(</span>
  546 |     | <span class='unexecuted'>            vars.netStEthBalance + LIQUIDATOR_REWARD == _stEthBalance,</span>
  547 |     | <span class='neutral'>            &quot;BorrowerOperations: deposited collateral mismatch!&quot;</span>
  548 |     | <span class='neutral'>        );</span>
  549 |     | <span class='neutral'></span>
  550 |     | <span class='unexecuted'>        return _cdpId;</span>
  551 |     | <span class='neutral'>    }</span>
  552 |     | <span class='neutral'></span>
  553 |     | <span class='neutral'>    /// @notice Function that allows the caller to repay all debt, withdraw collateral, and close the specified Cdp</span>
  554 |     | <span class='neutral'>    /// @notice Caller should have enough eBTC token to repay off the debt fully for specified Cdp</span>
  555 |     | <span class='neutral'>    /// @dev If caller is different from Cdp owner, it will need approval from Cdp owner for this call</span>
  556 |     | <span class='neutral'>    /// @param _cdpId The CdpId on which this operation is operated</span>
  557 |     | <span class='unexecuted'>    function closeCdp(bytes32 _cdpId) external override {</span>
  558 |     | <span class='unexecuted'>        address _borrower = sortedCdps.getOwnerAddress(_cdpId);</span>
  559 |     | <span class='unexecuted'>        _requireBorrowerOrPositionManagerAndUpdateManagerApproval(_borrower);</span>
  560 |     | <span class='neutral'></span>
  561 |     | <span class='unexecuted'>        _requireCdpisActive(cdpManager, _cdpId);</span>
  562 |     | <span class='neutral'></span>
  563 |     | <span class='unexecuted'>        cdpManager.syncAccounting(_cdpId);</span>
  564 |     | <span class='neutral'></span>
  565 |     | <span class='unexecuted'>        uint256 price = priceFeed.fetchPrice();</span>
  566 |     | <span class='unexecuted'>        _requireNotInRecoveryMode(_getCachedTCR(price));</span>
  567 |     | <span class='neutral'></span>
  568 |     | <span class='unexecuted'>        uint256 collShares = cdpManager.getCdpCollShares(_cdpId);</span>
  569 |     | <span class='unexecuted'>        uint256 debt = cdpManager.getCdpDebt(_cdpId);</span>
  570 |     | <span class='unexecuted'>        uint256 liquidatorRewardShares = cdpManager.getCdpLiquidatorRewardShares(_cdpId);</span>
  571 |     | <span class='neutral'></span>
  572 |     | <span class='unexecuted'>        _requireSufficientEbtcTokenBalance(msg.sender, debt);</span>
  573 |     | <span class='neutral'></span>
  574 |     | <span class='unexecuted'>        uint256 newTCR = _getNewTCRFromCdpChange(</span>
  575 |     | <span class='unexecuted'>            collateral.getPooledEthByShares(collShares),</span>
  576 |     | <span class='unexecuted'>            false,</span>
  577 |     | <span class='unexecuted'>            debt,</span>
  578 |     | <span class='unexecuted'>            false,</span>
  579 |     | <span class='unexecuted'>            price</span>
  580 |     | <span class='neutral'>        );</span>
  581 |     | <span class='unexecuted'>        _requireNewTCRisNotBelowCCR(newTCR);</span>
  582 |     | <span class='neutral'></span>
  583 |     | <span class='neutral'>        // == Grace Period == //</span>
  584 |     | <span class='neutral'>        // By definition we are not in RM, notify CDPManager to ensure &quot;Glass is on&quot;</span>
  585 |     | <span class='unexecuted'>        cdpManager.notifyEndGracePeriod(newTCR);</span>
  586 |     | <span class='neutral'></span>
  587 |     | <span class='unexecuted'>        cdpManager.closeCdp(_cdpId, _borrower, debt, collShares);</span>
  588 |     | <span class='neutral'></span>
  589 |     | <span class='neutral'>        // Burn the repaid EBTC from the user&#39;s balance</span>
  590 |     | <span class='unexecuted'>        _repayDebt(msg.sender, debt);</span>
  591 |     | <span class='neutral'></span>
  592 |     | <span class='neutral'>        // CEI: Send the collateral and liquidator reward shares back to the user</span>
  593 |     | <span class='unexecuted'>        activePool.transferSystemCollSharesAndLiquidatorReward(</span>
  594 |     | <span class='unexecuted'>            msg.sender,</span>
  595 |     | <span class='neutral'>            collShares,</span>
  596 |     | <span class='neutral'>            liquidatorRewardShares</span>
  597 |     | <span class='neutral'>        );</span>
  598 |     | <span class='neutral'>    }</span>
  599 |     | <span class='neutral'></span>
  600 |     | <span class='neutral'>    /// @notice Claim remaining collateral from a redemption or from a liquidation with ICR &gt; MCR in Recovery Mode</span>
  601 |     | <span class='neutral'>    /// @notice when a Cdp has been fully redeemed from and closed, or liquidated in Recovery Mode with a collateralization ratio higher enough (like over MCR)</span>
  602 |     | <span class='neutral'>    /// @notice the borrower is allowed to claim their stETH collateral surplus that remains in the system if any</span>
  603 |     | <span class='unexecuted'>    function claimSurplusCollShares() external override {</span>
  604 |     | <span class='neutral'>        // send ETH from CollSurplus Pool to owner</span>
  605 |     | <span class='unexecuted'>        collSurplusPool.claimSurplusCollShares(msg.sender);</span>
  606 |     | <span class='neutral'>    }</span>
  607 |     | <span class='neutral'></span>
  608 |     | <span class='neutral'>    /// @notice Returns true if the borrower is allowing position manager to act on their behalf</span>
  609 |     | <span class='neutral'>    /// @return PositionManagerApproval (None/OneTime/Persistent) status for given _borrower and _positionManager</span>
  610 |     | <span class='neutral'>    /// @param _borrower The Cdp owner who use eBTC</span>
  611 |     | <span class='neutral'>    /// @param _positionManager The position manager address in question whether it gets valid approval from _borrower</span>
  612 |     | <span class='unexecuted'>    function getPositionManagerApproval(</span>
  613 |     | <span class='neutral'>        address _borrower,</span>
  614 |     | <span class='neutral'>        address _positionManager</span>
  615 |     | <span class='unexecuted'>    ) external view override returns (PositionManagerApproval) {</span>
  616 |     | <span class='unexecuted'>        return _getPositionManagerApproval(_borrower, _positionManager);</span>
  617 |     | <span class='neutral'>    }</span>
  618 |     | <span class='neutral'></span>
  619 |     | <span class='unexecuted'>    function _getPositionManagerApproval(</span>
  620 |     | <span class='neutral'>        address _borrower,</span>
  621 |     | <span class='neutral'>        address _positionManager</span>
  622 |     | <span class='neutral'>    ) internal view returns (PositionManagerApproval) {</span>
  623 |     | <span class='unexecuted'>        return positionManagers[_borrower][_positionManager];</span>
  624 |     | <span class='neutral'>    }</span>
  625 |     | <span class='neutral'></span>
  626 |     | <span class='neutral'>    /// @notice Approve an account (_positionManager) to take arbitrary actions on your Cdps.</span>
  627 |     | <span class='neutral'>    /// @notice Position managers with &#39;Persistent&#39; status will be able to take actions indefinitely</span>
  628 |     | <span class='neutral'>    /// @notice Position managers with &#39;OneTIme&#39; status will be able to take a single action on one Cdp. Approval will be automatically revoked after one Cdp-related action.</span>
  629 |     | <span class='neutral'>    /// @notice Similar to approving tokens, approving a position manager allows _stealing of all positions_ if given to a malicious account.</span>
  630 |     | <span class='neutral'>    /// @param _positionManager The position manager address which will get the specified approval from caller</span>
  631 |     | <span class='neutral'>    /// @param _approval PositionManagerApproval (None/OneTime/Persistent) status set to the specified _positionManager for caller&#39;s Cdp</span>
  632 |     | <span class='unexecuted'>    function setPositionManagerApproval(</span>
  633 |     | <span class='neutral'>        address _positionManager,</span>
  634 |     | <span class='neutral'>        PositionManagerApproval _approval</span>
  635 |     | <span class='neutral'>    ) external override {</span>
  636 |     | <span class='unexecuted'>        _setPositionManagerApproval(msg.sender, _positionManager, _approval);</span>
  637 |     | <span class='neutral'>    }</span>
  638 |     | <span class='neutral'></span>
  639 |     | <span class='unexecuted'>    function _setPositionManagerApproval(</span>
  640 |     | <span class='neutral'>        address _borrower,</span>
  641 |     | <span class='neutral'>        address _positionManager,</span>
  642 |     | <span class='neutral'>        PositionManagerApproval _approval</span>
  643 |     | <span class='neutral'>    ) internal {</span>
  644 |     | <span class='unexecuted'>        positionManagers[_borrower][_positionManager] = _approval;</span>
  645 |     | <span class='unexecuted'>        emit PositionManagerApprovalSet(_borrower, _positionManager, _approval);</span>
  646 |     | <span class='neutral'>    }</span>
  647 |     | <span class='neutral'></span>
  648 |     | <span class='neutral'>    /// @notice Revoke a position manager from taking further actions on your Cdps</span>
  649 |     | <span class='neutral'>    /// @notice Similar to approving tokens, approving a position manager allows _stealing of all positions_ if given to a malicious account.</span>
  650 |     | <span class='neutral'>    /// @param _positionManager The position manager address which will get all approval revoked by caller (a Cdp owner)</span>
  651 |     | <span class='unexecuted'>    function revokePositionManagerApproval(address _positionManager) external override {</span>
  652 |     | <span class='unexecuted'>        _setPositionManagerApproval(msg.sender, _positionManager, PositionManagerApproval.None);</span>
  653 |     | <span class='neutral'>    }</span>
  654 |     | <span class='neutral'></span>
  655 |     | <span class='neutral'>    /// @notice Allows recipient of delegation to renounce it</span>
  656 |     | <span class='neutral'>    /// @param _borrower The Cdp owner address which will have all approval to the caller (a PositionManager) revoked.</span>
  657 |     | <span class='unexecuted'>    function renouncePositionManagerApproval(address _borrower) external override {</span>
  658 |     | <span class='unexecuted'>        _setPositionManagerApproval(_borrower, msg.sender, PositionManagerApproval.None);</span>
  659 |     | <span class='neutral'>    }</span>
  660 |     | <span class='neutral'></span>
  661 |     | <span class='neutral'>    /// @notice This function returns the domain separator for current chain</span>
  662 |     | <span class='neutral'>    /// @return EIP712 compatible Domain definition</span>
  663 |     | <span class='unexecuted'>    function DOMAIN_SEPARATOR() external view returns (bytes32) {</span>
  664 |     | <span class='unexecuted'>        return domainSeparator();</span>
  665 |     | <span class='neutral'>    }</span>
  666 |     | <span class='neutral'></span>
  667 |     | <span class='neutral'>    /// @notice This function returns the domain separator for current chain</span>
  668 |     | <span class='neutral'>    /// @return EIP712 compatible Domain definition</span>
  669 |     | <span class='unexecuted'>    function domainSeparator() public view override returns (bytes32) {</span>
  670 |     | <span class='unexecuted'>        if (_chainID() == _CACHED_CHAIN_ID) {</span>
  671 |     | <span class='unexecuted'>            return _CACHED_DOMAIN_SEPARATOR;</span>
  672 |     | <span class='neutral'>        } else {</span>
  673 |     | <span class='unexecuted'>            return _buildDomainSeparator(_TYPE_HASH, _HASHED_NAME, _HASHED_VERSION);</span>
  674 |     | <span class='neutral'>        }</span>
  675 |     | <span class='neutral'>    }</span>
  676 |     | <span class='neutral'></span>
  677 |     | <span class='neutral'>    function _chainID() private view returns (uint256) {</span>
  678 |     | <span class='unexecuted'>        return block.chainid;</span>
  679 |     | <span class='neutral'>    }</span>
  680 |     | <span class='neutral'></span>
  681 |     | <span class='unexecuted'>    function _buildDomainSeparator(</span>
  682 |     | <span class='neutral'>        bytes32 typeHash,</span>
  683 |     | <span class='neutral'>        bytes32 name,</span>
  684 |     | <span class='neutral'>        bytes32 version</span>
  685 |     | <span class='unexecuted'>    ) private view returns (bytes32) {</span>
  686 |     | <span class='unexecuted'>        return keccak256(abi.encode(typeHash, name, version, _chainID(), address(this)));</span>
  687 |     | <span class='neutral'>    }</span>
  688 |     | <span class='neutral'></span>
  689 |     | <span class='neutral'>    /// @notice This function returns the version parameter for the EIP712 domain</span>
  690 |     | <span class='neutral'>    /// @return EIP712 compatible version parameter</span>
  691 |     | <span class='unexecuted'>    function version() external pure override returns (string memory) {</span>
  692 |     | <span class='unexecuted'>        return _VERSION;</span>
  693 |     | <span class='neutral'>    }</span>
  694 |     | <span class='neutral'></span>
  695 |     | <span class='neutral'>    /// @notice This function returns hash of the fully encoded EIP712 message for the permitPositionManagerApproval.</span>
  696 |     | <span class='neutral'>    /// @return EIP712 compatible hash of Positon Manager permit</span>
  697 |     | <span class='unexecuted'>    function permitTypeHash() external pure override returns (bytes32) {</span>
  698 |     | <span class='neutral'>        return _PERMIT_POSITION_MANAGER_TYPEHASH;</span>
  699 |     | <span class='neutral'>    }</span>
  700 |     | <span class='neutral'></span>
  701 |     | <span class='neutral'>    /// @notice This function set given _approval for specified _borrower and _positionManager</span>
  702 |     | <span class='neutral'>    /// @notice by verifying the validity of given deadline and signature parameters (v, r, s).</span>
  703 |     | <span class='neutral'>    /// @param _borrower The Cdp owner</span>
  704 |     | <span class='neutral'>    /// @param _positionManager The delegate to which _borrower want to grant approval</span>
  705 |     | <span class='neutral'>    /// @param _approval The PositionManagerApproval (None/OneTime/Persistent) status to be set</span>
  706 |     | <span class='neutral'>    /// @param _deadline The permit valid deadline</span>
  707 |     | <span class='neutral'>    /// @param v The v part of signature from _borrower</span>
  708 |     | <span class='neutral'>    /// @param r The r part of signature from _borrower</span>
  709 |     | <span class='neutral'>    /// @param s The s part of signature from _borrower</span>
  710 |     | <span class='unexecuted'>    function permitPositionManagerApproval(</span>
  711 |     | <span class='neutral'>        address _borrower,</span>
  712 |     | <span class='neutral'>        address _positionManager,</span>
  713 |     | <span class='neutral'>        PositionManagerApproval _approval,</span>
  714 |     | <span class='neutral'>        uint256 _deadline,</span>
  715 |     | <span class='neutral'>        uint8 v,</span>
  716 |     | <span class='neutral'>        bytes32 r,</span>
  717 |     | <span class='neutral'>        bytes32 s</span>
  718 |     | <span class='unexecuted'>    ) external override {</span>
  719 |     | <span class='unexecuted'>        require(_deadline &gt;= block.timestamp, &quot;BorrowerOperations: Position manager permit expired&quot;);</span>
  720 |     | <span class='neutral'></span>
  721 |     | <span class='unexecuted'>        bytes32 digest = keccak256(</span>
  722 |     | <span class='unexecuted'>            abi.encodePacked(</span>
  723 |     | <span class='neutral'>                &quot;\x19\x01&quot;,</span>
  724 |     | <span class='unexecuted'>                domainSeparator(),</span>
  725 |     | <span class='unexecuted'>                keccak256(</span>
  726 |     | <span class='unexecuted'>                    abi.encode(</span>
  727 |     | <span class='neutral'>                        _PERMIT_POSITION_MANAGER_TYPEHASH,</span>
  728 |     | <span class='unexecuted'>                        _borrower,</span>
  729 |     | <span class='unexecuted'>                        _positionManager,</span>
  730 |     | <span class='unexecuted'>                        _approval,</span>
  731 |     | <span class='unexecuted'>                        _nonces[_borrower]++,</span>
  732 |     | <span class='unexecuted'>                        _deadline</span>
  733 |     | <span class='neutral'>                    )</span>
  734 |     | <span class='neutral'>                )</span>
  735 |     | <span class='neutral'>            )</span>
  736 |     | <span class='neutral'>        );</span>
  737 |     | <span class='unexecuted'>        address recoveredAddress = ecrecover(digest, v, r, s);</span>
  738 |     | <span class='unexecuted'>        require(</span>
  739 |     | <span class='unexecuted'>            recoveredAddress != address(0) &amp;&amp; recoveredAddress == _borrower,</span>
  740 |     | <span class='neutral'>            &quot;BorrowerOperations: Invalid signature&quot;</span>
  741 |     | <span class='neutral'>        );</span>
  742 |     | <span class='neutral'></span>
  743 |     | <span class='unexecuted'>        _setPositionManagerApproval(_borrower, _positionManager, _approval);</span>
  744 |     | <span class='neutral'>    }</span>
  745 |     | <span class='neutral'></span>
  746 |     | <span class='neutral'>    // --- Helper functions ---</span>
  747 |     | <span class='neutral'></span>
  748 |     | <span class='unexecuted'>    function _getCollSharesChangeFromStEthChange(</span>
  749 |     | <span class='neutral'>        uint256 _collReceived,</span>
  750 |     | <span class='neutral'>        uint256 _requestedCollWithdrawal</span>
  751 |     | <span class='unexecuted'>    ) internal view returns (uint256 collSharesChange, bool isCollIncrease) {</span>
  752 |     | <span class='unexecuted'>        if (_collReceived != 0) {</span>
  753 |     | <span class='unexecuted'>            collSharesChange = collateral.getSharesByPooledEth(_collReceived);</span>
  754 |     | <span class='unexecuted'>            isCollIncrease = true;</span>
  755 |     | <span class='neutral'>        } else {</span>
  756 |     | <span class='unexecuted'>            collSharesChange = collateral.getSharesByPooledEth(_requestedCollWithdrawal);</span>
  757 |     | <span class='neutral'>        }</span>
  758 |     | <span class='neutral'>    }</span>
  759 |     | <span class='neutral'></span>
  760 |     | <span class='neutral'>    /**</span>
  761 |     | <span class='neutral'>        @notice Process the token movements required by a Cdp adjustment.</span>
  762 |     | <span class='neutral'>        @notice Handles the cases of a debt increase / decrease, and/or a collateral increase / decrease.</span>
  763 |     | <span class='neutral'>     */</span>
  764 |     | <span class='unexecuted'>    function _processTokenMovesFromAdjustment(MoveTokensParams memory _varMvTokens) internal {</span>
  765 |     | <span class='neutral'>        // Debt increase: mint change value of new eBTC to user, increment ActivePool eBTC internal accounting</span>
  766 |     | <span class='unexecuted'>        if (_varMvTokens.isDebtIncrease) {</span>
  767 |     | <span class='unexecuted'>            _withdrawDebt(_varMvTokens.user, _varMvTokens.netDebtChange);</span>
  768 |     | <span class='neutral'>        } else {</span>
  769 |     | <span class='neutral'>            // Debt decrease: burn change value of eBTC from user, decrement ActivePool eBTC internal accounting</span>
  770 |     | <span class='unexecuted'>            _repayDebt(_varMvTokens.user, _varMvTokens.netDebtChange);</span>
  771 |     | <span class='neutral'>        }</span>
  772 |     | <span class='neutral'></span>
  773 |     | <span class='unexecuted'>        if (_varMvTokens.isCollIncrease) {</span>
  774 |     | <span class='neutral'>            // Coll increase: send change value of stETH to Active Pool, increment ActivePool stETH internal accounting</span>
  775 |     | <span class='unexecuted'>            _activePoolAddColl(_varMvTokens.collAddUnderlying, _varMvTokens.collSharesChange);</span>
  776 |     | <span class='neutral'>        } else {</span>
  777 |     | <span class='neutral'>            // Coll decrease: send change value of stETH to user, decrement ActivePool stETH internal accounting</span>
  778 |     | <span class='unexecuted'>            activePool.transferSystemCollShares(_varMvTokens.user, _varMvTokens.collSharesChange);</span>
  779 |     | <span class='neutral'>        }</span>
  780 |     | <span class='neutral'>    }</span>
  781 |     | <span class='neutral'></span>
  782 |     | <span class='neutral'>    /// @notice Send stETH to Active Pool and increase its recorded ETH balance</span>
  783 |     | <span class='neutral'>    /// @param _stEthBalance total balance of stETH to send, inclusive of coll and liquidatorRewardShares</span>
  784 |     | <span class='neutral'>    /// @param _sharesToTrack coll as shares (exclsuive of liquidator reward shares)</span>
  785 |     | <span class='neutral'>    /// @dev Liquidator reward shares are not considered as part of the system for CR purposes.</span>
  786 |     | <span class='neutral'>    /// @dev These number of liquidator shares associated with each Cdp are stored in the Cdp, while the actual tokens float in the active pool</span>
  787 |     | <span class='unexecuted'>    function _activePoolAddColl(uint256 _stEthBalance, uint256 _sharesToTrack) internal {</span>
  788 |     | <span class='neutral'>        // NOTE: No need for safe transfer if the collateral asset is standard. Make sure this is the case!</span>
  789 |     | <span class='unexecuted'>        collateral.transferFrom(msg.sender, address(activePool), _stEthBalance);</span>
  790 |     | <span class='unexecuted'>        activePool.increaseSystemCollShares(_sharesToTrack);</span>
  791 |     | <span class='neutral'>    }</span>
  792 |     | <span class='neutral'></span>
  793 |     | <span class='neutral'>    /// @dev Mint specified debt tokens to account and change global debt accounting accordingly</span>
  794 |     | <span class='unexecuted'>    function _withdrawDebt(address _account, uint256 _debt) internal {</span>
  795 |     | <span class='unexecuted'>        activePool.increaseSystemDebt(_debt);</span>
  796 |     | <span class='unexecuted'>        ebtcToken.mint(_account, _debt);</span>
  797 |     | <span class='neutral'>    }</span>
  798 |     | <span class='neutral'></span>
  799 |     | <span class='neutral'>    // Burn the specified amount of EBTC from _account and decreases the total active debt</span>
  800 |     | <span class='unexecuted'>    function _repayDebt(address _account, uint256 _debt) internal {</span>
  801 |     | <span class='unexecuted'>        activePool.decreaseSystemDebt(_debt);</span>
  802 |     | <span class='unexecuted'>        ebtcToken.burn(_account, _debt);</span>
  803 |     | <span class='neutral'>    }</span>
  804 |     | <span class='neutral'></span>
  805 |     | <span class='neutral'>    // --- &#39;Require&#39; wrapper functions ---</span>
  806 |     | <span class='neutral'></span>
  807 |     | <span class='unexecuted'>    function _requireSingularCollChange(</span>
  808 |     | <span class='neutral'>        uint256 _stEthBalanceIncrease,</span>
  809 |     | <span class='neutral'>        uint256 _stEthBalanceDecrease</span>
  810 |     | <span class='neutral'>    ) internal pure {</span>
  811 |     | <span class='unexecuted'>        require(</span>
  812 |     | <span class='unexecuted'>            _stEthBalanceIncrease == 0 || _stEthBalanceDecrease == 0,</span>
  813 |     | <span class='neutral'>            &quot;BorrowerOperations: Cannot add and withdraw collateral in same operation&quot;</span>
  814 |     | <span class='neutral'>        );</span>
  815 |     | <span class='neutral'>    }</span>
  816 |     | <span class='neutral'></span>
  817 |     | <span class='unexecuted'>    function _requireNonZeroAdjustment(</span>
  818 |     | <span class='neutral'>        uint256 _stEthBalanceIncrease,</span>
  819 |     | <span class='neutral'>        uint256 _debtChange,</span>
  820 |     | <span class='neutral'>        uint256 _stEthBalanceDecrease</span>
  821 |     | <span class='neutral'>    ) internal pure {</span>
  822 |     | <span class='unexecuted'>        require(</span>
  823 |     | <span class='unexecuted'>            _stEthBalanceIncrease &gt; 0 || _stEthBalanceDecrease &gt; 0 || _debtChange &gt; 0,</span>
  824 |     | <span class='neutral'>            &quot;BorrowerOperations: There must be either a collateral or debt change&quot;</span>
  825 |     | <span class='neutral'>        );</span>
  826 |     | <span class='neutral'>    }</span>
  827 |     | <span class='neutral'></span>
  828 |     | <span class='unexecuted'>    function _requireZeroOrMinAdjustment(uint256 _change) internal pure {</span>
  829 |     | <span class='unexecuted'>        require(</span>
  830 |     | <span class='unexecuted'>            _change == 0 || _change &gt;= MIN_CHANGE,</span>
  831 |     | <span class='neutral'>            &quot;BorrowerOperations: Collateral or debt change must be zero or above min&quot;</span>
  832 |     | <span class='neutral'>        );</span>
  833 |     | <span class='neutral'>    }</span>
  834 |     | <span class='neutral'></span>
  835 |     | <span class='unexecuted'>    function _requireCdpisActive(ICdpManager _cdpManager, bytes32 _cdpId) internal view {</span>
  836 |     | <span class='unexecuted'>        uint256 status = _cdpManager.getCdpStatus(_cdpId);</span>
  837 |     | <span class='unexecuted'>        require(status == 1, &quot;BorrowerOperations: Cdp does not exist or is closed&quot;);</span>
  838 |     | <span class='neutral'>    }</span>
  839 |     | <span class='neutral'></span>
  840 |     | <span class='unexecuted'>    function _requireCdpIsNonExistent(bytes32 _cdpId) internal view {</span>
  841 |     | <span class='unexecuted'>        uint status = cdpManager.getCdpStatus(_cdpId);</span>
  842 |     | <span class='unexecuted'>        require(status == 0, &quot;BorrowerOperations: Cdp is active or has been previously closed&quot;);</span>
  843 |     | <span class='neutral'>    }</span>
  844 |     | <span class='neutral'></span>
  845 |     | <span class='unexecuted'>    function _requireMinDebtChange(uint _debtChange) internal pure {</span>
  846 |     | <span class='unexecuted'>        require(</span>
  847 |     | <span class='unexecuted'>            _debtChange &gt;= MIN_CHANGE,</span>
  848 |     | <span class='neutral'>            &quot;BorrowerOperations: Debt increase requires min debtChange&quot;</span>
  849 |     | <span class='neutral'>        );</span>
  850 |     | <span class='neutral'>    }</span>
  851 |     | <span class='neutral'></span>
  852 |     | <span class='unexecuted'>    function _requireNotInRecoveryMode(uint256 _tcr) internal view {</span>
  853 |     | <span class='unexecuted'>        require(</span>
  854 |     | <span class='unexecuted'>            !_checkRecoveryModeForTCR(_tcr),</span>
  855 |     | <span class='neutral'>            &quot;BorrowerOperations: Operation not permitted during Recovery Mode&quot;</span>
  856 |     | <span class='neutral'>        );</span>
  857 |     | <span class='neutral'>    }</span>
  858 |     | <span class='neutral'></span>
  859 |     | <span class='unexecuted'>    function _requireNoStEthBalanceDecrease(uint256 _stEthBalanceDecrease) internal pure {</span>
  860 |     | <span class='unexecuted'>        require(</span>
  861 |     | <span class='unexecuted'>            _stEthBalanceDecrease == 0,</span>
  862 |     | <span class='neutral'>            &quot;BorrowerOperations: Collateral withdrawal not permitted during Recovery Mode&quot;</span>
  863 |     | <span class='neutral'>        );</span>
  864 |     | <span class='neutral'>    }</span>
  865 |     | <span class='neutral'></span>
  866 |     | <span class='unexecuted'>    function _requireValidAdjustmentInCurrentMode(</span>
  867 |     | <span class='neutral'>        bool _isRecoveryMode,</span>
  868 |     | <span class='neutral'>        uint256 _stEthBalanceDecrease,</span>
  869 |     | <span class='neutral'>        bool _isDebtIncrease,</span>
  870 |     | <span class='neutral'>        AdjustCdpLocals memory _vars</span>
  871 |     | <span class='neutral'>    ) internal {</span>
  872 |     | <span class='neutral'>        /*</span>
  873 |     | <span class='neutral'>         *In Recovery Mode, only allow:</span>
  874 |     | <span class='neutral'>         *</span>
  875 |     | <span class='neutral'>         * - Pure collateral top-up</span>
  876 |     | <span class='neutral'>         * - Pure debt repayment</span>
  877 |     | <span class='neutral'>         * - Collateral top-up with debt repayment</span>
  878 |     | <span class='neutral'>         * - A debt increase combined with a collateral top-up which makes the</span>
  879 |     | <span class='neutral'>         * ICR &gt;= 150% and improves the ICR (and by extension improves the TCR).</span>
  880 |     | <span class='neutral'>         *</span>
  881 |     | <span class='neutral'>         * In Normal Mode, ensure:</span>
  882 |     | <span class='neutral'>         *</span>
  883 |     | <span class='neutral'>         * - The new ICR is above MCR</span>
  884 |     | <span class='neutral'>         * - The adjustment won&#39;t pull the TCR below CCR</span>
  885 |     | <span class='neutral'>         */</span>
  886 |     | <span class='neutral'></span>
  887 |     | <span class='unexecuted'>        _vars.newTCR = _getNewTCRFromCdpChange(</span>
  888 |     | <span class='unexecuted'>            collateral.getPooledEthByShares(_vars.collSharesChange),</span>
  889 |     | <span class='unexecuted'>            _vars.isCollIncrease,</span>
  890 |     | <span class='unexecuted'>            _vars.netDebtChange,</span>
  891 |     | <span class='unexecuted'>            _isDebtIncrease,</span>
  892 |     | <span class='unexecuted'>            _vars.price</span>
  893 |     | <span class='neutral'>        );</span>
  894 |     | <span class='neutral'></span>
  895 |     | <span class='unexecuted'>        if (_isRecoveryMode) {</span>
  896 |     | <span class='unexecuted'>            _requireNoStEthBalanceDecrease(_stEthBalanceDecrease);</span>
  897 |     | <span class='unexecuted'>            if (_isDebtIncrease) {</span>
  898 |     | <span class='unexecuted'>                _requireICRisNotBelowCCR(_vars.newICR);</span>
  899 |     | <span class='unexecuted'>                _requireNoDecreaseOfICR(_vars.newICR, _vars.oldICR);</span>
  900 |     | <span class='neutral'>            }</span>
  901 |     | <span class='neutral'></span>
  902 |     | <span class='neutral'>            // == Grace Period == //</span>
  903 |     | <span class='neutral'>            // We are in RM, Edge case is Depositing Coll could exit RM</span>
  904 |     | <span class='neutral'>            // We check with newTCR</span>
  905 |     | <span class='unexecuted'>            if (_vars.newTCR &lt; CCR) {</span>
  906 |     | <span class='neutral'>                // Notify RM</span>
  907 |     | <span class='unexecuted'>                cdpManager.notifyStartGracePeriod(_vars.newTCR);</span>
  908 |     | <span class='neutral'>            } else {</span>
  909 |     | <span class='neutral'>                // Notify Back to Normal Mode</span>
  910 |     | <span class='unexecuted'>                cdpManager.notifyEndGracePeriod(_vars.newTCR);</span>
  911 |     | <span class='neutral'>            }</span>
  912 |     | <span class='neutral'>        } else {</span>
  913 |     | <span class='neutral'>            // if Normal Mode</span>
  914 |     | <span class='unexecuted'>            _requireICRisNotBelowMCR(_vars.newICR);</span>
  915 |     | <span class='unexecuted'>            _requireNewTCRisNotBelowCCR(_vars.newTCR);</span>
  916 |     | <span class='neutral'></span>
  917 |     | <span class='neutral'>            // == Grace Period == //</span>
  918 |     | <span class='neutral'>            // We are not in RM, no edge case, we always stay above RM</span>
  919 |     | <span class='neutral'>            // Always Notify Back to Normal Mode</span>
  920 |     | <span class='unexecuted'>            cdpManager.notifyEndGracePeriod(_vars.newTCR);</span>
  921 |     | <span class='neutral'>        }</span>
  922 |     | <span class='neutral'>    }</span>
  923 |     | <span class='neutral'></span>
  924 |     | <span class='unexecuted'>    function _requireICRisNotBelowMCR(uint256 _newICR) internal pure {</span>
  925 |     | <span class='unexecuted'>        require(</span>
  926 |     | <span class='unexecuted'>            _newICR &gt;= MCR,</span>
  927 |     | <span class='neutral'>            &quot;BorrowerOperations: An operation that would result in ICR &lt; MCR is not permitted&quot;</span>
  928 |     | <span class='neutral'>        );</span>
  929 |     | <span class='neutral'>    }</span>
  930 |     | <span class='neutral'></span>
  931 |     | <span class='unexecuted'>    function _requireICRisNotBelowCCR(uint256 _newICR) internal pure {</span>
  932 |     | <span class='unexecuted'>        require(_newICR &gt;= CCR, &quot;BorrowerOperations: Operation must leave cdp with ICR &gt;= CCR&quot;);</span>
  933 |     | <span class='neutral'>    }</span>
  934 |     | <span class='neutral'></span>
  935 |     | <span class='unexecuted'>    function _requireNoDecreaseOfICR(uint256 _newICR, uint256 _oldICR) internal pure {</span>
  936 |     | <span class='unexecuted'>        require(</span>
  937 |     | <span class='unexecuted'>            _newICR &gt;= _oldICR,</span>
  938 |     | <span class='neutral'>            &quot;BorrowerOperations: Cannot decrease your Cdp&#39;s ICR in Recovery Mode&quot;</span>
  939 |     | <span class='neutral'>        );</span>
  940 |     | <span class='neutral'>    }</span>
  941 |     | <span class='neutral'></span>
  942 |     | <span class='unexecuted'>    function _requireNewTCRisNotBelowCCR(uint256 _newTCR) internal pure {</span>
  943 |     | <span class='unexecuted'>        require(</span>
  944 |     | <span class='unexecuted'>            _newTCR &gt;= CCR,</span>
  945 |     | <span class='neutral'>            &quot;BorrowerOperations: An operation that would result in TCR &lt; CCR is not permitted&quot;</span>
  946 |     | <span class='neutral'>        );</span>
  947 |     | <span class='neutral'>    }</span>
  948 |     | <span class='neutral'></span>
  949 |     | <span class='unexecuted'>    function _requireMinDebt(uint256 _debt) internal pure {</span>
  950 |     | <span class='unexecuted'>        require(_debt &gt;= MIN_CHANGE, &quot;BorrowerOperations: Debt must be above min&quot;);</span>
  951 |     | <span class='neutral'>    }</span>
  952 |     | <span class='neutral'></span>
  953 |     | <span class='unexecuted'>    function _requireAtLeastMinNetStEthBalance(uint256 _stEthBalance) internal pure {</span>
  954 |     | <span class='unexecuted'>        require(</span>
  955 |     | <span class='unexecuted'>            _stEthBalance &gt;= MIN_NET_STETH_BALANCE,</span>
  956 |     | <span class='neutral'>            &quot;BorrowerOperations: Cdp&#39;s net stEth balance must not fall below minimum&quot;</span>
  957 |     | <span class='neutral'>        );</span>
  958 |     | <span class='neutral'>    }</span>
  959 |     | <span class='neutral'></span>
  960 |     | <span class='unexecuted'>    function _requireValidDebtRepayment(uint256 _currentDebt, uint256 _debtRepayment) internal pure {</span>
  961 |     | <span class='unexecuted'>        require(</span>
  962 |     | <span class='unexecuted'>            _debtRepayment &lt;= _currentDebt,</span>
  963 |     | <span class='neutral'>            &quot;BorrowerOperations: Amount repaid must not be larger than the Cdp&#39;s debt&quot;</span>
  964 |     | <span class='neutral'>        );</span>
  965 |     | <span class='neutral'>    }</span>
  966 |     | <span class='neutral'></span>
  967 |     | <span class='unexecuted'>    function _requireSufficientEbtcTokenBalance(</span>
  968 |     | <span class='neutral'>        address _account,</span>
  969 |     | <span class='neutral'>        uint256 _debtRepayment</span>
  970 |     | <span class='neutral'>    ) internal view {</span>
  971 |     | <span class='unexecuted'>        require(</span>
  972 |     | <span class='unexecuted'>            ebtcToken.balanceOf(_account) &gt;= _debtRepayment,</span>
  973 |     | <span class='neutral'>            &quot;BorrowerOperations: Caller doesnt have enough eBTC to make repayment&quot;</span>
  974 |     | <span class='neutral'>        );</span>
  975 |     | <span class='neutral'>    }</span>
  976 |     | <span class='neutral'></span>
  977 |     | <span class='unexecuted'>    function _requireBorrowerOrPositionManagerAndUpdateManagerApproval(address _borrower) internal {</span>
  978 |     | <span class='unexecuted'>        if (_borrower == msg.sender) {</span>
  979 |     | <span class='neutral'>            return; // Early return, no delegation</span>
  980 |     | <span class='neutral'>        }</span>
  981 |     | <span class='neutral'></span>
  982 |     | <span class='unexecuted'>        PositionManagerApproval _approval = _getPositionManagerApproval(_borrower, msg.sender);</span>
  983 |     | <span class='neutral'>        // Must be an approved position manager at this point</span>
  984 |     | <span class='unexecuted'>        require(</span>
  985 |     | <span class='unexecuted'>            _approval != PositionManagerApproval.None,</span>
  986 |     | <span class='neutral'>            &quot;BorrowerOperations: Only borrower account or approved position manager can OpenCdp on borrower&#39;s behalf&quot;</span>
  987 |     | <span class='neutral'>        );</span>
  988 |     | <span class='neutral'></span>
  989 |     | <span class='neutral'>        // Conditional Adjustment</span>
  990 |     | <span class='neutral'>        /// @dev If this is a position manager operation with a one-time approval, clear that approval</span>
  991 |     | <span class='neutral'>        /// @dev If the PositionManagerApproval was none, we should have failed with the check in _requireBorrowerOrPositionManagerAndUpdateManagerApproval</span>
  992 |     | <span class='unexecuted'>        if (_approval == PositionManagerApproval.OneTime) {</span>
  993 |     | <span class='unexecuted'>            _setPositionManagerApproval(_borrower, msg.sender, PositionManagerApproval.None);</span>
  994 |     | <span class='neutral'>        }</span>
  995 |     | <span class='neutral'>    }</span>
  996 |     | <span class='neutral'></span>
  997 |     | <span class='neutral'>    // --- ICR and TCR getters ---</span>
  998 |     | <span class='neutral'></span>
  999 |     | <span class='neutral'>    // Compute the new collateral ratio, considering the change in coll and debt. Assumes 0 pending rewards.</span>
 1000 |     | <span class='unexecuted'>    function _getNewNominalICRFromCdpChange(</span>
 1001 |     | <span class='neutral'>        AdjustCdpLocals memory vars,</span>
 1002 |     | <span class='neutral'>        bool _isDebtIncrease</span>
 1003 |     | <span class='unexecuted'>    ) internal pure returns (uint256) {</span>
 1004 |     | <span class='unexecuted'>        (uint256 newCollShares, uint256 newDebt) = _getNewCdpAmounts(</span>
 1005 |     | <span class='unexecuted'>            vars.collShares,</span>
 1006 |     | <span class='unexecuted'>            vars.debt,</span>
 1007 |     | <span class='unexecuted'>            vars.collSharesChange,</span>
 1008 |     | <span class='unexecuted'>            vars.isCollIncrease,</span>
 1009 |     | <span class='unexecuted'>            vars.netDebtChange,</span>
 1010 |     | <span class='unexecuted'>            _isDebtIncrease</span>
 1011 |     | <span class='neutral'>        );</span>
 1012 |     | <span class='neutral'></span>
 1013 |     | <span class='unexecuted'>        uint256 newNICR = EbtcMath._computeNominalCR(newCollShares, newDebt);</span>
 1014 |     | <span class='neutral'>        return newNICR;</span>
 1015 |     | <span class='neutral'>    }</span>
 1016 |     | <span class='neutral'></span>
 1017 |     | <span class='neutral'>    // Compute the new collateral ratio, considering the change in coll and debt. Assumes 0 pending rewards.</span>
 1018 |     | <span class='unexecuted'>    function _getNewICRFromCdpChange(</span>
 1019 |     | <span class='neutral'>        uint256 _collShares,</span>
 1020 |     | <span class='neutral'>        uint256 _debt,</span>
 1021 |     | <span class='neutral'>        uint256 _collSharesChange,</span>
 1022 |     | <span class='neutral'>        bool _isCollIncrease,</span>
 1023 |     | <span class='neutral'>        uint256 _debtChange,</span>
 1024 |     | <span class='neutral'>        bool _isDebtIncrease,</span>
 1025 |     | <span class='neutral'>        uint256 _price</span>
 1026 |     | <span class='unexecuted'>    ) internal view returns (uint256) {</span>
 1027 |     | <span class='unexecuted'>        (uint256 newCollShares, uint256 newDebt) = _getNewCdpAmounts(</span>
 1028 |     | <span class='unexecuted'>            _collShares,</span>
 1029 |     | <span class='unexecuted'>            _debt,</span>
 1030 |     | <span class='unexecuted'>            _collSharesChange,</span>
 1031 |     | <span class='unexecuted'>            _isCollIncrease,</span>
 1032 |     | <span class='unexecuted'>            _debtChange,</span>
 1033 |     | <span class='unexecuted'>            _isDebtIncrease</span>
 1034 |     | <span class='neutral'>        );</span>
 1035 |     | <span class='neutral'></span>
 1036 |     | <span class='unexecuted'>        uint256 newICR = EbtcMath._computeCR(</span>
 1037 |     | <span class='unexecuted'>            collateral.getPooledEthByShares(newCollShares),</span>
 1038 |     | <span class='unexecuted'>            newDebt,</span>
 1039 |     | <span class='unexecuted'>            _price</span>
 1040 |     | <span class='neutral'>        );</span>
 1041 |     | <span class='neutral'>        return newICR;</span>
 1042 |     | <span class='neutral'>    }</span>
 1043 |     | <span class='neutral'></span>
 1044 |     | <span class='unexecuted'>    function _getNewCdpAmounts(</span>
 1045 |     | <span class='neutral'>        uint256 _collShares,</span>
 1046 |     | <span class='neutral'>        uint256 _debt,</span>
 1047 |     | <span class='neutral'>        uint256 _collSharesChange,</span>
 1048 |     | <span class='neutral'>        bool _isCollIncrease,</span>
 1049 |     | <span class='neutral'>        uint256 _debtChange,</span>
 1050 |     | <span class='neutral'>        bool _isDebtIncrease</span>
 1051 |     | <span class='unexecuted'>    ) internal pure returns (uint256, uint256) {</span>
 1052 |     | <span class='unexecuted'>        uint256 newCollShares = _collShares;</span>
 1053 |     | <span class='unexecuted'>        uint256 newDebt = _debt;</span>
 1054 |     | <span class='neutral'></span>
 1055 |     | <span class='unexecuted'>        newCollShares = _isCollIncrease</span>
 1056 |     | <span class='unexecuted'>            ? _collShares + _collSharesChange</span>
 1057 |     | <span class='unexecuted'>            : _collShares - _collSharesChange;</span>
 1058 |     | <span class='unexecuted'>        newDebt = _isDebtIncrease ? _debt + _debtChange : _debt - _debtChange;</span>
 1059 |     | <span class='neutral'></span>
 1060 |     | <span class='unexecuted'>        return (newCollShares, newDebt);</span>
 1061 |     | <span class='neutral'>    }</span>
 1062 |     | <span class='neutral'></span>
 1063 |     | <span class='unexecuted'>    function _getNewTCRFromCdpChange(</span>
 1064 |     | <span class='neutral'>        uint256 _stEthBalanceChange,</span>
 1065 |     | <span class='neutral'>        bool _isCollIncrease,</span>
 1066 |     | <span class='neutral'>        uint256 _debtChange,</span>
 1067 |     | <span class='neutral'>        bool _isDebtIncrease,</span>
 1068 |     | <span class='neutral'>        uint256 _price</span>
 1069 |     | <span class='unexecuted'>    ) internal view returns (uint256) {</span>
 1070 |     | <span class='unexecuted'>        uint256 _systemCollShares = getSystemCollShares();</span>
 1071 |     | <span class='unexecuted'>        uint256 systemStEthBalance = collateral.getPooledEthByShares(_systemCollShares);</span>
 1072 |     | <span class='unexecuted'>        uint256 systemDebt = _getSystemDebt();</span>
 1073 |     | <span class='neutral'></span>
 1074 |     | <span class='unexecuted'>        systemStEthBalance = _isCollIncrease</span>
 1075 |     | <span class='unexecuted'>            ? systemStEthBalance + _stEthBalanceChange</span>
 1076 |     | <span class='unexecuted'>            : systemStEthBalance - _stEthBalanceChange;</span>
 1077 |     | <span class='unexecuted'>        systemDebt = _isDebtIncrease ? systemDebt + _debtChange : systemDebt - _debtChange;</span>
 1078 |     | <span class='neutral'></span>
 1079 |     | <span class='unexecuted'>        uint256 newTCR = EbtcMath._computeCR(systemStEthBalance, systemDebt, _price);</span>
 1080 |     | <span class='neutral'>        return newTCR;</span>
 1081 |     | <span class='neutral'>    }</span>
 1082 |     | <span class='neutral'></span>
 1083 |     | <span class='neutral'>    // === Flash Loans === //</span>
 1084 |     | <span class='neutral'></span>
 1085 |     | <span class='neutral'>    /// @notice Borrow assets with a flash loan</span>
 1086 |     | <span class='neutral'>    /// @param receiver The address to receive the flash loan</span>
 1087 |     | <span class='neutral'>    /// @param token The address of the token to loan</span>
 1088 |     | <span class='neutral'>    /// @param amount The amount of tokens to loan</span>
 1089 |     | <span class='neutral'>    /// @param data Additional data</span>
 1090 |     | <span class='neutral'>    /// @return A boolean value indicating whether the operation was successful</span>
 1091 |     | <span class='unexecuted'>    function flashLoan(</span>
 1092 |     | <span class='neutral'>        IERC3156FlashBorrower receiver,</span>
 1093 |     | <span class='neutral'>        address token,</span>
 1094 |     | <span class='neutral'>        uint256 amount,</span>
 1095 |     | <span class='neutral'>        bytes calldata data</span>
 1096 |     | <span class='unexecuted'>    ) external override returns (bool) {</span>
 1097 |     | <span class='unexecuted'>        require(amount &gt; 0, &quot;BorrowerOperations: 0 Amount&quot;);</span>
 1098 |     | <span class='unexecuted'>        uint256 fee = flashFee(token, amount); // NOTE: Check for `eBTCToken` is implicit here // NOTE: Pause check is here</span>
 1099 |     | <span class='unexecuted'>        require(amount &lt;= maxFlashLoan(token), &quot;BorrowerOperations: Too much&quot;);</span>
 1100 |     | <span class='neutral'></span>
 1101 |     | <span class='neutral'>        // Issue EBTC</span>
 1102 |     | <span class='unexecuted'>        ebtcToken.mint(address(receiver), amount);</span>
 1103 |     | <span class='neutral'></span>
 1104 |     | <span class='neutral'>        // Callback</span>
 1105 |     | <span class='unexecuted'>        require(</span>
 1106 |     | <span class='unexecuted'>            receiver.onFlashLoan(msg.sender, token, amount, fee, data) == FLASH_SUCCESS_VALUE,</span>
 1107 |     | <span class='neutral'>            &quot;IERC3156: Callback failed&quot;</span>
 1108 |     | <span class='neutral'>        );</span>
 1109 |     | <span class='neutral'></span>
 1110 |     | <span class='neutral'>        // Gas: Repay from user balance, so we don&#39;t trigger a new SSTORE</span>
 1111 |     | <span class='neutral'>        // Safe to use transferFrom and unchecked as it&#39;s a standard token</span>
 1112 |     | <span class='neutral'>        // Also saves gas</span>
 1113 |     | <span class='neutral'>        // Send both fee and amount to FEE_RECIPIENT, to burn allowance per EIP-3156</span>
 1114 |     | <span class='unexecuted'>        ebtcToken.transferFrom(address(receiver), feeRecipientAddress, fee + amount);</span>
 1115 |     | <span class='neutral'></span>
 1116 |     | <span class='neutral'>        // Burn amount, from FEE_RECIPIENT</span>
 1117 |     | <span class='unexecuted'>        ebtcToken.burn(feeRecipientAddress, amount);</span>
 1118 |     | <span class='neutral'></span>
 1119 |     | <span class='unexecuted'>        emit FlashLoanSuccess(address(receiver), token, amount, fee);</span>
 1120 |     | <span class='neutral'></span>
 1121 |     | <span class='unexecuted'>        return true;</span>
 1122 |     | <span class='neutral'>    }</span>
 1123 |     | <span class='neutral'></span>
 1124 |     | <span class='neutral'>    /// @notice Calculate the flash loan fee for a given token and amount loaned</span>
 1125 |     | <span class='neutral'>    /// @param token The address of the token to calculate the fee for</span>
 1126 |     | <span class='neutral'>    /// @param amount The amount of tokens to calculate the fee for</span>
 1127 |     | <span class='neutral'>    /// @return The flashloan fee calcualted for given token and loan amount</span>
 1128 |     | <span class='unexecuted'>    function flashFee(address token, uint256 amount) public view override returns (uint256) {</span>
 1129 |     | <span class='unexecuted'>        require(token == address(ebtcToken), &quot;BorrowerOperations: EBTC Only&quot;);</span>
 1130 |     | <span class='unexecuted'>        require(!flashLoansPaused, &quot;BorrowerOperations: Flash Loans Paused&quot;);</span>
 1131 |     | <span class='neutral'></span>
 1132 |     | <span class='unexecuted'>        return (amount * feeBps) / MAX_BPS;</span>
 1133 |     | <span class='neutral'>    }</span>
 1134 |     | <span class='neutral'></span>
 1135 |     | <span class='neutral'>    /// @notice Get the maximum flash loan amount for a specific token</span>
 1136 |     | <span class='neutral'>    /// @param token The address of the token to get the maximum flash loan amount for, exclusively used here for eBTC token</span>
 1137 |     | <span class='neutral'>    /// @return The maximum available flashloan amount for the token, equals to `type(uint112).max`</span>
 1138 |     | <span class='unexecuted'>    function maxFlashLoan(address token) public view override returns (uint256) {</span>
 1139 |     | <span class='unexecuted'>        if (token != address(ebtcToken)) {</span>
 1140 |     | <span class='unexecuted'>            return 0;</span>
 1141 |     | <span class='neutral'>        }</span>
 1142 |     | <span class='neutral'></span>
 1143 |     | <span class='unexecuted'>        if (flashLoansPaused) {</span>
 1144 |     | <span class='unexecuted'>            return 0;</span>
 1145 |     | <span class='neutral'>        }</span>
 1146 |     | <span class='neutral'></span>
 1147 |     | <span class='unexecuted'>        return type(uint112).max;</span>
 1148 |     | <span class='neutral'>    }</span>
 1149 |     | <span class='neutral'></span>
 1150 |     | <span class='neutral'>    // === Governed Functions ==</span>
 1151 |     | <span class='neutral'></span>
 1152 |     | <span class='neutral'>    /// @notice Sets new Fee for FlashLoans</span>
 1153 |     | <span class='neutral'>    /// @param _newFee The new flashloan fee to be set</span>
 1154 |     | <span class='unexecuted'>    function setFeeBps(uint256 _newFee) external requiresAuth {</span>
 1155 |     | <span class='unexecuted'>        require(_newFee &lt;= MAX_FEE_BPS, &quot;ERC3156FlashLender: _newFee should &lt;= MAX_FEE_BPS&quot;);</span>
 1156 |     | <span class='neutral'></span>
 1157 |     | <span class='unexecuted'>        cdpManager.syncGlobalAccounting();</span>
 1158 |     | <span class='neutral'></span>
 1159 |     | <span class='neutral'>        // set new flash fee</span>
 1160 |     | <span class='unexecuted'>        uint256 _oldFee = feeBps;</span>
 1161 |     | <span class='unexecuted'>        feeBps = uint16(_newFee);</span>
 1162 |     | <span class='unexecuted'>        emit FlashFeeSet(msg.sender, _oldFee, _newFee);</span>
 1163 |     | <span class='neutral'>    }</span>
 1164 |     | <span class='neutral'></span>
 1165 |     | <span class='neutral'>    /// @notice Should Flashloans be paused?</span>
 1166 |     | <span class='neutral'>    /// @param _paused The flag (true or false) whether flashloan will be paused</span>
 1167 |     | <span class='unexecuted'>    function setFlashLoansPaused(bool _paused) external requiresAuth {</span>
 1168 |     | <span class='unexecuted'>        cdpManager.syncGlobalAccounting();</span>
 1169 |     | <span class='neutral'></span>
 1170 |     | <span class='unexecuted'>        flashLoansPaused = _paused;</span>
 1171 |     | <span class='unexecuted'>        emit FlashLoansPaused(msg.sender, _paused);</span>
 1172 |     | <span class='neutral'>    }</span>
 1173 |     | <span class='neutral'>}</span>
 1174 |     | <span class='neutral'></span>

</code>
<br />

<b>/mnt/c/Users/Lourens/Documents/Recon-Fuzz/collabs/ebtc/packages/contracts/contracts/CdpManager.sol</b>
<code>
    1 |     | <span class='neutral'>// SPDX-License-Identifier: MIT</span>
    2 |     | <span class='neutral'></span>
    3 |     | <span class='neutral'>pragma solidity 0.8.17;</span>
    4 |     | <span class='neutral'></span>
    5 |     | <span class='neutral'>import &quot;./Interfaces/ICdpManager.sol&quot;;</span>
    6 |     | <span class='neutral'>import &quot;./Interfaces/ICollSurplusPool.sol&quot;;</span>
    7 |     | <span class='neutral'>import &quot;./Interfaces/IEBTCToken.sol&quot;;</span>
    8 |     | <span class='neutral'>import &quot;./Interfaces/ISortedCdps.sol&quot;;</span>
    9 |     | <span class='neutral'>import &quot;./Dependencies/ICollateralTokenOracle.sol&quot;;</span>
   10 |     | <span class='neutral'>import &quot;./CdpManagerStorage.sol&quot;;</span>
   11 |     | <span class='neutral'>import &quot;./Dependencies/Proxy.sol&quot;;</span>
   12 |     | <span class='neutral'>import &quot;./Dependencies/EbtcBase.sol&quot;;</span>
   13 |     | <span class='neutral'>import &quot;./Dependencies/EbtcMath.sol&quot;;</span>
   14 |     | <span class='neutral'></span>
   15 |     | <span class='neutral'>/// @title CdpManager is mainly in charge of all Cdp related core processing like collateral &amp; debt accounting, split fee calculation, redemption, etc</span>
   16 |     | <span class='neutral'>/// @notice Except for redemption, end user typically will interact with BorrowerOeprations for individual Cdp actions</span>
   17 |     | <span class='neutral'>/// @dev CdpManager also handles liquidation through delegatecall to LiquidationLibrary</span>
   18 |     | <span class='unexecuted'>contract CdpManager is CdpManagerStorage, ICdpManager, Proxy {</span>
   19 |     | <span class='neutral'>    // --- Dependency setter ---</span>
   20 |     | <span class='neutral'></span>
   21 |     | <span class='neutral'>    /// @notice Constructor for CdpManager contract.</span>
   22 |     | <span class='neutral'>    /// @dev Sets up dependencies and initial staking reward split.</span>
   23 |     | <span class='neutral'>    /// @param _liquidationLibraryAddress Address of the liquidation library.</span>
   24 |     | <span class='neutral'>    /// @param _authorityAddress Address of the authority.</span>
   25 |     | <span class='neutral'>    /// @param _borrowerOperationsAddress Address of BorrowerOperations.</span>
   26 |     | <span class='neutral'>    /// @param _collSurplusPoolAddress Address of CollSurplusPool.</span>
   27 |     | <span class='neutral'>    /// @param _ebtcTokenAddress Address of the eBTC token.</span>
   28 |     | <span class='neutral'>    /// @param _sortedCdpsAddress Address of the SortedCDPs.</span>
   29 |     | <span class='neutral'>    /// @param _activePoolAddress Address of the ActivePool.</span>
   30 |     | <span class='neutral'>    /// @param _priceFeedAddress Address of the price feed.</span>
   31 |     | <span class='neutral'>    /// @param _collTokenAddress Address of the collateral token.</span>
   32 |     | <span class='unexecuted'>    constructor(</span>
   33 |     | <span class='neutral'>        address _liquidationLibraryAddress,</span>
   34 |     | <span class='neutral'>        address _authorityAddress,</span>
   35 |     | <span class='neutral'>        address _borrowerOperationsAddress,</span>
   36 |     | <span class='neutral'>        address _collSurplusPoolAddress,</span>
   37 |     | <span class='neutral'>        address _ebtcTokenAddress,</span>
   38 |     | <span class='neutral'>        address _sortedCdpsAddress,</span>
   39 |     | <span class='neutral'>        address _activePoolAddress,</span>
   40 |     | <span class='neutral'>        address _priceFeedAddress,</span>
   41 |     | <span class='neutral'>        address _collTokenAddress</span>
   42 |     | <span class='neutral'>    )</span>
   43 |     | <span class='neutral'>        CdpManagerStorage(</span>
   44 |     | <span class='unexecuted'>            _liquidationLibraryAddress,</span>
   45 |     | <span class='unexecuted'>            _authorityAddress,</span>
   46 |     | <span class='unexecuted'>            _borrowerOperationsAddress,</span>
   47 |     | <span class='unexecuted'>            _collSurplusPoolAddress,</span>
   48 |     | <span class='unexecuted'>            _ebtcTokenAddress,</span>
   49 |     | <span class='unexecuted'>            _sortedCdpsAddress,</span>
   50 |     | <span class='unexecuted'>            _activePoolAddress,</span>
   51 |     | <span class='unexecuted'>            _priceFeedAddress,</span>
   52 |     | <span class='unexecuted'>            _collTokenAddress</span>
   53 |     | <span class='neutral'>        )</span>
   54 |     | <span class='unexecuted'>    {</span>
   55 |     | <span class='unexecuted'>        stakingRewardSplit = STAKING_REWARD_SPLIT;</span>
   56 |     | <span class='neutral'>        // Emit initial value for analytics</span>
   57 |     | <span class='unexecuted'>        emit StakingRewardSplitSet(stakingRewardSplit);</span>
   58 |     | <span class='neutral'></span>
   59 |     | <span class='unexecuted'>        (uint256 _oldIndex, uint256 _newIndex) = _readStEthIndex();</span>
   60 |     | <span class='unexecuted'>        _syncStEthIndex(_oldIndex, _newIndex);</span>
   61 |     | <span class='unexecuted'>        systemStEthFeePerUnitIndex = DECIMAL_PRECISION;</span>
   62 |     | <span class='neutral'>    }</span>
   63 |     | <span class='neutral'></span>
   64 |     | <span class='neutral'>    // --- Cdp Liquidation functions ---</span>
   65 |     | <span class='neutral'>    // -----------------------------------------------------------------</span>
   66 |     | <span class='neutral'>    //    Cdp ICR     |       Liquidation Behavior (TODO gas compensation?)</span>
   67 |     | <span class='neutral'>    //</span>
   68 |     | <span class='neutral'>    //  &lt; MCR         |  debt could be fully repaid by liquidator</span>
   69 |     | <span class='neutral'>    //                |  and ALL collateral transferred to liquidator</span>
   70 |     | <span class='neutral'>    //                |  OR debt could be partially repaid by liquidator and</span>
   71 |     | <span class='neutral'>    //                |  liquidator could get collateral of (repaidDebt * max(LICR, min(ICR, MCR)) / price)</span>
   72 |     | <span class='neutral'>    //</span>
   73 |     | <span class='neutral'>    //  &gt; MCR &amp; &lt; TCR |  only liquidatable in Recovery Mode (TCR &lt; CCR)</span>
   74 |     | <span class='neutral'>    //                |  debt could be fully repaid by liquidator</span>
   75 |     | <span class='neutral'>    //                |  and up to (repaid debt * MCR) worth of collateral</span>
   76 |     | <span class='neutral'>    //                |  transferred to liquidator while the residue of collateral</span>
   77 |     | <span class='neutral'>    //                |  will be available in CollSurplusPool for owner to claim</span>
   78 |     | <span class='neutral'>    //                |  OR debt could be partially repaid by liquidator and</span>
   79 |     | <span class='neutral'>    //                |  liquidator could get collateral of (repaidDebt * max(LICR, min(ICR, MCR)) / price)</span>
   80 |     | <span class='neutral'>    // -----------------------------------------------------------------</span>
   81 |     | <span class='neutral'></span>
   82 |     | <span class='neutral'>    /// @notice Fully liquidate a single Cdp by ID. Cdp must meet the criteria for liquidation at the time of execution.</span>
   83 |     | <span class='neutral'>    /// @notice callable by anyone, attempts to liquidate the CdpId. Executes successfully if Cdp meets the conditions for liquidation (e.g. in Normal Mode, it liquidates if the Cdp&#39;s ICR &lt; the system MCR).</span>
   84 |     | <span class='neutral'>    /// @dev forwards msg.data directly to the liquidation library using OZ proxy core delegation function</span>
   85 |     | <span class='neutral'>    /// @param _cdpId ID of the Cdp to liquidate.</span>
   86 |     | <span class='unexecuted'>    function liquidate(bytes32 _cdpId) external override {</span>
   87 |     | <span class='unexecuted'>        _delegate(liquidationLibrary);</span>
   88 |     | <span class='neutral'>    }</span>
   89 |     | <span class='neutral'></span>
   90 |     | <span class='neutral'>    /// @notice Partially liquidate a single Cdp.</span>
   91 |     | <span class='neutral'>    /// @dev forwards msg.data directly to the liquidation library using OZ proxy core delegation function</span>
   92 |     | <span class='neutral'>    /// @param _cdpId ID of the Cdp to partially liquidate.</span>
   93 |     | <span class='neutral'>    /// @param _partialAmount Amount to partially liquidate.</span>
   94 |     | <span class='neutral'>    /// @param _upperPartialHint Upper hint for reinsertion of the Cdp into the linked list.</span>
   95 |     | <span class='neutral'>    /// @param _lowerPartialHint Lower hint for reinsertion of the Cdp into the linked list.</span>
   96 |     | <span class='unexecuted'>    function partiallyLiquidate(</span>
   97 |     | <span class='neutral'>        bytes32 _cdpId,</span>
   98 |     | <span class='neutral'>        uint256 _partialAmount,</span>
   99 |     | <span class='neutral'>        bytes32 _upperPartialHint,</span>
  100 |     | <span class='neutral'>        bytes32 _lowerPartialHint</span>
  101 |     | <span class='neutral'>    ) external override {</span>
  102 |     | <span class='unexecuted'>        _requireAmountGreaterThanMin(_partialAmount);</span>
  103 |     | <span class='unexecuted'>        _delegate(liquidationLibrary);</span>
  104 |     | <span class='neutral'>    }</span>
  105 |     | <span class='neutral'></span>
  106 |     | <span class='neutral'>    // --- Batch/Sequence liquidation functions ---</span>
  107 |     | <span class='neutral'></span>
  108 |     | <span class='neutral'>    /// @notice Attempt to liquidate a custom list of Cdps provided by the caller</span>
  109 |     | <span class='neutral'>    /// @notice Callable by anyone, accepts a custom list of Cdps addresses as an argument.</span>
  110 |     | <span class='neutral'>    /// @notice Steps through the provided list and attempts to liquidate every Cdp, until it reaches the end or it runs out of gas.</span>
  111 |     | <span class='neutral'>    /// @notice A Cdp is liquidated only if it meets the conditions for liquidation.</span>
  112 |     | <span class='neutral'>    /// @dev forwards msg.data directly to the liquidation library using OZ proxy core delegation function</span>
  113 |     | <span class='neutral'>    /// @param _cdpArray Array of Cdps to liquidate.</span>
  114 |     | <span class='unexecuted'>    function batchLiquidateCdps(bytes32[] memory _cdpArray) external override {</span>
  115 |     | <span class='neutral'>        _delegate(liquidationLibrary);</span>
  116 |     | <span class='neutral'>    }</span>
  117 |     | <span class='neutral'></span>
  118 |     | <span class='neutral'>    // --- Redemption functions ---</span>
  119 |     | <span class='neutral'></span>
  120 |     | <span class='neutral'>    /// @notice // Redeem as much collateral as possible from given Cdp in exchange for EBTC up to specified maximum</span>
  121 |     | <span class='neutral'>    /// @param _redeemColFromCdp Struct containing variables for redeeming collateral.</span>
  122 |     | <span class='neutral'>    /// @return singleRedemption Struct containing redemption values.</span>
  123 |     | <span class='unexecuted'>    function _redeemCollateralFromCdp(</span>
  124 |     | <span class='neutral'>        SingleRedemptionInputs memory _redeemColFromCdp</span>
  125 |     | <span class='unexecuted'>    ) internal returns (SingleRedemptionValues memory singleRedemption) {</span>
  126 |     | <span class='neutral'>        // Determine the remaining amount (lot) to be redeemed,</span>
  127 |     | <span class='neutral'>        // capped by the entire debt of the Cdp minus the liquidation reserve</span>
  128 |     | <span class='unexecuted'>        singleRedemption.debtToRedeem = EbtcMath._min(</span>
  129 |     | <span class='unexecuted'>            _redeemColFromCdp.maxEBTCamount,</span>
  130 |     | <span class='unexecuted'>            Cdps[_redeemColFromCdp.cdpId].debt /// @audit Redeem everything</span>
  131 |     | <span class='neutral'>        );</span>
  132 |     | <span class='neutral'></span>
  133 |     | <span class='unexecuted'>        singleRedemption.collSharesDrawn = collateral.getSharesByPooledEth(</span>
  134 |     | <span class='unexecuted'>            (singleRedemption.debtToRedeem * DECIMAL_PRECISION) / _redeemColFromCdp.price</span>
  135 |     | <span class='neutral'>        );</span>
  136 |     | <span class='neutral'></span>
  137 |     | <span class='neutral'>        // Repurposing this struct here to avoid stack too deep.</span>
  138 |     | <span class='unexecuted'>        CdpDebtAndCollShares memory _oldDebtAndColl = CdpDebtAndCollShares(</span>
  139 |     | <span class='unexecuted'>            Cdps[_redeemColFromCdp.cdpId].debt,</span>
  140 |     | <span class='unexecuted'>            Cdps[_redeemColFromCdp.cdpId].coll</span>
  141 |     | <span class='neutral'>        );</span>
  142 |     | <span class='neutral'></span>
  143 |     | <span class='neutral'>        // Decrease the debt and collateral of the current Cdp according to the EBTC lot and corresponding ETH to send</span>
  144 |     | <span class='unexecuted'>        uint256 newDebt = _oldDebtAndColl.debt - singleRedemption.debtToRedeem;</span>
  145 |     | <span class='unexecuted'>        uint256 newColl = _oldDebtAndColl.collShares - singleRedemption.collSharesDrawn;</span>
  146 |     | <span class='neutral'></span>
  147 |     | <span class='unexecuted'>        if (newDebt == 0) {</span>
  148 |     | <span class='neutral'>            // No debt remains, close Cdp</span>
  149 |     | <span class='neutral'>            // No debt left in the Cdp, therefore the cdp gets closed</span>
  150 |     | <span class='unexecuted'>            {</span>
  151 |     | <span class='unexecuted'>                address _borrower = sortedCdps.getOwnerAddress(_redeemColFromCdp.cdpId);</span>
  152 |     | <span class='unexecuted'>                uint256 _liquidatorRewardShares = uint256(</span>
  153 |     | <span class='unexecuted'>                    Cdps[_redeemColFromCdp.cdpId].liquidatorRewardShares</span>
  154 |     | <span class='neutral'>                );</span>
  155 |     | <span class='neutral'></span>
  156 |     | <span class='unexecuted'>                singleRedemption.collSurplus = newColl; // Collateral surplus processed on full redemption</span>
  157 |     | <span class='unexecuted'>                singleRedemption.liquidatorRewardShares = _liquidatorRewardShares;</span>
  158 |     | <span class='unexecuted'>                singleRedemption.fullRedemption = true;</span>
  159 |     | <span class='neutral'></span>
  160 |     | <span class='unexecuted'>                _closeCdpByRedemption(</span>
  161 |     | <span class='unexecuted'>                    _redeemColFromCdp.cdpId,</span>
  162 |     | <span class='neutral'>                    0,</span>
  163 |     | <span class='neutral'>                    newColl,</span>
  164 |     | <span class='neutral'>                    _liquidatorRewardShares,</span>
  165 |     | <span class='neutral'>                    _borrower</span>
  166 |     | <span class='neutral'>                );</span>
  167 |     | <span class='neutral'></span>
  168 |     | <span class='unexecuted'>                emit CdpUpdated(</span>
  169 |     | <span class='unexecuted'>                    _redeemColFromCdp.cdpId,</span>
  170 |     | <span class='neutral'>                    _borrower,</span>
  171 |     | <span class='unexecuted'>                    msg.sender,</span>
  172 |     | <span class='unexecuted'>                    _oldDebtAndColl.debt,</span>
  173 |     | <span class='unexecuted'>                    _oldDebtAndColl.collShares,</span>
  174 |     | <span class='neutral'>                    0,</span>
  175 |     | <span class='neutral'>                    0,</span>
  176 |     | <span class='neutral'>                    0,</span>
  177 |     | <span class='unexecuted'>                    CdpOperation.redeemCollateral</span>
  178 |     | <span class='neutral'>                );</span>
  179 |     | <span class='neutral'>            }</span>
  180 |     | <span class='unexecuted'>        } else {</span>
  181 |     | <span class='neutral'>            // Debt remains, reinsert Cdp</span>
  182 |     | <span class='unexecuted'>            uint256 newNICR = EbtcMath._computeNominalCR(newColl, newDebt);</span>
  183 |     | <span class='neutral'></span>
  184 |     | <span class='neutral'>            /*</span>
  185 |     | <span class='neutral'>             * If the provided hint is out of date, we bail since trying to reinsert without a good hint will almost</span>
  186 |     | <span class='neutral'>             * certainly result in running out of gas.</span>
  187 |     | <span class='neutral'>             *</span>
  188 |     | <span class='neutral'>             * If the resultant net coll of the partial is less than the minimum, we bail.</span>
  189 |     | <span class='neutral'>             */</span>
  190 |     | <span class='unexecuted'>            if (</span>
  191 |     | <span class='unexecuted'>                newNICR != _redeemColFromCdp.partialRedemptionHintNICR ||</span>
  192 |     | <span class='unexecuted'>                collateral.getPooledEthByShares(newColl) &lt; MIN_NET_STETH_BALANCE ||</span>
  193 |     | <span class='unexecuted'>                newDebt &lt; MIN_CHANGE</span>
  194 |     | <span class='neutral'>            ) {</span>
  195 |     | <span class='unexecuted'>                _updateStakeAndTotalStakes(_redeemColFromCdp.cdpId);</span>
  196 |     | <span class='neutral'></span>
  197 |     | <span class='unexecuted'>                emit CdpUpdated(</span>
  198 |     | <span class='unexecuted'>                    _redeemColFromCdp.cdpId,</span>
  199 |     | <span class='unexecuted'>                    ISortedCdps(sortedCdps).getOwnerAddress(_redeemColFromCdp.cdpId),</span>
  200 |     | <span class='unexecuted'>                    msg.sender,</span>
  201 |     | <span class='unexecuted'>                    _oldDebtAndColl.debt,</span>
  202 |     | <span class='unexecuted'>                    _oldDebtAndColl.collShares,</span>
  203 |     | <span class='neutral'>                    _oldDebtAndColl.debt,</span>
  204 |     | <span class='neutral'>                    _oldDebtAndColl.collShares,</span>
  205 |     | <span class='unexecuted'>                    Cdps[_redeemColFromCdp.cdpId].stake,</span>
  206 |     | <span class='unexecuted'>                    CdpOperation.failedPartialRedemption</span>
  207 |     | <span class='neutral'>                );</span>
  208 |     | <span class='neutral'></span>
  209 |     | <span class='unexecuted'>                singleRedemption.cancelledPartial = true;</span>
  210 |     | <span class='neutral'>                return singleRedemption;</span>
  211 |     | <span class='neutral'>            }</span>
  212 |     | <span class='neutral'></span>
  213 |     | <span class='unexecuted'>            singleRedemption.newPartialNICR = newNICR;</span>
  214 |     | <span class='neutral'></span>
  215 |     | <span class='unexecuted'>            Cdps[_redeemColFromCdp.cdpId].debt = newDebt;</span>
  216 |     | <span class='unexecuted'>            Cdps[_redeemColFromCdp.cdpId].coll = newColl;</span>
  217 |     | <span class='unexecuted'>            _updateStakeAndTotalStakes(_redeemColFromCdp.cdpId);</span>
  218 |     | <span class='neutral'></span>
  219 |     | <span class='unexecuted'>            emit CdpUpdated(</span>
  220 |     | <span class='unexecuted'>                _redeemColFromCdp.cdpId,</span>
  221 |     | <span class='unexecuted'>                ISortedCdps(sortedCdps).getOwnerAddress(_redeemColFromCdp.cdpId),</span>
  222 |     | <span class='unexecuted'>                msg.sender,</span>
  223 |     | <span class='unexecuted'>                _oldDebtAndColl.debt,</span>
  224 |     | <span class='unexecuted'>                _oldDebtAndColl.collShares,</span>
  225 |     | <span class='unexecuted'>                newDebt,</span>
  226 |     | <span class='unexecuted'>                newColl,</span>
  227 |     | <span class='unexecuted'>                Cdps[_redeemColFromCdp.cdpId].stake,</span>
  228 |     | <span class='unexecuted'>                CdpOperation.redeemCollateral</span>
  229 |     | <span class='neutral'>            );</span>
  230 |     | <span class='neutral'>        }</span>
  231 |     | <span class='neutral'></span>
  232 |     | <span class='unexecuted'>        return singleRedemption;</span>
  233 |     | <span class='neutral'>    }</span>
  234 |     | <span class='neutral'></span>
  235 |     | <span class='neutral'>    /*</span>
  236 |     | <span class='neutral'>     * Called when a full redemption occurs, and closes the cdp.</span>
  237 |     | <span class='neutral'>     * The redeemer swaps (debt) EBTC for (debt)</span>
  238 |     | <span class='neutral'>     * worth of stETH, so the stETH liquidation reserve is all that remains.</span>
  239 |     | <span class='neutral'>     * In order to close the cdp, the stETH liquidation reserve is returned to the Cdp owner,</span>
  240 |     | <span class='neutral'>     * The debt recorded on the cdp&#39;s struct is zero&#39;d elswhere, in _closeCdp.</span>
  241 |     | <span class='neutral'>     * Any surplus stETH left in the cdp, is sent to the Coll surplus pool, and can be later claimed by the borrower.</span>
  242 |     | <span class='neutral'>     */</span>
  243 |     | <span class='unexecuted'>    function _closeCdpByRedemption(</span>
  244 |     | <span class='neutral'>        bytes32 _cdpId,</span>
  245 |     | <span class='neutral'>        uint256 _EBTC,</span>
  246 |     | <span class='neutral'>        uint256 _collSurplus,</span>
  247 |     | <span class='neutral'>        uint256 _liquidatorRewardShares,</span>
  248 |     | <span class='neutral'>        address _borrower</span>
  249 |     | <span class='neutral'>    ) internal {</span>
  250 |     | <span class='unexecuted'>        _closeCdpWithoutRemovingSortedCdps(_cdpId, Status.closedByRedemption);</span>
  251 |     | <span class='neutral'></span>
  252 |     | <span class='neutral'>        // Update Active Pool EBTC, and send ETH to account</span>
  253 |     | <span class='unexecuted'>        activePool.decreaseSystemDebt(_EBTC);</span>
  254 |     | <span class='neutral'></span>
  255 |     | <span class='neutral'>        // Register stETH surplus from upcoming transfers of stETH collateral and liquidator reward shares</span>
  256 |     | <span class='unexecuted'>        collSurplusPool.increaseSurplusCollShares(</span>
  257 |     | <span class='neutral'>            _cdpId,</span>
  258 |     | <span class='neutral'>            _borrower,</span>
  259 |     | <span class='neutral'>            _collSurplus,</span>
  260 |     | <span class='neutral'>            _liquidatorRewardShares</span>
  261 |     | <span class='neutral'>        );</span>
  262 |     | <span class='neutral'></span>
  263 |     | <span class='neutral'>        // CEI: send stETH coll and liquidator reward shares from Active Pool to CollSurplus Pool</span>
  264 |     | <span class='unexecuted'>        activePool.transferSystemCollSharesAndLiquidatorReward(</span>
  265 |     | <span class='unexecuted'>            address(collSurplusPool),</span>
  266 |     | <span class='neutral'>            _collSurplus,</span>
  267 |     | <span class='neutral'>            _liquidatorRewardShares</span>
  268 |     | <span class='neutral'>        );</span>
  269 |     | <span class='neutral'>    }</span>
  270 |     | <span class='neutral'></span>
  271 |     | <span class='neutral'>    /// @notice Returns true if the CdpId specified is the lowest-ICR Cdp in the linked list that still has MCR &gt; ICR</span>
  272 |     | <span class='neutral'>    /// @dev Returns false if the specified CdpId hint is blank</span>
  273 |     | <span class='neutral'>    /// @dev Returns false if the specified CdpId hint doesn&#39;t exist in the list</span>
  274 |     | <span class='neutral'>    /// @dev Returns false if the ICR of the specified CdpId is &lt; MCR</span>
  275 |     | <span class='neutral'>    /// @dev Returns true if the specified CdpId is not blank, exists in the list, has an ICR &gt; MCR, and the next lower Cdp in the list is either blank or has an ICR &lt; MCR.</span>
  276 |     | <span class='unexecuted'>    function _isValidFirstRedemptionHint(</span>
  277 |     | <span class='neutral'>        bytes32 _firstRedemptionHint,</span>
  278 |     | <span class='neutral'>        uint256 _price</span>
  279 |     | <span class='unexecuted'>    ) internal view returns (bool) {</span>
  280 |     | <span class='unexecuted'>        if (</span>
  281 |     | <span class='unexecuted'>            _firstRedemptionHint == sortedCdps.nonExistId() ||</span>
  282 |     | <span class='unexecuted'>            !sortedCdps.contains(_firstRedemptionHint) ||</span>
  283 |     | <span class='unexecuted'>            getSyncedICR(_firstRedemptionHint, _price) &lt; MCR</span>
  284 |     | <span class='neutral'>        ) {</span>
  285 |     | <span class='unexecuted'>            return false;</span>
  286 |     | <span class='neutral'>        }</span>
  287 |     | <span class='neutral'></span>
  288 |     | <span class='unexecuted'>        bytes32 nextCdp = sortedCdps.getNext(_firstRedemptionHint);</span>
  289 |     | <span class='unexecuted'>        return nextCdp == sortedCdps.nonExistId() || getSyncedICR(nextCdp, _price) &lt; MCR;</span>
  290 |     | <span class='neutral'>    }</span>
  291 |     | <span class='neutral'></span>
  292 |     | <span class='neutral'>    /// @notice Send _debt EBTC to the system and redeem the corresponding amount of collateral</span>
  293 |     | <span class='neutral'>    /// @notice from as many Cdps as are needed to fill the redemption request.</span>
  294 |     | <span class='neutral'>    /// @notice</span>
  295 |     | <span class='neutral'>    /// @notice Note that if _debt is very large, this function can run out of gas, specially if traversed cdps are small (meaning many small Cdps are redeemed against).</span>
  296 |     | <span class='neutral'>    /// @notice This can be easily avoided by splitting the total _debt in appropriate chunks and calling the function multiple times.</span>
  297 |     | <span class='neutral'>    /// @notice</span>
  298 |     | <span class='neutral'>    /// @notice There is a optional parameter `_maxIterations` which can also be provided, so the loop through Cdps is capped (if it’s zero, it will be ignored).</span>
  299 |     | <span class='neutral'>    /// @notice This makes it easier to avoid OOG for the frontend, as only knowing approximately the average cost of an iteration is enough,</span>
  300 |     | <span class='neutral'>    /// @notice without needing to know the &quot;topology&quot; of the cdp list. It also avoids the need to set the cap in stone in the contract,</span>
  301 |     | <span class='neutral'>    /// @notice nor doing gas calculations, as both gas price and opcode costs can vary.</span>
  302 |     | <span class='neutral'>    /// @notice</span>
  303 |     | <span class='neutral'>    /// @notice All Cdps that are redeemed from -- with the likely exception of the last one -- will end up with no debt left,</span>
  304 |     | <span class='neutral'>    /// @notice therefore they will be closed.</span>
  305 |     | <span class='neutral'>    /// @notice If the last Cdp does have some remaining debt &amp; collateral (it has a valid meaningful ICR) then reinsertion of the CDP</span>
  306 |     | <span class='neutral'>    /// @notice could be anywhere in the entire SortedCdps list, therefore this redemption requires a hint.</span>
  307 |     | <span class='neutral'>    /// @notice</span>
  308 |     | <span class='neutral'>    /// @notice A frontend should use HintHelper.getRedemptionHints() to calculate what the ICR of this Cdp will be after redemption,</span>
  309 |     | <span class='neutral'>    /// @notice and pass a hint for its position in the SortedCdps list along with the ICR value that the hint was found for.</span>
  310 |     | <span class='neutral'>    /// @notice</span>
  311 |     | <span class='neutral'>    /// @notice If another transaction modifies the list between calling getRedemptionHints()</span>
  312 |     | <span class='neutral'>    /// @notice and passing the hints to redeemCollateral(), it is very likely that the last (partially)</span>
  313 |     | <span class='neutral'>    /// @notice redeemed Cdp would end up with a different ICR than what the hint is for.</span>
  314 |     | <span class='neutral'>    /// @notice</span>
  315 |     | <span class='neutral'>    /// @notice In this case, the redemption will stop after the last completely redeemed Cdp and the sender will keep the</span>
  316 |     | <span class='neutral'>    /// @notice remaining EBTC amount, which they can attempt to redeem later.</span>
  317 |     | <span class='neutral'>    /// @param _debt The total eBTC debt amount to be redeemed</span>
  318 |     | <span class='neutral'>    /// @param _firstRedemptionHint The first CdpId to be considered for redemption, could get from HintHelper.getRedemptionHints()</span>
  319 |     | <span class='neutral'>    /// @param _upperPartialRedemptionHint The first CdpId to be considered for redemption, could get from HintHelper.getApproxHint(_partialRedemptionHintNICR) then SortedCdps.findInsertPosition(_partialRedemptionHintNICR)</span>
  320 |     | <span class='neutral'>    /// @param _lowerPartialRedemptionHint The first CdpId to be considered for redemption, could get from HintHelper.getApproxHint(_partialRedemptionHintNICR) then SortedCdps.findInsertPosition(_partialRedemptionHintNICR)</span>
  321 |     | <span class='neutral'>    /// @param _partialRedemptionHintNICR The new Nominal Collateral Ratio (NICR) of the last redeemed CDP after partial redemption, could get from HintHelper.getRedemptionHints()</span>
  322 |     | <span class='neutral'>    /// @param _maxIterations The maximum allowed iteration along the SortedCdps loop, if zero then there is no limit</span>
  323 |     | <span class='neutral'>    /// @param _maxFeePercentage The maximum allowed redemption fee for this redemption</span>
  324 |     | <span class='unexecuted'>    function redeemCollateral(</span>
  325 |     | <span class='neutral'>        uint256 _debt,</span>
  326 |     | <span class='neutral'>        bytes32 _firstRedemptionHint,</span>
  327 |     | <span class='neutral'>        bytes32 _upperPartialRedemptionHint,</span>
  328 |     | <span class='neutral'>        bytes32 _lowerPartialRedemptionHint,</span>
  329 |     | <span class='neutral'>        uint256 _partialRedemptionHintNICR,</span>
  330 |     | <span class='neutral'>        uint256 _maxIterations,</span>
  331 |     | <span class='neutral'>        uint256 _maxFeePercentage</span>
  332 |     | <span class='neutral'>    ) external override nonReentrantSelfAndBOps {</span>
  333 |     | <span class='unexecuted'>        RedemptionTotals memory totals;</span>
  334 |     | <span class='neutral'></span>
  335 |     | <span class='neutral'>        // early check to ensure redemption is not paused</span>
  336 |     | <span class='unexecuted'>        require(redemptionsPaused == false, &quot;CdpManager: Redemptions Paused&quot;);</span>
  337 |     | <span class='neutral'></span>
  338 |     | <span class='unexecuted'>        _requireValidMaxFeePercentage(_maxFeePercentage);</span>
  339 |     | <span class='neutral'></span>
  340 |     | <span class='unexecuted'>        _syncGlobalAccounting(); // Apply state, we will syncGracePeriod at end of function</span>
  341 |     | <span class='neutral'></span>
  342 |     | <span class='unexecuted'>        totals.price = priceFeed.fetchPrice();</span>
  343 |     | <span class='unexecuted'>        {</span>
  344 |     | <span class='unexecuted'>            (</span>
  345 |     | <span class='unexecuted'>                uint256 tcrAtStart,</span>
  346 |     | <span class='neutral'>                uint256 systemCollSharesAtStart,</span>
  347 |     | <span class='neutral'>                uint256 systemDebtAtStart</span>
  348 |     | <span class='unexecuted'>            ) = _getTCRWithSystemDebtAndCollShares(totals.price);</span>
  349 |     | <span class='unexecuted'>            totals.tcrAtStart = tcrAtStart;</span>
  350 |     | <span class='unexecuted'>            totals.systemCollSharesAtStart = systemCollSharesAtStart;</span>
  351 |     | <span class='unexecuted'>            totals.systemDebtAtStart = systemDebtAtStart;</span>
  352 |     | <span class='neutral'></span>
  353 |     | <span class='unexecuted'>            if (!activePool.twapDisabled()) {</span>
  354 |     | <span class='unexecuted'>                try activePool.observe() returns (uint256 _twapSystemDebtAtStart) {</span>
  355 |     | <span class='neutral'>                    // @audit Return the smaller value of the two, bias towards a larger redemption scaling fee</span>
  356 |     | <span class='unexecuted'>                    totals.twapSystemDebtAtStart = EbtcMath._min(</span>
  357 |     | <span class='unexecuted'>                        _twapSystemDebtAtStart,</span>
  358 |     | <span class='unexecuted'>                        systemDebtAtStart</span>
  359 |     | <span class='neutral'>                    );</span>
  360 |     | <span class='neutral'>                } catch {</span>
  361 |     | <span class='unexecuted'>                    totals.twapSystemDebtAtStart = systemDebtAtStart;</span>
  362 |     | <span class='neutral'>                }</span>
  363 |     | <span class='neutral'>            } else {</span>
  364 |     | <span class='unexecuted'>                totals.twapSystemDebtAtStart = systemDebtAtStart;</span>
  365 |     | <span class='neutral'>            }</span>
  366 |     | <span class='neutral'>        }</span>
  367 |     | <span class='neutral'></span>
  368 |     | <span class='unexecuted'>        _requireTCRisNotBelowMCR(totals.price, totals.tcrAtStart);</span>
  369 |     | <span class='unexecuted'>        _requireAmountGreaterThanMin(_debt);</span>
  370 |     | <span class='neutral'></span>
  371 |     | <span class='unexecuted'>        _requireEbtcBalanceCoversRedemptionAndWithinSupply(</span>
  372 |     | <span class='unexecuted'>            msg.sender,</span>
  373 |     | <span class='unexecuted'>            _debt,</span>
  374 |     | <span class='unexecuted'>            totals.systemDebtAtStart</span>
  375 |     | <span class='neutral'>        );</span>
  376 |     | <span class='neutral'></span>
  377 |     | <span class='unexecuted'>        totals.remainingDebtToRedeem = _debt;</span>
  378 |     | <span class='neutral'>        address currentBorrower;</span>
  379 |     | <span class='unexecuted'>        bytes32 _cId = _firstRedemptionHint;</span>
  380 |     | <span class='neutral'></span>
  381 |     | <span class='unexecuted'>        if (_isValidFirstRedemptionHint(_firstRedemptionHint, totals.price)) {</span>
  382 |     | <span class='unexecuted'>            currentBorrower = sortedCdps.getOwnerAddress(_firstRedemptionHint);</span>
  383 |     | <span class='neutral'>        } else {</span>
  384 |     | <span class='unexecuted'>            _cId = sortedCdps.getLast();</span>
  385 |     | <span class='unexecuted'>            currentBorrower = sortedCdps.getOwnerAddress(_cId);</span>
  386 |     | <span class='neutral'>            // Find the first cdp with ICR &gt;= MCR</span>
  387 |     | <span class='unexecuted'>            while (currentBorrower != address(0) &amp;&amp; getSyncedICR(_cId, totals.price) &lt; MCR) {</span>
  388 |     | <span class='unexecuted'>                _cId = sortedCdps.getPrev(_cId);</span>
  389 |     | <span class='unexecuted'>                currentBorrower = sortedCdps.getOwnerAddress(_cId);</span>
  390 |     | <span class='neutral'>            }</span>
  391 |     | <span class='neutral'>        }</span>
  392 |     | <span class='neutral'></span>
  393 |     | <span class='neutral'>        // Loop through the Cdps starting from the one with lowest collateral</span>
  394 |     | <span class='neutral'>        // ratio until _amount of EBTC is exchanged for collateral</span>
  395 |     | <span class='unexecuted'>        if (_maxIterations == 0) {</span>
  396 |     | <span class='unexecuted'>            _maxIterations = type(uint256).max;</span>
  397 |     | <span class='neutral'>        }</span>
  398 |     | <span class='neutral'></span>
  399 |     | <span class='unexecuted'>        bytes32 _firstRedeemed = _cId;</span>
  400 |     | <span class='neutral'>        bytes32 _lastRedeemed = _cId;</span>
  401 |     | <span class='neutral'>        uint256 _numCdpsFullyRedeemed;</span>
  402 |     | <span class='neutral'></span>
  403 |     | <span class='neutral'>        /**</span>
  404 |     | <span class='neutral'>            Core Redemption Loop</span>
  405 |     | <span class='neutral'>        */</span>
  406 |     | <span class='neutral'>        uint256 _partialRedeemedNewNICR;</span>
  407 |     | <span class='unexecuted'>        while (</span>
  408 |     | <span class='unexecuted'>            currentBorrower != address(0) &amp;&amp; totals.remainingDebtToRedeem &gt; 0 &amp;&amp; _maxIterations &gt; 0</span>
  409 |     | <span class='neutral'>        ) {</span>
  410 |     | <span class='neutral'>            // Save the address of the Cdp preceding the current one, before potentially modifying the list</span>
  411 |     | <span class='unexecuted'>            {</span>
  412 |     | <span class='unexecuted'>                _syncAccounting(_cId); /// @audit This happens even if the re-insertion doesn&#39;t</span>
  413 |     | <span class='neutral'></span>
  414 |     | <span class='unexecuted'>                SingleRedemptionInputs memory _redeemColFromCdp = SingleRedemptionInputs(</span>
  415 |     | <span class='unexecuted'>                    _cId,</span>
  416 |     | <span class='unexecuted'>                    totals.remainingDebtToRedeem,</span>
  417 |     | <span class='unexecuted'>                    totals.price,</span>
  418 |     | <span class='unexecuted'>                    _upperPartialRedemptionHint,</span>
  419 |     | <span class='unexecuted'>                    _lowerPartialRedemptionHint,</span>
  420 |     | <span class='unexecuted'>                    _partialRedemptionHintNICR</span>
  421 |     | <span class='neutral'>                );</span>
  422 |     | <span class='unexecuted'>                SingleRedemptionValues memory singleRedemption = _redeemCollateralFromCdp(</span>
  423 |     | <span class='unexecuted'>                    _redeemColFromCdp</span>
  424 |     | <span class='neutral'>                );</span>
  425 |     | <span class='neutral'>                // Partial redemption was cancelled (out-of-date hint, or new net debt &lt; minimum),</span>
  426 |     | <span class='neutral'>                // therefore we could not redeem from the last Cdp</span>
  427 |     | <span class='unexecuted'>                if (singleRedemption.cancelledPartial) break;</span>
  428 |     | <span class='neutral'></span>
  429 |     | <span class='neutral'>                // prepare for reinsertion if there is partial redemption</span>
  430 |     | <span class='unexecuted'>                if (singleRedemption.newPartialNICR &gt; 0) {</span>
  431 |     | <span class='unexecuted'>                    _partialRedeemedNewNICR = singleRedemption.newPartialNICR;</span>
  432 |     | <span class='neutral'>                }</span>
  433 |     | <span class='neutral'></span>
  434 |     | <span class='unexecuted'>                totals.debtToRedeem = totals.debtToRedeem + singleRedemption.debtToRedeem;</span>
  435 |     | <span class='unexecuted'>                totals.collSharesDrawn = totals.collSharesDrawn + singleRedemption.collSharesDrawn;</span>
  436 |     | <span class='unexecuted'>                totals.remainingDebtToRedeem =</span>
  437 |     | <span class='unexecuted'>                    totals.remainingDebtToRedeem -</span>
  438 |     | <span class='unexecuted'>                    singleRedemption.debtToRedeem;</span>
  439 |     | <span class='unexecuted'>                totals.totalCollSharesSurplus =</span>
  440 |     | <span class='unexecuted'>                    totals.totalCollSharesSurplus +</span>
  441 |     | <span class='unexecuted'>                    singleRedemption.collSurplus;</span>
  442 |     | <span class='neutral'></span>
  443 |     | <span class='unexecuted'>                bytes32 _nextId = sortedCdps.getPrev(_cId);</span>
  444 |     | <span class='unexecuted'>                if (singleRedemption.fullRedemption) {</span>
  445 |     | <span class='unexecuted'>                    _lastRedeemed = _cId;</span>
  446 |     | <span class='unexecuted'>                    _numCdpsFullyRedeemed = _numCdpsFullyRedeemed + 1;</span>
  447 |     | <span class='unexecuted'>                    _cId = _nextId;</span>
  448 |     | <span class='neutral'>                }</span>
  449 |     | <span class='neutral'></span>
  450 |     | <span class='unexecuted'>                address nextUserToCheck = sortedCdps.getOwnerAddress(_nextId);</span>
  451 |     | <span class='unexecuted'>                currentBorrower = nextUserToCheck;</span>
  452 |     | <span class='neutral'>            }</span>
  453 |     | <span class='unexecuted'>            _maxIterations--;</span>
  454 |     | <span class='neutral'>        }</span>
  455 |     | <span class='unexecuted'>        require(totals.collSharesDrawn &gt; 0, &quot;CdpManager: Unable to redeem any amount&quot;);</span>
  456 |     | <span class='neutral'></span>
  457 |     | <span class='neutral'>        // remove from sortedCdps</span>
  458 |     | <span class='unexecuted'>        if (_numCdpsFullyRedeemed == 1) {</span>
  459 |     | <span class='unexecuted'>            sortedCdps.remove(_firstRedeemed);</span>
  460 |     | <span class='unexecuted'>        } else if (_numCdpsFullyRedeemed &gt; 1) {</span>
  461 |     | <span class='unexecuted'>            bytes32[] memory _toRemoveIds = _getCdpIdsToRemove(</span>
  462 |     | <span class='unexecuted'>                _lastRedeemed,</span>
  463 |     | <span class='unexecuted'>                _numCdpsFullyRedeemed,</span>
  464 |     | <span class='unexecuted'>                _firstRedeemed</span>
  465 |     | <span class='neutral'>            );</span>
  466 |     | <span class='unexecuted'>            sortedCdps.batchRemove(_toRemoveIds);</span>
  467 |     | <span class='neutral'>        }</span>
  468 |     | <span class='neutral'></span>
  469 |     | <span class='neutral'>        // reinsert partially redemeed CDP if any</span>
  470 |     | <span class='unexecuted'>        if (_cId != bytes32(0) &amp;&amp; _partialRedeemedNewNICR &gt; 0) {</span>
  471 |     | <span class='unexecuted'>            sortedCdps.reInsert(</span>
  472 |     | <span class='neutral'>                _cId,</span>
  473 |     | <span class='neutral'>                _partialRedeemedNewNICR,</span>
  474 |     | <span class='neutral'>                _upperPartialRedemptionHint,</span>
  475 |     | <span class='neutral'>                _lowerPartialRedemptionHint</span>
  476 |     | <span class='neutral'>            );</span>
  477 |     | <span class='neutral'>        }</span>
  478 |     | <span class='neutral'></span>
  479 |     | <span class='neutral'>        // Decay the baseRate due to time passed, and then increase it according to the size of this redemption.</span>
  480 |     | <span class='neutral'>        // Use the saved total EBTC supply value, from before it was reduced by the redemption.</span>
  481 |     | <span class='unexecuted'>        _updateBaseRateFromRedemption(</span>
  482 |     | <span class='unexecuted'>            totals.collSharesDrawn,</span>
  483 |     | <span class='unexecuted'>            totals.price,</span>
  484 |     | <span class='unexecuted'>            totals.twapSystemDebtAtStart</span>
  485 |     | <span class='neutral'>        );</span>
  486 |     | <span class='neutral'></span>
  487 |     | <span class='neutral'>        // Calculate the ETH fee</span>
  488 |     | <span class='unexecuted'>        totals.feeCollShares = _getRedemptionFee(totals.collSharesDrawn);</span>
  489 |     | <span class='neutral'></span>
  490 |     | <span class='unexecuted'>        _requireUserAcceptsFee(totals.feeCollShares, totals.collSharesDrawn, _maxFeePercentage);</span>
  491 |     | <span class='neutral'></span>
  492 |     | <span class='unexecuted'>        totals.collSharesToRedeemer = totals.collSharesDrawn - totals.feeCollShares;</span>
  493 |     | <span class='neutral'></span>
  494 |     | <span class='unexecuted'>        _syncGracePeriodForGivenValues(</span>
  495 |     | <span class='unexecuted'>            totals.systemCollSharesAtStart - totals.collSharesDrawn - totals.totalCollSharesSurplus,</span>
  496 |     | <span class='unexecuted'>            totals.systemDebtAtStart - totals.debtToRedeem,</span>
  497 |     | <span class='unexecuted'>            totals.price</span>
  498 |     | <span class='neutral'>        );</span>
  499 |     | <span class='neutral'></span>
  500 |     | <span class='unexecuted'>        emit Redemption(</span>
  501 |     | <span class='unexecuted'>            _debt,</span>
  502 |     | <span class='unexecuted'>            totals.debtToRedeem,</span>
  503 |     | <span class='unexecuted'>            totals.collSharesDrawn,</span>
  504 |     | <span class='unexecuted'>            totals.feeCollShares,</span>
  505 |     | <span class='unexecuted'>            msg.sender</span>
  506 |     | <span class='neutral'>        );</span>
  507 |     | <span class='neutral'></span>
  508 |     | <span class='neutral'>        // Burn the total eBTC that is redeemed</span>
  509 |     | <span class='unexecuted'>        ebtcToken.burn(msg.sender, totals.debtToRedeem);</span>
  510 |     | <span class='neutral'></span>
  511 |     | <span class='neutral'>        // Update Active Pool eBTC debt internal accounting</span>
  512 |     | <span class='unexecuted'>        activePool.decreaseSystemDebt(totals.debtToRedeem);</span>
  513 |     | <span class='neutral'></span>
  514 |     | <span class='neutral'>        // Allocate the stETH fee to the FeeRecipient</span>
  515 |     | <span class='unexecuted'>        activePool.allocateSystemCollSharesToFeeRecipient(totals.feeCollShares);</span>
  516 |     | <span class='neutral'></span>
  517 |     | <span class='neutral'>        // CEI: Send the stETH drawn to the redeemer</span>
  518 |     | <span class='unexecuted'>        activePool.transferSystemCollShares(msg.sender, totals.collSharesToRedeemer);</span>
  519 |     | <span class='neutral'></span>
  520 |     | <span class='neutral'>        // final check if we not in RecoveryMode at redemption start</span>
  521 |     | <span class='unexecuted'>        if (!_checkRecoveryModeForTCR(totals.tcrAtStart)) {</span>
  522 |     | <span class='unexecuted'>            require(</span>
  523 |     | <span class='unexecuted'>                !_checkRecoveryMode(totals.price),</span>
  524 |     | <span class='neutral'>                &quot;CdpManager: redemption should not trigger RecoveryMode&quot;</span>
  525 |     | <span class='neutral'>            );</span>
  526 |     | <span class='neutral'>        }</span>
  527 |     | <span class='neutral'>    }</span>
  528 |     | <span class='neutral'></span>
  529 |     | <span class='neutral'>    // --- Helper functions ---</span>
  530 |     | <span class='neutral'></span>
  531 |     | <span class='unexecuted'>    function _getCdpIdsToRemove(</span>
  532 |     | <span class='neutral'>        bytes32 _start,</span>
  533 |     | <span class='neutral'>        uint256 _total,</span>
  534 |     | <span class='neutral'>        bytes32 _end</span>
  535 |     | <span class='unexecuted'>    ) internal view returns (bytes32[] memory) {</span>
  536 |     | <span class='unexecuted'>        uint256 _cnt = _total;</span>
  537 |     | <span class='unexecuted'>        bytes32 _id = _start;</span>
  538 |     | <span class='unexecuted'>        bytes32[] memory _toRemoveIds = new bytes32[](_total);</span>
  539 |     | <span class='unexecuted'>        while (_cnt &gt; 0 &amp;&amp; _id != bytes32(0)) {</span>
  540 |     | <span class='unexecuted'>            _toRemoveIds[_total - _cnt] = _id;</span>
  541 |     | <span class='unexecuted'>            _cnt = _cnt - 1;</span>
  542 |     | <span class='unexecuted'>            _id = sortedCdps.getNext(_id);</span>
  543 |     | <span class='neutral'>        }</span>
  544 |     | <span class='unexecuted'>        require(_toRemoveIds[0] == _start, &quot;CdpManager: batchRemoveSortedCdpIds check start error&quot;);</span>
  545 |     | <span class='unexecuted'>        require(</span>
  546 |     | <span class='unexecuted'>            _toRemoveIds[_total - 1] == _end,</span>
  547 |     | <span class='neutral'>            &quot;CdpManager: batchRemoveSortedCdpIds check end error&quot;</span>
  548 |     | <span class='neutral'>        );</span>
  549 |     | <span class='neutral'>        return _toRemoveIds;</span>
  550 |     | <span class='neutral'>    }</span>
  551 |     | <span class='neutral'></span>
  552 |     | <span class='neutral'>    /// @notice Synchorize the accounting for the specified Cdp</span>
  553 |     | <span class='neutral'>    /// @notice It will synchronize global accounting with stETH share index first</span>
  554 |     | <span class='neutral'>    /// @notice then apply split fee and debt redistribution if any</span>
  555 |     | <span class='neutral'>    /// @param _cdpId cdpId to sync pending accounting state for</span>
  556 |     | <span class='unexecuted'>    function syncAccounting(bytes32 _cdpId) external virtual override {</span>
  557 |     | <span class='neutral'>        /// @audit Opening can cause invalid reordering of Cdps due to changing values without reInserting into sortedCdps</span>
  558 |     | <span class='unexecuted'>        _requireCallerIsBorrowerOperations();</span>
  559 |     | <span class='unexecuted'>        return _syncAccounting(_cdpId);</span>
  560 |     | <span class='neutral'>    }</span>
  561 |     | <span class='neutral'></span>
  562 |     | <span class='neutral'>    /// @notice Update stake for the specified Cdp and total stake within the system.</span>
  563 |     | <span class='neutral'>    /// @dev Only BorrowerOperations is allowed to call this function</span>
  564 |     | <span class='neutral'>    /// @param _cdpId cdpId to update stake for</span>
  565 |     | <span class='unexecuted'>    function updateStakeAndTotalStakes(bytes32 _cdpId) external override returns (uint256) {</span>
  566 |     | <span class='unexecuted'>        _requireCallerIsBorrowerOperations();</span>
  567 |     | <span class='unexecuted'>        return _updateStakeAndTotalStakes(_cdpId);</span>
  568 |     | <span class='neutral'>    }</span>
  569 |     | <span class='neutral'></span>
  570 |     | <span class='neutral'>    /// @notice Close the specified Cdp by ID.</span>
  571 |     | <span class='neutral'>    /// @dev Only BorrowerOperations is allowed to call this function.</span>
  572 |     | <span class='neutral'>    /// @dev This will close the Cdp and update its status to `closedByOwner`</span>
  573 |     | <span class='neutral'>    /// @dev The collateral and debt will be zero&#39;d out</span>
  574 |     | <span class='neutral'>    /// @dev The Cdp will be removed from the sorted list</span>
  575 |     | <span class='neutral'>    /// @dev The close will emit a `CdpUpdated` event containing closing details</span>
  576 |     | <span class='neutral'>    /// @param _cdpId ID of the Cdp to close</span>
  577 |     | <span class='neutral'>    /// @param _borrower Address of the Cdp borrower</span>
  578 |     | <span class='neutral'>    /// @param _debt The recorded Cdp debt prior to closing</span>
  579 |     | <span class='neutral'>    /// @param _coll The recorded Cdp collateral shares prior to closing</span>
  580 |     | <span class='unexecuted'>    function closeCdp(</span>
  581 |     | <span class='neutral'>        bytes32 _cdpId,</span>
  582 |     | <span class='neutral'>        address _borrower,</span>
  583 |     | <span class='neutral'>        uint256 _debt,</span>
  584 |     | <span class='neutral'>        uint256 _coll</span>
  585 |     | <span class='neutral'>    ) external override {</span>
  586 |     | <span class='unexecuted'>        _requireCallerIsBorrowerOperations();</span>
  587 |     | <span class='unexecuted'>        emit CdpUpdated(_cdpId, _borrower, msg.sender, _debt, _coll, 0, 0, 0, CdpOperation.closeCdp);</span>
  588 |     | <span class='unexecuted'>        return _closeCdp(_cdpId, Status.closedByOwner);</span>
  589 |     | <span class='neutral'>    }</span>
  590 |     | <span class='neutral'></span>
  591 |     | <span class='neutral'>    // --- Recovery Mode and TCR functions ---</span>
  592 |     | <span class='neutral'></span>
  593 |     | <span class='neutral'>    /// @notice Get the sum of debt units assigned to all Cdps within eBTC system</span>
  594 |     | <span class='neutral'>    /// @dev It is actually the `systemDebt` value of the ActivePool.</span>
  595 |     | <span class='neutral'>    /// @return entireSystemDebt entire system debt accounting value</span>
  596 |     | <span class='unexecuted'>    function getSystemDebt() public view returns (uint256 entireSystemDebt) {</span>
  597 |     | <span class='unexecuted'>        return _getSystemDebt();</span>
  598 |     | <span class='neutral'>    }</span>
  599 |     | <span class='neutral'></span>
  600 |     | <span class='neutral'>    /// @notice The total collateralization ratio (TCR) of the system as a cached &quot;view&quot; (maybe outdated)</span>
  601 |     | <span class='neutral'>    /// @dev It is based on the current recorded system debt and collateral.</span>
  602 |     | <span class='neutral'>    /// @dev Possible split fee is not considered with this function.</span>
  603 |     | <span class='neutral'>    /// @dev Please use getSyncedTCR() otherwise</span>
  604 |     | <span class='neutral'>    /// @param _price The current stETH:BTC price</span>
  605 |     | <span class='neutral'>    /// @return TCR The cached total collateralization ratio (TCR) of the system (does not take into account pending global state)</span>
  606 |     | <span class='unexecuted'>    function getCachedTCR(uint256 _price) external view override returns (uint256) {</span>
  607 |     | <span class='unexecuted'>        return _getCachedTCR(_price);</span>
  608 |     | <span class='neutral'>    }</span>
  609 |     | <span class='neutral'></span>
  610 |     | <span class='neutral'>    /// @notice Whether or not the system is in Recovery Mode (TCR is below the CCR)</span>
  611 |     | <span class='neutral'>    /// @dev Possible split fee is not considered with this function.</span>
  612 |     | <span class='neutral'>    /// @dev Please use getSyncedTCR() otherwise</span>
  613 |     | <span class='neutral'>    /// @param _price The current stETH:BTC price</span>
  614 |     | <span class='neutral'>    /// @return True if system is in recovery mode with cached values (TCR &lt; CCR), false otherwise</span>
  615 |     | <span class='unexecuted'>    function checkRecoveryMode(uint256 _price) external view override returns (bool) {</span>
  616 |     | <span class='unexecuted'>        return _checkRecoveryMode(_price);</span>
  617 |     | <span class='neutral'>    }</span>
  618 |     | <span class='neutral'></span>
  619 |     | <span class='neutral'>    // Check whether or not the system *would be* in Recovery Mode,</span>
  620 |     | <span class='neutral'>    // given an ETH:USD price, and the entire system coll and debt.</span>
  621 |     | <span class='unexecuted'>    function _checkPotentialRecoveryMode(</span>
  622 |     | <span class='neutral'>        uint256 _systemCollShares,</span>
  623 |     | <span class='neutral'>        uint256 _systemDebt,</span>
  624 |     | <span class='neutral'>        uint256 _price</span>
  625 |     | <span class='unexecuted'>    ) internal view returns (bool) {</span>
  626 |     | <span class='unexecuted'>        uint256 TCR = _computeTCRWithGivenSystemValues(_systemCollShares, _systemDebt, _price);</span>
  627 |     | <span class='neutral'>        return TCR &lt; CCR;</span>
  628 |     | <span class='neutral'>    }</span>
  629 |     | <span class='neutral'></span>
  630 |     | <span class='neutral'>    // --- Redemption fee functions ---</span>
  631 |     | <span class='neutral'></span>
  632 |     | <span class='neutral'>    /*</span>
  633 |     | <span class='neutral'>     * This function has two impacts on the baseRate state variable:</span>
  634 |     | <span class='neutral'>     * 1) decays the baseRate based on time passed since last redemption or EBTC borrowing operation.</span>
  635 |     | <span class='neutral'>     * then,</span>
  636 |     | <span class='neutral'>     * 2) increases the baseRate based on the amount redeemed, as a proportion of total supply</span>
  637 |     | <span class='neutral'>     */</span>
  638 |     | <span class='unexecuted'>    function _updateBaseRateFromRedemption(</span>
  639 |     | <span class='neutral'>        uint256 _ETHDrawn,</span>
  640 |     | <span class='neutral'>        uint256 _price,</span>
  641 |     | <span class='neutral'>        uint256 _totalEBTCSupply</span>
  642 |     | <span class='unexecuted'>    ) internal returns (uint256) {</span>
  643 |     | <span class='unexecuted'>        uint256 decayedBaseRate = _calcDecayedBaseRate();</span>
  644 |     | <span class='neutral'></span>
  645 |     | <span class='neutral'>        /* Convert the drawn ETH back to EBTC at face value rate (1 EBTC:1 USD), in order to get</span>
  646 |     | <span class='neutral'>         * the fraction of total supply that was redeemed at face value. */</span>
  647 |     | <span class='unexecuted'>        uint256 redeemedEBTCFraction = (collateral.getPooledEthByShares(_ETHDrawn) * _price) /</span>
  648 |     | <span class='unexecuted'>            _totalEBTCSupply;</span>
  649 |     | <span class='neutral'></span>
  650 |     | <span class='unexecuted'>        uint256 newBaseRate = decayedBaseRate + (redeemedEBTCFraction / beta);</span>
  651 |     | <span class='unexecuted'>        newBaseRate = EbtcMath._min(newBaseRate, DECIMAL_PRECISION); // cap baseRate at a maximum of 100%</span>
  652 |     | <span class='unexecuted'>        require(newBaseRate &gt; 0, &quot;CdpManager: new baseRate is zero!&quot;); // Base rate is always non-zero after redemption</span>
  653 |     | <span class='neutral'></span>
  654 |     | <span class='neutral'>        // Update the baseRate state variable</span>
  655 |     | <span class='unexecuted'>        baseRate = newBaseRate;</span>
  656 |     | <span class='unexecuted'>        emit BaseRateUpdated(newBaseRate);</span>
  657 |     | <span class='neutral'></span>
  658 |     | <span class='unexecuted'>        _updateLastRedemptionTimestamp();</span>
  659 |     | <span class='neutral'></span>
  660 |     | <span class='neutral'>        return newBaseRate;</span>
  661 |     | <span class='neutral'>    }</span>
  662 |     | <span class='neutral'></span>
  663 |     | <span class='neutral'>    /// @return current fee rate for redemption with base rate</span>
  664 |     | <span class='unexecuted'>    function getRedemptionRate() public view override returns (uint256) {</span>
  665 |     | <span class='unexecuted'>        return _calcRedemptionRate(baseRate);</span>
  666 |     | <span class='neutral'>    }</span>
  667 |     | <span class='neutral'></span>
  668 |     | <span class='neutral'>    /// @return current fee rate for redemption with decayed base rate</span>
  669 |     | <span class='unexecuted'>    function getRedemptionRateWithDecay() public view override returns (uint256) {</span>
  670 |     | <span class='unexecuted'>        return _calcRedemptionRate(_calcDecayedBaseRate());</span>
  671 |     | <span class='neutral'>    }</span>
  672 |     | <span class='neutral'></span>
  673 |     | <span class='unexecuted'>    function _calcRedemptionRate(uint256 _baseRate) internal view returns (uint256) {</span>
  674 |     | <span class='neutral'>        return</span>
  675 |     | <span class='unexecuted'>            EbtcMath._min(</span>
  676 |     | <span class='unexecuted'>                redemptionFeeFloor + _baseRate,</span>
  677 |     | <span class='neutral'>                DECIMAL_PRECISION // cap at a maximum of 100%</span>
  678 |     | <span class='neutral'>            );</span>
  679 |     | <span class='neutral'>    }</span>
  680 |     | <span class='neutral'></span>
  681 |     | <span class='unexecuted'>    function _getRedemptionFee(uint256 _ETHDrawn) internal view returns (uint256) {</span>
  682 |     | <span class='unexecuted'>        return _calcRedemptionFee(getRedemptionRate(), _ETHDrawn);</span>
  683 |     | <span class='neutral'>    }</span>
  684 |     | <span class='neutral'></span>
  685 |     | <span class='neutral'>    /// @return redemption fee for the specified collateral amount</span>
  686 |     | <span class='neutral'>    /// @param _stETHToRedeem The total expected stETH amount to redeem</span>
  687 |     | <span class='unexecuted'>    function getRedemptionFeeWithDecay(</span>
  688 |     | <span class='neutral'>        uint256 _stETHToRedeem</span>
  689 |     | <span class='unexecuted'>    ) external view override returns (uint256) {</span>
  690 |     | <span class='unexecuted'>        return _calcRedemptionFee(getRedemptionRateWithDecay(), _stETHToRedeem);</span>
  691 |     | <span class='neutral'>    }</span>
  692 |     | <span class='neutral'></span>
  693 |     | <span class='unexecuted'>    function _calcRedemptionFee(</span>
  694 |     | <span class='neutral'>        uint256 _redemptionRate,</span>
  695 |     | <span class='neutral'>        uint256 _ETHDrawn</span>
  696 |     | <span class='unexecuted'>    ) internal pure returns (uint256) {</span>
  697 |     | <span class='unexecuted'>        uint256 redemptionFee = (_redemptionRate * _ETHDrawn) / DECIMAL_PRECISION;</span>
  698 |     | <span class='unexecuted'>        require(redemptionFee &lt; _ETHDrawn, &quot;CdpManager: Fee would eat up all returned collateral&quot;);</span>
  699 |     | <span class='neutral'>        return redemptionFee;</span>
  700 |     | <span class='neutral'>    }</span>
  701 |     | <span class='neutral'></span>
  702 |     | <span class='unexecuted'>    function _decayBaseRate() internal {</span>
  703 |     | <span class='unexecuted'>        uint256 decayedBaseRate = _calcDecayedBaseRate();</span>
  704 |     | <span class='unexecuted'>        require(decayedBaseRate &lt;= DECIMAL_PRECISION, &quot;CdpManager: baseRate too large!&quot;); // The baseRate can decay to 0</span>
  705 |     | <span class='neutral'></span>
  706 |     | <span class='unexecuted'>        baseRate = decayedBaseRate;</span>
  707 |     | <span class='unexecuted'>        emit BaseRateUpdated(decayedBaseRate);</span>
  708 |     | <span class='neutral'></span>
  709 |     | <span class='unexecuted'>        _updateLastRedemptionTimestamp();</span>
  710 |     | <span class='neutral'>    }</span>
  711 |     | <span class='neutral'></span>
  712 |     | <span class='neutral'>    // --- Internal fee functions ---</span>
  713 |     | <span class='neutral'></span>
  714 |     | <span class='neutral'>    // Update the last fee operation time only if time passed &gt;= decay interval. This prevents base rate griefing.</span>
  715 |     | <span class='unexecuted'>    function _updateLastRedemptionTimestamp() internal {</span>
  716 |     | <span class='unexecuted'>        uint256 timePassed = block.timestamp &gt; lastRedemptionTimestamp</span>
  717 |     | <span class='unexecuted'>            ? block.timestamp - lastRedemptionTimestamp</span>
  718 |     | <span class='unexecuted'>            : 0;</span>
  719 |     | <span class='neutral'></span>
  720 |     | <span class='unexecuted'>        if (timePassed &gt;= SECONDS_IN_ONE_MINUTE) {</span>
  721 |     | <span class='neutral'>            // Using the effective elapsed time that is consumed so far to update lastRedemptionTimestamp</span>
  722 |     | <span class='neutral'>            // instead block.timestamp for consistency with _calcDecayedBaseRate()</span>
  723 |     | <span class='unexecuted'>            lastRedemptionTimestamp += _minutesPassedSinceLastRedemption() * SECONDS_IN_ONE_MINUTE;</span>
  724 |     | <span class='unexecuted'>            emit LastRedemptionTimestampUpdated(block.timestamp);</span>
  725 |     | <span class='neutral'>        }</span>
  726 |     | <span class='neutral'>    }</span>
  727 |     | <span class='neutral'></span>
  728 |     | <span class='unexecuted'>    function _calcDecayedBaseRate() internal view returns (uint256) {</span>
  729 |     | <span class='unexecuted'>        uint256 minutesPassed = _minutesPassedSinceLastRedemption();</span>
  730 |     | <span class='unexecuted'>        uint256 decayFactor = EbtcMath._decPow(minuteDecayFactor, minutesPassed);</span>
  731 |     | <span class='neutral'></span>
  732 |     | <span class='unexecuted'>        return (baseRate * decayFactor) / DECIMAL_PRECISION;</span>
  733 |     | <span class='neutral'>    }</span>
  734 |     | <span class='neutral'></span>
  735 |     | <span class='unexecuted'>    function _minutesPassedSinceLastRedemption() internal view returns (uint256) {</span>
  736 |     | <span class='neutral'>        return</span>
  737 |     | <span class='unexecuted'>            block.timestamp &gt; lastRedemptionTimestamp</span>
  738 |     | <span class='unexecuted'>                ? ((block.timestamp - lastRedemptionTimestamp) / SECONDS_IN_ONE_MINUTE)</span>
  739 |     | <span class='unexecuted'>                : 0;</span>
  740 |     | <span class='neutral'>    }</span>
  741 |     | <span class='neutral'></span>
  742 |     | <span class='neutral'>    /// @return timestamp when this contract is deployed</span>
  743 |     | <span class='unexecuted'>    function getDeploymentStartTime() public view returns (uint256) {</span>
  744 |     | <span class='unexecuted'>        return deploymentStartTime;</span>
  745 |     | <span class='neutral'>    }</span>
  746 |     | <span class='neutral'></span>
  747 |     | <span class='neutral'>    /// @notice Check whether or not the system *would be* in Recovery Mode,</span>
  748 |     | <span class='neutral'>    /// @notice given an ETH:eBTC price, and the entire system coll and debt.</span>
  749 |     | <span class='neutral'>    /// @param _systemCollShares The total collateral of the system to be used for the TCR calculation</span>
  750 |     | <span class='neutral'>    /// @param _systemDebt The total debt of the system to be used for the TCR calculation</span>
  751 |     | <span class='neutral'>    /// @param _price The ETH:eBTC price to be used for the TCR calculation</span>
  752 |     | <span class='neutral'>    /// @return flag (true or false) whether the system would be in Recovery Mode for specified status parameters</span>
  753 |     | <span class='unexecuted'>    function checkPotentialRecoveryMode(</span>
  754 |     | <span class='neutral'>        uint256 _systemCollShares,</span>
  755 |     | <span class='neutral'>        uint256 _systemDebt,</span>
  756 |     | <span class='neutral'>        uint256 _price</span>
  757 |     | <span class='unexecuted'>    ) external view returns (bool) {</span>
  758 |     | <span class='unexecuted'>        return _checkPotentialRecoveryMode(_systemCollShares, _systemDebt, _price);</span>
  759 |     | <span class='neutral'>    }</span>
  760 |     | <span class='neutral'></span>
  761 |     | <span class='neutral'>    // --- &#39;require&#39; wrapper functions ---</span>
  762 |     | <span class='neutral'></span>
  763 |     | <span class='unexecuted'>    function _requireEbtcBalanceCoversRedemptionAndWithinSupply(</span>
  764 |     | <span class='neutral'>        address _redeemer,</span>
  765 |     | <span class='neutral'>        uint256 _amount,</span>
  766 |     | <span class='neutral'>        uint256 _totalSupply</span>
  767 |     | <span class='neutral'>    ) internal view {</span>
  768 |     | <span class='unexecuted'>        uint256 callerBalance = ebtcToken.balanceOf(_redeemer);</span>
  769 |     | <span class='unexecuted'>        require(</span>
  770 |     | <span class='unexecuted'>            callerBalance &gt;= _amount,</span>
  771 |     | <span class='neutral'>            &quot;CdpManager: Requested redemption amount must be &lt;= user&#39;s EBTC token balance&quot;</span>
  772 |     | <span class='neutral'>        );</span>
  773 |     | <span class='unexecuted'>        require(</span>
  774 |     | <span class='unexecuted'>            callerBalance &lt;= _totalSupply,</span>
  775 |     | <span class='neutral'>            &quot;CdpManager: redeemer&#39;s EBTC balance exceeds total supply!&quot;</span>
  776 |     | <span class='neutral'>        );</span>
  777 |     | <span class='neutral'>    }</span>
  778 |     | <span class='neutral'></span>
  779 |     | <span class='unexecuted'>    function _requireAmountGreaterThanMin(uint256 _amount) internal pure {</span>
  780 |     | <span class='unexecuted'>        require(_amount &gt;= MIN_CHANGE, &quot;CdpManager: Amount must be greater than min&quot;);</span>
  781 |     | <span class='neutral'>    }</span>
  782 |     | <span class='neutral'></span>
  783 |     | <span class='unexecuted'>    function _requireTCRisNotBelowMCR(uint256 _price, uint256 _TCR) internal view {</span>
  784 |     | <span class='unexecuted'>        require(_TCR &gt;= MCR, &quot;CdpManager: Cannot redeem when TCR &lt; MCR&quot;);</span>
  785 |     | <span class='neutral'>    }</span>
  786 |     | <span class='neutral'></span>
  787 |     | <span class='unexecuted'>    function _requireValidMaxFeePercentage(uint256 _maxFeePercentage) internal view {</span>
  788 |     | <span class='unexecuted'>        require(</span>
  789 |     | <span class='unexecuted'>            _maxFeePercentage &gt;= redemptionFeeFloor &amp;&amp; _maxFeePercentage &lt;= DECIMAL_PRECISION,</span>
  790 |     | <span class='neutral'>            &quot;Max fee percentage must be between redemption fee floor and 100%&quot;</span>
  791 |     | <span class='neutral'>        );</span>
  792 |     | <span class='neutral'>    }</span>
  793 |     | <span class='neutral'></span>
  794 |     | <span class='neutral'>    // --- Governance Parameters ---</span>
  795 |     | <span class='neutral'></span>
  796 |     | <span class='neutral'>    /// @notice Set the staking reward split percentage</span>
  797 |     | <span class='neutral'>    /// @dev Only callable by authorized addresses</span>
  798 |     | <span class='neutral'>    /// @param _stakingRewardSplit New staking reward split percentage value</span>
  799 |     | <span class='unexecuted'>    function setStakingRewardSplit(uint256 _stakingRewardSplit) external requiresAuth {</span>
  800 |     | <span class='unexecuted'>        require(</span>
  801 |     | <span class='unexecuted'>            _stakingRewardSplit &lt;= MAX_REWARD_SPLIT,</span>
  802 |     | <span class='neutral'>            &quot;CDPManager: new staking reward split exceeds max&quot;</span>
  803 |     | <span class='neutral'>        );</span>
  804 |     | <span class='neutral'></span>
  805 |     | <span class='unexecuted'>        syncGlobalAccountingAndGracePeriod();</span>
  806 |     | <span class='neutral'></span>
  807 |     | <span class='unexecuted'>        stakingRewardSplit = _stakingRewardSplit;</span>
  808 |     | <span class='unexecuted'>        emit StakingRewardSplitSet(_stakingRewardSplit);</span>
  809 |     | <span class='neutral'>    }</span>
  810 |     | <span class='neutral'></span>
  811 |     | <span class='neutral'>    /// @notice Set the minimum redemption fee floor percentage</span>
  812 |     | <span class='neutral'>    /// @dev Only callable by authorized addresses</span>
  813 |     | <span class='neutral'>    /// @param _redemptionFeeFloor New minimum redemption fee floor percentage</span>
  814 |     | <span class='unexecuted'>    function setRedemptionFeeFloor(uint256 _redemptionFeeFloor) external requiresAuth {</span>
  815 |     | <span class='unexecuted'>        require(</span>
  816 |     | <span class='unexecuted'>            _redemptionFeeFloor &gt;= MIN_REDEMPTION_FEE_FLOOR,</span>
  817 |     | <span class='neutral'>            &quot;CDPManager: new redemption fee floor is lower than minimum&quot;</span>
  818 |     | <span class='neutral'>        );</span>
  819 |     | <span class='unexecuted'>        require(</span>
  820 |     | <span class='unexecuted'>            _redemptionFeeFloor &lt;= DECIMAL_PRECISION,</span>
  821 |     | <span class='neutral'>            &quot;CDPManager: new redemption fee floor is higher than maximum&quot;</span>
  822 |     | <span class='neutral'>        );</span>
  823 |     | <span class='neutral'></span>
  824 |     | <span class='unexecuted'>        syncGlobalAccountingAndGracePeriod();</span>
  825 |     | <span class='neutral'></span>
  826 |     | <span class='unexecuted'>        redemptionFeeFloor = _redemptionFeeFloor;</span>
  827 |     | <span class='unexecuted'>        emit RedemptionFeeFloorSet(_redemptionFeeFloor);</span>
  828 |     | <span class='neutral'>    }</span>
  829 |     | <span class='neutral'></span>
  830 |     | <span class='neutral'>    /// @notice Set the minute decay factor for the redemption fee rate</span>
  831 |     | <span class='neutral'>    /// @dev Only callable by authorized addresses</span>
  832 |     | <span class='neutral'>    /// @param _minuteDecayFactor New minute decay factor value</span>
  833 |     | <span class='unexecuted'>    function setMinuteDecayFactor(uint256 _minuteDecayFactor) external requiresAuth {</span>
  834 |     | <span class='unexecuted'>        require(</span>
  835 |     | <span class='unexecuted'>            _minuteDecayFactor &gt;= MIN_MINUTE_DECAY_FACTOR,</span>
  836 |     | <span class='neutral'>            &quot;CDPManager: new minute decay factor out of range&quot;</span>
  837 |     | <span class='neutral'>        );</span>
  838 |     | <span class='unexecuted'>        require(</span>
  839 |     | <span class='unexecuted'>            _minuteDecayFactor &lt;= MAX_MINUTE_DECAY_FACTOR,</span>
  840 |     | <span class='neutral'>            &quot;CDPManager: new minute decay factor out of range&quot;</span>
  841 |     | <span class='neutral'>        );</span>
  842 |     | <span class='neutral'></span>
  843 |     | <span class='unexecuted'>        syncGlobalAccountingAndGracePeriod();</span>
  844 |     | <span class='neutral'></span>
  845 |     | <span class='neutral'>        // decay first according to previous factor</span>
  846 |     | <span class='unexecuted'>        _decayBaseRate();</span>
  847 |     | <span class='neutral'></span>
  848 |     | <span class='neutral'>        // set new factor after decaying</span>
  849 |     | <span class='unexecuted'>        minuteDecayFactor = _minuteDecayFactor;</span>
  850 |     | <span class='unexecuted'>        emit MinuteDecayFactorSet(_minuteDecayFactor);</span>
  851 |     | <span class='neutral'>    }</span>
  852 |     | <span class='neutral'></span>
  853 |     | <span class='neutral'>    /// @notice Set the beta value that controls redemption fee rate</span>
  854 |     | <span class='neutral'>    /// @dev Only callable by authorized addresses</span>
  855 |     | <span class='neutral'>    /// @param _beta New beta value</span>
  856 |     | <span class='unexecuted'>    function setBeta(uint256 _beta) external requiresAuth {</span>
  857 |     | <span class='unexecuted'>        syncGlobalAccountingAndGracePeriod();</span>
  858 |     | <span class='neutral'></span>
  859 |     | <span class='unexecuted'>        _decayBaseRate();</span>
  860 |     | <span class='neutral'></span>
  861 |     | <span class='unexecuted'>        beta = _beta;</span>
  862 |     | <span class='unexecuted'>        emit BetaSet(_beta);</span>
  863 |     | <span class='neutral'>    }</span>
  864 |     | <span class='neutral'></span>
  865 |     | <span class='neutral'>    /// @notice Pause or unpause redemptions</span>
  866 |     | <span class='neutral'>    /// @dev Only callable by authorized addresses</span>
  867 |     | <span class='neutral'>    /// @param _paused True to pause redemptions, false to unpause</span>
  868 |     | <span class='neutral'></span>
  869 |     | <span class='unexecuted'>    function setRedemptionsPaused(bool _paused) external requiresAuth {</span>
  870 |     | <span class='unexecuted'>        syncGlobalAccountingAndGracePeriod();</span>
  871 |     | <span class='unexecuted'>        _decayBaseRate();</span>
  872 |     | <span class='neutral'></span>
  873 |     | <span class='unexecuted'>        redemptionsPaused = _paused;</span>
  874 |     | <span class='unexecuted'>        emit RedemptionsPaused(_paused);</span>
  875 |     | <span class='neutral'>    }</span>
  876 |     | <span class='neutral'></span>
  877 |     | <span class='neutral'>    // --- Cdp property getters ---</span>
  878 |     | <span class='neutral'></span>
  879 |     | <span class='neutral'>    /// @notice Get status of a Cdp. Named enum values can be found in ICdpManagerData.Status</span>
  880 |     | <span class='neutral'>    /// @param _cdpId ID of the Cdp to get status for</span>
  881 |     | <span class='neutral'>    /// @return Status code of the Cdp</span>
  882 |     | <span class='unexecuted'>    function getCdpStatus(bytes32 _cdpId) external view override returns (uint256) {</span>
  883 |     | <span class='unexecuted'>        return uint256(Cdps[_cdpId].status);</span>
  884 |     | <span class='neutral'>    }</span>
  885 |     | <span class='neutral'></span>
  886 |     | <span class='neutral'>    /// @notice Get stake value of a Cdp</span>
  887 |     | <span class='neutral'>    /// @param _cdpId ID of the Cdp to get stake for</span>
  888 |     | <span class='neutral'>    /// @return Stake value of the Cdp</span>
  889 |     | <span class='unexecuted'>    function getCdpStake(bytes32 _cdpId) external view override returns (uint256) {</span>
  890 |     | <span class='unexecuted'>        return Cdps[_cdpId].stake;</span>
  891 |     | <span class='neutral'>    }</span>
  892 |     | <span class='neutral'></span>
  893 |     | <span class='neutral'>    /// @notice Get stored debt value of a Cdp, in eBTC units</span>
  894 |     | <span class='neutral'>    /// @notice Cached value - does not include pending changes from redistributions</span>
  895 |     | <span class='neutral'>    /// @param _cdpId ID of the Cdp to get debt for</span>
  896 |     | <span class='neutral'>    /// @return Debt value of the Cdp in eBTC</span>
  897 |     | <span class='unexecuted'>    function getCdpDebt(bytes32 _cdpId) external view override returns (uint256) {</span>
  898 |     | <span class='unexecuted'>        return Cdps[_cdpId].debt;</span>
  899 |     | <span class='neutral'>    }</span>
  900 |     | <span class='neutral'></span>
  901 |     | <span class='neutral'>    /// @notice Get stored collateral value of a Cdp, in stETH shares</span>
  902 |     | <span class='neutral'>    /// @notice Cached value - does not include pending changes from staking yield</span>
  903 |     | <span class='neutral'>    /// @param _cdpId ID of the Cdp to get collateral for</span>
  904 |     | <span class='neutral'>    /// @return Collateral value of the Cdp in stETH shares</span>
  905 |     | <span class='unexecuted'>    function getCdpCollShares(bytes32 _cdpId) external view override returns (uint256) {</span>
  906 |     | <span class='unexecuted'>        return Cdps[_cdpId].coll;</span>
  907 |     | <span class='neutral'>    }</span>
  908 |     | <span class='neutral'></span>
  909 |     | <span class='neutral'>    /// @notice Get shares value of the liquidator gas incentive reward stored for a Cdp.</span>
  910 |     | <span class='neutral'>    /// @notice The value stored is processed when a Cdp closes.</span>
  911 |     | <span class='neutral'>    /// @dev Upon closing by borrower, This value is returned directly to the borrower.</span>
  912 |     | <span class='neutral'>    /// @dev Upon closing by a position manager, This value is returned directly to the position manager.</span>
  913 |     | <span class='neutral'>    /// @dev Upon a full liquidation, This value is given to liquidators upon fully liquidating the Cdp</span>
  914 |     | <span class='neutral'>    /// @dev Upon redemption, This value is sent to the CollSurplusPool for reclaiming by the borrower.</span>
  915 |     | <span class='neutral'>    /// @param _cdpId ID of the Cdp to get liquidator reward shares for</span>
  916 |     | <span class='neutral'>    /// @return Liquidator reward shares value of the Cdp</span>
  917 |     | <span class='unexecuted'>    function getCdpLiquidatorRewardShares(bytes32 _cdpId) external view override returns (uint256) {</span>
  918 |     | <span class='unexecuted'>        return uint256(Cdps[_cdpId].liquidatorRewardShares);</span>
  919 |     | <span class='neutral'>    }</span>
  920 |     | <span class='neutral'></span>
  921 |     | <span class='neutral'>    // --- Cdp property setters, called by BorrowerOperations ---</span>
  922 |     | <span class='neutral'></span>
  923 |     | <span class='neutral'>    /// @notice Initialize all state for new Cdp</span>
  924 |     | <span class='neutral'>    /// @dev Only callable by BorrowerOperations, critical trust assumption</span>
  925 |     | <span class='neutral'>    /// @dev Requires Cdp to be already inserted into linked list correctly</span>
  926 |     | <span class='neutral'>    /// @param _cdpId ID of Cdp to initialize state for</span>
  927 |     | <span class='neutral'>    /// @param _debt Initial debt units of Cdp</span>
  928 |     | <span class='neutral'>    /// @param _coll Initial collateral shares of Cdp</span>
  929 |     | <span class='neutral'>    /// @param _liquidatorRewardShares Liquidator reward shares for Cdp liquidation gas stipend</span>
  930 |     | <span class='neutral'>    /// @param _borrower Address of the Cdp borrower</span>
  931 |     | <span class='unexecuted'>    function initializeCdp(</span>
  932 |     | <span class='neutral'>        bytes32 _cdpId,</span>
  933 |     | <span class='neutral'>        uint256 _debt,</span>
  934 |     | <span class='neutral'>        uint256 _coll,</span>
  935 |     | <span class='neutral'>        uint256 _liquidatorRewardShares,</span>
  936 |     | <span class='neutral'>        address _borrower</span>
  937 |     | <span class='unexecuted'>    ) external {</span>
  938 |     | <span class='unexecuted'>        _requireCallerIsBorrowerOperations();</span>
  939 |     | <span class='neutral'></span>
  940 |     | <span class='unexecuted'>        Cdps[_cdpId].debt = _debt;</span>
  941 |     | <span class='unexecuted'>        Cdps[_cdpId].coll = _coll;</span>
  942 |     | <span class='unexecuted'>        Cdps[_cdpId].status = Status.active;</span>
  943 |     | <span class='unexecuted'>        Cdps[_cdpId].liquidatorRewardShares = EbtcMath.toUint128(_liquidatorRewardShares);</span>
  944 |     | <span class='neutral'></span>
  945 |     | <span class='unexecuted'>        cdpStEthFeePerUnitIndex[_cdpId] = systemStEthFeePerUnitIndex; /// @audit We critically assume global accounting is synced here</span>
  946 |     | <span class='unexecuted'>        _updateRedistributedDebtIndex(_cdpId);</span>
  947 |     | <span class='unexecuted'>        uint256 stake = _updateStakeAndTotalStakes(_cdpId);</span>
  948 |     | <span class='neutral'></span>
  949 |     | <span class='neutral'>        // Previous debt and coll are known to be zero upon opening a new Cdp</span>
  950 |     | <span class='unexecuted'>        emit CdpUpdated(</span>
  951 |     | <span class='unexecuted'>            _cdpId,</span>
  952 |     | <span class='unexecuted'>            _borrower,</span>
  953 |     | <span class='unexecuted'>            msg.sender,</span>
  954 |     | <span class='unexecuted'>            0,</span>
  955 |     | <span class='unexecuted'>            0,</span>
  956 |     | <span class='unexecuted'>            _debt,</span>
  957 |     | <span class='unexecuted'>            _coll,</span>
  958 |     | <span class='unexecuted'>            stake,</span>
  959 |     | <span class='unexecuted'>            CdpOperation.openCdp</span>
  960 |     | <span class='neutral'>        );</span>
  961 |     | <span class='neutral'>    }</span>
  962 |     | <span class='neutral'></span>
  963 |     | <span class='neutral'>    /// @notice Set new Cdp debt and collateral values, updating stake accordingly</span>
  964 |     | <span class='neutral'>    /// @dev Only callable by BorrowerOperations, critical trust assumption</span>
  965 |     | <span class='neutral'>    /// @param _cdpId ID of Cdp to update state for</span>
  966 |     | <span class='neutral'>    /// @param _borrower Address of the Cdp borrower</span>
  967 |     | <span class='neutral'>    /// @param _coll Previous collateral shares of Cdp, before update</span>
  968 |     | <span class='neutral'>    /// @param _debt Previous debt units of Cdp, before update.</span>
  969 |     | <span class='neutral'>    /// @param _newColl New collateral shares of Cdp after update operation</span>
  970 |     | <span class='neutral'>    /// @param _newDebt New debt units of Cdp after update operation</span>
  971 |     | <span class='unexecuted'>    function updateCdp(</span>
  972 |     | <span class='neutral'>        bytes32 _cdpId,</span>
  973 |     | <span class='neutral'>        address _borrower,</span>
  974 |     | <span class='neutral'>        uint256 _coll,</span>
  975 |     | <span class='neutral'>        uint256 _debt,</span>
  976 |     | <span class='neutral'>        uint256 _newColl,</span>
  977 |     | <span class='neutral'>        uint256 _newDebt</span>
  978 |     | <span class='unexecuted'>    ) external {</span>
  979 |     | <span class='unexecuted'>        _requireCallerIsBorrowerOperations();</span>
  980 |     | <span class='neutral'></span>
  981 |     | <span class='neutral'>        _setCdpCollShares(_cdpId, _newColl);</span>
  982 |     | <span class='neutral'>        _setCdpDebt(_cdpId, _newDebt);</span>
  983 |     | <span class='neutral'></span>
  984 |     | <span class='unexecuted'>        uint256 stake = _updateStakeAndTotalStakes(_cdpId);</span>
  985 |     | <span class='neutral'></span>
  986 |     | <span class='unexecuted'>        emit CdpUpdated(</span>
  987 |     | <span class='unexecuted'>            _cdpId,</span>
  988 |     | <span class='unexecuted'>            _borrower,</span>
  989 |     | <span class='unexecuted'>            msg.sender,</span>
  990 |     | <span class='unexecuted'>            _debt,</span>
  991 |     | <span class='unexecuted'>            _coll,</span>
  992 |     | <span class='unexecuted'>            _newDebt,</span>
  993 |     | <span class='unexecuted'>            _newColl,</span>
  994 |     | <span class='unexecuted'>            stake,</span>
  995 |     | <span class='unexecuted'>            CdpOperation.adjustCdp</span>
  996 |     | <span class='neutral'>        );</span>
  997 |     | <span class='neutral'>    }</span>
  998 |     | <span class='neutral'></span>
  999 |     | <span class='neutral'>    /// @notice Set the collateral of a Cdp</span>
 1000 |     | <span class='neutral'>    /// @param _cdpId The ID of the Cdp</span>
 1001 |     | <span class='neutral'>    /// @param _newColl New collateral value, in stETH shares</span>
 1002 |     | <span class='neutral'>    function _setCdpCollShares(bytes32 _cdpId, uint256 _newColl) internal {</span>
 1003 |     | <span class='unexecuted'>        Cdps[_cdpId].coll = _newColl;</span>
 1004 |     | <span class='neutral'>    }</span>
 1005 |     | <span class='neutral'></span>
 1006 |     | <span class='neutral'>    /// @notice Set the debt of a Cdp</span>
 1007 |     | <span class='neutral'>    /// @param _cdpId The ID of the Cdp</span>
 1008 |     | <span class='neutral'>    /// @param _newDebt New debt units value</span>
 1009 |     | <span class='neutral'>    function _setCdpDebt(bytes32 _cdpId, uint256 _newDebt) internal {</span>
 1010 |     | <span class='unexecuted'>        Cdps[_cdpId].debt = _newDebt;</span>
 1011 |     | <span class='neutral'>    }</span>
 1012 |     | <span class='neutral'>}</span>
 1013 |     | <span class='neutral'></span>

</code>
<br />

<b>/mnt/c/Users/Lourens/Documents/Recon-Fuzz/collabs/ebtc/packages/contracts/contracts/CdpManagerStorage.sol</b>
<code>
   1 |     | <span class='neutral'>// SPDX-License-Identifier: MIT</span>
   2 |     | <span class='neutral'></span>
   3 |     | <span class='neutral'>pragma solidity 0.8.17;</span>
   4 |     | <span class='neutral'></span>
   5 |     | <span class='neutral'>import &quot;./Interfaces/ICdpManager.sol&quot;;</span>
   6 |     | <span class='neutral'>import &quot;./Interfaces/ICollSurplusPool.sol&quot;;</span>
   7 |     | <span class='neutral'>import &quot;./Interfaces/IEBTCToken.sol&quot;;</span>
   8 |     | <span class='neutral'>import &quot;./Interfaces/ISortedCdps.sol&quot;;</span>
   9 |     | <span class='neutral'>import &quot;./Dependencies/EbtcBase.sol&quot;;</span>
  10 |     | <span class='neutral'>import &quot;./Dependencies/ReentrancyGuard.sol&quot;;</span>
  11 |     | <span class='neutral'>import &quot;./Dependencies/ICollateralTokenOracle.sol&quot;;</span>
  12 |     | <span class='neutral'>import &quot;./Dependencies/AuthNoOwner.sol&quot;;</span>
  13 |     | <span class='neutral'></span>
  14 |     | <span class='neutral'>/// @title CDP Manager storage and shared functions with LiquidationLibrary</span>
  15 |     | <span class='neutral'>/// @dev All features around Cdp management are split into separate parts to get around contract size limitations.</span>
  16 |     | <span class='neutral'>/// @dev Liquidation related functions are delegated to LiquidationLibrary contract code.</span>
  17 |     | <span class='neutral'>/// @dev Both CdpManager and LiquidationLibrary must maintain **the same storage layout**, so shared storage components</span>
  18 |     | <span class='neutral'>/// @dev and shared functions are added here in CdpManagerStorage to de-dup code</span>
  19 |     | <span class='unexecuted'>contract CdpManagerStorage is EbtcBase, ReentrancyGuard, ICdpManagerData, AuthNoOwner {</span>
  20 |     | <span class='neutral'>    // NOTE: No packing cause it&#39;s the last var, no need for u64</span>
  21 |     | <span class='unexecuted'>    uint128 public constant UNSET_TIMESTAMP = type(uint128).max;</span>
  22 |     | <span class='unexecuted'>    uint128 public constant MINIMUM_GRACE_PERIOD = 15 minutes;</span>
  23 |     | <span class='neutral'></span>
  24 |     | <span class='unexecuted'>    uint128 public lastGracePeriodStartTimestamp = UNSET_TIMESTAMP; // use max to signify</span>
  25 |     | <span class='unexecuted'>    uint128 public recoveryModeGracePeriodDuration = MINIMUM_GRACE_PERIOD;</span>
  26 |     | <span class='neutral'></span>
  27 |     | <span class='neutral'>    /// @notice Start the recovery mode grace period, if the system is in RM and the grace period timestamp has not already been set</span>
  28 |     | <span class='neutral'>    /// @dev Trusted function to allow BorrowerOperations actions to set RM Grace Period</span>
  29 |     | <span class='neutral'>    /// @dev Assumes BorrowerOperations has correctly calculated and passed in the new system TCR</span>
  30 |     | <span class='neutral'>    /// @dev To maintain CEI compliance we use this trusted function</span>
  31 |     | <span class='neutral'>    /// @param tcr The TCR to be checked whether Grace Period should be started</span>
  32 |     | <span class='unexecuted'>    function notifyStartGracePeriod(uint256 tcr) external {</span>
  33 |     | <span class='unexecuted'>        _requireCallerIsBorrowerOperations();</span>
  34 |     | <span class='unexecuted'>        _startGracePeriod(tcr);</span>
  35 |     | <span class='neutral'>    }</span>
  36 |     | <span class='neutral'></span>
  37 |     | <span class='neutral'>    /// @notice End the recovery mode grace period, if the system is no longer in RM</span>
  38 |     | <span class='neutral'>    /// @dev Trusted function to allow BorrowerOperations actions to set RM Grace Period</span>
  39 |     | <span class='neutral'>    /// @dev Assumes BorrowerOperations has correctly calculated and passed in the new system TCR</span>
  40 |     | <span class='neutral'>    /// @dev To maintain CEI compliance we use this trusted function</span>
  41 |     | <span class='neutral'>    /// @param tcr The TCR to be checked whether Grace Period should be ended</span>
  42 |     | <span class='unexecuted'>    function notifyEndGracePeriod(uint256 tcr) external {</span>
  43 |     | <span class='unexecuted'>        _requireCallerIsBorrowerOperations();</span>
  44 |     | <span class='unexecuted'>        _endGracePeriod(tcr);</span>
  45 |     | <span class='neutral'>    }</span>
  46 |     | <span class='neutral'></span>
  47 |     | <span class='neutral'>    /// @dev Internal notify called by Redemptions and Liquidations</span>
  48 |     | <span class='neutral'>    /// @dev Specified TCR is emitted for notification pruposes regardless of whether the Grace Period timestamp is set</span>
  49 |     | <span class='unexecuted'>    function _startGracePeriod(uint256 _tcr) internal {</span>
  50 |     | <span class='unexecuted'>        emit TCRNotified(_tcr);</span>
  51 |     | <span class='neutral'></span>
  52 |     | <span class='unexecuted'>        if (lastGracePeriodStartTimestamp == UNSET_TIMESTAMP) {</span>
  53 |     | <span class='unexecuted'>            lastGracePeriodStartTimestamp = uint128(block.timestamp);</span>
  54 |     | <span class='neutral'></span>
  55 |     | <span class='unexecuted'>            emit GracePeriodStart();</span>
  56 |     | <span class='neutral'>        }</span>
  57 |     | <span class='neutral'>    }</span>
  58 |     | <span class='neutral'></span>
  59 |     | <span class='neutral'>    /// @notice Clear RM Grace Period timestamp if it has been set</span>
  60 |     | <span class='neutral'>    /// @notice No input validation, calling function must confirm that the system is not in recovery mode to be valid</span>
  61 |     | <span class='neutral'>    /// @dev Specified TCR is emitted for notification pruposes regardless of whether the Grace Period timestamp is set</span>
  62 |     | <span class='neutral'>    /// @dev Internal notify called by Redemptions and Liquidations</span>
  63 |     | <span class='unexecuted'>    function _endGracePeriod(uint256 _tcr) internal {</span>
  64 |     | <span class='unexecuted'>        emit TCRNotified(_tcr);</span>
  65 |     | <span class='neutral'></span>
  66 |     | <span class='unexecuted'>        if (lastGracePeriodStartTimestamp != UNSET_TIMESTAMP) {</span>
  67 |     | <span class='unexecuted'>            lastGracePeriodStartTimestamp = UNSET_TIMESTAMP;</span>
  68 |     | <span class='neutral'></span>
  69 |     | <span class='unexecuted'>            emit GracePeriodEnd();</span>
  70 |     | <span class='neutral'>        }</span>
  71 |     | <span class='neutral'>    }</span>
  72 |     | <span class='neutral'></span>
  73 |     | <span class='unexecuted'>    function _syncGracePeriod() internal {</span>
  74 |     | <span class='unexecuted'>        uint256 price = priceFeed.fetchPrice();</span>
  75 |     | <span class='unexecuted'>        uint256 tcr = _getCachedTCR(price);</span>
  76 |     | <span class='unexecuted'>        bool isRecoveryMode = _checkRecoveryModeForTCR(tcr);</span>
  77 |     | <span class='neutral'></span>
  78 |     | <span class='unexecuted'>        if (isRecoveryMode) {</span>
  79 |     | <span class='unexecuted'>            _startGracePeriod(tcr);</span>
  80 |     | <span class='neutral'>        } else {</span>
  81 |     | <span class='unexecuted'>            _endGracePeriod(tcr);</span>
  82 |     | <span class='neutral'>        }</span>
  83 |     | <span class='neutral'>    }</span>
  84 |     | <span class='neutral'></span>
  85 |     | <span class='neutral'>    /// @dev Set RM grace period based on specified system collShares, system debt, and price</span>
  86 |     | <span class='neutral'>    /// @dev Variant for internal use in redemptions and liquidations</span>
  87 |     | <span class='unexecuted'>    function _syncGracePeriodForGivenValues(</span>
  88 |     | <span class='neutral'>        uint256 systemCollShares,</span>
  89 |     | <span class='neutral'>        uint256 systemDebt,</span>
  90 |     | <span class='neutral'>        uint256 price</span>
  91 |     | <span class='unexecuted'>    ) internal {</span>
  92 |     | <span class='neutral'>        // Compute TCR with specified values</span>
  93 |     | <span class='unexecuted'>        uint256 newTCR = EbtcMath._computeCR(</span>
  94 |     | <span class='unexecuted'>            collateral.getPooledEthByShares(systemCollShares),</span>
  95 |     | <span class='unexecuted'>            systemDebt,</span>
  96 |     | <span class='unexecuted'>            price</span>
  97 |     | <span class='neutral'>        );</span>
  98 |     | <span class='neutral'></span>
  99 |     | <span class='unexecuted'>        if (newTCR &lt; CCR) {</span>
 100 |     | <span class='neutral'>            // Notify system is in RM</span>
 101 |     | <span class='unexecuted'>            _startGracePeriod(newTCR);</span>
 102 |     | <span class='neutral'>        } else {</span>
 103 |     | <span class='neutral'>            // Notify system is outside RM</span>
 104 |     | <span class='unexecuted'>            _endGracePeriod(newTCR);</span>
 105 |     | <span class='neutral'>        }</span>
 106 |     | <span class='neutral'>    }</span>
 107 |     | <span class='neutral'></span>
 108 |     | <span class='neutral'>    /// @notice Set grace period duratin</span>
 109 |     | <span class='neutral'>    /// @notice Permissioned governance function, must set grace period duration above hardcoded minimum</span>
 110 |     | <span class='neutral'>    /// @param _gracePeriod new grace period duration, in seconds</span>
 111 |     | <span class='unexecuted'>    function setGracePeriod(uint128 _gracePeriod) external requiresAuth {</span>
 112 |     | <span class='unexecuted'>        require(</span>
 113 |     | <span class='unexecuted'>            _gracePeriod &gt;= MINIMUM_GRACE_PERIOD,</span>
 114 |     | <span class='neutral'>            &quot;CdpManager: Grace period below minimum duration&quot;</span>
 115 |     | <span class='neutral'>        );</span>
 116 |     | <span class='neutral'></span>
 117 |     | <span class='unexecuted'>        syncGlobalAccountingAndGracePeriod();</span>
 118 |     | <span class='unexecuted'>        recoveryModeGracePeriodDuration = _gracePeriod;</span>
 119 |     | <span class='unexecuted'>        emit GracePeriodDurationSet(_gracePeriod);</span>
 120 |     | <span class='neutral'>    }</span>
 121 |     | <span class='neutral'></span>
 122 |     | <span class='unexecuted'>    string public constant NAME = &quot;CdpManager&quot;;</span>
 123 |     | <span class='neutral'></span>
 124 |     | <span class='neutral'>    // --- Connected contract declarations ---</span>
 125 |     | <span class='neutral'></span>
 126 |     | <span class='unexecuted'>    address public immutable borrowerOperationsAddress;</span>
 127 |     | <span class='neutral'></span>
 128 |     | <span class='neutral'>    ICollSurplusPool immutable collSurplusPool;</span>
 129 |     | <span class='neutral'></span>
 130 |     | <span class='unexecuted'>    IEBTCToken public immutable override ebtcToken;</span>
 131 |     | <span class='neutral'></span>
 132 |     | <span class='unexecuted'>    address public immutable liquidationLibrary;</span>
 133 |     | <span class='neutral'></span>
 134 |     | <span class='neutral'>    // A doubly linked list of Cdps, sorted by their sorted by their collateral ratios</span>
 135 |     | <span class='unexecuted'>    ISortedCdps public immutable sortedCdps;</span>
 136 |     | <span class='neutral'></span>
 137 |     | <span class='neutral'>    // --- Data structures ---</span>
 138 |     | <span class='neutral'></span>
 139 |     | <span class='unexecuted'>    uint256 public constant SECONDS_IN_ONE_MINUTE = 60;</span>
 140 |     | <span class='neutral'></span>
 141 |     | <span class='unexecuted'>    uint256 public constant MIN_REDEMPTION_FEE_FLOOR = (DECIMAL_PRECISION * 5) / 1000; // 0.5%</span>
 142 |     | <span class='unexecuted'>    uint256 public redemptionFeeFloor = MIN_REDEMPTION_FEE_FLOOR;</span>
 143 |     | <span class='unexecuted'>    bool public redemptionsPaused;</span>
 144 |     | <span class='neutral'>    /*</span>
 145 |     | <span class='neutral'>     * Half-life of 12h. 12h = 720 min</span>
 146 |     | <span class='neutral'>     * (1/2) = d^720 =&gt; d = (1/2)^(1/720)</span>
 147 |     | <span class='neutral'>     */</span>
 148 |     | <span class='unexecuted'>    uint256 public minuteDecayFactor = 999037758833783000;</span>
 149 |     | <span class='unexecuted'>    uint256 public constant MIN_MINUTE_DECAY_FACTOR = 1; // Non-zero</span>
 150 |     | <span class='unexecuted'>    uint256 public constant MAX_MINUTE_DECAY_FACTOR = 999999999999999999; // Corresponds to a very fast decay rate, but not too extreme</span>
 151 |     | <span class='neutral'></span>
 152 |     | <span class='neutral'>    uint256 internal immutable deploymentStartTime;</span>
 153 |     | <span class='neutral'></span>
 154 |     | <span class='neutral'>    /*</span>
 155 |     | <span class='neutral'>     * BETA: 18 digit decimal. Parameter by which to divide the redeemed fraction,</span>
 156 |     | <span class='neutral'>     * in order to calc the new base rate from a redemption.</span>
 157 |     | <span class='neutral'>     * Corresponds to (1 / ALPHA) in the Liquity white paper.</span>
 158 |     | <span class='neutral'>     */</span>
 159 |     | <span class='unexecuted'>    uint256 public beta = 2;</span>
 160 |     | <span class='neutral'></span>
 161 |     | <span class='unexecuted'>    uint256 public baseRate;</span>
 162 |     | <span class='neutral'></span>
 163 |     | <span class='unexecuted'>    uint256 public stakingRewardSplit;</span>
 164 |     | <span class='neutral'></span>
 165 |     | <span class='neutral'>    // The timestamp of the latest fee operation (redemption or new EBTC issuance)</span>
 166 |     | <span class='unexecuted'>    uint256 public lastRedemptionTimestamp;</span>
 167 |     | <span class='neutral'></span>
 168 |     | <span class='unexecuted'>    mapping(bytes32 =&gt; Cdp) public Cdps;</span>
 169 |     | <span class='neutral'></span>
 170 |     | <span class='unexecuted'>    uint256 public override totalStakes;</span>
 171 |     | <span class='neutral'></span>
 172 |     | <span class='neutral'>    // Snapshot of the value of totalStakes, taken immediately after the latest liquidation and split fee claim</span>
 173 |     | <span class='unexecuted'>    uint256 public totalStakesSnapshot;</span>
 174 |     | <span class='neutral'></span>
 175 |     | <span class='neutral'>    // Snapshot of the total collateral across the ActivePool, immediately after the latest liquidation and split fee claim</span>
 176 |     | <span class='unexecuted'>    uint256 public totalCollateralSnapshot;</span>
 177 |     | <span class='neutral'></span>
 178 |     | <span class='neutral'>    /*</span>
 179 |     | <span class='neutral'>     * systemDebtRedistributionIndex track the sums of accumulated socialized liquidations per unit staked.</span>
 180 |     | <span class='neutral'>     * During its lifetime, each stake earns:</span>
 181 |     | <span class='neutral'>     *</span>
 182 |     | <span class='neutral'>     * A systemDebt increase  of ( stake * [systemDebtRedistributionIndex - systemDebtRedistributionIndex(0)] )</span>
 183 |     | <span class='neutral'>     *</span>
 184 |     | <span class='neutral'>     * Where systemDebtRedistributionIndex(0) are snapshots of systemDebtRedistributionIndex</span>
 185 |     | <span class='neutral'>     * for the active Cdp taken at the instant the stake was made</span>
 186 |     | <span class='neutral'>     */</span>
 187 |     | <span class='unexecuted'>    uint256 public systemDebtRedistributionIndex;</span>
 188 |     | <span class='neutral'></span>
 189 |     | <span class='neutral'>    // Map active cdps to their RewardSnapshot (eBTC debt redistributed)</span>
 190 |     | <span class='unexecuted'>    mapping(bytes32 =&gt; uint256) public cdpDebtRedistributionIndex;</span>
 191 |     | <span class='neutral'></span>
 192 |     | <span class='neutral'>    // Error trackers for the cdp redistribution calculation</span>
 193 |     | <span class='unexecuted'>    uint256 public lastEBTCDebtErrorRedistribution;</span>
 194 |     | <span class='neutral'></span>
 195 |     | <span class='neutral'>    /* Global Index for (Full Price Per Share) of underlying collateral token */</span>
 196 |     | <span class='unexecuted'>    uint256 public override stEthIndex;</span>
 197 |     | <span class='neutral'>    /* Global Fee accumulator (never decreasing) per stake unit in CDPManager, similar to systemDebtRedistributionIndex */</span>
 198 |     | <span class='unexecuted'>    uint256 public override systemStEthFeePerUnitIndex;</span>
 199 |     | <span class='neutral'>    /* Global Fee accumulator calculation error due to integer division, similar to redistribution calculation */</span>
 200 |     | <span class='unexecuted'>    uint256 public override systemStEthFeePerUnitIndexError;</span>
 201 |     | <span class='neutral'>    /* Individual CDP Fee accumulator tracker, used to calculate fee split distribution */</span>
 202 |     | <span class='unexecuted'>    mapping(bytes32 =&gt; uint256) public cdpStEthFeePerUnitIndex;</span>
 203 |     | <span class='neutral'></span>
 204 |     | <span class='neutral'>    /// @notice Initializes the contract with the provided addresses and sets up the required initial state</span>
 205 |     | <span class='neutral'>    /// @param _liquidationLibraryAddress The address of the Liquidation Library</span>
 206 |     | <span class='neutral'>    /// @param _authorityAddress The address of the Authority</span>
 207 |     | <span class='neutral'>    /// @param _borrowerOperationsAddress The address of Borrower Operations</span>
 208 |     | <span class='neutral'>    /// @param _collSurplusPool The address of the Collateral Surplus Pool</span>
 209 |     | <span class='neutral'>    /// @param _ebtcToken The address of the eBTC Token contract</span>
 210 |     | <span class='neutral'>    /// @param _sortedCdps The address of the Sorted CDPs contract</span>
 211 |     | <span class='neutral'>    /// @param _activePool The address of the Active Pool</span>
 212 |     | <span class='neutral'>    /// @param _priceFeed The address of the Price Feed</span>
 213 |     | <span class='neutral'>    /// @param _collateral The address of the Collateral token</span>
 214 |     | <span class='unexecuted'>    constructor(</span>
 215 |     | <span class='neutral'>        address _liquidationLibraryAddress,</span>
 216 |     | <span class='neutral'>        address _authorityAddress,</span>
 217 |     | <span class='neutral'>        address _borrowerOperationsAddress,</span>
 218 |     | <span class='neutral'>        address _collSurplusPool,</span>
 219 |     | <span class='neutral'>        address _ebtcToken,</span>
 220 |     | <span class='neutral'>        address _sortedCdps,</span>
 221 |     | <span class='neutral'>        address _activePool,</span>
 222 |     | <span class='neutral'>        address _priceFeed,</span>
 223 |     | <span class='neutral'>        address _collateral</span>
 224 |     | <span class='neutral'>    ) EbtcBase(_activePool, _priceFeed, _collateral) {</span>
 225 |     | <span class='unexecuted'>        deploymentStartTime = block.timestamp;</span>
 226 |     | <span class='unexecuted'>        liquidationLibrary = _liquidationLibraryAddress;</span>
 227 |     | <span class='neutral'></span>
 228 |     | <span class='unexecuted'>        _initializeAuthority(_authorityAddress);</span>
 229 |     | <span class='neutral'></span>
 230 |     | <span class='unexecuted'>        borrowerOperationsAddress = _borrowerOperationsAddress;</span>
 231 |     | <span class='unexecuted'>        collSurplusPool = ICollSurplusPool(_collSurplusPool);</span>
 232 |     | <span class='unexecuted'>        ebtcToken = IEBTCToken(_ebtcToken);</span>
 233 |     | <span class='unexecuted'>        sortedCdps = ISortedCdps(_sortedCdps);</span>
 234 |     | <span class='neutral'>    }</span>
 235 |     | <span class='neutral'></span>
 236 |     | <span class='neutral'>    /// @notice BorrowerOperations and CdpManager share reentrancy status by confirming the other&#39;s locked flag before beginning operation</span>
 237 |     | <span class='neutral'>    /// @dev This is an alternative to the more heavyweight solution of both being able to set the reentrancy flag on a 3rd contract.</span>
 238 |     | <span class='neutral'>    modifier nonReentrantSelfAndBOps() {</span>
 239 |     | <span class='unexecuted'>        require(locked == OPEN, &quot;CdpManager: Reentrancy in nonReentrant call&quot;);</span>
 240 |     | <span class='unexecuted'>        require(</span>
 241 |     | <span class='unexecuted'>            ReentrancyGuard(borrowerOperationsAddress).locked() == OPEN,</span>
 242 |     | <span class='neutral'>            &quot;BorrowerOperations: Reentrancy in nonReentrant call&quot;</span>
 243 |     | <span class='neutral'>        );</span>
 244 |     | <span class='neutral'></span>
 245 |     | <span class='unexecuted'>        locked = LOCKED;</span>
 246 |     | <span class='neutral'></span>
 247 |     | <span class='neutral'>        _;</span>
 248 |     | <span class='neutral'></span>
 249 |     | <span class='unexecuted'>        locked = OPEN;</span>
 250 |     | <span class='neutral'>    }</span>
 251 |     | <span class='neutral'></span>
 252 |     | <span class='unexecuted'>    function _closeCdp(bytes32 _cdpId, Status closedStatus) internal {</span>
 253 |     | <span class='unexecuted'>        _closeCdpWithoutRemovingSortedCdps(_cdpId, closedStatus);</span>
 254 |     | <span class='unexecuted'>        sortedCdps.remove(_cdpId);</span>
 255 |     | <span class='neutral'>    }</span>
 256 |     | <span class='neutral'></span>
 257 |     | <span class='unexecuted'>    function _closeCdpWithoutRemovingSortedCdps(bytes32 _cdpId, Status closedStatus) internal {</span>
 258 |     | <span class='unexecuted'>        require(</span>
 259 |     | <span class='unexecuted'>            closedStatus != Status.nonExistent &amp;&amp; closedStatus != Status.active,</span>
 260 |     | <span class='neutral'>            &quot;CdpManagerStorage: close non-exist or non-active CDP!&quot;</span>
 261 |     | <span class='neutral'>        );</span>
 262 |     | <span class='neutral'></span>
 263 |     | <span class='unexecuted'>        uint256 cdpIdsArrayLength = getActiveCdpsCount();</span>
 264 |     | <span class='unexecuted'>        _requireMoreThanOneCdpInSystem(cdpIdsArrayLength);</span>
 265 |     | <span class='neutral'></span>
 266 |     | <span class='unexecuted'>        _removeStake(_cdpId);</span>
 267 |     | <span class='neutral'></span>
 268 |     | <span class='unexecuted'>        Cdps[_cdpId].status = closedStatus;</span>
 269 |     | <span class='unexecuted'>        Cdps[_cdpId].coll = 0;</span>
 270 |     | <span class='unexecuted'>        Cdps[_cdpId].debt = 0;</span>
 271 |     | <span class='unexecuted'>        Cdps[_cdpId].liquidatorRewardShares = 0;</span>
 272 |     | <span class='neutral'></span>
 273 |     | <span class='unexecuted'>        cdpDebtRedistributionIndex[_cdpId] = 0;</span>
 274 |     | <span class='unexecuted'>        cdpStEthFeePerUnitIndex[_cdpId] = 0;</span>
 275 |     | <span class='neutral'>    }</span>
 276 |     | <span class='neutral'></span>
 277 |     | <span class='neutral'>    /*</span>
 278 |     | <span class='neutral'>     * Updates snapshots of system total stakes and total collateral,</span>
 279 |     | <span class='neutral'>     * excluding a given collateral remainder from the calculation.</span>
 280 |     | <span class='neutral'>     * Used in a liquidation sequence.</span>
 281 |     | <span class='neutral'>     *</span>
 282 |     | <span class='neutral'>     * The calculation excludes a portion of collateral that is in the ActivePool:</span>
 283 |     | <span class='neutral'>     *</span>
 284 |     | <span class='neutral'>     * the total stETH liquidator reward compensation from the liquidation sequence</span>
 285 |     | <span class='neutral'>     *</span>
 286 |     | <span class='neutral'>     * The stETH as compensation must be excluded as it is always sent out at the very end of the liquidation sequence.</span>
 287 |     | <span class='neutral'>     */</span>
 288 |     | <span class='unexecuted'>    function _updateSystemSnapshotsExcludeCollRemainder(uint256 _collRemainder) internal {</span>
 289 |     | <span class='unexecuted'>        uint256 _totalStakesSnapshot = totalStakes;</span>
 290 |     | <span class='unexecuted'>        totalStakesSnapshot = _totalStakesSnapshot;</span>
 291 |     | <span class='neutral'></span>
 292 |     | <span class='unexecuted'>        uint256 _totalCollateralSnapshot = activePool.getSystemCollShares() - _collRemainder;</span>
 293 |     | <span class='unexecuted'>        totalCollateralSnapshot = _totalCollateralSnapshot;</span>
 294 |     | <span class='neutral'></span>
 295 |     | <span class='unexecuted'>        emit SystemSnapshotsUpdated(_totalStakesSnapshot, _totalCollateralSnapshot);</span>
 296 |     | <span class='neutral'>    }</span>
 297 |     | <span class='neutral'></span>
 298 |     | <span class='neutral'>    /// @dev get the pending Cdp debt &quot;reward&quot; (i.e. the amount of extra debt assigned to the Cdp) from liquidation redistribution events, earned by their stake</span>
 299 |     | <span class='unexecuted'>    function _getPendingRedistributedDebt(</span>
 300 |     | <span class='neutral'>        bytes32 _cdpId</span>
 301 |     | <span class='unexecuted'>    ) internal view returns (uint256 pendingEBTCDebtReward, uint256 _debtIndexDiff) {</span>
 302 |     | <span class='unexecuted'>        Cdp storage cdp = Cdps[_cdpId];</span>
 303 |     | <span class='neutral'></span>
 304 |     | <span class='unexecuted'>        if (cdp.status != Status.active) {</span>
 305 |     | <span class='unexecuted'>            return (0, 0);</span>
 306 |     | <span class='neutral'>        }</span>
 307 |     | <span class='neutral'></span>
 308 |     | <span class='unexecuted'>        _debtIndexDiff = systemDebtRedistributionIndex - cdpDebtRedistributionIndex[_cdpId];</span>
 309 |     | <span class='neutral'></span>
 310 |     | <span class='unexecuted'>        if (_debtIndexDiff &gt; 0) {</span>
 311 |     | <span class='unexecuted'>            pendingEBTCDebtReward = (cdp.stake * _debtIndexDiff) / DECIMAL_PRECISION;</span>
 312 |     | <span class='neutral'>        } else {</span>
 313 |     | <span class='unexecuted'>            return (0, 0);</span>
 314 |     | <span class='neutral'>        }</span>
 315 |     | <span class='neutral'>    }</span>
 316 |     | <span class='neutral'></span>
 317 |     | <span class='neutral'>    /*</span>
 318 |     | <span class='neutral'>     * A Cdp has pending redistributed debt if its snapshot is less than the current rewards per-unit-staked sum:</span>
 319 |     | <span class='neutral'>     * this indicates that redistributions have occured since the snapshot was made, and the user therefore has</span>
 320 |     | <span class='neutral'>     * pending debt</span>
 321 |     | <span class='neutral'>     */</span>
 322 |     | <span class='unexecuted'>    function _hasRedistributedDebt(bytes32 _cdpId) internal view returns (bool) {</span>
 323 |     | <span class='unexecuted'>        if (Cdps[_cdpId].status != Status.active) {</span>
 324 |     | <span class='unexecuted'>            return false;</span>
 325 |     | <span class='neutral'>        }</span>
 326 |     | <span class='neutral'></span>
 327 |     | <span class='unexecuted'>        return (cdpDebtRedistributionIndex[_cdpId] &lt; systemDebtRedistributionIndex);</span>
 328 |     | <span class='neutral'>    }</span>
 329 |     | <span class='neutral'></span>
 330 |     | <span class='neutral'>    /// @dev Sync Cdp debt redistribution index to global value</span>
 331 |     | <span class='unexecuted'>    function _updateRedistributedDebtIndex(bytes32 _cdpId) internal {</span>
 332 |     | <span class='unexecuted'>        uint256 _systemDebtRedistributionIndex = systemDebtRedistributionIndex;</span>
 333 |     | <span class='neutral'></span>
 334 |     | <span class='unexecuted'>        cdpDebtRedistributionIndex[_cdpId] = _systemDebtRedistributionIndex;</span>
 335 |     | <span class='unexecuted'>        emit CdpDebtRedistributionIndexUpdated(_cdpId, _systemDebtRedistributionIndex);</span>
 336 |     | <span class='neutral'>    }</span>
 337 |     | <span class='neutral'></span>
 338 |     | <span class='neutral'>    /// @dev Calculate the new collateral and debt values for a given CDP, based on pending state changes</span>
 339 |     | <span class='unexecuted'>    function _syncAccounting(bytes32 _cdpId) internal {</span>
 340 |     | <span class='neutral'>        // Ensure global states like systemStEthFeePerUnitIndex get updated in a timely fashion</span>
 341 |     | <span class='neutral'>        // whenever there is a CDP modification operation,</span>
 342 |     | <span class='neutral'>        // such as opening, closing, adding collateral, repaying debt, or liquidating</span>
 343 |     | <span class='unexecuted'>        _syncGlobalAccounting();</span>
 344 |     | <span class='neutral'></span>
 345 |     | <span class='unexecuted'>        uint256 _oldPerUnitCdp = cdpStEthFeePerUnitIndex[_cdpId];</span>
 346 |     | <span class='unexecuted'>        uint256 _systemStEthFeePerUnitIndex = systemStEthFeePerUnitIndex;</span>
 347 |     | <span class='neutral'></span>
 348 |     | <span class='unexecuted'>        (</span>
 349 |     | <span class='neutral'>            uint256 _newColl,</span>
 350 |     | <span class='neutral'>            uint256 _newDebt,</span>
 351 |     | <span class='neutral'>            uint256 _feeSplitDistributed,</span>
 352 |     | <span class='neutral'>            uint _pendingDebt,</span>
 353 |     | <span class='neutral'>            uint256 _debtIndexDelta</span>
 354 |     | <span class='unexecuted'>        ) = _calcSyncedAccounting(_cdpId, _oldPerUnitCdp, _systemStEthFeePerUnitIndex);</span>
 355 |     | <span class='neutral'></span>
 356 |     | <span class='neutral'>        // If any collShares or debt changes occured</span>
 357 |     | <span class='unexecuted'>        if (_feeSplitDistributed &gt; 0 || _debtIndexDelta &gt; 0) {</span>
 358 |     | <span class='unexecuted'>            Cdp storage _cdp = Cdps[_cdpId];</span>
 359 |     | <span class='neutral'></span>
 360 |     | <span class='unexecuted'>            uint prevCollShares = _cdp.coll;</span>
 361 |     | <span class='unexecuted'>            uint256 prevDebt = _cdp.debt;</span>
 362 |     | <span class='neutral'></span>
 363 |     | <span class='neutral'>            // Apply Fee Split</span>
 364 |     | <span class='unexecuted'>            if (_feeSplitDistributed &gt; 0) {</span>
 365 |     | <span class='unexecuted'>                _applyAccumulatedFeeSplit(</span>
 366 |     | <span class='unexecuted'>                    _cdpId,</span>
 367 |     | <span class='unexecuted'>                    _newColl,</span>
 368 |     | <span class='unexecuted'>                    _feeSplitDistributed,</span>
 369 |     | <span class='unexecuted'>                    _oldPerUnitCdp,</span>
 370 |     | <span class='unexecuted'>                    _systemStEthFeePerUnitIndex</span>
 371 |     | <span class='neutral'>                );</span>
 372 |     | <span class='neutral'>            }</span>
 373 |     | <span class='neutral'></span>
 374 |     | <span class='neutral'>            // Apply Debt Redistribution</span>
 375 |     | <span class='unexecuted'>            if (_debtIndexDelta &gt; 0) {</span>
 376 |     | <span class='unexecuted'>                _updateRedistributedDebtIndex(_cdpId);</span>
 377 |     | <span class='neutral'></span>
 378 |     | <span class='unexecuted'>                if (prevDebt != _newDebt) {</span>
 379 |     | <span class='neutral'>                    {</span>
 380 |     | <span class='neutral'>                        // Apply pending debt redistribution to this CDP</span>
 381 |     | <span class='unexecuted'>                        _cdp.debt = _newDebt;</span>
 382 |     | <span class='neutral'>                    }</span>
 383 |     | <span class='neutral'>                }</span>
 384 |     | <span class='neutral'>            }</span>
 385 |     | <span class='unexecuted'>            emit CdpUpdated(</span>
 386 |     | <span class='unexecuted'>                _cdpId,</span>
 387 |     | <span class='unexecuted'>                ISortedCdps(sortedCdps).getOwnerAddress(_cdpId),</span>
 388 |     | <span class='unexecuted'>                msg.sender,</span>
 389 |     | <span class='unexecuted'>                prevDebt,</span>
 390 |     | <span class='unexecuted'>                prevCollShares,</span>
 391 |     | <span class='unexecuted'>                _newDebt,</span>
 392 |     | <span class='unexecuted'>                _newColl,</span>
 393 |     | <span class='unexecuted'>                _cdp.stake,</span>
 394 |     | <span class='unexecuted'>                CdpOperation.syncAccounting</span>
 395 |     | <span class='neutral'>            );</span>
 396 |     | <span class='neutral'>        }</span>
 397 |     | <span class='neutral'></span>
 398 |     | <span class='neutral'>        // sync per stake index for given CDP</span>
 399 |     | <span class='unexecuted'>        if (_oldPerUnitCdp != _systemStEthFeePerUnitIndex) {</span>
 400 |     | <span class='unexecuted'>            cdpStEthFeePerUnitIndex[_cdpId] = _systemStEthFeePerUnitIndex;</span>
 401 |     | <span class='neutral'>        }</span>
 402 |     | <span class='neutral'>    }</span>
 403 |     | <span class='neutral'></span>
 404 |     | <span class='neutral'>    // Remove borrower&#39;s stake from the totalStakes sum, and set their stake to 0</span>
 405 |     | <span class='unexecuted'>    function _removeStake(bytes32 _cdpId) internal {</span>
 406 |     | <span class='unexecuted'>        uint256 _newTotalStakes = totalStakes - Cdps[_cdpId].stake;</span>
 407 |     | <span class='unexecuted'>        totalStakes = _newTotalStakes;</span>
 408 |     | <span class='unexecuted'>        Cdps[_cdpId].stake = 0;</span>
 409 |     | <span class='unexecuted'>        emit TotalStakesUpdated(_newTotalStakes);</span>
 410 |     | <span class='neutral'>    }</span>
 411 |     | <span class='neutral'></span>
 412 |     | <span class='neutral'>    // Update borrower&#39;s stake based on their latest collateral value</span>
 413 |     | <span class='neutral'>    // and update totalStakes accordingly as well</span>
 414 |     | <span class='unexecuted'>    function _updateStakeAndTotalStakes(bytes32 _cdpId) internal returns (uint256) {</span>
 415 |     | <span class='unexecuted'>        (uint256 newStake, uint256 oldStake) = _updateStakeForCdp(_cdpId);</span>
 416 |     | <span class='neutral'></span>
 417 |     | <span class='unexecuted'>        uint256 _newTotalStakes = totalStakes + newStake - oldStake;</span>
 418 |     | <span class='unexecuted'>        totalStakes = _newTotalStakes;</span>
 419 |     | <span class='neutral'></span>
 420 |     | <span class='unexecuted'>        emit TotalStakesUpdated(_newTotalStakes);</span>
 421 |     | <span class='neutral'></span>
 422 |     | <span class='unexecuted'>        return newStake;</span>
 423 |     | <span class='neutral'>    }</span>
 424 |     | <span class='neutral'></span>
 425 |     | <span class='neutral'>    // Update borrower&#39;s stake based on their latest collateral value</span>
 426 |     | <span class='unexecuted'>    function _updateStakeForCdp(bytes32 _cdpId) internal returns (uint256, uint256) {</span>
 427 |     | <span class='unexecuted'>        Cdp storage _cdp = Cdps[_cdpId];</span>
 428 |     | <span class='unexecuted'>        uint256 newStake = _computeNewStake(_cdp.coll);</span>
 429 |     | <span class='unexecuted'>        uint256 oldStake = _cdp.stake;</span>
 430 |     | <span class='unexecuted'>        _cdp.stake = newStake;</span>
 431 |     | <span class='neutral'></span>
 432 |     | <span class='neutral'>        return (newStake, oldStake);</span>
 433 |     | <span class='neutral'>    }</span>
 434 |     | <span class='neutral'></span>
 435 |     | <span class='neutral'>    // Calculate a new stake based on the snapshots of the totalStakes and totalCollateral taken at the last liquidation</span>
 436 |     | <span class='unexecuted'>    function _computeNewStake(uint256 _coll) internal view returns (uint256) {</span>
 437 |     | <span class='unexecuted'>        uint256 stake;</span>
 438 |     | <span class='unexecuted'>        if (totalCollateralSnapshot == 0) {</span>
 439 |     | <span class='unexecuted'>            stake = _coll;</span>
 440 |     | <span class='neutral'>        } else {</span>
 441 |     | <span class='neutral'>            /*</span>
 442 |     | <span class='neutral'>             * The following check holds true because:</span>
 443 |     | <span class='neutral'>             * - The system always contains &gt;= 1 cdp</span>
 444 |     | <span class='neutral'>             * - When we close or liquidate a cdp, we redistribute the pending rewards,</span>
 445 |     | <span class='neutral'>             * so if all cdps were closed/liquidated,</span>
 446 |     | <span class='neutral'>             * rewards would’ve been emptied and totalCollateralSnapshot would be zero too.</span>
 447 |     | <span class='neutral'>             */</span>
 448 |     | <span class='unexecuted'>            require(totalStakesSnapshot &gt; 0, &quot;CdpManagerStorage: zero totalStakesSnapshot!&quot;);</span>
 449 |     | <span class='unexecuted'>            stake = (_coll * totalStakesSnapshot) / totalCollateralSnapshot;</span>
 450 |     | <span class='neutral'>        }</span>
 451 |     | <span class='neutral'>        return stake;</span>
 452 |     | <span class='neutral'>    }</span>
 453 |     | <span class='neutral'></span>
 454 |     | <span class='neutral'>    // --- Recovery Mode and TCR functions ---</span>
 455 |     | <span class='neutral'></span>
 456 |     | <span class='neutral'>    // Calculate TCR given an price, and the entire system coll and debt.</span>
 457 |     | <span class='neutral'>    function _computeTCRWithGivenSystemValues(</span>
 458 |     | <span class='neutral'>        uint256 _systemCollShares,</span>
 459 |     | <span class='neutral'>        uint256 _systemDebt,</span>
 460 |     | <span class='neutral'>        uint256 _price</span>
 461 |     | <span class='neutral'>    ) internal view returns (uint256) {</span>
 462 |     | <span class='neutral'>        uint256 _totalColl = collateral.getPooledEthByShares(_systemCollShares);</span>
 463 |     | <span class='neutral'>        return EbtcMath._computeCR(_totalColl, _systemDebt, _price);</span>
 464 |     | <span class='neutral'>    }</span>
 465 |     | <span class='neutral'></span>
 466 |     | <span class='neutral'>    // --- Staking-Reward Fee split functions ---</span>
 467 |     | <span class='neutral'></span>
 468 |     | <span class='neutral'>    /// @notice Claim split fee if there is staking-reward coming</span>
 469 |     | <span class='neutral'>    /// @notice and update global index &amp; fee-per-unit variables</span>
 470 |     | <span class='neutral'>    /// @dev only BorrowerOperations is allowed to call this</span>
 471 |     | <span class='neutral'>    /// @dev otherwise use syncGlobalAccountingAndGracePeriod()</span>
 472 |     | <span class='unexecuted'>    function syncGlobalAccounting() external {</span>
 473 |     | <span class='unexecuted'>        _requireCallerIsBorrowerOperations();</span>
 474 |     | <span class='unexecuted'>        _syncGlobalAccounting();</span>
 475 |     | <span class='neutral'>    }</span>
 476 |     | <span class='neutral'></span>
 477 |     | <span class='unexecuted'>    function _syncGlobalAccounting() internal {</span>
 478 |     | <span class='unexecuted'>        (uint256 _oldIndex, uint256 _newIndex) = _readStEthIndex();</span>
 479 |     | <span class='unexecuted'>        _syncStEthIndex(_oldIndex, _newIndex);</span>
 480 |     | <span class='unexecuted'>        if (_newIndex &gt; _oldIndex &amp;&amp; totalStakes &gt; 0) {</span>
 481 |     | <span class='unexecuted'>            (</span>
 482 |     | <span class='unexecuted'>                uint256 _feeTaken,</span>
 483 |     | <span class='unexecuted'>                uint256 _newFeePerUnit,</span>
 484 |     | <span class='unexecuted'>                uint256 _perUnitError</span>
 485 |     | <span class='unexecuted'>            ) = _calcSyncedGlobalAccounting(_newIndex, _oldIndex);</span>
 486 |     | <span class='unexecuted'>            _takeSplitAndUpdateFeePerUnit(_feeTaken, _newFeePerUnit, _perUnitError);</span>
 487 |     | <span class='unexecuted'>            _updateSystemSnapshotsExcludeCollRemainder(0);</span>
 488 |     | <span class='neutral'>        }</span>
 489 |     | <span class='neutral'>    }</span>
 490 |     | <span class='neutral'></span>
 491 |     | <span class='neutral'>    /// @notice Claim fee split, if there is staking-reward coming</span>
 492 |     | <span class='neutral'>    /// @notice and update global index &amp; fee-per-unit variables</span>
 493 |     | <span class='neutral'>    /// @notice and toggles Grace Period accordingly.</span>
 494 |     | <span class='neutral'>    /// @dev Call this if you want to help eBTC system to accrue split fee</span>
 495 |     | <span class='unexecuted'>    function syncGlobalAccountingAndGracePeriod() public {</span>
 496 |     | <span class='unexecuted'>        _syncGlobalAccounting(); // Apply // Could trigger RM</span>
 497 |     | <span class='unexecuted'>        _syncGracePeriod(); // Synch Grace Period</span>
 498 |     | <span class='neutral'>    }</span>
 499 |     | <span class='neutral'></span>
 500 |     | <span class='neutral'>    /// @return existing(old) local stETH index AND</span>
 501 |     | <span class='neutral'>    /// @return current(new) stETH index from collateral token</span>
 502 |     | <span class='unexecuted'>    function _readStEthIndex() internal view returns (uint256, uint256) {</span>
 503 |     | <span class='unexecuted'>        return (stEthIndex, collateral.getPooledEthByShares(DECIMAL_PRECISION));</span>
 504 |     | <span class='neutral'>    }</span>
 505 |     | <span class='neutral'></span>
 506 |     | <span class='neutral'>    // Update the global index via collateral token</span>
 507 |     | <span class='unexecuted'>    function _syncStEthIndex(uint256 _oldIndex, uint256 _newIndex) internal {</span>
 508 |     | <span class='unexecuted'>        if (_newIndex != _oldIndex) {</span>
 509 |     | <span class='unexecuted'>            stEthIndex = _newIndex;</span>
 510 |     | <span class='unexecuted'>            emit StEthIndexUpdated(_oldIndex, _newIndex, block.timestamp);</span>
 511 |     | <span class='neutral'>        }</span>
 512 |     | <span class='neutral'>    }</span>
 513 |     | <span class='neutral'></span>
 514 |     | <span class='neutral'>    /// @notice Calculate fee for given pair of collateral indexes</span>
 515 |     | <span class='neutral'>    /// @param _newIndex The value synced with stETH.getPooledEthByShares(1e18)</span>
 516 |     | <span class='neutral'>    /// @param _prevIndex The cached global value of `stEthIndex`</span>
 517 |     | <span class='neutral'>    /// @return _feeTaken The fee split in collateral token which will be deduced from current total system collateral</span>
 518 |     | <span class='neutral'>    /// @return _deltaFeePerUnit The fee split increase per unit, used to added to `systemStEthFeePerUnitIndex`</span>
 519 |     | <span class='neutral'>    /// @return _perUnitError The fee split calculation error, used to update `systemStEthFeePerUnitIndexError`</span>
 520 |     | <span class='unexecuted'>    function calcFeeUponStakingReward(</span>
 521 |     | <span class='neutral'>        uint256 _newIndex,</span>
 522 |     | <span class='neutral'>        uint256 _prevIndex</span>
 523 |     | <span class='unexecuted'>    ) public view returns (uint256, uint256, uint256) {</span>
 524 |     | <span class='unexecuted'>        require(_newIndex &gt; _prevIndex, &quot;CDPManager: only take fee with bigger new index&quot;);</span>
 525 |     | <span class='unexecuted'>        uint256 deltaIndex = _newIndex - _prevIndex;</span>
 526 |     | <span class='unexecuted'>        uint256 deltaIndexFees = (deltaIndex * stakingRewardSplit) / MAX_REWARD_SPLIT;</span>
 527 |     | <span class='neutral'></span>
 528 |     | <span class='neutral'>        // we take the fee for all CDPs immediately which is scaled by index precision</span>
 529 |     | <span class='unexecuted'>        uint256 _deltaFeeSplit = deltaIndexFees * getSystemCollShares();</span>
 530 |     | <span class='unexecuted'>        uint256 _cachedAllStakes = totalStakes;</span>
 531 |     | <span class='neutral'>        // return the values to update the global fee accumulator</span>
 532 |     | <span class='unexecuted'>        uint256 _feeTaken = collateral.getSharesByPooledEth(_deltaFeeSplit) / DECIMAL_PRECISION;</span>
 533 |     | <span class='unexecuted'>        uint256 _deltaFeeSplitShare = (_feeTaken * DECIMAL_PRECISION) +</span>
 534 |     | <span class='unexecuted'>            systemStEthFeePerUnitIndexError;</span>
 535 |     | <span class='unexecuted'>        uint256 _deltaFeePerUnit = _deltaFeeSplitShare / _cachedAllStakes;</span>
 536 |     | <span class='unexecuted'>        uint256 _perUnitError = _deltaFeeSplitShare - (_deltaFeePerUnit * _cachedAllStakes);</span>
 537 |     | <span class='unexecuted'>        return (_feeTaken, _deltaFeePerUnit, _perUnitError);</span>
 538 |     | <span class='neutral'>    }</span>
 539 |     | <span class='neutral'></span>
 540 |     | <span class='neutral'>    // Take the cut from staking reward</span>
 541 |     | <span class='neutral'>    // and update global fee-per-unit accumulator</span>
 542 |     | <span class='unexecuted'>    function _takeSplitAndUpdateFeePerUnit(</span>
 543 |     | <span class='neutral'>        uint256 _feeTaken,</span>
 544 |     | <span class='neutral'>        uint256 _newPerUnit,</span>
 545 |     | <span class='neutral'>        uint256 _newErrorPerUnit</span>
 546 |     | <span class='unexecuted'>    ) internal {</span>
 547 |     | <span class='unexecuted'>        uint256 _oldPerUnit = systemStEthFeePerUnitIndex;</span>
 548 |     | <span class='neutral'></span>
 549 |     | <span class='unexecuted'>        systemStEthFeePerUnitIndex = _newPerUnit;</span>
 550 |     | <span class='unexecuted'>        systemStEthFeePerUnitIndexError = _newErrorPerUnit;</span>
 551 |     | <span class='neutral'></span>
 552 |     | <span class='unexecuted'>        require(activePool.getSystemCollShares() &gt; _feeTaken, &quot;CDPManager: fee split is too big&quot;);</span>
 553 |     | <span class='unexecuted'>        activePool.allocateSystemCollSharesToFeeRecipient(_feeTaken);</span>
 554 |     | <span class='neutral'></span>
 555 |     | <span class='unexecuted'>        emit CollateralFeePerUnitUpdated(_oldPerUnit, _newPerUnit, _feeTaken);</span>
 556 |     | <span class='neutral'>    }</span>
 557 |     | <span class='neutral'></span>
 558 |     | <span class='neutral'>    // Apply accumulated fee split distributed to the CDP</span>
 559 |     | <span class='neutral'>    // and update its accumulator tracker accordingly</span>
 560 |     | <span class='unexecuted'>    function _applyAccumulatedFeeSplit(</span>
 561 |     | <span class='neutral'>        bytes32 _cdpId,</span>
 562 |     | <span class='neutral'>        uint256 _newColl,</span>
 563 |     | <span class='neutral'>        uint256 _feeSplitDistributed,</span>
 564 |     | <span class='neutral'>        uint256 _oldPerUnitCdp,</span>
 565 |     | <span class='neutral'>        uint256 _systemStEthFeePerUnitIndex</span>
 566 |     | <span class='neutral'>    ) internal {</span>
 567 |     | <span class='neutral'>        // apply split fee to given CDP</span>
 568 |     | <span class='unexecuted'>        Cdps[_cdpId].coll = _newColl;</span>
 569 |     | <span class='neutral'></span>
 570 |     | <span class='unexecuted'>        emit CdpFeeSplitApplied(</span>
 571 |     | <span class='neutral'>            _cdpId,</span>
 572 |     | <span class='neutral'>            _oldPerUnitCdp,</span>
 573 |     | <span class='neutral'>            _systemStEthFeePerUnitIndex,</span>
 574 |     | <span class='neutral'>            _feeSplitDistributed,</span>
 575 |     | <span class='neutral'>            _newColl</span>
 576 |     | <span class='neutral'>        );</span>
 577 |     | <span class='neutral'>    }</span>
 578 |     | <span class='neutral'></span>
 579 |     | <span class='neutral'>    /// @notice Calculate the applied split fee(scaled by 1e18) and the resulting CDP collateral share after applied</span>
 580 |     | <span class='neutral'>    /// @param _cdpId The Cdp to which the calculated split fee is going to be applied</span>
 581 |     | <span class='neutral'>    /// @param _systemStEthFeePerUnitIndex The fee-per-stake-unit value to be used in fee split calculation, could be result of calcFeeUponStakingReward()</span>
 582 |     | <span class='neutral'>    /// @return _feeSplitDistributed The applied fee split to the specified Cdp (scaled up by 1e18)</span>
 583 |     | <span class='neutral'>    /// @return _cdpCol The new collateral share of the specified Cdp after fe split applied</span>
 584 |     | <span class='unexecuted'>    function getAccumulatedFeeSplitApplied(</span>
 585 |     | <span class='neutral'>        bytes32 _cdpId,</span>
 586 |     | <span class='neutral'>        uint256 _systemStEthFeePerUnitIndex</span>
 587 |     | <span class='unexecuted'>    ) public view returns (uint256, uint256) {</span>
 588 |     | <span class='unexecuted'>        uint256 _cdpStEthFeePerUnitIndex = cdpStEthFeePerUnitIndex[_cdpId];</span>
 589 |     | <span class='unexecuted'>        uint256 _cdpCol = Cdps[_cdpId].coll;</span>
 590 |     | <span class='neutral'></span>
 591 |     | <span class='unexecuted'>        if (</span>
 592 |     | <span class='unexecuted'>            _cdpStEthFeePerUnitIndex == 0 ||</span>
 593 |     | <span class='unexecuted'>            _cdpCol == 0 ||</span>
 594 |     | <span class='unexecuted'>            _cdpStEthFeePerUnitIndex == _systemStEthFeePerUnitIndex</span>
 595 |     | <span class='neutral'>        ) {</span>
 596 |     | <span class='unexecuted'>            return (0, _cdpCol);</span>
 597 |     | <span class='neutral'>        }</span>
 598 |     | <span class='neutral'></span>
 599 |     | <span class='unexecuted'>        uint256 _feeSplitDistributed = Cdps[_cdpId].stake *</span>
 600 |     | <span class='unexecuted'>            (_systemStEthFeePerUnitIndex - _cdpStEthFeePerUnitIndex);</span>
 601 |     | <span class='neutral'></span>
 602 |     | <span class='unexecuted'>        uint256 _scaledCdpColl = _cdpCol * DECIMAL_PRECISION;</span>
 603 |     | <span class='neutral'></span>
 604 |     | <span class='unexecuted'>        if (_scaledCdpColl &gt; _feeSplitDistributed) {</span>
 605 |     | <span class='unexecuted'>            return (</span>
 606 |     | <span class='unexecuted'>                _feeSplitDistributed,</span>
 607 |     | <span class='unexecuted'>                (_scaledCdpColl - _feeSplitDistributed) / DECIMAL_PRECISION</span>
 608 |     | <span class='neutral'>            );</span>
 609 |     | <span class='neutral'>        } else {</span>
 610 |     | <span class='neutral'>            // extreme unlikely case to skip fee split on this CDP to avoid revert</span>
 611 |     | <span class='unexecuted'>            return (0, _cdpCol);</span>
 612 |     | <span class='neutral'>        }</span>
 613 |     | <span class='neutral'>    }</span>
 614 |     | <span class='neutral'></span>
 615 |     | <span class='neutral'>    // -- Modifier functions --</span>
 616 |     | <span class='unexecuted'>    function _requireCdpIsActive(bytes32 _cdpId) internal view {</span>
 617 |     | <span class='unexecuted'>        require(Cdps[_cdpId].status == Status.active, &quot;CdpManager: Cdp does not exist or is closed&quot;);</span>
 618 |     | <span class='neutral'>    }</span>
 619 |     | <span class='neutral'></span>
 620 |     | <span class='unexecuted'>    function _requireMoreThanOneCdpInSystem(uint256 CdpOwnersArrayLength) internal view {</span>
 621 |     | <span class='unexecuted'>        require(</span>
 622 |     | <span class='unexecuted'>            CdpOwnersArrayLength &gt; 1 &amp;&amp; sortedCdps.getSize() &gt; 1,</span>
 623 |     | <span class='neutral'>            &quot;CdpManager: Only one cdp in the system&quot;</span>
 624 |     | <span class='neutral'>        );</span>
 625 |     | <span class='neutral'>    }</span>
 626 |     | <span class='neutral'></span>
 627 |     | <span class='unexecuted'>    function _requireCallerIsBorrowerOperations() internal view {</span>
 628 |     | <span class='unexecuted'>        require(</span>
 629 |     | <span class='unexecuted'>            msg.sender == borrowerOperationsAddress,</span>
 630 |     | <span class='neutral'>            &quot;CdpManager: Caller is not the BorrowerOperations contract&quot;</span>
 631 |     | <span class='neutral'>        );</span>
 632 |     | <span class='neutral'>    }</span>
 633 |     | <span class='neutral'></span>
 634 |     | <span class='neutral'>    // --- Helper functions ---</span>
 635 |     | <span class='neutral'></span>
 636 |     | <span class='neutral'>    /// @notice Return the Nominal Collateral Ratio (NICR) of the specified Cdp as &quot;cached view&quot; (maybe outdated).</span>
 637 |     | <span class='neutral'>    /// @dev Takes a cdp&#39;s pending coll and debt rewards from redistributions into account.</span>
 638 |     | <span class='neutral'>    /// @param _cdpId The CdpId whose NICR to be queried</span>
 639 |     | <span class='neutral'>    /// @return The Nominal Collateral Ratio (NICR) of the specified Cdp.</span>
 640 |     | <span class='neutral'>    /// @dev Use getSyncedNominalICR() instead if pending fee split and debt redistribution should be considered</span>
 641 |     | <span class='unexecuted'>    function getCachedNominalICR(bytes32 _cdpId) external view returns (uint256) {</span>
 642 |     | <span class='unexecuted'>        (uint256 currentEBTCDebt, uint256 currentCollShares) = getSyncedDebtAndCollShares(_cdpId);</span>
 643 |     | <span class='neutral'></span>
 644 |     | <span class='unexecuted'>        uint256 NICR = EbtcMath._computeNominalCR(currentCollShares, currentEBTCDebt);</span>
 645 |     | <span class='neutral'>        return NICR;</span>
 646 |     | <span class='neutral'>    }</span>
 647 |     | <span class='neutral'></span>
 648 |     | <span class='neutral'>    /// @notice Return the Nominal Collateral Ratio (NICR) of the specified Cdp.</span>
 649 |     | <span class='neutral'>    /// @dev Takes a cdp&#39;s pending coll and debt rewards as well as stETH Index into account.</span>
 650 |     | <span class='neutral'>    /// @param _cdpId The CdpId whose NICR to be queried</span>
 651 |     | <span class='neutral'>    /// @return The Nominal Collateral Ratio (NICR) of the specified Cdp with fee split and debt redistribution considered.</span>
 652 |     | <span class='unexecuted'>    function getSyncedNominalICR(bytes32 _cdpId) external view returns (uint256) {</span>
 653 |     | <span class='unexecuted'>        (uint256 _oldIndex, uint256 _newIndex) = _readStEthIndex();</span>
 654 |     | <span class='unexecuted'>        (, uint256 _newGlobalSplitIdx, ) = _calcSyncedGlobalAccounting(_newIndex, _oldIndex);</span>
 655 |     | <span class='unexecuted'>        (uint256 _newColl, uint256 _newDebt, , uint256 _pendingDebt, ) = _calcSyncedAccounting(</span>
 656 |     | <span class='unexecuted'>            _cdpId,</span>
 657 |     | <span class='unexecuted'>            cdpStEthFeePerUnitIndex[_cdpId],</span>
 658 |     | <span class='unexecuted'>            _newGlobalSplitIdx /// NOTE: This is latest index</span>
 659 |     | <span class='neutral'>        );</span>
 660 |     | <span class='neutral'></span>
 661 |     | <span class='unexecuted'>        uint256 NICR = EbtcMath._computeNominalCR(_newColl, _newDebt);</span>
 662 |     | <span class='neutral'>        return NICR;</span>
 663 |     | <span class='neutral'>    }</span>
 664 |     | <span class='neutral'></span>
 665 |     | <span class='neutral'>    /// @notice Return the Individual Collateral Ratio (ICR) of the specified Cdp as &quot;cached view&quot; (maybe outdated).</span>
 666 |     | <span class='neutral'>    /// @param _cdpId The CdpId whose ICR to be queried</span>
 667 |     | <span class='neutral'>    /// @return The Individual Collateral Ratio (ICR) of the specified Cdp.</span>
 668 |     | <span class='neutral'>    /// @dev Use getSyncedICR() instead if pending fee split and debt redistribution should be considered</span>
 669 |     | <span class='unexecuted'>    function getCachedICR(bytes32 _cdpId, uint256 _price) public view returns (uint256) {</span>
 670 |     | <span class='unexecuted'>        (uint256 currentEBTCDebt, uint256 currentCollShares) = getSyncedDebtAndCollShares(_cdpId);</span>
 671 |     | <span class='unexecuted'>        uint256 ICR = _calculateCR(currentCollShares, currentEBTCDebt, _price);</span>
 672 |     | <span class='neutral'>        return ICR;</span>
 673 |     | <span class='neutral'>    }</span>
 674 |     | <span class='neutral'></span>
 675 |     | <span class='unexecuted'>    function _calculateCR(</span>
 676 |     | <span class='neutral'>        uint256 currentCollShare,</span>
 677 |     | <span class='neutral'>        uint256 currentDebt,</span>
 678 |     | <span class='neutral'>        uint256 _price</span>
 679 |     | <span class='unexecuted'>    ) internal view returns (uint256) {</span>
 680 |     | <span class='unexecuted'>        uint256 _underlyingCollateral = collateral.getPooledEthByShares(currentCollShare);</span>
 681 |     | <span class='unexecuted'>        return EbtcMath._computeCR(_underlyingCollateral, currentDebt, _price);</span>
 682 |     | <span class='neutral'>    }</span>
 683 |     | <span class='neutral'></span>
 684 |     | <span class='neutral'>    /// @notice Return the pending extra debt assigned to the Cdp from liquidation redistribution, calcualted by Cdp&#39;s stake</span>
 685 |     | <span class='neutral'>    /// @param _cdpId The CdpId whose pending debt redistribution to be queried</span>
 686 |     | <span class='neutral'>    /// @return pendingEBTCDebtReward The pending debt redistribution of the specified Cdp.</span>
 687 |     | <span class='unexecuted'>    function getPendingRedistributedDebt(</span>
 688 |     | <span class='neutral'>        bytes32 _cdpId</span>
 689 |     | <span class='unexecuted'>    ) public view returns (uint256 pendingEBTCDebtReward) {</span>
 690 |     | <span class='unexecuted'>        (uint256 _pendingDebt, ) = _getPendingRedistributedDebt(_cdpId);</span>
 691 |     | <span class='neutral'>        return _pendingDebt;</span>
 692 |     | <span class='neutral'>    }</span>
 693 |     | <span class='neutral'></span>
 694 |     | <span class='neutral'>    /// @return Whether the debt redistribution tracking index of the specified Cdp is less than the global tracking one (meaning it might get pending debt redistribution)</span>
 695 |     | <span class='neutral'>    /// @param _cdpId The CdpId whose debt redistribution tracking index to be queried against the gloabl one</span>
 696 |     | <span class='unexecuted'>    function hasPendingRedistributedDebt(bytes32 _cdpId) public view returns (bool) {</span>
 697 |     | <span class='unexecuted'>        return _hasRedistributedDebt(_cdpId);</span>
 698 |     | <span class='neutral'>    }</span>
 699 |     | <span class='neutral'></span>
 700 |     | <span class='neutral'>    // Return the Cdps entire debt and coll struct</span>
 701 |     | <span class='unexecuted'>    function _getSyncedDebtAndCollShares(</span>
 702 |     | <span class='neutral'>        bytes32 _cdpId</span>
 703 |     | <span class='neutral'>    ) internal view returns (CdpDebtAndCollShares memory) {</span>
 704 |     | <span class='unexecuted'>        (uint256 entireDebt, uint256 entireColl) = getSyncedDebtAndCollShares(_cdpId);</span>
 705 |     | <span class='unexecuted'>        return CdpDebtAndCollShares(entireDebt, entireColl);</span>
 706 |     | <span class='neutral'>    }</span>
 707 |     | <span class='neutral'></span>
 708 |     | <span class='neutral'>    /// @notice Calculate the Cdps entire debt and coll, including pending debt redistributions and collateral reduction from split fee.</span>
 709 |     | <span class='neutral'>    /// @param _cdpId The CdpId to be queried</span>
 710 |     | <span class='neutral'>    /// @return debt The total debt value of the Cdp including debt redistribution considered</span>
 711 |     | <span class='neutral'>    /// @return coll The total collateral value of the Cdp including possible fee split considered</span>
 712 |     | <span class='neutral'>    /// @dev Should always use this as the first(default) choice for Cdp position size query</span>
 713 |     | <span class='unexecuted'>    function getSyncedDebtAndCollShares(</span>
 714 |     | <span class='neutral'>        bytes32 _cdpId</span>
 715 |     | <span class='unexecuted'>    ) public view returns (uint256 debt, uint256 coll) {</span>
 716 |     | <span class='unexecuted'>        (uint256 _newColl, uint256 _newDebt, , , ) = _calcSyncedAccounting(</span>
 717 |     | <span class='unexecuted'>            _cdpId,</span>
 718 |     | <span class='unexecuted'>            cdpStEthFeePerUnitIndex[_cdpId],</span>
 719 |     | <span class='unexecuted'>            systemStEthFeePerUnitIndex</span>
 720 |     | <span class='neutral'>        );</span>
 721 |     | <span class='neutral'>        coll = _newColl;</span>
 722 |     | <span class='neutral'>        debt = _newDebt;</span>
 723 |     | <span class='neutral'>    }</span>
 724 |     | <span class='neutral'></span>
 725 |     | <span class='neutral'>    /// @dev calculate pending global state change to be applied:</span>
 726 |     | <span class='neutral'>    /// @return split fee taken (if any) AND</span>
 727 |     | <span class='neutral'>    /// @return new split index per stake unit AND</span>
 728 |     | <span class='neutral'>    /// @return new split index error</span>
 729 |     | <span class='unexecuted'>    function _calcSyncedGlobalAccounting(</span>
 730 |     | <span class='neutral'>        uint256 _newIndex,</span>
 731 |     | <span class='neutral'>        uint256 _oldIndex</span>
 732 |     | <span class='unexecuted'>    ) internal view returns (uint256, uint256, uint256) {</span>
 733 |     | <span class='unexecuted'>        if (_newIndex &gt; _oldIndex &amp;&amp; totalStakes &gt; 0) {</span>
 734 |     | <span class='neutral'>            /// @audit-ok We don&#39;t take the fee if we had a negative rebase</span>
 735 |     | <span class='unexecuted'>            (</span>
 736 |     | <span class='unexecuted'>                uint256 _feeTaken,</span>
 737 |     | <span class='unexecuted'>                uint256 _deltaFeePerUnit,</span>
 738 |     | <span class='unexecuted'>                uint256 _perUnitError</span>
 739 |     | <span class='unexecuted'>            ) = calcFeeUponStakingReward(_newIndex, _oldIndex);</span>
 740 |     | <span class='neutral'></span>
 741 |     | <span class='neutral'>            // calculate new split per stake unit</span>
 742 |     | <span class='unexecuted'>            uint256 _newPerUnit = systemStEthFeePerUnitIndex + _deltaFeePerUnit;</span>
 743 |     | <span class='unexecuted'>            return (_feeTaken, _newPerUnit, _perUnitError);</span>
 744 |     | <span class='neutral'>        } else {</span>
 745 |     | <span class='unexecuted'>            return (0, systemStEthFeePerUnitIndex, systemStEthFeePerUnitIndexError);</span>
 746 |     | <span class='neutral'>        }</span>
 747 |     | <span class='neutral'>    }</span>
 748 |     | <span class='neutral'></span>
 749 |     | <span class='neutral'>    /// @dev calculate pending state change to be applied for given CDP and global split index(typically already synced):</span>
 750 |     | <span class='neutral'>    /// @return new CDP collateral share after pending change applied</span>
 751 |     | <span class='neutral'>    /// @return new CDP debt after pending change applied</span>
 752 |     | <span class='neutral'>    /// @return split fee applied to given CDP</span>
 753 |     | <span class='neutral'>    /// @return redistributed debt applied to given CDP</span>
 754 |     | <span class='neutral'>    /// @return delta between debt redistribution index of given CDP and global tracking index</span>
 755 |     | <span class='unexecuted'>    function _calcSyncedAccounting(</span>
 756 |     | <span class='neutral'>        bytes32 _cdpId,</span>
 757 |     | <span class='neutral'>        uint256 _cdpPerUnitIdx,</span>
 758 |     | <span class='neutral'>        uint256 _systemStEthFeePerUnitIndex</span>
 759 |     | <span class='unexecuted'>    ) internal view returns (uint256, uint256, uint256, uint256, uint256) {</span>
 760 |     | <span class='neutral'>        uint256 _feeSplitApplied;</span>
 761 |     | <span class='unexecuted'>        uint256 _newCollShare = Cdps[_cdpId].coll;</span>
 762 |     | <span class='neutral'></span>
 763 |     | <span class='neutral'>        // processing split fee to be applied</span>
 764 |     | <span class='unexecuted'>        if (_cdpPerUnitIdx != _systemStEthFeePerUnitIndex &amp;&amp; _cdpPerUnitIdx &gt; 0) {</span>
 765 |     | <span class='unexecuted'>            (</span>
 766 |     | <span class='unexecuted'>                uint256 _feeSplitDistributed,</span>
 767 |     | <span class='unexecuted'>                uint256 _newCollShareAfter</span>
 768 |     | <span class='unexecuted'>            ) = getAccumulatedFeeSplitApplied(_cdpId, _systemStEthFeePerUnitIndex);</span>
 769 |     | <span class='neutral'>            _feeSplitApplied = _feeSplitDistributed;</span>
 770 |     | <span class='neutral'>            _newCollShare = _newCollShareAfter;</span>
 771 |     | <span class='neutral'>        }</span>
 772 |     | <span class='neutral'></span>
 773 |     | <span class='neutral'>        // processing redistributed debt to be applied</span>
 774 |     | <span class='unexecuted'>        (</span>
 775 |     | <span class='unexecuted'>            uint256 _newDebt,</span>
 776 |     | <span class='unexecuted'>            uint256 pendingDebtRedistributed,</span>
 777 |     | <span class='unexecuted'>            uint256 _debtIndexDelta</span>
 778 |     | <span class='unexecuted'>        ) = _getSyncedCdpDebtAndRedistribution(_cdpId);</span>
 779 |     | <span class='neutral'></span>
 780 |     | <span class='neutral'>        return (</span>
 781 |     | <span class='unexecuted'>            _newCollShare,</span>
 782 |     | <span class='neutral'>            _newDebt,</span>
 783 |     | <span class='unexecuted'>            _feeSplitApplied,</span>
 784 |     | <span class='neutral'>            pendingDebtRedistributed,</span>
 785 |     | <span class='neutral'>            _debtIndexDelta</span>
 786 |     | <span class='neutral'>        );</span>
 787 |     | <span class='neutral'>    }</span>
 788 |     | <span class='neutral'></span>
 789 |     | <span class='neutral'>    /// @return CDP debt and pending redistribution from liquidation applied</span>
 790 |     | <span class='unexecuted'>    function _getSyncedCdpDebtAndRedistribution(</span>
 791 |     | <span class='neutral'>        bytes32 _cdpId</span>
 792 |     | <span class='unexecuted'>    ) internal view returns (uint256, uint256, uint256) {</span>
 793 |     | <span class='unexecuted'>        (uint256 pendingDebtRedistributed, uint256 _debtIndexDelta) = _getPendingRedistributedDebt(</span>
 794 |     | <span class='unexecuted'>            _cdpId</span>
 795 |     | <span class='neutral'>        );</span>
 796 |     | <span class='unexecuted'>        uint256 _newDebt = Cdps[_cdpId].debt;</span>
 797 |     | <span class='unexecuted'>        if (pendingDebtRedistributed &gt; 0) {</span>
 798 |     | <span class='unexecuted'>            _newDebt = _newDebt + pendingDebtRedistributed;</span>
 799 |     | <span class='neutral'>        }</span>
 800 |     | <span class='unexecuted'>        return (_newDebt, pendingDebtRedistributed, _debtIndexDelta);</span>
 801 |     | <span class='neutral'>    }</span>
 802 |     | <span class='neutral'></span>
 803 |     | <span class='neutral'>    /// @notice Calculate the Cdps entire debt, including pending debt redistributions.</span>
 804 |     | <span class='neutral'>    /// @param _cdpId The CdpId to be queried</span>
 805 |     | <span class='neutral'>    /// @return _newDebt The total debt value of the Cdp including debt redistribution considered</span>
 806 |     | <span class='neutral'>    /// @dev Should always use this as the first(default) choice for Cdp debt query</span>
 807 |     | <span class='unexecuted'>    function getSyncedCdpDebt(bytes32 _cdpId) public view returns (uint256) {</span>
 808 |     | <span class='unexecuted'>        (uint256 _newDebt, , ) = _getSyncedCdpDebtAndRedistribution(_cdpId);</span>
 809 |     | <span class='neutral'>        return _newDebt;</span>
 810 |     | <span class='neutral'>    }</span>
 811 |     | <span class='neutral'></span>
 812 |     | <span class='neutral'>    /// @notice Calculate the Cdps entire collateral, including pending fee split to be applied</span>
 813 |     | <span class='neutral'>    /// @param _cdpId The CdpId to be queried</span>
 814 |     | <span class='neutral'>    /// @return _newColl The total collateral value of the Cdp including fee split considered</span>
 815 |     | <span class='neutral'>    /// @dev Should always use this as the first(default) choice for Cdp collateral query</span>
 816 |     | <span class='unexecuted'>    function getSyncedCdpCollShares(bytes32 _cdpId) public view returns (uint256) {</span>
 817 |     | <span class='unexecuted'>        (uint256 _oldIndex, uint256 _newIndex) = _readStEthIndex();</span>
 818 |     | <span class='unexecuted'>        (, uint256 _newGlobalSplitIdx, ) = _calcSyncedGlobalAccounting(_newIndex, _oldIndex);</span>
 819 |     | <span class='unexecuted'>        (uint256 _newColl, , , , ) = _calcSyncedAccounting(</span>
 820 |     | <span class='unexecuted'>            _cdpId,</span>
 821 |     | <span class='unexecuted'>            cdpStEthFeePerUnitIndex[_cdpId],</span>
 822 |     | <span class='neutral'>            _newGlobalSplitIdx</span>
 823 |     | <span class='neutral'>        );</span>
 824 |     | <span class='neutral'>        return _newColl;</span>
 825 |     | <span class='neutral'>    }</span>
 826 |     | <span class='neutral'></span>
 827 |     | <span class='neutral'>    /// @notice Calculate the Cdps ICR, including pending debt distribution and fee split to be applied</span>
 828 |     | <span class='neutral'>    /// @param _cdpId The CdpId to be queried</span>
 829 |     | <span class='neutral'>    /// @param _price The ETH:eBTC price to be used in ICR calculation</span>
 830 |     | <span class='neutral'>    /// @return The ICR of the Cdp including debt distribution and fee split considered</span>
 831 |     | <span class='neutral'>    /// @dev Should always use this as the first(default) choice for Cdp ICR query</span>
 832 |     | <span class='unexecuted'>    function getSyncedICR(bytes32 _cdpId, uint256 _price) public view returns (uint256) {</span>
 833 |     | <span class='unexecuted'>        uint256 _debt = getSyncedCdpDebt(_cdpId);</span>
 834 |     | <span class='unexecuted'>        uint256 _collShare = getSyncedCdpCollShares(_cdpId);</span>
 835 |     | <span class='unexecuted'>        return _calculateCR(_collShare, _debt, _price);</span>
 836 |     | <span class='neutral'>    }</span>
 837 |     | <span class='neutral'></span>
 838 |     | <span class='neutral'>    /// @notice return system collateral share, including pending fee split to be taken</span>
 839 |     | <span class='unexecuted'>    function getSyncedSystemCollShares() public view returns (uint256) {</span>
 840 |     | <span class='unexecuted'>        (uint256 _oldIndex, uint256 _newIndex) = _readStEthIndex();</span>
 841 |     | <span class='unexecuted'>        (uint256 _feeTaken, , ) = _calcSyncedGlobalAccounting(_newIndex, _oldIndex);</span>
 842 |     | <span class='neutral'></span>
 843 |     | <span class='unexecuted'>        uint256 _systemCollShare = activePool.getSystemCollShares();</span>
 844 |     | <span class='unexecuted'>        if (_feeTaken &gt; 0) {</span>
 845 |     | <span class='unexecuted'>            _systemCollShare = _systemCollShare - _feeTaken;</span>
 846 |     | <span class='neutral'>        }</span>
 847 |     | <span class='unexecuted'>        return _systemCollShare;</span>
 848 |     | <span class='neutral'>    }</span>
 849 |     | <span class='neutral'></span>
 850 |     | <span class='neutral'>    /// @notice Calculate the TCR, including pending debt distribution and fee split to be taken</span>
 851 |     | <span class='neutral'>    /// @param _price The ETH:eBTC price to be used in TCR calculation</span>
 852 |     | <span class='neutral'>    /// @return The TCR of the eBTC system including debt distribution and fee split considered</span>
 853 |     | <span class='neutral'>    /// @dev Should always use this as the first(default) choice for TCR query</span>
 854 |     | <span class='unexecuted'>    function getSyncedTCR(uint256 _price) public view returns (uint256) {</span>
 855 |     | <span class='unexecuted'>        uint256 _systemCollShare = getSyncedSystemCollShares();</span>
 856 |     | <span class='unexecuted'>        uint256 _systemDebt = activePool.getSystemDebt();</span>
 857 |     | <span class='unexecuted'>        return _calculateCR(_systemCollShare, _systemDebt, _price);</span>
 858 |     | <span class='neutral'>    }</span>
 859 |     | <span class='neutral'></span>
 860 |     | <span class='neutral'>    /// @notice Get the count of active Cdps in the system</span>
 861 |     | <span class='neutral'>    /// @return The number of current active Cdps (not closed) in the system.</span>
 862 |     | <span class='unexecuted'>    function getActiveCdpsCount() public view override returns (uint256) {</span>
 863 |     | <span class='unexecuted'>        return sortedCdps.getSize();</span>
 864 |     | <span class='neutral'>    }</span>
 865 |     | <span class='neutral'></span>
 866 |     | <span class='neutral'>    /// @param icr The ICR of a Cdp to check if liquidatable</span>
 867 |     | <span class='neutral'>    /// @param tcr The TCR of the eBTC system used to determine if Recovery Mode is triggered</span>
 868 |     | <span class='neutral'>    /// @return whether the Cdp of specified icr is liquidatable with specified tcr</span>
 869 |     | <span class='neutral'>    /// @dev The flag will only be set to true if enough time has passed since Grace Period starts</span>
 870 |     | <span class='unexecuted'>    function canLiquidateRecoveryMode(uint256 icr, uint256 tcr) public view returns (bool) {</span>
 871 |     | <span class='unexecuted'>        return _checkICRAgainstTCR(icr, tcr) &amp;&amp; _recoveryModeGracePeriodPassed();</span>
 872 |     | <span class='neutral'>    }</span>
 873 |     | <span class='neutral'></span>
 874 |     | <span class='neutral'>    /// @dev Check if enough time has passed for grace period after enabled</span>
 875 |     | <span class='unexecuted'>    function _recoveryModeGracePeriodPassed() internal view returns (bool) {</span>
 876 |     | <span class='neutral'>        // we have waited enough</span>
 877 |     | <span class='unexecuted'>        uint128 cachedLastGracePeriodStartTimestamp = lastGracePeriodStartTimestamp;</span>
 878 |     | <span class='unexecuted'>        return</span>
 879 |     | <span class='unexecuted'>            cachedLastGracePeriodStartTimestamp != UNSET_TIMESTAMP &amp;&amp;</span>
 880 |     | <span class='unexecuted'>            block.timestamp &gt; cachedLastGracePeriodStartTimestamp + recoveryModeGracePeriodDuration;</span>
 881 |     | <span class='neutral'>    }</span>
 882 |     | <span class='neutral'>}</span>
 883 |     | <span class='neutral'></span>

</code>
<br />

<b>/mnt/c/Users/Lourens/Documents/Recon-Fuzz/collabs/ebtc/packages/contracts/contracts/CollSurplusPool.sol</b>
<code>
   1 |     | <span class='neutral'>// SPDX-License-Identifier: MIT</span>
   2 |     | <span class='neutral'></span>
   3 |     | <span class='neutral'>pragma solidity 0.8.17;</span>
   4 |     | <span class='neutral'></span>
   5 |     | <span class='neutral'>import &quot;./Interfaces/ICollSurplusPool.sol&quot;;</span>
   6 |     | <span class='neutral'>import &quot;./Dependencies/ICollateralToken.sol&quot;;</span>
   7 |     | <span class='neutral'>import &quot;./Dependencies/SafeERC20.sol&quot;;</span>
   8 |     | <span class='neutral'>import &quot;./Dependencies/ReentrancyGuard.sol&quot;;</span>
   9 |     | <span class='neutral'>import &quot;./Dependencies/AuthNoOwner.sol&quot;;</span>
  10 |     | <span class='neutral'>import &quot;./Interfaces/IActivePool.sol&quot;;</span>
  11 |     | <span class='neutral'></span>
  12 |     | <span class='neutral'>/// @notice CollSurplusPool holds stETH collateral for Cdp owner when redemption or liquidation happens</span>
  13 |     | <span class='neutral'>/// @notice only if there is a remaining portion of the closed Cdp for the owner to claim</span>
  14 |     | <span class='neutral'>/// @dev While an owner could have multiple different sized Cdps, the remaining surplus colateral from all of its closed Cdp</span>
  15 |     | <span class='neutral'>/// @dev is consolidated into one balance here</span>
  16 |     | <span class='unexecuted'>contract CollSurplusPool is ICollSurplusPool, ReentrancyGuard, AuthNoOwner {</span>
  17 |     | <span class='neutral'>    using SafeERC20 for IERC20;</span>
  18 |     | <span class='neutral'></span>
  19 |     | <span class='unexecuted'>    string public constant NAME = &quot;CollSurplusPool&quot;;</span>
  20 |     | <span class='neutral'></span>
  21 |     | <span class='unexecuted'>    address public immutable borrowerOperationsAddress;</span>
  22 |     | <span class='unexecuted'>    address public immutable cdpManagerAddress;</span>
  23 |     | <span class='unexecuted'>    address public immutable activePoolAddress;</span>
  24 |     | <span class='unexecuted'>    address public immutable feeRecipientAddress;</span>
  25 |     | <span class='unexecuted'>    ICollateralToken public immutable collateral;</span>
  26 |     | <span class='neutral'></span>
  27 |     | <span class='neutral'>    // deposited ether tracker</span>
  28 |     | <span class='neutral'>    uint256 internal totalSurplusCollShares;</span>
  29 |     | <span class='neutral'>    // Collateral surplus claimable by cdp owners</span>
  30 |     | <span class='neutral'>    mapping(address =&gt; uint256) internal balances;</span>
  31 |     | <span class='neutral'></span>
  32 |     | <span class='neutral'>    // --- Contract setters ---</span>
  33 |     | <span class='neutral'></span>
  34 |     | <span class='neutral'>    /**</span>
  35 |     | <span class='neutral'>     * @notice Sets the addresses of the contracts and renounces ownership</span>
  36 |     | <span class='neutral'>     * @dev One-time initialization function. Can only be called by the owner as a security measure. Ownership is renounced after the function is called.</span>
  37 |     | <span class='neutral'>     * @param _borrowerOperationsAddress The address of the BorrowerOperations</span>
  38 |     | <span class='neutral'>     * @param _cdpManagerAddress The address of the CDPManager</span>
  39 |     | <span class='neutral'>     * @param _activePoolAddress The address of the ActivePool</span>
  40 |     | <span class='neutral'>     * @param _collTokenAddress The address of the CollateralToken</span>
  41 |     | <span class='neutral'>     */</span>
  42 |     | <span class='unexecuted'>    constructor(</span>
  43 |     | <span class='neutral'>        address _borrowerOperationsAddress,</span>
  44 |     | <span class='neutral'>        address _cdpManagerAddress,</span>
  45 |     | <span class='neutral'>        address _activePoolAddress,</span>
  46 |     | <span class='neutral'>        address _collTokenAddress</span>
  47 |     | <span class='unexecuted'>    ) {</span>
  48 |     | <span class='unexecuted'>        borrowerOperationsAddress = _borrowerOperationsAddress;</span>
  49 |     | <span class='unexecuted'>        cdpManagerAddress = _cdpManagerAddress;</span>
  50 |     | <span class='unexecuted'>        activePoolAddress = _activePoolAddress;</span>
  51 |     | <span class='unexecuted'>        collateral = ICollateralToken(_collTokenAddress);</span>
  52 |     | <span class='unexecuted'>        feeRecipientAddress = IActivePool(activePoolAddress).feeRecipientAddress();</span>
  53 |     | <span class='neutral'></span>
  54 |     | <span class='unexecuted'>        address _authorityAddress = address(AuthNoOwner(cdpManagerAddress).authority());</span>
  55 |     | <span class='unexecuted'>        if (_authorityAddress != address(0)) {</span>
  56 |     | <span class='unexecuted'>            _initializeAuthority(_authorityAddress);</span>
  57 |     | <span class='neutral'>        }</span>
  58 |     | <span class='neutral'>    }</span>
  59 |     | <span class='neutral'></span>
  60 |     | <span class='neutral'>    /// @return The current total collateral surplus available in this pool</span>
  61 |     | <span class='unexecuted'>    function getTotalSurplusCollShares() external view override returns (uint256) {</span>
  62 |     | <span class='unexecuted'>        return totalSurplusCollShares;</span>
  63 |     | <span class='neutral'>    }</span>
  64 |     | <span class='neutral'></span>
  65 |     | <span class='neutral'>    /// @return The collateral surplus available for the specified owner _account</span>
  66 |     | <span class='neutral'>    /// @param _account The address of the owner whose surplus balance to be queried</span>
  67 |     | <span class='unexecuted'>    function getSurplusCollShares(address _account) external view override returns (uint256) {</span>
  68 |     | <span class='unexecuted'>        return balances[_account];</span>
  69 |     | <span class='neutral'>    }</span>
  70 |     | <span class='neutral'></span>
  71 |     | <span class='neutral'>    // --- Pool functionality ---</span>
  72 |     | <span class='neutral'></span>
  73 |     | <span class='neutral'>    /// @notice Increases the claimable surplus collateral shares for the specified account.</span>
  74 |     | <span class='neutral'>    /// @notice Internal permissioned system function, can track amounts added from collateral shares and liquidator reward shares separately for accounting purposes.</span>
  75 |     | <span class='neutral'>    /// @dev Only the CdpManager contract can call this function.</span>
  76 |     | <span class='neutral'>    /// @param _cdpId CdpId surplus collateral shares come from, for accounting purposes.</span>
  77 |     | <span class='neutral'>    /// @param _account The account to increase collateral surplus balance for.</span>
  78 |     | <span class='neutral'>    /// @param _collateralShares The number of collateral shares to be added to the owner&#39;s surplus balance, from Cdp collateral shares.</span>
  79 |     | <span class='neutral'>    /// @param _liquidatorRewardShares The number of collateral shares to be added to the owner&#39;s surplus balance, from liquidator reward shares.</span>
  80 |     | <span class='unexecuted'>    function increaseSurplusCollShares(</span>
  81 |     | <span class='neutral'>        bytes32 _cdpId,</span>
  82 |     | <span class='neutral'>        address _account,</span>
  83 |     | <span class='neutral'>        uint256 _collateralShares,</span>
  84 |     | <span class='neutral'>        uint256 _liquidatorRewardShares</span>
  85 |     | <span class='unexecuted'>    ) external override {</span>
  86 |     | <span class='unexecuted'>        _requireCallerIsCdpManager();</span>
  87 |     | <span class='neutral'></span>
  88 |     | <span class='unexecuted'>        uint256 _totalClaimableSurplusCollShares = balances[_account] +</span>
  89 |     | <span class='unexecuted'>            _collateralShares +</span>
  90 |     | <span class='unexecuted'>            _liquidatorRewardShares;</span>
  91 |     | <span class='unexecuted'>        balances[_account] = _totalClaimableSurplusCollShares;</span>
  92 |     | <span class='neutral'></span>
  93 |     | <span class='unexecuted'>        emit SurplusCollSharesAdded(</span>
  94 |     | <span class='unexecuted'>            _cdpId,</span>
  95 |     | <span class='neutral'>            _account,</span>
  96 |     | <span class='neutral'>            _totalClaimableSurplusCollShares,</span>
  97 |     | <span class='neutral'>            _collateralShares,</span>
  98 |     | <span class='neutral'>            _liquidatorRewardShares</span>
  99 |     | <span class='neutral'>        );</span>
 100 |     | <span class='neutral'>    }</span>
 101 |     | <span class='neutral'></span>
 102 |     | <span class='neutral'>    /// @notice Allow owner to claim all its surplus recorded in this pool</span>
 103 |     | <span class='neutral'>    /// @dev stETH token will be sent to _account address if any surplus exist</span>
 104 |     | <span class='neutral'>    /// @param _account The owner address whose surplus balance is to be claimed</span>
 105 |     | <span class='unexecuted'>    function claimSurplusCollShares(address _account) external override {</span>
 106 |     | <span class='unexecuted'>        _requireCallerIsBorrowerOperations();</span>
 107 |     | <span class='unexecuted'>        uint256 claimableColl = balances[_account];</span>
 108 |     | <span class='unexecuted'>        require(claimableColl &gt; 0, &quot;CollSurplusPool: No collateral available to claim&quot;);</span>
 109 |     | <span class='neutral'></span>
 110 |     | <span class='unexecuted'>        balances[_account] = 0;</span>
 111 |     | <span class='neutral'></span>
 112 |     | <span class='unexecuted'>        uint256 cachedTotalSurplusCollShares = totalSurplusCollShares;</span>
 113 |     | <span class='neutral'></span>
 114 |     | <span class='unexecuted'>        require(cachedTotalSurplusCollShares &gt;= claimableColl, &quot;!CollSurplusPoolBal&quot;);</span>
 115 |     | <span class='neutral'>        // Safe per the check above</span>
 116 |     | <span class='neutral'>        unchecked {</span>
 117 |     | <span class='unexecuted'>            totalSurplusCollShares = cachedTotalSurplusCollShares - claimableColl;</span>
 118 |     | <span class='neutral'>        }</span>
 119 |     | <span class='unexecuted'>        emit CollSharesTransferred(_account, claimableColl);</span>
 120 |     | <span class='neutral'></span>
 121 |     | <span class='neutral'>        // NOTE: No need for safe transfer if the collateral asset is standard. Make sure this is the case!</span>
 122 |     | <span class='unexecuted'>        collateral.transferShares(_account, claimableColl);</span>
 123 |     | <span class='neutral'>    }</span>
 124 |     | <span class='neutral'></span>
 125 |     | <span class='neutral'>    // --- &#39;require&#39; functions ---</span>
 126 |     | <span class='neutral'></span>
 127 |     | <span class='unexecuted'>    function _requireCallerIsBorrowerOperations() internal view {</span>
 128 |     | <span class='unexecuted'>        require(</span>
 129 |     | <span class='unexecuted'>            msg.sender == borrowerOperationsAddress,</span>
 130 |     | <span class='neutral'>            &quot;CollSurplusPool: Caller is not Borrower Operations&quot;</span>
 131 |     | <span class='neutral'>        );</span>
 132 |     | <span class='neutral'>    }</span>
 133 |     | <span class='neutral'></span>
 134 |     | <span class='unexecuted'>    function _requireCallerIsCdpManager() internal view {</span>
 135 |     | <span class='unexecuted'>        require(msg.sender == cdpManagerAddress, &quot;CollSurplusPool: Caller is not CdpManager&quot;);</span>
 136 |     | <span class='neutral'>    }</span>
 137 |     | <span class='neutral'></span>
 138 |     | <span class='unexecuted'>    function _requireCallerIsActivePool() internal view {</span>
 139 |     | <span class='unexecuted'>        require(msg.sender == activePoolAddress, &quot;CollSurplusPool: Caller is not Active Pool&quot;);</span>
 140 |     | <span class='neutral'>    }</span>
 141 |     | <span class='neutral'></span>
 142 |     | <span class='neutral'>    /// @notice Increase total collateral surplus balance by _value</span>
 143 |     | <span class='neutral'>    /// @param _value The surplus increase value</span>
 144 |     | <span class='neutral'>    /// @dev only ActivePool is allowed to call this function</span>
 145 |     | <span class='unexecuted'>    function increaseTotalSurplusCollShares(uint256 _value) external override {</span>
 146 |     | <span class='unexecuted'>        _requireCallerIsActivePool();</span>
 147 |     | <span class='unexecuted'>        totalSurplusCollShares = totalSurplusCollShares + _value;</span>
 148 |     | <span class='neutral'>    }</span>
 149 |     | <span class='neutral'></span>
 150 |     | <span class='neutral'>    // === Governed Functions === //</span>
 151 |     | <span class='neutral'></span>
 152 |     | <span class='neutral'>    /// @dev Function to move unintended dust that are not protected to fee recipient</span>
 153 |     | <span class='neutral'>    /// @notice moves given amount of given token (collateral is NOT allowed)</span>
 154 |     | <span class='neutral'>    /// @notice because recipient are fixed, this function is safe to be called by anyone</span>
 155 |     | <span class='neutral'>    /// @param token The token to be swept</span>
 156 |     | <span class='neutral'>    /// @param amount The token value to be swept</span>
 157 |     | <span class='unexecuted'>    function sweepToken(address token, uint256 amount) public nonReentrant requiresAuth {</span>
 158 |     | <span class='unexecuted'>        require(token != address(collateral), &quot;CollSurplusPool: Cannot Sweep Collateral&quot;);</span>
 159 |     | <span class='neutral'></span>
 160 |     | <span class='unexecuted'>        uint256 balance = IERC20(token).balanceOf(address(this));</span>
 161 |     | <span class='unexecuted'>        require(amount &lt;= balance, &quot;CollSurplusPool: Attempt to sweep more than balance&quot;);</span>
 162 |     | <span class='neutral'></span>
 163 |     | <span class='unexecuted'>        IERC20(token).safeTransfer(feeRecipientAddress, amount);</span>
 164 |     | <span class='neutral'></span>
 165 |     | <span class='unexecuted'>        emit SweepTokenSuccess(token, amount, feeRecipientAddress);</span>
 166 |     | <span class='neutral'>    }</span>
 167 |     | <span class='neutral'>}</span>
 168 |     | <span class='neutral'></span>

</code>
<br />

<b>/mnt/c/Users/Lourens/Documents/Recon-Fuzz/collabs/ebtc/packages/contracts/contracts/Dependencies/Address.sol</b>
<code>
   1 |     | <span class='neutral'>// SPDX-License-Identifier: MIT</span>
   2 |     | <span class='neutral'>// OpenZeppelin Contracts (last updated v4.8.0) (utils/Address.sol)</span>
   3 |     | <span class='neutral'></span>
   4 |     | <span class='neutral'>pragma solidity 0.8.17;</span>
   5 |     | <span class='neutral'></span>
   6 |     | <span class='neutral'>/**</span>
   7 |     | <span class='neutral'> * @dev Collection of functions related to the address type</span>
   8 |     | <span class='neutral'> */</span>
   9 |     | <span class='unexecuted'>library Address {</span>
  10 |     | <span class='neutral'>    /**</span>
  11 |     | <span class='neutral'>     * @dev Returns true if `account` is a contract.</span>
  12 |     | <span class='neutral'>     *</span>
  13 |     | <span class='neutral'>     * [IMPORTANT]</span>
  14 |     | <span class='neutral'>     * ====</span>
  15 |     | <span class='neutral'>     * It is unsafe to assume that an address for which this function returns</span>
  16 |     | <span class='neutral'>     * false is an externally-owned account (EOA) and not a contract.</span>
  17 |     | <span class='neutral'>     *</span>
  18 |     | <span class='neutral'>     * Among others, `isContract` will return false for the following</span>
  19 |     | <span class='neutral'>     * types of addresses:</span>
  20 |     | <span class='neutral'>     *</span>
  21 |     | <span class='neutral'>     *  - an externally-owned account</span>
  22 |     | <span class='neutral'>     *  - a contract in construction</span>
  23 |     | <span class='neutral'>     *  - an address where a contract will be created</span>
  24 |     | <span class='neutral'>     *  - an address where a contract lived, but was destroyed</span>
  25 |     | <span class='neutral'>     *</span>
  26 |     | <span class='neutral'>     * Furthermore, `isContract` will also return true if the target contract within</span>
  27 |     | <span class='neutral'>     * the same transaction is already scheduled for destruction by `SELFDESTRUCT`,</span>
  28 |     | <span class='neutral'>     * which only has an effect at the end of a transaction.</span>
  29 |     | <span class='neutral'>     * ====</span>
  30 |     | <span class='neutral'>     *</span>
  31 |     | <span class='neutral'>     * [IMPORTANT]</span>
  32 |     | <span class='neutral'>     * ====</span>
  33 |     | <span class='neutral'>     * You shouldn&#39;t rely on `isContract` to protect against flash loan attacks!</span>
  34 |     | <span class='neutral'>     *</span>
  35 |     | <span class='neutral'>     * Preventing calls from contracts is highly discouraged. It breaks composability, breaks support for smart wallets</span>
  36 |     | <span class='neutral'>     * like Gnosis Safe, and does not provide security since it can be circumvented by calling from a contract</span>
  37 |     | <span class='neutral'>     * constructor.</span>
  38 |     | <span class='neutral'>     * ====</span>
  39 |     | <span class='neutral'>     */</span>
  40 |     | <span class='neutral'>    function isContract(address account) internal view returns (bool) {</span>
  41 |     | <span class='neutral'>        // This method relies on extcodesize/address.code.length, which returns 0</span>
  42 |     | <span class='neutral'>        // for contracts in construction, since the code is only stored at the end</span>
  43 |     | <span class='neutral'>        // of the constructor execution.</span>
  44 |     | <span class='neutral'></span>
  45 |     | <span class='unexecuted'>        return account.code.length &gt; 0;</span>
  46 |     | <span class='neutral'>    }</span>
  47 |     | <span class='neutral'></span>
  48 |     | <span class='neutral'>    /**</span>
  49 |     | <span class='neutral'>     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`], but with</span>
  50 |     | <span class='neutral'>     * `errorMessage` as a fallback revert reason when `target` reverts.</span>
  51 |     | <span class='neutral'>     *</span>
  52 |     | <span class='neutral'>     * _Available since v3.1._</span>
  53 |     | <span class='neutral'>     */</span>
  54 |     | <span class='unexecuted'>    function functionCall(</span>
  55 |     | <span class='neutral'>        address target,</span>
  56 |     | <span class='neutral'>        bytes memory data,</span>
  57 |     | <span class='neutral'>        string memory errorMessage</span>
  58 |     | <span class='unexecuted'>    ) internal returns (bytes memory) {</span>
  59 |     | <span class='unexecuted'>        return functionCallWithValue(target, data, 0, errorMessage);</span>
  60 |     | <span class='neutral'>    }</span>
  61 |     | <span class='neutral'></span>
  62 |     | <span class='neutral'>    /**</span>
  63 |     | <span class='neutral'>     * @dev Same as {xref-Address-functionCallWithValue-address-bytes-uint256-}[`functionCallWithValue`], but</span>
  64 |     | <span class='neutral'>     * with `errorMessage` as a fallback revert reason when `target` reverts.</span>
  65 |     | <span class='neutral'>     *</span>
  66 |     | <span class='neutral'>     * _Available since v3.1._</span>
  67 |     | <span class='neutral'>     */</span>
  68 |     | <span class='unexecuted'>    function functionCallWithValue(</span>
  69 |     | <span class='neutral'>        address target,</span>
  70 |     | <span class='neutral'>        bytes memory data,</span>
  71 |     | <span class='neutral'>        uint256 value,</span>
  72 |     | <span class='neutral'>        string memory errorMessage</span>
  73 |     | <span class='unexecuted'>    ) internal returns (bytes memory) {</span>
  74 |     | <span class='unexecuted'>        require(address(this).balance &gt;= value, &quot;Address: insufficient balance for call&quot;);</span>
  75 |     | <span class='unexecuted'>        (bool success, bytes memory returndata) = target.call{value: value}(data);</span>
  76 |     | <span class='unexecuted'>        return verifyCallResultFromTarget(target, success, returndata, errorMessage);</span>
  77 |     | <span class='neutral'>    }</span>
  78 |     | <span class='neutral'></span>
  79 |     | <span class='neutral'>    /**</span>
  80 |     | <span class='neutral'>     * @dev Tool to verify that a low level call to smart-contract was successful, and revert (either by bubbling</span>
  81 |     | <span class='neutral'>     * the revert reason or using the provided one) in case of unsuccessful call or if target was not a contract.</span>
  82 |     | <span class='neutral'>     *</span>
  83 |     | <span class='neutral'>     * _Available since v4.8._</span>
  84 |     | <span class='neutral'>     */</span>
  85 |     | <span class='unexecuted'>    function verifyCallResultFromTarget(</span>
  86 |     | <span class='neutral'>        address target,</span>
  87 |     | <span class='neutral'>        bool success,</span>
  88 |     | <span class='neutral'>        bytes memory returndata,</span>
  89 |     | <span class='neutral'>        string memory errorMessage</span>
  90 |     | <span class='unexecuted'>    ) internal view returns (bytes memory) {</span>
  91 |     | <span class='unexecuted'>        if (success) {</span>
  92 |     | <span class='unexecuted'>            if (returndata.length == 0) {</span>
  93 |     | <span class='neutral'>                // only check isContract if the call was successful and the return data is empty</span>
  94 |     | <span class='neutral'>                // otherwise we already know that it was a contract</span>
  95 |     | <span class='unexecuted'>                require(isContract(target), &quot;Address: call to non-contract&quot;);</span>
  96 |     | <span class='neutral'>            }</span>
  97 |     | <span class='unexecuted'>            return returndata;</span>
  98 |     | <span class='neutral'>        } else {</span>
  99 |     | <span class='unexecuted'>            _revert(returndata, errorMessage);</span>
 100 |     | <span class='neutral'>        }</span>
 101 |     | <span class='neutral'>    }</span>
 102 |     | <span class='neutral'></span>
 103 |     | <span class='neutral'>    function _revert(bytes memory returndata, string memory errorMessage) private pure {</span>
 104 |     | <span class='neutral'>        // Look for revert reason and bubble it up if present</span>
 105 |     | <span class='unexecuted'>        if (returndata.length &gt; 0) {</span>
 106 |     | <span class='neutral'>            // The easiest way to bubble the revert reason is using memory via assembly</span>
 107 |     | <span class='neutral'>            /// @solidity memory-safe-assembly</span>
 108 |     | <span class='neutral'>            assembly {</span>
 109 |     | <span class='unexecuted'>                let returndata_size := mload(returndata)</span>
 110 |     | <span class='unexecuted'>                revert(add(32, returndata), returndata_size)</span>
 111 |     | <span class='neutral'>            }</span>
 112 |     | <span class='neutral'>        } else {</span>
 113 |     | <span class='unexecuted'>            revert(errorMessage);</span>
 114 |     | <span class='neutral'>        }</span>
 115 |     | <span class='neutral'>    }</span>
 116 |     | <span class='neutral'>}</span>
 117 |     | <span class='neutral'></span>

</code>
<br />

<b>/mnt/c/Users/Lourens/Documents/Recon-Fuzz/collabs/ebtc/packages/contracts/contracts/Dependencies/AggregatorV3Interface.sol</b>
<code>
  1 |     | <span class='neutral'>// SPDX-License-Identifier: MIT</span>
  2 |     | <span class='neutral'>// Code from https://github.com/smartcontractkit/chainlink/blob/master/evm-contracts/src/v0.6/interfaces/AggregatorV3Interface.sol</span>
  3 |     | <span class='neutral'></span>
  4 |     | <span class='neutral'>pragma solidity 0.8.17;</span>
  5 |     | <span class='neutral'></span>
  6 |     | <span class='neutral'>interface AggregatorV3Interface {</span>
  7 |     | <span class='neutral'>    function decimals() external view returns (uint8);</span>
  8 |     | <span class='neutral'></span>
  9 |     | <span class='neutral'>    function description() external view returns (string memory);</span>
 10 |     | <span class='neutral'></span>
 11 |     | <span class='neutral'>    function version() external view returns (uint256);</span>
 12 |     | <span class='neutral'></span>
 13 |     | <span class='neutral'>    // getRoundData and latestRoundData should both raise &quot;No data present&quot;</span>
 14 |     | <span class='neutral'>    // if they do not have data to report, instead of returning unset values</span>
 15 |     | <span class='neutral'>    // which could be misinterpreted as actual reported values.</span>
 16 |     | <span class='neutral'>    function getRoundData(</span>
 17 |     | <span class='neutral'>        uint80 _roundId</span>
 18 |     | <span class='neutral'>    )</span>
 19 |     | <span class='neutral'>        external</span>
 20 |     | <span class='neutral'>        view</span>
 21 |     | <span class='neutral'>        returns (</span>
 22 |     | <span class='neutral'>            uint80 roundId,</span>
 23 |     | <span class='neutral'>            int256 answer,</span>
 24 |     | <span class='neutral'>            uint256 startedAt,</span>
 25 |     | <span class='neutral'>            uint256 updatedAt,</span>
 26 |     | <span class='neutral'>            uint80 answeredInRound</span>
 27 |     | <span class='neutral'>        );</span>
 28 |     | <span class='neutral'></span>
 29 |     | <span class='neutral'>    function latestRoundData()</span>
 30 |     | <span class='neutral'>        external</span>
 31 |     | <span class='neutral'>        view</span>
 32 |     | <span class='neutral'>        returns (</span>
 33 |     | <span class='neutral'>            uint80 roundId,</span>
 34 |     | <span class='neutral'>            int256 answer,</span>
 35 |     | <span class='neutral'>            uint256 startedAt,</span>
 36 |     | <span class='neutral'>            uint256 updatedAt,</span>
 37 |     | <span class='neutral'>            uint80 answeredInRound</span>
 38 |     | <span class='neutral'>        );</span>
 39 |     | <span class='neutral'>}</span>
 40 |     | <span class='neutral'></span>

</code>
<br />

<b>/mnt/c/Users/Lourens/Documents/Recon-Fuzz/collabs/ebtc/packages/contracts/contracts/Dependencies/Auth.sol</b>
<code>
  1 |     | <span class='neutral'>// SPDX-License-Identifier: AGPL-3.0-only</span>
  2 |     | <span class='neutral'>pragma solidity 0.8.17;</span>
  3 |     | <span class='neutral'></span>
  4 |     | <span class='neutral'>import {Authority} from &quot;./Authority.sol&quot;;</span>
  5 |     | <span class='neutral'></span>
  6 |     | <span class='neutral'>/// @notice Provides a flexible and updatable auth pattern which is completely separate from application logic.</span>
  7 |     | <span class='neutral'>/// @author Solmate (https://github.com/transmissions11/solmate/blob/main/src/auth/Auth.sol)</span>
  8 |     | <span class='neutral'>/// @author Modified from Dappsys (https://github.com/dapphub/ds-auth/blob/master/src/auth.sol)</span>
  9 |     | <span class='neutral'>abstract contract Auth {</span>
 10 |     | <span class='neutral'>    event OwnershipTransferred(address indexed user, address indexed newOwner);</span>
 11 |     | <span class='neutral'></span>
 12 |     | <span class='neutral'>    event AuthorityUpdated(address indexed user, Authority indexed newAuthority);</span>
 13 |     | <span class='neutral'></span>
 14 |     | <span class='unexecuted'>    address public owner;</span>
 15 |     | <span class='neutral'></span>
 16 |     | <span class='unexecuted'>    Authority public authority;</span>
 17 |     | <span class='neutral'></span>
 18 |     | <span class='unexecuted'>    constructor(address _owner, Authority _authority) {</span>
 19 |     | <span class='unexecuted'>        owner = _owner;</span>
 20 |     | <span class='unexecuted'>        authority = _authority;</span>
 21 |     | <span class='neutral'></span>
 22 |     | <span class='unexecuted'>        emit OwnershipTransferred(msg.sender, _owner);</span>
 23 |     | <span class='unexecuted'>        emit AuthorityUpdated(msg.sender, _authority);</span>
 24 |     | <span class='neutral'>    }</span>
 25 |     | <span class='neutral'></span>
 26 |     | <span class='neutral'>    modifier requiresAuth() virtual {</span>
 27 |     | <span class='unexecuted'>        require(isAuthorized(msg.sender, msg.sig), &quot;Auth: UNAUTHORIZED&quot;);</span>
 28 |     | <span class='neutral'></span>
 29 |     | <span class='neutral'>        _;</span>
 30 |     | <span class='neutral'>    }</span>
 31 |     | <span class='neutral'></span>
 32 |     | <span class='unexecuted'>    function isAuthorized(address user, bytes4 functionSig) internal view virtual returns (bool) {</span>
 33 |     | <span class='unexecuted'>        Authority auth = authority; // Memoizing authority saves us a warm SLOAD, around 100 gas.</span>
 34 |     | <span class='neutral'></span>
 35 |     | <span class='neutral'>        // Checking if the caller is the owner only after calling the authority saves gas in most cases, but be</span>
 36 |     | <span class='neutral'>        // aware that this makes protected functions uncallable even to the owner if the authority is out of order.</span>
 37 |     | <span class='unexecuted'>        return</span>
 38 |     | <span class='unexecuted'>            (address(auth) != address(0) &amp;&amp; auth.canCall(user, address(this), functionSig)) ||</span>
 39 |     | <span class='unexecuted'>            user == owner;</span>
 40 |     | <span class='neutral'>    }</span>
 41 |     | <span class='neutral'></span>
 42 |     | <span class='unexecuted'>    function setAuthority(Authority newAuthority) public virtual {</span>
 43 |     | <span class='neutral'>        // We check if the caller is the owner first because we want to ensure they can</span>
 44 |     | <span class='neutral'>        // always swap out the authority even if it&#39;s reverting or using up a lot of gas.</span>
 45 |     | <span class='unexecuted'>        require(msg.sender == owner || authority.canCall(msg.sender, address(this), msg.sig));</span>
 46 |     | <span class='neutral'></span>
 47 |     | <span class='unexecuted'>        authority = newAuthority;</span>
 48 |     | <span class='neutral'></span>
 49 |     | <span class='unexecuted'>        emit AuthorityUpdated(msg.sender, newAuthority);</span>
 50 |     | <span class='neutral'>    }</span>
 51 |     | <span class='neutral'></span>
 52 |     | <span class='unexecuted'>    function transferOwnership(address newOwner) public virtual requiresAuth {</span>
 53 |     | <span class='unexecuted'>        owner = newOwner;</span>
 54 |     | <span class='neutral'></span>
 55 |     | <span class='unexecuted'>        emit OwnershipTransferred(msg.sender, newOwner);</span>
 56 |     | <span class='neutral'>    }</span>
 57 |     | <span class='neutral'>}</span>
 58 |     | <span class='neutral'></span>

</code>
<br />

<b>/mnt/c/Users/Lourens/Documents/Recon-Fuzz/collabs/ebtc/packages/contracts/contracts/Dependencies/AuthNoOwner.sol</b>
<code>
  1 |     | <span class='neutral'>// SPDX-License-Identifier: AGPL-3.0-only</span>
  2 |     | <span class='neutral'>pragma solidity 0.8.17;</span>
  3 |     | <span class='neutral'></span>
  4 |     | <span class='neutral'>import {Authority} from &quot;./Authority.sol&quot;;</span>
  5 |     | <span class='neutral'></span>
  6 |     | <span class='neutral'>/// @notice Provides a flexible and updatable auth pattern which is completely separate from application logic.</span>
  7 |     | <span class='neutral'>/// @author Modified by BadgerDAO to remove owner</span>
  8 |     | <span class='neutral'>/// @author Solmate (https://github.com/transmissions11/solmate/blob/main/src/auth/Auth.sol)</span>
  9 |     | <span class='neutral'>/// @author Modified from Dappsys (https://github.com/dapphub/ds-auth/blob/master/src/auth.sol)</span>
 10 |     | <span class='unexecuted'>contract AuthNoOwner {</span>
 11 |     | <span class='neutral'>    event AuthorityUpdated(address indexed user, Authority indexed newAuthority);</span>
 12 |     | <span class='neutral'></span>
 13 |     | <span class='neutral'>    Authority private _authority;</span>
 14 |     | <span class='neutral'>    bool private _authorityInitialized;</span>
 15 |     | <span class='neutral'></span>
 16 |     | <span class='neutral'>    modifier requiresAuth() virtual {</span>
 17 |     | <span class='unexecuted'>        require(isAuthorized(msg.sender, msg.sig), &quot;Auth: UNAUTHORIZED&quot;);</span>
 18 |     | <span class='neutral'></span>
 19 |     | <span class='neutral'>        _;</span>
 20 |     | <span class='neutral'>    }</span>
 21 |     | <span class='neutral'></span>
 22 |     | <span class='unexecuted'>    function authority() public view returns (Authority) {</span>
 23 |     | <span class='unexecuted'>        return _authority;</span>
 24 |     | <span class='neutral'>    }</span>
 25 |     | <span class='neutral'></span>
 26 |     | <span class='unexecuted'>    function authorityInitialized() public view returns (bool) {</span>
 27 |     | <span class='unexecuted'>        return _authorityInitialized;</span>
 28 |     | <span class='neutral'>    }</span>
 29 |     | <span class='neutral'></span>
 30 |     | <span class='unexecuted'>    function isAuthorized(address user, bytes4 functionSig) internal view virtual returns (bool) {</span>
 31 |     | <span class='unexecuted'>        Authority auth = _authority; // Memoizing authority saves us a warm SLOAD, around 100 gas.</span>
 32 |     | <span class='neutral'></span>
 33 |     | <span class='neutral'>        // Checking if the caller is the owner only after calling the authority saves gas in most cases, but be</span>
 34 |     | <span class='neutral'>        // aware that this makes protected functions uncallable even to the owner if the authority is out of order.</span>
 35 |     | <span class='unexecuted'>        return (address(auth) != address(0) &amp;&amp; auth.canCall(user, address(this), functionSig));</span>
 36 |     | <span class='neutral'>    }</span>
 37 |     | <span class='neutral'></span>
 38 |     | <span class='neutral'>    /// @notice Changed constructor to initialize to allow flexiblity of constructor vs initializer use</span>
 39 |     | <span class='neutral'>    /// @notice sets authorityInitiailzed flag to ensure only one use of</span>
 40 |     | <span class='unexecuted'>    function _initializeAuthority(address newAuthority) internal {</span>
 41 |     | <span class='unexecuted'>        require(address(_authority) == address(0), &quot;Auth: authority is non-zero&quot;);</span>
 42 |     | <span class='unexecuted'>        require(!_authorityInitialized, &quot;Auth: authority already initialized&quot;);</span>
 43 |     | <span class='neutral'></span>
 44 |     | <span class='unexecuted'>        _authority = Authority(newAuthority);</span>
 45 |     | <span class='unexecuted'>        _authorityInitialized = true;</span>
 46 |     | <span class='neutral'></span>
 47 |     | <span class='unexecuted'>        emit AuthorityUpdated(address(this), Authority(newAuthority));</span>
 48 |     | <span class='neutral'>    }</span>
 49 |     | <span class='neutral'>}</span>
 50 |     | <span class='neutral'></span>

</code>
<br />

<b>/mnt/c/Users/Lourens/Documents/Recon-Fuzz/collabs/ebtc/packages/contracts/contracts/Dependencies/Authority.sol</b>
<code>
  1 |     | <span class='neutral'>// SPDX-License-Identifier: AGPL-3.0-only</span>
  2 |     | <span class='neutral'>pragma solidity 0.8.17;</span>
  3 |     | <span class='neutral'></span>
  4 |     | <span class='neutral'>/// @notice A generic interface for a contract which provides authorization data to an Auth instance.</span>
  5 |     | <span class='neutral'>/// @author Solmate (https://github.com/transmissions11/solmate/blob/main/src/auth/Auth.sol)</span>
  6 |     | <span class='neutral'>/// @author Modified from Dappsys (https://github.com/dapphub/ds-auth/blob/master/src/auth.sol)</span>
  7 |     | <span class='neutral'>interface Authority {</span>
  8 |     | <span class='neutral'>    function canCall(address user, address target, bytes4 functionSig) external view returns (bool);</span>
  9 |     | <span class='neutral'>}</span>
 10 |     | <span class='neutral'></span>

</code>
<br />

<b>/mnt/c/Users/Lourens/Documents/Recon-Fuzz/collabs/ebtc/packages/contracts/contracts/Dependencies/BaseMath.sol</b>
<code>
 1 |     | <span class='neutral'>// SPDX-License-Identifier: MIT</span>
 2 |     | <span class='neutral'>pragma solidity 0.8.17;</span>
 3 |     | <span class='neutral'></span>
 4 |     | <span class='unexecuted'>contract BaseMath {</span>
 5 |     | <span class='unexecuted'>    uint256 public constant DECIMAL_PRECISION = 1e18;</span>
 6 |     | <span class='neutral'>}</span>
 7 |     | <span class='neutral'></span>

</code>
<br />

<b>/mnt/c/Users/Lourens/Documents/Recon-Fuzz/collabs/ebtc/packages/contracts/contracts/Dependencies/Context.sol</b>
<code>
  1 |     | <span class='neutral'>// SPDX-License-Identifier: MIT</span>
  2 |     | <span class='neutral'>// OpenZeppelin Contracts v4.4.1 (utils/Context.sol)</span>
  3 |     | <span class='neutral'></span>
  4 |     | <span class='neutral'>pragma solidity 0.8.17;</span>
  5 |     | <span class='neutral'></span>
  6 |     | <span class='neutral'>/**</span>
  7 |     | <span class='neutral'> * @dev Provides information about the current execution context, including the</span>
  8 |     | <span class='neutral'> * sender of the transaction and its data. While these are generally available</span>
  9 |     | <span class='neutral'> * via msg.sender and msg.data, they should not be accessed in such a direct</span>
 10 |     | <span class='neutral'> * manner, since when dealing with meta-transactions the account sending and</span>
 11 |     | <span class='neutral'> * paying for execution may not be the actual sender (as far as an application</span>
 12 |     | <span class='neutral'> * is concerned).</span>
 13 |     | <span class='neutral'> *</span>
 14 |     | <span class='neutral'> * This contract is only required for intermediate, library-like contracts.</span>
 15 |     | <span class='neutral'> */</span>
 16 |     | <span class='neutral'>abstract contract Context {</span>
 17 |     | <span class='neutral'>    function _msgSender() internal view virtual returns (address) {</span>
 18 |     | <span class='unexecuted'>        return msg.sender;</span>
 19 |     | <span class='neutral'>    }</span>
 20 |     | <span class='neutral'></span>
 21 |     | <span class='neutral'>    function _msgData() internal view virtual returns (bytes calldata) {</span>
 22 |     | <span class='neutral'>        return msg.data;</span>
 23 |     | <span class='neutral'>    }</span>
 24 |     | <span class='neutral'>}</span>
 25 |     | <span class='neutral'></span>

</code>
<br />

<b>/mnt/c/Users/Lourens/Documents/Recon-Fuzz/collabs/ebtc/packages/contracts/contracts/Dependencies/Create3.sol</b>
<code>
   1 |     | <span class='neutral'>//SPDX-License-Identifier: Unlicense</span>
   2 |     | <span class='neutral'>pragma solidity 0.8.17;</span>
   3 |     | <span class='neutral'></span>
   4 |     | <span class='neutral'>/**</span>
   5 |     | <span class='neutral'>  @title A library for deploying contracts EIP-3171 style.</span>
   6 |     | <span class='neutral'>  @author Agustin Aguilar &lt;aa@horizon.io&gt;</span>
   7 |     | <span class='neutral'>*/</span>
   8 |     | <span class='unexecuted'>library Create3 {</span>
   9 |     | <span class='neutral'>    error ErrorCreatingProxy();</span>
  10 |     | <span class='neutral'>    error ErrorCreatingContract();</span>
  11 |     | <span class='neutral'>    error TargetAlreadyExists();</span>
  12 |     | <span class='neutral'></span>
  13 |     | <span class='neutral'>    /**</span>
  14 |     | <span class='neutral'>    @notice The bytecode for a contract that proxies the creation of another contract</span>
  15 |     | <span class='neutral'>    @dev If this code is deployed using CREATE2 it can be used to decouple `creationCode` from the child contract address</span>
  16 |     | <span class='neutral'></span>
  17 |     | <span class='neutral'>  0x67363d3d37363d34f03d5260086018f3:</span>
  18 |     | <span class='neutral'>      0x00  0x67  0x67XXXXXXXXXXXXXXXX  PUSH8 bytecode  0x363d3d37363d34f0</span>
  19 |     | <span class='neutral'>      0x01  0x3d  0x3d                  RETURNDATASIZE  0 0x363d3d37363d34f0</span>
  20 |     | <span class='neutral'>      0x02  0x52  0x52                  MSTORE</span>
  21 |     | <span class='neutral'>      0x03  0x60  0x6008                PUSH1 08        8</span>
  22 |     | <span class='neutral'>      0x04  0x60  0x6018                PUSH1 18        24 8</span>
  23 |     | <span class='neutral'>      0x05  0xf3  0xf3                  RETURN</span>
  24 |     | <span class='neutral'></span>
  25 |     | <span class='neutral'>  0x363d3d37363d34f0:</span>
  26 |     | <span class='neutral'>      0x00  0x36  0x36                  CALLDATASIZE    cds</span>
  27 |     | <span class='neutral'>      0x01  0x3d  0x3d                  RETURNDATASIZE  0 cds</span>
  28 |     | <span class='neutral'>      0x02  0x3d  0x3d                  RETURNDATASIZE  0 0 cds</span>
  29 |     | <span class='neutral'>      0x03  0x37  0x37                  CALLDATACOPY</span>
  30 |     | <span class='neutral'>      0x04  0x36  0x36                  CALLDATASIZE    cds</span>
  31 |     | <span class='neutral'>      0x05  0x3d  0x3d                  RETURNDATASIZE  0 cds</span>
  32 |     | <span class='neutral'>      0x06  0x34  0x34                  CALLVALUE       val 0 cds</span>
  33 |     | <span class='neutral'>      0x07  0xf0  0xf0                  CREATE          addr</span>
  34 |     | <span class='neutral'>  */</span>
  35 |     | <span class='neutral'></span>
  36 |     | <span class='neutral'>    bytes internal constant PROXY_CHILD_BYTECODE =</span>
  37 |     | <span class='neutral'>        hex&quot;67_36_3d_3d_37_36_3d_34_f0_3d_52_60_08_60_18_f3&quot;;</span>
  38 |     | <span class='neutral'></span>
  39 |     | <span class='neutral'>    //                        KECCAK256_PROXY_CHILD_BYTECODE = keccak256(PROXY_CHILD_BYTECODE);</span>
  40 |     | <span class='neutral'>    bytes32 internal constant KECCAK256_PROXY_CHILD_BYTECODE =</span>
  41 |     | <span class='unexecuted'>        0x21c35dbe1b344a2488cf3321d6ce542f8e9f305544ff09e4993a62319a497c1f;</span>
  42 |     | <span class='neutral'></span>
  43 |     | <span class='neutral'>    /**</span>
  44 |     | <span class='neutral'>    @notice Returns the size of the code on a given address</span>
  45 |     | <span class='neutral'>    @param _addr Address that may or may not contain code</span>
  46 |     | <span class='neutral'>    @return size of the code on the given `_addr`</span>
  47 |     | <span class='neutral'>  */</span>
  48 |     | <span class='neutral'>    function codeSize(address _addr) internal view returns (uint256 size) {</span>
  49 |     | <span class='neutral'>        assembly {</span>
  50 |     | <span class='unexecuted'>            size := extcodesize(_addr)</span>
  51 |     | <span class='neutral'>        }</span>
  52 |     | <span class='neutral'>    }</span>
  53 |     | <span class='neutral'></span>
  54 |     | <span class='neutral'>    /**</span>
  55 |     | <span class='neutral'>    @notice Creates a new contract with given `_creationCode` and `_salt`</span>
  56 |     | <span class='neutral'>    @param _salt Salt of the contract creation, resulting address will be derivated from this value only</span>
  57 |     | <span class='neutral'>    @param _creationCode Creation code (constructor) of the contract to be deployed, this value doesn&#39;t affect the resulting address</span>
  58 |     | <span class='neutral'>    @return addr of the deployed contract, reverts on error</span>
  59 |     | <span class='neutral'>  */</span>
  60 |     | <span class='unexecuted'>    function create3(bytes32 _salt, bytes memory _creationCode) internal returns (address addr) {</span>
  61 |     | <span class='unexecuted'>        return create3(_salt, _creationCode, 0);</span>
  62 |     | <span class='neutral'>    }</span>
  63 |     | <span class='neutral'></span>
  64 |     | <span class='neutral'>    /**</span>
  65 |     | <span class='neutral'>    @notice Creates a new contract with given `_creationCode` and `_salt`</span>
  66 |     | <span class='neutral'>    @param _salt Salt of the contract creation, resulting address will be derivated from this value only</span>
  67 |     | <span class='neutral'>    @param _creationCode Creation code (constructor) of the contract to be deployed, this value doesn&#39;t affect the resulting address</span>
  68 |     | <span class='neutral'>    @param _value In WEI of ETH to be forwarded to child contract</span>
  69 |     | <span class='neutral'>    @return addr of the deployed contract, reverts on error</span>
  70 |     | <span class='neutral'>  */</span>
  71 |     | <span class='unexecuted'>    function create3(</span>
  72 |     | <span class='neutral'>        bytes32 _salt,</span>
  73 |     | <span class='neutral'>        bytes memory _creationCode,</span>
  74 |     | <span class='neutral'>        uint256 _value</span>
  75 |     | <span class='unexecuted'>    ) internal returns (address addr) {</span>
  76 |     | <span class='neutral'>        // Creation code</span>
  77 |     | <span class='unexecuted'>        bytes memory creationCode = PROXY_CHILD_BYTECODE;</span>
  78 |     | <span class='neutral'></span>
  79 |     | <span class='neutral'>        // Get target final address</span>
  80 |     | <span class='unexecuted'>        addr = addressOf(_salt);</span>
  81 |     | <span class='unexecuted'>        if (codeSize(addr) != 0) revert TargetAlreadyExists();</span>
  82 |     | <span class='neutral'></span>
  83 |     | <span class='neutral'>        // Create CREATE2 proxy</span>
  84 |     | <span class='unexecuted'>        address proxy;</span>
  85 |     | <span class='neutral'>        assembly {</span>
  86 |     | <span class='unexecuted'>            proxy := create2(0, add(creationCode, 32), mload(creationCode), _salt)</span>
  87 |     | <span class='neutral'>        }</span>
  88 |     | <span class='unexecuted'>        if (proxy == address(0)) revert ErrorCreatingProxy();</span>
  89 |     | <span class='neutral'></span>
  90 |     | <span class='neutral'>        // Call proxy with final init code</span>
  91 |     | <span class='unexecuted'>        (bool success, ) = proxy.call{value: _value}(_creationCode);</span>
  92 |     | <span class='unexecuted'>        if (!success || codeSize(addr) == 0) revert ErrorCreatingContract();</span>
  93 |     | <span class='neutral'>    }</span>
  94 |     | <span class='neutral'></span>
  95 |     | <span class='neutral'>    /**</span>
  96 |     | <span class='neutral'>    @notice Computes the resulting address of a contract deployed using address(this) and the given `_salt`</span>
  97 |     | <span class='neutral'>    @param _salt Salt of the contract creation, resulting address will be derivated from this value only</span>
  98 |     | <span class='neutral'>    @return addr of the deployed contract, reverts on error</span>
  99 |     | <span class='neutral'></span>
 100 |     | <span class='neutral'>    @dev The address creation formula is: keccak256(rlp([keccak256(0xff ++ address(this) ++ _salt ++ keccak256(childBytecode))[12:], 0x01]))</span>
 101 |     | <span class='neutral'>  */</span>
 102 |     | <span class='unexecuted'>    function addressOf(bytes32 _salt) internal view returns (address) {</span>
 103 |     | <span class='neutral'>        address proxy = address(</span>
 104 |     | <span class='neutral'>            uint160(</span>
 105 |     | <span class='neutral'>                uint256(</span>
 106 |     | <span class='unexecuted'>                    keccak256(</span>
 107 |     | <span class='unexecuted'>                        abi.encodePacked(</span>
 108 |     | <span class='neutral'>                            hex&quot;ff&quot;,</span>
 109 |     | <span class='unexecuted'>                            address(this),</span>
 110 |     | <span class='neutral'>                            _salt,</span>
 111 |     | <span class='neutral'>                            KECCAK256_PROXY_CHILD_BYTECODE</span>
 112 |     | <span class='neutral'>                        )</span>
 113 |     | <span class='neutral'>                    )</span>
 114 |     | <span class='neutral'>                )</span>
 115 |     | <span class='neutral'>            )</span>
 116 |     | <span class='neutral'>        );</span>
 117 |     | <span class='neutral'></span>
 118 |     | <span class='unexecuted'>        return address(uint160(uint256(keccak256(abi.encodePacked(hex&quot;d6_94&quot;, proxy, hex&quot;01&quot;)))));</span>
 119 |     | <span class='neutral'>    }</span>
 120 |     | <span class='neutral'>}</span>
 121 |     | <span class='neutral'></span>

</code>
<br />

<b>/mnt/c/Users/Lourens/Documents/Recon-Fuzz/collabs/ebtc/packages/contracts/contracts/Dependencies/ERC3156FlashLender.sol</b>
<code>
  1 |     | <span class='neutral'>// SPDX-License-Identifier: MIT</span>
  2 |     | <span class='neutral'></span>
  3 |     | <span class='neutral'>pragma solidity 0.8.17;</span>
  4 |     | <span class='neutral'></span>
  5 |     | <span class='neutral'>import &quot;../Interfaces/IERC3156FlashLender.sol&quot;;</span>
  6 |     | <span class='neutral'>import &quot;../Interfaces/IWETH.sol&quot;;</span>
  7 |     | <span class='neutral'></span>
  8 |     | <span class='neutral'>abstract contract ERC3156FlashLender is IERC3156FlashLender {</span>
  9 |     | <span class='unexecuted'>    uint256 public constant MAX_BPS = 10_000;</span>
 10 |     | <span class='unexecuted'>    uint256 public constant MAX_FEE_BPS = 1_000; // 10%</span>
 11 |     | <span class='unexecuted'>    bytes32 public constant FLASH_SUCCESS_VALUE = keccak256(&quot;ERC3156FlashBorrower.onFlashLoan&quot;);</span>
 12 |     | <span class='neutral'></span>
 13 |     | <span class='neutral'>    // Functions to modify these variables must be included in impelemnting contracts if desired</span>
 14 |     | <span class='unexecuted'>    uint16 public feeBps = 3; // may be subject to future adjustments through protocol governance</span>
 15 |     | <span class='unexecuted'>    bool public flashLoansPaused;</span>
 16 |     | <span class='neutral'>}</span>
 17 |     | <span class='neutral'></span>

</code>
<br />

<b>/mnt/c/Users/Lourens/Documents/Recon-Fuzz/collabs/ebtc/packages/contracts/contracts/Dependencies/EbtcBase.sol</b>
<code>
   1 |     | <span class='neutral'>// SPDX-License-Identifier: MIT</span>
   2 |     | <span class='neutral'></span>
   3 |     | <span class='neutral'>pragma solidity 0.8.17;</span>
   4 |     | <span class='neutral'></span>
   5 |     | <span class='neutral'>import &quot;./BaseMath.sol&quot;;</span>
   6 |     | <span class='neutral'>import &quot;./EbtcMath.sol&quot;;</span>
   7 |     | <span class='neutral'>import &quot;../Interfaces/IActivePool.sol&quot;;</span>
   8 |     | <span class='neutral'>import &quot;../Interfaces/IPriceFeed.sol&quot;;</span>
   9 |     | <span class='neutral'>import &quot;../Interfaces/IEbtcBase.sol&quot;;</span>
  10 |     | <span class='neutral'>import &quot;../Dependencies/ICollateralToken.sol&quot;;</span>
  11 |     | <span class='neutral'></span>
  12 |     | <span class='neutral'>/*</span>
  13 |     | <span class='neutral'> * Base contract for CdpManager, BorrowerOperations. Contains global system constants and</span>
  14 |     | <span class='neutral'> * common functions.</span>
  15 |     | <span class='neutral'> */</span>
  16 |     | <span class='unexecuted'>contract EbtcBase is BaseMath, IEbtcBase {</span>
  17 |     | <span class='neutral'>    // Collateral Ratio applied for Liquidation Incentive</span>
  18 |     | <span class='neutral'>    // i.e., liquidator repay $1 worth of debt to get back $1.03 worth of collateral</span>
  19 |     | <span class='unexecuted'>    uint256 public constant LICR = 1030000000000000000; // 103%</span>
  20 |     | <span class='neutral'></span>
  21 |     | <span class='neutral'>    // Minimum collateral ratio for individual cdps</span>
  22 | *   | <span class='executed'>    uint256 public constant MCR = 1100000000000000000; // 110%</span>
  23 |     | <span class='neutral'></span>
  24 |     | <span class='neutral'>    // Critical system collateral ratio. If the system&#39;s total collateral ratio (TCR) falls below the CCR, Recovery Mode is triggered.</span>
  25 | *   | <span class='executed'>    uint256 public constant CCR = 1250000000000000000; // 125%</span>
  26 |     | <span class='neutral'></span>
  27 |     | <span class='neutral'>    // Amount of stETH collateral to be locked in active pool on opening cdps</span>
  28 |     | <span class='unexecuted'>    uint256 public constant LIQUIDATOR_REWARD = 2e17;</span>
  29 |     | <span class='neutral'></span>
  30 |     | <span class='neutral'>    // Minimum amount of stETH collateral a CDP must have</span>
  31 |     | <span class='unexecuted'>    uint256 public constant MIN_NET_STETH_BALANCE = 2e18;</span>
  32 |     | <span class='neutral'></span>
  33 |     | <span class='unexecuted'>    uint256 public constant PERCENT_DIVISOR = 200; // dividing by 200 yields 0.5%</span>
  34 |     | <span class='neutral'></span>
  35 |     | <span class='unexecuted'>    uint256 public constant BORROWING_FEE_FLOOR = 0; // 0.5%</span>
  36 |     | <span class='neutral'></span>
  37 |     | <span class='unexecuted'>    uint256 public constant STAKING_REWARD_SPLIT = 5_000; // taking 50% cut from staking reward</span>
  38 |     | <span class='neutral'></span>
  39 |     | <span class='unexecuted'>    uint256 public constant MAX_REWARD_SPLIT = 10_000;</span>
  40 |     | <span class='neutral'></span>
  41 |     | <span class='unexecuted'>    uint256 public constant MIN_CHANGE = 1000;</span>
  42 |     | <span class='neutral'></span>
  43 |     | <span class='unexecuted'>    IActivePool public immutable activePool;</span>
  44 |     | <span class='neutral'></span>
  45 |     | <span class='unexecuted'>    IPriceFeed public immutable override priceFeed;</span>
  46 |     | <span class='neutral'></span>
  47 |     | <span class='neutral'>    // the only collateral token allowed in CDP</span>
  48 |     | <span class='unexecuted'>    ICollateralToken public immutable collateral;</span>
  49 |     | <span class='neutral'></span>
  50 |     | <span class='neutral'>    /// @notice Initializes the contract with the provided addresses</span>
  51 |     | <span class='neutral'>    /// @param _activePoolAddress The address of the ActivePool contract</span>
  52 |     | <span class='neutral'>    /// @param _priceFeedAddress The address of the PriceFeed contract</span>
  53 |     | <span class='neutral'>    /// @param _collateralAddress The address of the CollateralToken contract</span>
  54 |     | <span class='unexecuted'>    constructor(address _activePoolAddress, address _priceFeedAddress, address _collateralAddress) {</span>
  55 |     | <span class='unexecuted'>        activePool = IActivePool(_activePoolAddress);</span>
  56 |     | <span class='unexecuted'>        priceFeed = IPriceFeed(_priceFeedAddress);</span>
  57 |     | <span class='unexecuted'>        collateral = ICollateralToken(_collateralAddress);</span>
  58 |     | <span class='neutral'>    }</span>
  59 |     | <span class='neutral'></span>
  60 |     | <span class='neutral'>    // --- Gas compensation functions ---</span>
  61 |     | <span class='neutral'></span>
  62 |     | <span class='unexecuted'>    function _calcNetStEthBalance(uint256 _stEthBalance) internal pure returns (uint256) {</span>
  63 |     | <span class='unexecuted'>        return _stEthBalance - LIQUIDATOR_REWARD;</span>
  64 |     | <span class='neutral'>    }</span>
  65 |     | <span class='neutral'></span>
  66 |     | <span class='neutral'>    /// @notice Get the entire system collateral</span>
  67 |     | <span class='neutral'>    /// @notice Entire system collateral = collateral allocated to system in ActivePool, using it&#39;s internal accounting</span>
  68 |     | <span class='neutral'>    /// @dev Collateral tokens stored in ActivePool for liquidator rewards, fees, or coll in CollSurplusPool, are not included</span>
  69 | *   | <span class='executed'>    function getSystemCollShares() public view returns (uint256 entireSystemColl) {</span>
  70 | *   | <span class='executed'>        return (activePool.getSystemCollShares());</span>
  71 |     | <span class='neutral'>    }</span>
  72 |     | <span class='neutral'></span>
  73 |     | <span class='neutral'>    /**</span>
  74 |     | <span class='neutral'>        @notice Get the entire system debt</span>
  75 |     | <span class='neutral'>        @notice Entire system collateral = collateral stored in ActivePool, using their internal accounting</span>
  76 |     | <span class='neutral'>     */</span>
  77 | *   | <span class='executed'>    function _getSystemDebt() internal view returns (uint256 entireSystemDebt) {</span>
  78 | *   | <span class='executed'>        return (activePool.getSystemDebt());</span>
  79 |     | <span class='neutral'>    }</span>
  80 |     | <span class='neutral'></span>
  81 |     | <span class='unexecuted'>    function _getCachedTCR(uint256 _price) internal view returns (uint256 TCR) {</span>
  82 |     | <span class='unexecuted'>        (TCR, , ) = _getTCRWithSystemDebtAndCollShares(_price);</span>
  83 |     | <span class='neutral'>    }</span>
  84 |     | <span class='neutral'></span>
  85 | *   | <span class='executed'>    function _getTCRWithSystemDebtAndCollShares(</span>
  86 |     | <span class='neutral'>        uint256 _price</span>
  87 | *   | <span class='executed'>    ) internal view returns (uint256 TCR, uint256 _coll, uint256 _debt) {</span>
  88 | *   | <span class='executed'>        uint256 systemCollShares = getSystemCollShares();</span>
  89 | *   | <span class='executed'>        uint256 systemDebt = _getSystemDebt();</span>
  90 |     | <span class='neutral'></span>
  91 | *   | <span class='executed'>        uint256 _systemStEthBalance = collateral.getPooledEthByShares(systemCollShares);</span>
  92 | *   | <span class='executed'>        TCR = EbtcMath._computeCR(_systemStEthBalance, systemDebt, _price);</span>
  93 |     | <span class='neutral'></span>
  94 | *   | <span class='executed'>        return (TCR, systemCollShares, systemDebt);</span>
  95 |     | <span class='neutral'>    }</span>
  96 |     | <span class='neutral'></span>
  97 |     | <span class='unexecuted'>    function _checkRecoveryMode(uint256 _price) internal view returns (bool) {</span>
  98 |     | <span class='unexecuted'>        return _checkRecoveryModeForTCR(_getCachedTCR(_price));</span>
  99 |     | <span class='neutral'>    }</span>
 100 |     | <span class='neutral'></span>
 101 | *   | <span class='executed'>    function _checkRecoveryModeForTCR(uint256 _tcr) internal view returns (bool) {</span>
 102 | *   | <span class='executed'>        return _tcr &lt; CCR;</span>
 103 |     | <span class='neutral'>    }</span>
 104 |     | <span class='neutral'></span>
 105 |     | <span class='unexecuted'>    function _requireUserAcceptsFee(</span>
 106 |     | <span class='neutral'>        uint256 _fee,</span>
 107 |     | <span class='neutral'>        uint256 _amount,</span>
 108 |     | <span class='neutral'>        uint256 _maxFeePercentage</span>
 109 |     | <span class='neutral'>    ) internal pure {</span>
 110 |     | <span class='unexecuted'>        uint256 feePercentage = (_fee * DECIMAL_PRECISION) / _amount;</span>
 111 |     | <span class='unexecuted'>        require(feePercentage &lt;= _maxFeePercentage, &quot;Fee exceeded provided maximum&quot;);</span>
 112 |     | <span class='neutral'>    }</span>
 113 |     | <span class='neutral'></span>
 114 |     | <span class='neutral'>    // Convert debt denominated in ETH to debt denominated in BTC given that _price is ETH/BTC</span>
 115 |     | <span class='neutral'>    // _debt is denominated in ETH</span>
 116 |     | <span class='neutral'>    // _price is ETH/BTC</span>
 117 |     | <span class='unexecuted'>    function _convertDebtDenominationToBtc(</span>
 118 |     | <span class='neutral'>        uint256 _debt,</span>
 119 |     | <span class='neutral'>        uint256 _price</span>
 120 |     | <span class='unexecuted'>    ) internal pure returns (uint256) {</span>
 121 |     | <span class='unexecuted'>        return (_debt * _price) / DECIMAL_PRECISION;</span>
 122 |     | <span class='neutral'>    }</span>
 123 |     | <span class='neutral'></span>
 124 |     | <span class='neutral'>    /// @dev return true if given ICR is qualified for liquidation compared to configured threshold</span>
 125 |     | <span class='neutral'>    /// @dev this function ONLY checks numbers not check grace period switch for Recovery Mode</span>
 126 | *   | <span class='executed'>    function _checkICRAgainstLiqThreshold(uint256 _icr, uint _tcr) internal view returns (bool) {</span>
 127 |     | <span class='neutral'>        // Either undercollateralized</span>
 128 |     | <span class='neutral'>        // OR, it&#39;s RM AND they meet the requirement</span>
 129 |     | <span class='neutral'>        // Swapped Requirement &amp;&amp; RM to save gas</span>
 130 |     | <span class='neutral'>        return</span>
 131 | *   | <span class='executed'>            _checkICRAgainstMCR(_icr) ||</span>
 132 | *   | <span class='executed'>            (_checkICRAgainstTCR(_icr, _tcr) &amp;&amp; _checkRecoveryModeForTCR(_tcr));</span>
 133 |     | <span class='neutral'>    }</span>
 134 |     | <span class='neutral'></span>
 135 |     | <span class='neutral'>    /// @dev return true if given ICR is qualified for liquidation compared to MCR</span>
 136 | *   | <span class='executed'>    function _checkICRAgainstMCR(uint256 _icr) internal view returns (bool) {</span>
 137 | *   | <span class='executed'>        return _icr &lt; MCR;</span>
 138 |     | <span class='neutral'>    }</span>
 139 |     | <span class='neutral'></span>
 140 |     | <span class='neutral'>    /// @dev return true if given ICR is qualified for liquidation compared to TCR</span>
 141 |     | <span class='neutral'>    /// @dev typically used in Recovery Mode</span>
 142 |     | <span class='neutral'>    function _checkICRAgainstTCR(uint256 _icr, uint _tcr) internal view returns (bool) {</span>
 143 |     | <span class='neutral'>        /// @audit is _icr &lt;= _tcr more dangerous for overal system safety?</span>
 144 |     | <span class='neutral'>        /// @audit Should we use _icr &lt; CCR to allow any risky CDP being liquidated?</span>
 145 | *   | <span class='executed'>        return _icr &lt;= _tcr;</span>
 146 |     | <span class='neutral'>    }</span>
 147 |     | <span class='neutral'>}</span>
 148 |     | <span class='neutral'></span>

</code>
<br />

<b>/mnt/c/Users/Lourens/Documents/Recon-Fuzz/collabs/ebtc/packages/contracts/contracts/Dependencies/EbtcMath.sol</b>
<code>
   1 |     | <span class='neutral'>// SPDX-License-Identifier: MIT</span>
   2 |     | <span class='neutral'></span>
   3 |     | <span class='neutral'>pragma solidity 0.8.17;</span>
   4 |     | <span class='neutral'></span>
   5 |     | <span class='unexecuted'>library EbtcMath {</span>
   6 |     | <span class='unexecuted'>    uint256 internal constant DECIMAL_PRECISION = 1e18;</span>
   7 |     | <span class='unexecuted'>    uint256 public constant MAX_TCR = type(uint256).max;</span>
   8 |     | <span class='neutral'></span>
   9 |     | <span class='neutral'>    /* Precision for Nominal ICR (independent of price). Rationale for the value:</span>
  10 |     | <span class='neutral'>     *</span>
  11 |     | <span class='neutral'>     * - Making it “too high” could lead to overflows.</span>
  12 |     | <span class='neutral'>     * - Making it “too low” could lead to an ICR equal to zero, due to truncation from Solidity floor division.</span>
  13 |     | <span class='neutral'>     *</span>
  14 |     | <span class='neutral'>     * This value of 1e20 is chosen for safety: the NICR will only overflow for numerator &gt; ~1e39 ETH,</span>
  15 |     | <span class='neutral'>     * and will only truncate to 0 if the denominator is at least 1e20 times greater than the numerator.</span>
  16 |     | <span class='neutral'>     *</span>
  17 |     | <span class='neutral'>     */</span>
  18 |     | <span class='unexecuted'>    uint256 internal constant NICR_PRECISION = 1e20;</span>
  19 |     | <span class='neutral'></span>
  20 |     | <span class='unexecuted'>    function _min(uint256 _a, uint256 _b) internal pure returns (uint256) {</span>
  21 |     | <span class='unexecuted'>        return (_a &lt; _b) ? _a : _b;</span>
  22 |     | <span class='neutral'>    }</span>
  23 |     | <span class='neutral'></span>
  24 |     | <span class='unexecuted'>    function _max(uint256 _a, uint256 _b) internal pure returns (uint256) {</span>
  25 |     | <span class='unexecuted'>        return (_a &gt;= _b) ? _a : _b;</span>
  26 |     | <span class='neutral'>    }</span>
  27 |     | <span class='neutral'></span>
  28 |     | <span class='neutral'>    /**</span>
  29 |     | <span class='neutral'>     * credit to OpenZeppelin</span>
  30 |     | <span class='neutral'>     * @dev Returns the downcasted uint128 from uint256, reverting on</span>
  31 |     | <span class='neutral'>     * overflow (when the input is greater than largest uint128).</span>
  32 |     | <span class='neutral'>     *</span>
  33 |     | <span class='neutral'>     * Counterpart to Solidity&#39;s `uint128` operator.</span>
  34 |     | <span class='neutral'>     *</span>
  35 |     | <span class='neutral'>     * Requirements:</span>
  36 |     | <span class='neutral'>     *</span>
  37 |     | <span class='neutral'>     * - input must fit into 128 bits</span>
  38 |     | <span class='neutral'>     */</span>
  39 |     | <span class='unexecuted'>    function toUint128(uint256 value) internal pure returns (uint128) {</span>
  40 |     | <span class='unexecuted'>        require(value &lt;= type(uint128).max, &quot;EbtcMath: downcast to uint128 will overflow&quot;);</span>
  41 |     | <span class='unexecuted'>        return uint128(value);</span>
  42 |     | <span class='neutral'>    }</span>
  43 |     | <span class='neutral'></span>
  44 |     | <span class='neutral'>    /*</span>
  45 |     | <span class='neutral'>     * Multiply two decimal numbers and use normal rounding rules:</span>
  46 |     | <span class='neutral'>     * -round product up if 19&#39;th mantissa digit &gt;= 5</span>
  47 |     | <span class='neutral'>     * -round product down if 19&#39;th mantissa digit &lt; 5</span>
  48 |     | <span class='neutral'>     *</span>
  49 |     | <span class='neutral'>     * Used only inside the exponentiation, _decPow().</span>
  50 |     | <span class='neutral'>     */</span>
  51 |     | <span class='unexecuted'>    function decMul(uint256 x, uint256 y) internal pure returns (uint256 decProd) {</span>
  52 |     | <span class='unexecuted'>        uint256 prod_xy = x * y;</span>
  53 |     | <span class='neutral'></span>
  54 |     | <span class='unexecuted'>        decProd = (prod_xy + (DECIMAL_PRECISION / 2)) / DECIMAL_PRECISION;</span>
  55 |     | <span class='neutral'>    }</span>
  56 |     | <span class='neutral'></span>
  57 |     | <span class='neutral'>    /*</span>
  58 |     | <span class='neutral'>     * _decPow: Exponentiation function for 18-digit decimal base, and integer exponent n.</span>
  59 |     | <span class='neutral'>     *</span>
  60 |     | <span class='neutral'>     * Uses the efficient &quot;exponentiation by squaring&quot; algorithm. O(log(n)) complexity.</span>
  61 |     | <span class='neutral'>     *</span>
  62 |     | <span class='neutral'>     * Called by two functions that represent time in units of minutes:</span>
  63 |     | <span class='neutral'>     * 1) CdpManager._calcDecayedBaseRate</span>
  64 |     | <span class='neutral'>     * 2) CommunityIssuance._getCumulativeIssuanceFraction</span>
  65 |     | <span class='neutral'>     *</span>
  66 |     | <span class='neutral'>     * The exponent is capped to avoid reverting due to overflow. The cap 525600000 equals</span>
  67 |     | <span class='neutral'>     * &quot;minutes in 1000 years&quot;: 60 * 24 * 365 * 1000</span>
  68 |     | <span class='neutral'>     *</span>
  69 |     | <span class='neutral'>     * If a period of &gt; 1000 years is ever used as an exponent in either of the above functions, the result will be</span>
  70 |     | <span class='neutral'>     * negligibly different from just passing the cap, since:</span>
  71 |     | <span class='neutral'>     *</span>
  72 |     | <span class='neutral'>     * In function 1), the decayed base rate will be 0 for 1000 years or &gt; 1000 years</span>
  73 |     | <span class='neutral'>     * In function 2), the difference in tokens issued at 1000 years and any time &gt; 1000 years, will be negligible</span>
  74 |     | <span class='neutral'>     */</span>
  75 |     | <span class='unexecuted'>    function _decPow(uint256 _base, uint256 _minutes) internal pure returns (uint256) {</span>
  76 |     | <span class='unexecuted'>        if (_minutes &gt; 525600000) {</span>
  77 |     | <span class='unexecuted'>            _minutes = 525600000;</span>
  78 |     | <span class='neutral'>        } // cap to avoid overflow</span>
  79 |     | <span class='neutral'></span>
  80 |     | <span class='unexecuted'>        if (_minutes == 0) {</span>
  81 |     | <span class='unexecuted'>            return DECIMAL_PRECISION;</span>
  82 |     | <span class='neutral'>        }</span>
  83 |     | <span class='neutral'></span>
  84 |     | <span class='neutral'>        uint256 y = DECIMAL_PRECISION;</span>
  85 |     | <span class='unexecuted'>        uint256 x = _base;</span>
  86 |     | <span class='unexecuted'>        uint256 n = _minutes;</span>
  87 |     | <span class='neutral'></span>
  88 |     | <span class='neutral'>        // Exponentiation-by-squaring</span>
  89 |     | <span class='unexecuted'>        while (n &gt; 1) {</span>
  90 |     | <span class='unexecuted'>            if (n % 2 == 0) {</span>
  91 |     | <span class='unexecuted'>                x = decMul(x, x);</span>
  92 |     | <span class='unexecuted'>                n = n / 2;</span>
  93 |     | <span class='neutral'>            } else {</span>
  94 |     | <span class='neutral'>                // if (n % 2 != 0)</span>
  95 |     | <span class='unexecuted'>                y = decMul(x, y);</span>
  96 |     | <span class='unexecuted'>                x = decMul(x, x);</span>
  97 |     | <span class='unexecuted'>                n = (n - 1) / 2;</span>
  98 |     | <span class='neutral'>            }</span>
  99 |     | <span class='neutral'>        }</span>
 100 |     | <span class='neutral'></span>
 101 |     | <span class='unexecuted'>        return decMul(x, y);</span>
 102 |     | <span class='neutral'>    }</span>
 103 |     | <span class='neutral'></span>
 104 |     | <span class='unexecuted'>    function _getAbsoluteDifference(uint256 _a, uint256 _b) internal pure returns (uint256) {</span>
 105 |     | <span class='unexecuted'>        return (_a &gt;= _b) ? (_a - _b) : (_b - _a);</span>
 106 |     | <span class='neutral'>    }</span>
 107 |     | <span class='neutral'></span>
 108 |     | <span class='unexecuted'>    function _computeNominalCR(uint256 _collShares, uint256 _debt) internal pure returns (uint256) {</span>
 109 |     | <span class='unexecuted'>        if (_debt &gt; 0) {</span>
 110 |     | <span class='unexecuted'>            return (_collShares * NICR_PRECISION) / _debt;</span>
 111 |     | <span class='neutral'>        }</span>
 112 |     | <span class='neutral'>        // Return the maximal value for uint256 if the Cdp has a debt of 0. Represents &quot;infinite&quot; CR.</span>
 113 |     | <span class='neutral'>        else {</span>
 114 |     | <span class='neutral'>            // if (_debt == 0)</span>
 115 |     | <span class='unexecuted'>            return MAX_TCR;</span>
 116 |     | <span class='neutral'>        }</span>
 117 |     | <span class='neutral'>    }</span>
 118 |     | <span class='neutral'></span>
 119 |     | <span class='neutral'>    /// @dev Compute collateralization ratio, given stETH balance, price, and debt balance</span>
 120 | *   | <span class='executed'>    function _computeCR(</span>
 121 |     | <span class='neutral'>        uint256 _stEthBalance,</span>
 122 |     | <span class='neutral'>        uint256 _debt,</span>
 123 |     | <span class='neutral'>        uint256 _price</span>
 124 | *   | <span class='executed'>    ) internal pure returns (uint256) {</span>
 125 | *   | <span class='executed'>        if (_debt &gt; 0) {</span>
 126 | *   | <span class='executed'>            uint256 newCollRatio = (_stEthBalance * _price) / _debt;</span>
 127 |     | <span class='neutral'></span>
 128 | *   | <span class='executed'>            return newCollRatio;</span>
 129 |     | <span class='neutral'>        }</span>
 130 |     | <span class='neutral'>        // Return the maximal value for uint256 if the Cdp has a debt of 0. Represents &quot;infinite&quot; CR.</span>
 131 |     | <span class='neutral'>        else {</span>
 132 |     | <span class='neutral'>            // if (_debt == 0)</span>
 133 |     | <span class='unexecuted'>            return MAX_TCR;</span>
 134 |     | <span class='neutral'>        }</span>
 135 |     | <span class='neutral'>    }</span>
 136 |     | <span class='neutral'>}</span>
 137 |     | <span class='neutral'></span>

</code>
<br />

<b>/mnt/c/Users/Lourens/Documents/Recon-Fuzz/collabs/ebtc/packages/contracts/contracts/Dependencies/EnumerableSet.sol</b>
<code>
   1 |     | <span class='neutral'>// SPDX-License-Identifier: MIT</span>
   2 |     | <span class='neutral'>// OpenZeppelin Contracts (last updated v4.8.0) (utils/structs/EnumerableSet.sol)</span>
   3 |     | <span class='neutral'>// This file was procedurally generated from scripts/generate/templates/EnumerableSet.js.</span>
   4 |     | <span class='neutral'></span>
   5 |     | <span class='neutral'>pragma solidity 0.8.17;</span>
   6 |     | <span class='neutral'></span>
   7 |     | <span class='neutral'>/**</span>
   8 |     | <span class='neutral'> * @dev Library for managing</span>
   9 |     | <span class='neutral'> * https://en.wikipedia.org/wiki/Set_(abstract_data_type)[sets] of primitive</span>
  10 |     | <span class='neutral'> * types.</span>
  11 |     | <span class='neutral'> *</span>
  12 |     | <span class='neutral'> * Sets have the following properties:</span>
  13 |     | <span class='neutral'> *</span>
  14 |     | <span class='neutral'> * - Elements are added, removed, and checked for existence in constant time</span>
  15 |     | <span class='neutral'> * (O(1)).</span>
  16 |     | <span class='neutral'> * - Elements are enumerated in O(n). No guarantees are made on the ordering.</span>
  17 |     | <span class='neutral'> *</span>
  18 |     | <span class='neutral'> * ```solidity</span>
  19 |     | <span class='neutral'> * contract Example {</span>
  20 |     | <span class='neutral'> *     // Add the library methods</span>
  21 |     | <span class='neutral'> *     using EnumerableSet for EnumerableSet.AddressSet;</span>
  22 |     | <span class='neutral'> *</span>
  23 |     | <span class='neutral'> *     // Declare a set state variable</span>
  24 |     | <span class='neutral'> *     EnumerableSet.AddressSet private mySet;</span>
  25 |     | <span class='neutral'> * }</span>
  26 |     | <span class='neutral'> * ```</span>
  27 |     | <span class='neutral'> *</span>
  28 |     | <span class='neutral'> * As of v3.3.0, sets of type `bytes32` (`Bytes32Set`), `address` (`AddressSet`)</span>
  29 |     | <span class='neutral'> * and `uint256` (`UintSet`) are supported.</span>
  30 |     | <span class='neutral'> *</span>
  31 |     | <span class='neutral'> * [WARNING]</span>
  32 |     | <span class='neutral'> * ====</span>
  33 |     | <span class='neutral'> * Trying to delete such a structure from storage will likely result in data corruption, rendering the structure</span>
  34 |     | <span class='neutral'> * unusable.</span>
  35 |     | <span class='neutral'> * See https://github.com/ethereum/solidity/pull/11843[ethereum/solidity#11843] for more info.</span>
  36 |     | <span class='neutral'> *</span>
  37 |     | <span class='neutral'> * In order to clean an EnumerableSet, you can either remove all elements one by one or create a fresh instance using an</span>
  38 |     | <span class='neutral'> * array of EnumerableSet.</span>
  39 |     | <span class='neutral'> * ====</span>
  40 |     | <span class='neutral'> */</span>
  41 |     | <span class='unexecuted'>library EnumerableSet {</span>
  42 |     | <span class='neutral'>    // To implement this library for multiple types with as little code</span>
  43 |     | <span class='neutral'>    // repetition as possible, we write it in terms of a generic Set type with</span>
  44 |     | <span class='neutral'>    // bytes32 values.</span>
  45 |     | <span class='neutral'>    // The Set implementation uses private functions, and user-facing</span>
  46 |     | <span class='neutral'>    // implementations (such as AddressSet) are just wrappers around the</span>
  47 |     | <span class='neutral'>    // underlying Set.</span>
  48 |     | <span class='neutral'>    // This means that we can only create new EnumerableSets for types that fit</span>
  49 |     | <span class='neutral'>    // in bytes32.</span>
  50 |     | <span class='neutral'></span>
  51 |     | <span class='neutral'>    struct Set {</span>
  52 |     | <span class='neutral'>        // Storage of set values</span>
  53 |     | <span class='neutral'>        bytes32[] _values;</span>
  54 |     | <span class='neutral'>        // Position of the value in the `values` array, plus 1 because index 0</span>
  55 |     | <span class='neutral'>        // means a value is not in the set.</span>
  56 |     | <span class='neutral'>        mapping(bytes32 =&gt; uint256) _indexes;</span>
  57 |     | <span class='neutral'>    }</span>
  58 |     | <span class='neutral'></span>
  59 |     | <span class='neutral'>    /**</span>
  60 |     | <span class='neutral'>     * @dev Add a value to a set. O(1).</span>
  61 |     | <span class='neutral'>     *</span>
  62 |     | <span class='neutral'>     * Returns true if the value was added to the set, that is if it was not</span>
  63 |     | <span class='neutral'>     * already present.</span>
  64 |     | <span class='neutral'>     */</span>
  65 |     | <span class='unexecuted'>    function _add(Set storage set, bytes32 value) private returns (bool) {</span>
  66 |     | <span class='unexecuted'>        if (!_contains(set, value)) {</span>
  67 |     | <span class='unexecuted'>            set._values.push(value);</span>
  68 |     | <span class='neutral'>            // The value is stored at length-1, but we add 1 to all indexes</span>
  69 |     | <span class='neutral'>            // and use 0 as a sentinel value</span>
  70 |     | <span class='unexecuted'>            set._indexes[value] = set._values.length;</span>
  71 |     | <span class='unexecuted'>            return true;</span>
  72 |     | <span class='neutral'>        } else {</span>
  73 |     | <span class='unexecuted'>            return false;</span>
  74 |     | <span class='neutral'>        }</span>
  75 |     | <span class='neutral'>    }</span>
  76 |     | <span class='neutral'></span>
  77 |     | <span class='neutral'>    /**</span>
  78 |     | <span class='neutral'>     * @dev Removes a value from a set. O(1).</span>
  79 |     | <span class='neutral'>     *</span>
  80 |     | <span class='neutral'>     * Returns true if the value was removed from the set, that is if it was</span>
  81 |     | <span class='neutral'>     * present.</span>
  82 |     | <span class='neutral'>     */</span>
  83 |     | <span class='unexecuted'>    function _remove(Set storage set, bytes32 value) private returns (bool) {</span>
  84 |     | <span class='neutral'>        // We read and store the value&#39;s index to prevent multiple reads from the same storage slot</span>
  85 |     | <span class='unexecuted'>        uint256 valueIndex = set._indexes[value];</span>
  86 |     | <span class='neutral'></span>
  87 |     | <span class='unexecuted'>        if (valueIndex != 0) {</span>
  88 |     | <span class='neutral'>            // Equivalent to contains(set, value)</span>
  89 |     | <span class='neutral'>            // To delete an element from the _values array in O(1), we swap the element to delete with the last one in</span>
  90 |     | <span class='neutral'>            // the array, and then remove the last element (sometimes called as &#39;swap and pop&#39;).</span>
  91 |     | <span class='neutral'>            // This modifies the order of the array, as noted in {at}.</span>
  92 |     | <span class='neutral'></span>
  93 |     | <span class='unexecuted'>            uint256 toDeleteIndex = valueIndex - 1;</span>
  94 |     | <span class='unexecuted'>            uint256 lastIndex = set._values.length - 1;</span>
  95 |     | <span class='neutral'></span>
  96 |     | <span class='unexecuted'>            if (lastIndex != toDeleteIndex) {</span>
  97 |     | <span class='unexecuted'>                bytes32 lastValue = set._values[lastIndex];</span>
  98 |     | <span class='neutral'></span>
  99 |     | <span class='neutral'>                // Move the last value to the index where the value to delete is</span>
 100 |     | <span class='unexecuted'>                set._values[toDeleteIndex] = lastValue;</span>
 101 |     | <span class='neutral'>                // Update the index for the moved value</span>
 102 |     | <span class='unexecuted'>                set._indexes[lastValue] = valueIndex; // Replace lastValue&#39;s index to valueIndex</span>
 103 |     | <span class='neutral'>            }</span>
 104 |     | <span class='neutral'></span>
 105 |     | <span class='neutral'>            // Delete the slot where the moved value was stored</span>
 106 |     | <span class='unexecuted'>            set._values.pop();</span>
 107 |     | <span class='neutral'></span>
 108 |     | <span class='neutral'>            // Delete the index for the deleted slot</span>
 109 |     | <span class='unexecuted'>            delete set._indexes[value];</span>
 110 |     | <span class='neutral'></span>
 111 |     | <span class='unexecuted'>            return true;</span>
 112 |     | <span class='neutral'>        } else {</span>
 113 |     | <span class='unexecuted'>            return false;</span>
 114 |     | <span class='neutral'>        }</span>
 115 |     | <span class='neutral'>    }</span>
 116 |     | <span class='neutral'></span>
 117 |     | <span class='neutral'>    /**</span>
 118 |     | <span class='neutral'>     * @dev Returns true if the value is in the set. O(1).</span>
 119 |     | <span class='neutral'>     */</span>
 120 |     | <span class='unexecuted'>    function _contains(Set storage set, bytes32 value) private view returns (bool) {</span>
 121 |     | <span class='unexecuted'>        return set._indexes[value] != 0;</span>
 122 |     | <span class='neutral'>    }</span>
 123 |     | <span class='neutral'></span>
 124 |     | <span class='neutral'>    /**</span>
 125 |     | <span class='neutral'>     * @dev Returns the number of values on the set. O(1).</span>
 126 |     | <span class='neutral'>     */</span>
 127 |     | <span class='unexecuted'>    function _length(Set storage set) private view returns (uint256) {</span>
 128 |     | <span class='unexecuted'>        return set._values.length;</span>
 129 |     | <span class='neutral'>    }</span>
 130 |     | <span class='neutral'></span>
 131 |     | <span class='neutral'>    /**</span>
 132 |     | <span class='neutral'>     * @dev Returns the value stored at position `index` in the set. O(1).</span>
 133 |     | <span class='neutral'>     *</span>
 134 |     | <span class='neutral'>     * Note that there are no guarantees on the ordering of values inside the</span>
 135 |     | <span class='neutral'>     * array, and it may change when more values are added or removed.</span>
 136 |     | <span class='neutral'>     *</span>
 137 |     | <span class='neutral'>     * Requirements:</span>
 138 |     | <span class='neutral'>     *</span>
 139 |     | <span class='neutral'>     * - `index` must be strictly less than {length}.</span>
 140 |     | <span class='neutral'>     */</span>
 141 |     | <span class='unexecuted'>    function _at(Set storage set, uint256 index) private view returns (bytes32) {</span>
 142 |     | <span class='unexecuted'>        return set._values[index];</span>
 143 |     | <span class='neutral'>    }</span>
 144 |     | <span class='neutral'></span>
 145 |     | <span class='neutral'>    /**</span>
 146 |     | <span class='neutral'>     * @dev Return the entire set in an array</span>
 147 |     | <span class='neutral'>     *</span>
 148 |     | <span class='neutral'>     * WARNING: This operation will copy the entire storage to memory, which can be quite expensive. This is designed</span>
 149 |     | <span class='neutral'>     * to mostly be used by view accessors that are queried without any gas fees. Developers should keep in mind that</span>
 150 |     | <span class='neutral'>     * this function has an unbounded cost, and using it as part of a state-changing function may render the function</span>
 151 |     | <span class='neutral'>     * uncallable if the set grows to a point where copying to memory consumes too much gas to fit in a block.</span>
 152 |     | <span class='neutral'>     */</span>
 153 |     | <span class='unexecuted'>    function _values(Set storage set) private view returns (bytes32[] memory) {</span>
 154 |     | <span class='unexecuted'>        return set._values;</span>
 155 |     | <span class='neutral'>    }</span>
 156 |     | <span class='neutral'></span>
 157 |     | <span class='neutral'>    // Bytes32Set</span>
 158 |     | <span class='neutral'></span>
 159 |     | <span class='neutral'>    struct Bytes32Set {</span>
 160 |     | <span class='neutral'>        Set _inner;</span>
 161 |     | <span class='neutral'>    }</span>
 162 |     | <span class='neutral'></span>
 163 |     | <span class='neutral'>    /**</span>
 164 |     | <span class='neutral'>     * @dev Add a value to a set. O(1).</span>
 165 |     | <span class='neutral'>     *</span>
 166 |     | <span class='neutral'>     * Returns true if the value was added to the set, that is if it was not</span>
 167 |     | <span class='neutral'>     * already present.</span>
 168 |     | <span class='neutral'>     */</span>
 169 |     | <span class='unexecuted'>    function add(Bytes32Set storage set, bytes32 value) internal returns (bool) {</span>
 170 |     | <span class='unexecuted'>        return _add(set._inner, value);</span>
 171 |     | <span class='neutral'>    }</span>
 172 |     | <span class='neutral'></span>
 173 |     | <span class='neutral'>    /**</span>
 174 |     | <span class='neutral'>     * @dev Removes a value from a set. O(1).</span>
 175 |     | <span class='neutral'>     *</span>
 176 |     | <span class='neutral'>     * Returns true if the value was removed from the set, that is if it was</span>
 177 |     | <span class='neutral'>     * present.</span>
 178 |     | <span class='neutral'>     */</span>
 179 |     | <span class='unexecuted'>    function remove(Bytes32Set storage set, bytes32 value) internal returns (bool) {</span>
 180 |     | <span class='unexecuted'>        return _remove(set._inner, value);</span>
 181 |     | <span class='neutral'>    }</span>
 182 |     | <span class='neutral'></span>
 183 |     | <span class='neutral'>    /**</span>
 184 |     | <span class='neutral'>     * @dev Returns true if the value is in the set. O(1).</span>
 185 |     | <span class='neutral'>     */</span>
 186 |     | <span class='neutral'>    function contains(Bytes32Set storage set, bytes32 value) internal view returns (bool) {</span>
 187 |     | <span class='neutral'>        return _contains(set._inner, value);</span>
 188 |     | <span class='neutral'>    }</span>
 189 |     | <span class='neutral'></span>
 190 |     | <span class='neutral'>    /**</span>
 191 |     | <span class='neutral'>     * @dev Returns the number of values in the set. O(1).</span>
 192 |     | <span class='neutral'>     */</span>
 193 |     | <span class='unexecuted'>    function length(Bytes32Set storage set) internal view returns (uint256) {</span>
 194 |     | <span class='unexecuted'>        return _length(set._inner);</span>
 195 |     | <span class='neutral'>    }</span>
 196 |     | <span class='neutral'></span>
 197 |     | <span class='neutral'>    /**</span>
 198 |     | <span class='neutral'>     * @dev Returns the value stored at position `index` in the set. O(1).</span>
 199 |     | <span class='neutral'>     *</span>
 200 |     | <span class='neutral'>     * Note that there are no guarantees on the ordering of values inside the</span>
 201 |     | <span class='neutral'>     * array, and it may change when more values are added or removed.</span>
 202 |     | <span class='neutral'>     *</span>
 203 |     | <span class='neutral'>     * Requirements:</span>
 204 |     | <span class='neutral'>     *</span>
 205 |     | <span class='neutral'>     * - `index` must be strictly less than {length}.</span>
 206 |     | <span class='neutral'>     */</span>
 207 |     | <span class='neutral'>    function at(Bytes32Set storage set, uint256 index) internal view returns (bytes32) {</span>
 208 |     | <span class='neutral'>        return _at(set._inner, index);</span>
 209 |     | <span class='neutral'>    }</span>
 210 |     | <span class='neutral'></span>
 211 |     | <span class='neutral'>    /**</span>
 212 |     | <span class='neutral'>     * @dev Return the entire set in an array</span>
 213 |     | <span class='neutral'>     *</span>
 214 |     | <span class='neutral'>     * WARNING: This operation will copy the entire storage to memory, which can be quite expensive. This is designed</span>
 215 |     | <span class='neutral'>     * to mostly be used by view accessors that are queried without any gas fees. Developers should keep in mind that</span>
 216 |     | <span class='neutral'>     * this function has an unbounded cost, and using it as part of a state-changing function may render the function</span>
 217 |     | <span class='neutral'>     * uncallable if the set grows to a point where copying to memory consumes too much gas to fit in a block.</span>
 218 |     | <span class='neutral'>     */</span>
 219 |     | <span class='unexecuted'>    function values(Bytes32Set storage set) internal view returns (bytes32[] memory) {</span>
 220 |     | <span class='unexecuted'>        bytes32[] memory store = _values(set._inner);</span>
 221 |     | <span class='neutral'>        bytes32[] memory result;</span>
 222 |     | <span class='neutral'></span>
 223 |     | <span class='neutral'>        /// @solidity memory-safe-assembly</span>
 224 |     | <span class='neutral'>        assembly {</span>
 225 |     | <span class='neutral'>            result := store</span>
 226 |     | <span class='neutral'>        }</span>
 227 |     | <span class='neutral'></span>
 228 |     | <span class='neutral'>        return result;</span>
 229 |     | <span class='neutral'>    }</span>
 230 |     | <span class='neutral'></span>
 231 |     | <span class='neutral'>    // AddressSet</span>
 232 |     | <span class='neutral'></span>
 233 |     | <span class='neutral'>    struct AddressSet {</span>
 234 |     | <span class='neutral'>        Set _inner;</span>
 235 |     | <span class='neutral'>    }</span>
 236 |     | <span class='neutral'></span>
 237 |     | <span class='neutral'>    /**</span>
 238 |     | <span class='neutral'>     * @dev Add a value to a set. O(1).</span>
 239 |     | <span class='neutral'>     *</span>
 240 |     | <span class='neutral'>     * Returns true if the value was added to the set, that is if it was not</span>
 241 |     | <span class='neutral'>     * already present.</span>
 242 |     | <span class='neutral'>     */</span>
 243 |     | <span class='unexecuted'>    function add(AddressSet storage set, address value) internal returns (bool) {</span>
 244 |     | <span class='unexecuted'>        return _add(set._inner, bytes32(uint256(uint160(value))));</span>
 245 |     | <span class='neutral'>    }</span>
 246 |     | <span class='neutral'></span>
 247 |     | <span class='neutral'>    /**</span>
 248 |     | <span class='neutral'>     * @dev Removes a value from a set. O(1).</span>
 249 |     | <span class='neutral'>     *</span>
 250 |     | <span class='neutral'>     * Returns true if the value was removed from the set, that is if it was</span>
 251 |     | <span class='neutral'>     * present.</span>
 252 |     | <span class='neutral'>     */</span>
 253 |     | <span class='unexecuted'>    function remove(AddressSet storage set, address value) internal returns (bool) {</span>
 254 |     | <span class='unexecuted'>        return _remove(set._inner, bytes32(uint256(uint160(value))));</span>
 255 |     | <span class='neutral'>    }</span>
 256 |     | <span class='neutral'></span>
 257 |     | <span class='neutral'>    /**</span>
 258 |     | <span class='neutral'>     * @dev Returns true if the value is in the set. O(1).</span>
 259 |     | <span class='neutral'>     */</span>
 260 |     | <span class='unexecuted'>    function contains(AddressSet storage set, address value) internal view returns (bool) {</span>
 261 |     | <span class='unexecuted'>        return _contains(set._inner, bytes32(uint256(uint160(value))));</span>
 262 |     | <span class='neutral'>    }</span>
 263 |     | <span class='neutral'></span>
 264 |     | <span class='neutral'>    /**</span>
 265 |     | <span class='neutral'>     * @dev Returns the number of values in the set. O(1).</span>
 266 |     | <span class='neutral'>     */</span>
 267 |     | <span class='neutral'>    function length(AddressSet storage set) internal view returns (uint256) {</span>
 268 |     | <span class='neutral'>        return _length(set._inner);</span>
 269 |     | <span class='neutral'>    }</span>
 270 |     | <span class='neutral'></span>
 271 |     | <span class='neutral'>    /**</span>
 272 |     | <span class='neutral'>     * @dev Returns the value stored at position `index` in the set. O(1).</span>
 273 |     | <span class='neutral'>     *</span>
 274 |     | <span class='neutral'>     * Note that there are no guarantees on the ordering of values inside the</span>
 275 |     | <span class='neutral'>     * array, and it may change when more values are added or removed.</span>
 276 |     | <span class='neutral'>     *</span>
 277 |     | <span class='neutral'>     * Requirements:</span>
 278 |     | <span class='neutral'>     *</span>
 279 |     | <span class='neutral'>     * - `index` must be strictly less than {length}.</span>
 280 |     | <span class='neutral'>     */</span>
 281 |     | <span class='unexecuted'>    function at(AddressSet storage set, uint256 index) internal view returns (address) {</span>
 282 |     | <span class='unexecuted'>        return address(uint160(uint256(_at(set._inner, index))));</span>
 283 |     | <span class='neutral'>    }</span>
 284 |     | <span class='neutral'></span>
 285 |     | <span class='neutral'>    /**</span>
 286 |     | <span class='neutral'>     * @dev Return the entire set in an array</span>
 287 |     | <span class='neutral'>     *</span>
 288 |     | <span class='neutral'>     * WARNING: This operation will copy the entire storage to memory, which can be quite expensive. This is designed</span>
 289 |     | <span class='neutral'>     * to mostly be used by view accessors that are queried without any gas fees. Developers should keep in mind that</span>
 290 |     | <span class='neutral'>     * this function has an unbounded cost, and using it as part of a state-changing function may render the function</span>
 291 |     | <span class='neutral'>     * uncallable if the set grows to a point where copying to memory consumes too much gas to fit in a block.</span>
 292 |     | <span class='neutral'>     */</span>
 293 |     | <span class='neutral'>    function values(AddressSet storage set) internal view returns (address[] memory) {</span>
 294 |     | <span class='neutral'>        bytes32[] memory store = _values(set._inner);</span>
 295 |     | <span class='neutral'>        address[] memory result;</span>
 296 |     | <span class='neutral'></span>
 297 |     | <span class='neutral'>        /// @solidity memory-safe-assembly</span>
 298 |     | <span class='neutral'>        assembly {</span>
 299 |     | <span class='neutral'>            result := store</span>
 300 |     | <span class='neutral'>        }</span>
 301 |     | <span class='neutral'></span>
 302 |     | <span class='neutral'>        return result;</span>
 303 |     | <span class='neutral'>    }</span>
 304 |     | <span class='neutral'></span>
 305 |     | <span class='neutral'>    // UintSet</span>
 306 |     | <span class='neutral'></span>
 307 |     | <span class='neutral'>    struct UintSet {</span>
 308 |     | <span class='neutral'>        Set _inner;</span>
 309 |     | <span class='neutral'>    }</span>
 310 |     | <span class='neutral'></span>
 311 |     | <span class='neutral'>    /**</span>
 312 |     | <span class='neutral'>     * @dev Add a value to a set. O(1).</span>
 313 |     | <span class='neutral'>     *</span>
 314 |     | <span class='neutral'>     * Returns true if the value was added to the set, that is if it was not</span>
 315 |     | <span class='neutral'>     * already present.</span>
 316 |     | <span class='neutral'>     */</span>
 317 |     | <span class='neutral'>    function add(UintSet storage set, uint256 value) internal returns (bool) {</span>
 318 |     | <span class='neutral'>        return _add(set._inner, bytes32(value));</span>
 319 |     | <span class='neutral'>    }</span>
 320 |     | <span class='neutral'></span>
 321 |     | <span class='neutral'>    /**</span>
 322 |     | <span class='neutral'>     * @dev Removes a value from a set. O(1).</span>
 323 |     | <span class='neutral'>     *</span>
 324 |     | <span class='neutral'>     * Returns true if the value was removed from the set, that is if it was</span>
 325 |     | <span class='neutral'>     * present.</span>
 326 |     | <span class='neutral'>     */</span>
 327 |     | <span class='neutral'>    function remove(UintSet storage set, uint256 value) internal returns (bool) {</span>
 328 |     | <span class='neutral'>        return _remove(set._inner, bytes32(value));</span>
 329 |     | <span class='neutral'>    }</span>
 330 |     | <span class='neutral'></span>
 331 |     | <span class='neutral'>    /**</span>
 332 |     | <span class='neutral'>     * @dev Returns true if the value is in the set. O(1).</span>
 333 |     | <span class='neutral'>     */</span>
 334 |     | <span class='neutral'>    function contains(UintSet storage set, uint256 value) internal view returns (bool) {</span>
 335 |     | <span class='neutral'>        return _contains(set._inner, bytes32(value));</span>
 336 |     | <span class='neutral'>    }</span>
 337 |     | <span class='neutral'></span>
 338 |     | <span class='neutral'>    /**</span>
 339 |     | <span class='neutral'>     * @dev Returns the number of values in the set. O(1).</span>
 340 |     | <span class='neutral'>     */</span>
 341 |     | <span class='neutral'>    function length(UintSet storage set) internal view returns (uint256) {</span>
 342 |     | <span class='neutral'>        return _length(set._inner);</span>
 343 |     | <span class='neutral'>    }</span>
 344 |     | <span class='neutral'></span>
 345 |     | <span class='neutral'>    /**</span>
 346 |     | <span class='neutral'>     * @dev Returns the value stored at position `index` in the set. O(1).</span>
 347 |     | <span class='neutral'>     *</span>
 348 |     | <span class='neutral'>     * Note that there are no guarantees on the ordering of values inside the</span>
 349 |     | <span class='neutral'>     * array, and it may change when more values are added or removed.</span>
 350 |     | <span class='neutral'>     *</span>
 351 |     | <span class='neutral'>     * Requirements:</span>
 352 |     | <span class='neutral'>     *</span>
 353 |     | <span class='neutral'>     * - `index` must be strictly less than {length}.</span>
 354 |     | <span class='neutral'>     */</span>
 355 |     | <span class='neutral'>    function at(UintSet storage set, uint256 index) internal view returns (uint256) {</span>
 356 |     | <span class='neutral'>        return uint256(_at(set._inner, index));</span>
 357 |     | <span class='neutral'>    }</span>
 358 |     | <span class='neutral'></span>
 359 |     | <span class='neutral'>    /**</span>
 360 |     | <span class='neutral'>     * @dev Return the entire set in an array</span>
 361 |     | <span class='neutral'>     *</span>
 362 |     | <span class='neutral'>     * WARNING: This operation will copy the entire storage to memory, which can be quite expensive. This is designed</span>
 363 |     | <span class='neutral'>     * to mostly be used by view accessors that are queried without any gas fees. Developers should keep in mind that</span>
 364 |     | <span class='neutral'>     * this function has an unbounded cost, and using it as part of a state-changing function may render the function</span>
 365 |     | <span class='neutral'>     * uncallable if the set grows to a point where copying to memory consumes too much gas to fit in a block.</span>
 366 |     | <span class='neutral'>     */</span>
 367 |     | <span class='neutral'>    function values(UintSet storage set) internal view returns (uint256[] memory) {</span>
 368 |     | <span class='neutral'>        bytes32[] memory store = _values(set._inner);</span>
 369 |     | <span class='neutral'>        uint256[] memory result;</span>
 370 |     | <span class='neutral'></span>
 371 |     | <span class='neutral'>        /// @solidity memory-safe-assembly</span>
 372 |     | <span class='neutral'>        assembly {</span>
 373 |     | <span class='neutral'>            result := store</span>
 374 |     | <span class='neutral'>        }</span>
 375 |     | <span class='neutral'></span>
 376 |     | <span class='neutral'>        return result;</span>
 377 |     | <span class='neutral'>    }</span>
 378 |     | <span class='neutral'>}</span>
 379 |     | <span class='neutral'></span>

</code>
<br />

<b>/mnt/c/Users/Lourens/Documents/Recon-Fuzz/collabs/ebtc/packages/contracts/contracts/Dependencies/ICollateralToken.sol</b>
<code>
  1 |     | <span class='neutral'>// SPDX-License-Identifier: MIT</span>
  2 |     | <span class='neutral'>pragma solidity 0.8.17;</span>
  3 |     | <span class='neutral'></span>
  4 |     | <span class='neutral'>import &quot;./IERC20.sol&quot;;</span>
  5 |     | <span class='neutral'></span>
  6 |     | <span class='neutral'>/**</span>
  7 |     | <span class='neutral'> * Based on the stETH:</span>
  8 |     | <span class='neutral'> *  -   https://docs.lido.fi/contracts/lido#</span>
  9 |     | <span class='neutral'> */</span>
 10 |     | <span class='neutral'>interface ICollateralToken is IERC20 {</span>
 11 |     | <span class='neutral'>    // Returns the amount of shares that corresponds to _ethAmount protocol-controlled Ether</span>
 12 |     | <span class='neutral'>    function getSharesByPooledEth(uint256 _ethAmount) external view returns (uint256);</span>
 13 |     | <span class='neutral'></span>
 14 |     | <span class='neutral'>    // Returns the amount of Ether that corresponds to _sharesAmount token shares</span>
 15 |     | <span class='neutral'>    function getPooledEthByShares(uint256 _sharesAmount) external view returns (uint256);</span>
 16 |     | <span class='neutral'></span>
 17 |     | <span class='neutral'>    // Moves `_sharesAmount` token shares from the caller&#39;s account to the `_recipient` account.</span>
 18 |     | <span class='neutral'>    function transferShares(address _recipient, uint256 _sharesAmount) external returns (uint256);</span>
 19 |     | <span class='neutral'></span>
 20 |     | <span class='neutral'>    // Returns the amount of shares owned by _account</span>
 21 |     | <span class='neutral'>    function sharesOf(address _account) external view returns (uint256);</span>
 22 |     | <span class='neutral'></span>
 23 |     | <span class='neutral'>    // Returns authorized oracle address</span>
 24 |     | <span class='neutral'>    function getOracle() external view returns (address);</span>
 25 |     | <span class='neutral'>}</span>
 26 |     | <span class='neutral'></span>

</code>
<br />

<b>/mnt/c/Users/Lourens/Documents/Recon-Fuzz/collabs/ebtc/packages/contracts/contracts/Dependencies/ICollateralTokenOracle.sol</b>
<code>
  1 |     | <span class='neutral'>// SPDX-License-Identifier: MIT</span>
  2 |     | <span class='neutral'>pragma solidity 0.8.17;</span>
  3 |     | <span class='neutral'></span>
  4 |     | <span class='neutral'>/**</span>
  5 |     | <span class='neutral'> * Based on the stETH:</span>
  6 |     | <span class='neutral'> *  -   https://docs.lido.fi/contracts/lido#</span>
  7 |     | <span class='neutral'> */</span>
  8 |     | <span class='neutral'>interface ICollateralTokenOracle {</span>
  9 |     | <span class='neutral'>    // Return beacon specification data.</span>
 10 |     | <span class='neutral'>    function getBeaconSpec()</span>
 11 |     | <span class='neutral'>        external</span>
 12 |     | <span class='neutral'>        view</span>
 13 |     | <span class='neutral'>        returns (</span>
 14 |     | <span class='neutral'>            uint64 epochsPerFrame,</span>
 15 |     | <span class='neutral'>            uint64 slotsPerEpoch,</span>
 16 |     | <span class='neutral'>            uint64 secondsPerSlot,</span>
 17 |     | <span class='neutral'>            uint64 genesisTime</span>
 18 |     | <span class='neutral'>        );</span>
 19 |     | <span class='neutral'>}</span>
 20 |     | <span class='neutral'></span>

</code>
<br />

<b>/mnt/c/Users/Lourens/Documents/Recon-Fuzz/collabs/ebtc/packages/contracts/contracts/Dependencies/IERC20.sol</b>
<code>
  1 |     | <span class='neutral'>// SPDX-License-Identifier: MIT</span>
  2 |     | <span class='neutral'></span>
  3 |     | <span class='neutral'>pragma solidity 0.8.17;</span>
  4 |     | <span class='neutral'></span>
  5 |     | <span class='neutral'>/**</span>
  6 |     | <span class='neutral'> * Based on the OpenZeppelin IER20 interface:</span>
  7 |     | <span class='neutral'> * https://github.com/OpenZeppelin/openzeppelin-contracts/blob/master/contracts/token/ERC20/IERC20.sol</span>
  8 |     | <span class='neutral'> *</span>
  9 |     | <span class='neutral'> * @dev Interface of the ERC20 standard as defined in the EIP.</span>
 10 |     | <span class='neutral'> */</span>
 11 |     | <span class='neutral'>interface IERC20 {</span>
 12 |     | <span class='neutral'>    /**</span>
 13 |     | <span class='neutral'>     * @dev Returns the amount of tokens in existence.</span>
 14 |     | <span class='neutral'>     */</span>
 15 |     | <span class='neutral'>    function totalSupply() external view returns (uint256);</span>
 16 |     | <span class='neutral'></span>
 17 |     | <span class='neutral'>    /**</span>
 18 |     | <span class='neutral'>     * @dev Returns the amount of tokens owned by `account`.</span>
 19 |     | <span class='neutral'>     */</span>
 20 |     | <span class='neutral'>    function balanceOf(address account) external view returns (uint256);</span>
 21 |     | <span class='neutral'></span>
 22 |     | <span class='neutral'>    /**</span>
 23 |     | <span class='neutral'>     * @dev Moves `amount` tokens from the caller&#39;s account to `recipient`.</span>
 24 |     | <span class='neutral'>     *</span>
 25 |     | <span class='neutral'>     * Returns a boolean value indicating whether the operation succeeded.</span>
 26 |     | <span class='neutral'>     *</span>
 27 |     | <span class='neutral'>     * Emits a {Transfer} event.</span>
 28 |     | <span class='neutral'>     */</span>
 29 |     | <span class='neutral'>    function transfer(address recipient, uint256 amount) external returns (bool);</span>
 30 |     | <span class='neutral'></span>
 31 |     | <span class='neutral'>    /**</span>
 32 |     | <span class='neutral'>     * @dev Returns the remaining number of tokens that `spender` will be</span>
 33 |     | <span class='neutral'>     * allowed to spend on behalf of `owner` through {transferFrom}. This is</span>
 34 |     | <span class='neutral'>     * zero by default.</span>
 35 |     | <span class='neutral'>     *</span>
 36 |     | <span class='neutral'>     * This value changes when {approve} or {transferFrom} are called.</span>
 37 |     | <span class='neutral'>     */</span>
 38 |     | <span class='neutral'>    function allowance(address owner, address spender) external view returns (uint256);</span>
 39 |     | <span class='neutral'></span>
 40 |     | <span class='neutral'>    function increaseAllowance(address spender, uint256 addedValue) external returns (bool);</span>
 41 |     | <span class='neutral'></span>
 42 |     | <span class='neutral'>    function decreaseAllowance(address spender, uint256 subtractedValue) external returns (bool);</span>
 43 |     | <span class='neutral'></span>
 44 |     | <span class='neutral'>    /**</span>
 45 |     | <span class='neutral'>     * @dev Sets `amount` as the allowance of `spender` over the caller&#39;s tokens.</span>
 46 |     | <span class='neutral'>     *</span>
 47 |     | <span class='neutral'>     * Returns a boolean value indicating whether the operation succeeded.</span>
 48 |     | <span class='neutral'>     *</span>
 49 |     | <span class='neutral'>     * IMPORTANT: Beware that changing an allowance with this method brings the risk</span>
 50 |     | <span class='neutral'>     * that someone may use both the old and the new allowance by unfortunate</span>
 51 |     | <span class='neutral'>     * transaction ordering. One possible solution to mitigate this race</span>
 52 |     | <span class='neutral'>     * condition is to first reduce the spender&#39;s allowance to 0 and set the</span>
 53 |     | <span class='neutral'>     * desired value afterwards:</span>
 54 |     | <span class='neutral'>     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729</span>
 55 |     | <span class='neutral'>     *</span>
 56 |     | <span class='neutral'>     * Emits an {Approval} event.</span>
 57 |     | <span class='neutral'>     */</span>
 58 |     | <span class='neutral'>    function approve(address spender, uint256 amount) external returns (bool);</span>
 59 |     | <span class='neutral'></span>
 60 |     | <span class='neutral'>    /**</span>
 61 |     | <span class='neutral'>     * @dev Moves `amount` tokens from `sender` to `recipient` using the</span>
 62 |     | <span class='neutral'>     * allowance mechanism. `amount` is then deducted from the caller&#39;s</span>
 63 |     | <span class='neutral'>     * allowance.</span>
 64 |     | <span class='neutral'>     *</span>
 65 |     | <span class='neutral'>     * Returns a boolean value indicating whether the operation succeeded.</span>
 66 |     | <span class='neutral'>     *</span>
 67 |     | <span class='neutral'>     * Emits a {Transfer} event.</span>
 68 |     | <span class='neutral'>     */</span>
 69 |     | <span class='neutral'>    function transferFrom(address sender, address recipient, uint256 amount) external returns (bool);</span>
 70 |     | <span class='neutral'></span>
 71 |     | <span class='neutral'>    function name() external view returns (string memory);</span>
 72 |     | <span class='neutral'></span>
 73 |     | <span class='neutral'>    function symbol() external view returns (string memory);</span>
 74 |     | <span class='neutral'></span>
 75 |     | <span class='neutral'>    function decimals() external view returns (uint8);</span>
 76 |     | <span class='neutral'></span>
 77 |     | <span class='neutral'>    /**</span>
 78 |     | <span class='neutral'>     * @dev Emitted when `value` tokens are moved from one account (`from`) to</span>
 79 |     | <span class='neutral'>     * another (`to`).</span>
 80 |     | <span class='neutral'>     *</span>
 81 |     | <span class='neutral'>     * Note that `value` may be zero.</span>
 82 |     | <span class='neutral'>     */</span>
 83 |     | <span class='neutral'>    event Transfer(address indexed from, address indexed to, uint256 value);</span>
 84 |     | <span class='neutral'></span>
 85 |     | <span class='neutral'>    /**</span>
 86 |     | <span class='neutral'>     * @dev Emitted when the allowance of a `spender` for an `owner` is set by</span>
 87 |     | <span class='neutral'>     * a call to {approve}. `value` is the new allowance.</span>
 88 |     | <span class='neutral'>     */</span>
 89 |     | <span class='neutral'>    event Approval(address indexed owner, address indexed spender, uint256 value);</span>
 90 |     | <span class='neutral'>}</span>
 91 |     | <span class='neutral'></span>

</code>
<br />

<b>/mnt/c/Users/Lourens/Documents/Recon-Fuzz/collabs/ebtc/packages/contracts/contracts/Dependencies/IERC2612.sol</b>
<code>
  1 |     | <span class='neutral'>// SPDX-License-Identifier: MIT</span>
  2 |     | <span class='neutral'></span>
  3 |     | <span class='neutral'>pragma solidity 0.8.17;</span>
  4 |     | <span class='neutral'></span>
  5 |     | <span class='neutral'>/**</span>
  6 |     | <span class='neutral'> * @dev Interface of the ERC2612 standard as defined in the EIP.</span>
  7 |     | <span class='neutral'> *</span>
  8 |     | <span class='neutral'> * Adds the {permit} method, which can be used to change one&#39;s</span>
  9 |     | <span class='neutral'> * {IERC20-allowance} without having to send a transaction, by signing a</span>
 10 |     | <span class='neutral'> * message. This allows users to spend tokens without having to hold Ether.</span>
 11 |     | <span class='neutral'> *</span>
 12 |     | <span class='neutral'> * See https://eips.ethereum.org/EIPS/eip-2612.</span>
 13 |     | <span class='neutral'> *</span>
 14 |     | <span class='neutral'> * Code adapted from https://github.com/OpenZeppelin/openzeppelin-contracts/pull/2237/</span>
 15 |     | <span class='neutral'> */</span>
 16 |     | <span class='neutral'>interface IERC2612 {</span>
 17 |     | <span class='neutral'>    /**</span>
 18 |     | <span class='neutral'>     * @dev Sets `amount` as the allowance of `spender` over `owner`&#39;s tokens,</span>
 19 |     | <span class='neutral'>     * given `owner`&#39;s signed approval.</span>
 20 |     | <span class='neutral'>     *</span>
 21 |     | <span class='neutral'>     * IMPORTANT: The same issues {IERC20-approve} has related to transaction</span>
 22 |     | <span class='neutral'>     * ordering also apply here.</span>
 23 |     | <span class='neutral'>     *</span>
 24 |     | <span class='neutral'>     * Emits an {Approval} event.</span>
 25 |     | <span class='neutral'>     *</span>
 26 |     | <span class='neutral'>     * Requirements:</span>
 27 |     | <span class='neutral'>     *</span>
 28 |     | <span class='neutral'>     * - `owner` cannot be the zero address.</span>
 29 |     | <span class='neutral'>     * - `spender` cannot be the zero address.</span>
 30 |     | <span class='neutral'>     * - `deadline` must be a timestamp in the future.</span>
 31 |     | <span class='neutral'>     * - `v`, `r` and `s` must be a valid `secp256k1` signature from `owner`</span>
 32 |     | <span class='neutral'>     * over the EIP712-formatted function arguments.</span>
 33 |     | <span class='neutral'>     * - the signature must use ``owner``&#39;s current nonce (see {nonces}).</span>
 34 |     | <span class='neutral'>     *</span>
 35 |     | <span class='neutral'>     * For more information on the signature format, see the</span>
 36 |     | <span class='neutral'>     * https://eips.ethereum.org/EIPS/eip-2612#specification[relevant EIP</span>
 37 |     | <span class='neutral'>     * section].</span>
 38 |     | <span class='neutral'>     */</span>
 39 |     | <span class='neutral'>    function permit(</span>
 40 |     | <span class='neutral'>        address owner,</span>
 41 |     | <span class='neutral'>        address spender,</span>
 42 |     | <span class='neutral'>        uint256 amount,</span>
 43 |     | <span class='neutral'>        uint256 deadline,</span>
 44 |     | <span class='neutral'>        uint8 v,</span>
 45 |     | <span class='neutral'>        bytes32 r,</span>
 46 |     | <span class='neutral'>        bytes32 s</span>
 47 |     | <span class='neutral'>    ) external;</span>
 48 |     | <span class='neutral'></span>
 49 |     | <span class='neutral'>    /**</span>
 50 |     | <span class='neutral'>     * @dev Returns the current ERC2612 nonce for `owner`. This value must be</span>
 51 |     | <span class='neutral'>     * included whenever a signature is generated for {permit}.</span>
 52 |     | <span class='neutral'>     *</span>
 53 |     | <span class='neutral'>     * Every successful call to {permit} increases `owner`&#39;s nonce by one. This</span>
 54 |     | <span class='neutral'>     * prevents a signature from being used multiple times.</span>
 55 |     | <span class='neutral'>     *</span>
 56 |     | <span class='neutral'>     * `owner` can limit the time a Permit is valid for by setting `deadline` to</span>
 57 |     | <span class='neutral'>     * a value in the near future. The deadline argument can be set to uint256(-1) to</span>
 58 |     | <span class='neutral'>     * create Permits that effectively never expire.</span>
 59 |     | <span class='neutral'>     */</span>
 60 |     | <span class='neutral'>    function nonces(address owner) external view returns (uint256);</span>
 61 |     | <span class='neutral'></span>
 62 |     | <span class='neutral'>    function version() external view returns (string memory);</span>
 63 |     | <span class='neutral'></span>
 64 |     | <span class='neutral'>    function permitTypeHash() external view returns (bytes32);</span>
 65 |     | <span class='neutral'></span>
 66 |     | <span class='neutral'>    function domainSeparator() external view returns (bytes32);</span>
 67 |     | <span class='neutral'>}</span>
 68 |     | <span class='neutral'></span>

</code>
<br />

<b>/mnt/c/Users/Lourens/Documents/Recon-Fuzz/collabs/ebtc/packages/contracts/contracts/Dependencies/IRolesAuthority.sol</b>
<code>
  1 |     | <span class='neutral'>// SPDX-License-Identifier: AGPL-3.0-only</span>
  2 |     | <span class='neutral'>pragma solidity 0.8.17;</span>
  3 |     | <span class='neutral'></span>
  4 |     | <span class='neutral'>import &quot;./EnumerableSet.sol&quot;;</span>
  5 |     | <span class='neutral'></span>
  6 |     | <span class='neutral'>/// @notice Role based Authority that supports up to 256 roles.</span>
  7 |     | <span class='neutral'>/// @author BadgerDAO</span>
  8 |     | <span class='neutral'>/// @author Modified from Solmate (https://github.com/transmissions11/solmate/blob/main/src/auth/authorities/RolesAuthority.sol)</span>
  9 |     | <span class='neutral'>/// @author Modified from Dappsys (https://github.com/dapphub/ds-roles/blob/master/src/roles.sol)</span>
 10 |     | <span class='neutral'>interface IRolesAuthority {</span>
 11 |     | <span class='neutral'>    event UserRoleUpdated(address indexed user, uint8 indexed role, bool enabled);</span>
 12 |     | <span class='neutral'></span>
 13 |     | <span class='neutral'>    event PublicCapabilityUpdated(address indexed target, bytes4 indexed functionSig, bool enabled);</span>
 14 |     | <span class='neutral'>    event CapabilityBurned(address indexed target, bytes4 indexed functionSig);</span>
 15 |     | <span class='neutral'></span>
 16 |     | <span class='neutral'>    event RoleCapabilityUpdated(</span>
 17 |     | <span class='neutral'>        uint8 indexed role,</span>
 18 |     | <span class='neutral'>        address indexed target,</span>
 19 |     | <span class='neutral'>        bytes4 indexed functionSig,</span>
 20 |     | <span class='neutral'>        bool enabled</span>
 21 |     | <span class='neutral'>    );</span>
 22 |     | <span class='neutral'></span>
 23 |     | <span class='neutral'>    enum CapabilityFlag {</span>
 24 |     | <span class='neutral'>        None,</span>
 25 |     | <span class='neutral'>        Public,</span>
 26 |     | <span class='neutral'>        Burned</span>
 27 |     | <span class='neutral'>    }</span>
 28 |     | <span class='neutral'>}</span>
 29 |     | <span class='neutral'></span>

</code>
<br />

<b>/mnt/c/Users/Lourens/Documents/Recon-Fuzz/collabs/ebtc/packages/contracts/contracts/Dependencies/Ownable.sol</b>
<code>
  1 |     | <span class='neutral'>// SPDX-License-Identifier: MIT</span>
  2 |     | <span class='neutral'>// OpenZeppelin Contracts (last updated v4.7.0) (access/Ownable.sol)</span>
  3 |     | <span class='neutral'></span>
  4 |     | <span class='neutral'>pragma solidity 0.8.17;</span>
  5 |     | <span class='neutral'></span>
  6 |     | <span class='neutral'>import &quot;./Context.sol&quot;;</span>
  7 |     | <span class='neutral'></span>
  8 |     | <span class='neutral'>/**</span>
  9 |     | <span class='neutral'> * @dev Contract module which provides a basic access control mechanism, where</span>
 10 |     | <span class='neutral'> * there is an account (an owner) that can be granted exclusive access to</span>
 11 |     | <span class='neutral'> * specific functions.</span>
 12 |     | <span class='neutral'> *</span>
 13 |     | <span class='neutral'> * By default, the owner account will be the one that deploys the contract. This</span>
 14 |     | <span class='neutral'> * can later be changed with {transferOwnership}.</span>
 15 |     | <span class='neutral'> *</span>
 16 |     | <span class='neutral'> * This module is used through inheritance. It will make available the modifier</span>
 17 |     | <span class='neutral'> * `onlyOwner`, which can be applied to your functions to restrict their use to</span>
 18 |     | <span class='neutral'> * the owner.</span>
 19 |     | <span class='neutral'> */</span>
 20 |     | <span class='neutral'>abstract contract Ownable is Context {</span>
 21 |     | <span class='neutral'>    address private _owner;</span>
 22 |     | <span class='neutral'></span>
 23 |     | <span class='neutral'>    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);</span>
 24 |     | <span class='neutral'></span>
 25 |     | <span class='neutral'>    /**</span>
 26 |     | <span class='neutral'>     * @dev Initializes the contract setting the deployer as the initial owner.</span>
 27 |     | <span class='neutral'>     */</span>
 28 |     | <span class='neutral'>    constructor() {</span>
 29 |     | <span class='unexecuted'>        _transferOwnership(_msgSender());</span>
 30 |     | <span class='neutral'>    }</span>
 31 |     | <span class='neutral'></span>
 32 |     | <span class='neutral'>    /**</span>
 33 |     | <span class='neutral'>     * @dev Throws if called by any account other than the owner.</span>
 34 |     | <span class='neutral'>     */</span>
 35 |     | <span class='neutral'>    modifier onlyOwner() {</span>
 36 |     | <span class='unexecuted'>        _checkOwner();</span>
 37 |     | <span class='neutral'>        _;</span>
 38 |     | <span class='neutral'>    }</span>
 39 |     | <span class='neutral'></span>
 40 |     | <span class='neutral'>    /**</span>
 41 |     | <span class='neutral'>     * @dev Returns the address of the current owner.</span>
 42 |     | <span class='neutral'>     */</span>
 43 |     | <span class='unexecuted'>    function owner() public view virtual returns (address) {</span>
 44 |     | <span class='unexecuted'>        return _owner;</span>
 45 |     | <span class='neutral'>    }</span>
 46 |     | <span class='neutral'></span>
 47 |     | <span class='neutral'>    /**</span>
 48 |     | <span class='neutral'>     * @dev Throws if the sender is not the owner.</span>
 49 |     | <span class='neutral'>     */</span>
 50 |     | <span class='unexecuted'>    function _checkOwner() internal view virtual {</span>
 51 |     | <span class='unexecuted'>        require(owner() == _msgSender(), &quot;Ownable: caller is not the owner&quot;);</span>
 52 |     | <span class='neutral'>    }</span>
 53 |     | <span class='neutral'></span>
 54 |     | <span class='neutral'>    /**</span>
 55 |     | <span class='neutral'>     * @dev Leaves the contract without owner. It will not be possible to call</span>
 56 |     | <span class='neutral'>     * `onlyOwner` functions anymore. Can only be called by the current owner.</span>
 57 |     | <span class='neutral'>     *</span>
 58 |     | <span class='neutral'>     * NOTE: Renouncing ownership will leave the contract without an owner,</span>
 59 |     | <span class='neutral'>     * thereby removing any functionality that is only available to the owner.</span>
 60 |     | <span class='neutral'>     */</span>
 61 |     | <span class='unexecuted'>    function renounceOwnership() public virtual onlyOwner {</span>
 62 |     | <span class='unexecuted'>        _transferOwnership(address(0));</span>
 63 |     | <span class='neutral'>    }</span>
 64 |     | <span class='neutral'></span>
 65 |     | <span class='neutral'>    /**</span>
 66 |     | <span class='neutral'>     * @dev Transfers ownership of the contract to a new account (`newOwner`).</span>
 67 |     | <span class='neutral'>     * Can only be called by the current owner.</span>
 68 |     | <span class='neutral'>     */</span>
 69 |     | <span class='unexecuted'>    function transferOwnership(address newOwner) public virtual onlyOwner {</span>
 70 |     | <span class='unexecuted'>        require(newOwner != address(0), &quot;Ownable: new owner is the zero address&quot;);</span>
 71 |     | <span class='unexecuted'>        _transferOwnership(newOwner);</span>
 72 |     | <span class='neutral'>    }</span>
 73 |     | <span class='neutral'></span>
 74 |     | <span class='neutral'>    /**</span>
 75 |     | <span class='neutral'>     * @dev Transfers ownership of the contract to a new account (`newOwner`).</span>
 76 |     | <span class='neutral'>     * Internal function without access restriction.</span>
 77 |     | <span class='neutral'>     */</span>
 78 |     | <span class='unexecuted'>    function _transferOwnership(address newOwner) internal virtual {</span>
 79 |     | <span class='unexecuted'>        address oldOwner = _owner;</span>
 80 |     | <span class='unexecuted'>        _owner = newOwner;</span>
 81 |     | <span class='unexecuted'>        emit OwnershipTransferred(oldOwner, newOwner);</span>
 82 |     | <span class='neutral'>    }</span>
 83 |     | <span class='neutral'>}</span>
 84 |     | <span class='neutral'></span>

</code>
<br />

<b>/mnt/c/Users/Lourens/Documents/Recon-Fuzz/collabs/ebtc/packages/contracts/contracts/Dependencies/PermitNonce.sol</b>
<code>
  1 |     | <span class='neutral'>// SPDX-License-Identifier: MIT</span>
  2 |     | <span class='neutral'></span>
  3 |     | <span class='neutral'>pragma solidity 0.8.17;</span>
  4 |     | <span class='neutral'>import &quot;../Interfaces/IPermitNonce.sol&quot;;</span>
  5 |     | <span class='neutral'></span>
  6 |     | <span class='neutral'>/**</span>
  7 |     | <span class='neutral'> * @dev This abstract contract provides a mapping from address to nonce (uint256) used for permit signature</span>
  8 |     | <span class='neutral'> */</span>
  9 |     | <span class='unexecuted'>contract PermitNonce is IPermitNonce {</span>
 10 |     | <span class='neutral'>    mapping(address =&gt; uint256) internal _nonces;</span>
 11 |     | <span class='neutral'></span>
 12 |     | <span class='neutral'>    /// @dev Increase current nonce for msg.sender by one.</span>
 13 |     | <span class='neutral'>    /// @notice This function could be used to invalidate any signed permit out there</span>
 14 |     | <span class='unexecuted'>    function increasePermitNonce() external returns (uint256) {</span>
 15 |     | <span class='unexecuted'>        return ++_nonces[msg.sender];</span>
 16 |     | <span class='neutral'>    }</span>
 17 |     | <span class='neutral'></span>
 18 |     | <span class='neutral'>    /// @dev Return current nonce for msg.sender fOR EIP-2612 compatibility</span>
 19 |     | <span class='unexecuted'>    function nonces(address owner) external view virtual returns (uint256) {</span>
 20 |     | <span class='unexecuted'>        return _nonces[owner];</span>
 21 |     | <span class='neutral'>    }</span>
 22 |     | <span class='neutral'>}</span>
 23 |     | <span class='neutral'></span>

</code>
<br />

<b>/mnt/c/Users/Lourens/Documents/Recon-Fuzz/collabs/ebtc/packages/contracts/contracts/Dependencies/Proxy.sol</b>
<code>
  1 |     | <span class='neutral'>// SPDX-License-Identifier: MIT</span>
  2 |     | <span class='neutral'>// OpenZeppelin Contracts (last updated v4.6.0) (proxy/Proxy.sol)</span>
  3 |     | <span class='neutral'></span>
  4 |     | <span class='neutral'>pragma solidity 0.8.17;</span>
  5 |     | <span class='neutral'></span>
  6 |     | <span class='neutral'>/**</span>
  7 |     | <span class='neutral'> * @dev This abstract contract provides a fallback function that delegates all calls to another contract using the EVM</span>
  8 |     | <span class='neutral'> * instruction `delegatecall`. We refer to the second contract as the _implementation_ behind the proxy, and it has to</span>
  9 |     | <span class='neutral'> * be specified by overriding the virtual {_implementation} function.</span>
 10 |     | <span class='neutral'> *</span>
 11 |     | <span class='neutral'> * Additionally, delegation to the implementation can be triggered manually through the {_fallback} function, or to a</span>
 12 |     | <span class='neutral'> * different contract through the {_delegate} function.</span>
 13 |     | <span class='neutral'> *</span>
 14 |     | <span class='neutral'> * The success and return data of the delegated call will be returned back to the caller of the proxy.</span>
 15 |     | <span class='neutral'> * @dev BadgerDAO: Simplified to the core delegation functionality, without any additional features.</span>
 16 |     | <span class='neutral'> */</span>
 17 |     | <span class='unexecuted'>contract Proxy {</span>
 18 |     | <span class='neutral'>    /**</span>
 19 |     | <span class='neutral'>     * @dev Delegates the current call to `implementation`.</span>
 20 |     | <span class='neutral'>     *</span>
 21 |     | <span class='neutral'>     * This function does not return to its internal call site, it will return directly to the external caller.</span>
 22 |     | <span class='neutral'>     */</span>
 23 |     | <span class='unexecuted'>    function _delegate(address implementation) internal virtual {</span>
 24 |     | <span class='neutral'>        assembly {</span>
 25 |     | <span class='neutral'>            // Copy msg.data. We take full control of memory in this inline assembly</span>
 26 |     | <span class='neutral'>            // block because it will not return to Solidity code. We overwrite the</span>
 27 |     | <span class='neutral'>            // Solidity scratch pad at memory position 0.</span>
 28 |     | <span class='unexecuted'>            calldatacopy(0, 0, calldatasize())</span>
 29 |     | <span class='neutral'></span>
 30 |     | <span class='neutral'>            // Call the implementation.</span>
 31 |     | <span class='neutral'>            // out and outsize are 0 because we don&#39;t know the size yet.</span>
 32 |     | <span class='unexecuted'>            let result := delegatecall(gas(), implementation, 0, calldatasize(), 0, 0)</span>
 33 |     | <span class='neutral'></span>
 34 |     | <span class='neutral'>            // Copy the returned data.</span>
 35 |     | <span class='unexecuted'>            returndatacopy(0, 0, returndatasize())</span>
 36 |     | <span class='neutral'></span>
 37 |     | <span class='unexecuted'>            switch result</span>
 38 |     | <span class='neutral'>            // delegatecall returns 0 on error.</span>
 39 |     | <span class='unexecuted'>            case 0 {</span>
 40 |     | <span class='unexecuted'>                revert(0, returndatasize())</span>
 41 |     | <span class='neutral'>            }</span>
 42 |     | <span class='neutral'>            default {</span>
 43 |     | <span class='unexecuted'>                return(0, returndatasize())</span>
 44 |     | <span class='neutral'>            }</span>
 45 |     | <span class='neutral'>        }</span>
 46 |     | <span class='neutral'>    }</span>
 47 |     | <span class='neutral'>}</span>
 48 |     | <span class='neutral'></span>

</code>
<br />

<b>/mnt/c/Users/Lourens/Documents/Recon-Fuzz/collabs/ebtc/packages/contracts/contracts/Dependencies/ReentrancyGuard.sol</b>
<code>
  1 |     | <span class='neutral'>// SPDX-License-Identifier: AGPL-3.0-only</span>
  2 |     | <span class='neutral'>pragma solidity 0.8.17;</span>
  3 |     | <span class='neutral'></span>
  4 |     | <span class='neutral'>/// @notice Gas optimized reentrancy protection for smart contracts.</span>
  5 |     | <span class='neutral'>/// @author Solmate (https://github.com/transmissions11/solmate/blob/main/src/utils/ReentrancyGuard.sol)</span>
  6 |     | <span class='neutral'>/// @author Modified from OpenZeppelin (https://github.com/OpenZeppelin/openzeppelin-contracts/blob/master/contracts/security/ReentrancyGuard.sol)</span>
  7 |     | <span class='neutral'>abstract contract ReentrancyGuard {</span>
  8 |     | <span class='unexecuted'>    uint256 internal constant OPEN = 1;</span>
  9 |     | <span class='unexecuted'>    uint256 internal constant LOCKED = 2;</span>
 10 |     | <span class='neutral'></span>
 11 |     | <span class='unexecuted'>    uint256 public locked = OPEN;</span>
 12 |     | <span class='neutral'></span>
 13 |     | <span class='neutral'>    modifier nonReentrant() virtual {</span>
 14 |     | <span class='unexecuted'>        require(locked == OPEN, &quot;ReentrancyGuard: Reentrancy in nonReentrant call&quot;);</span>
 15 |     | <span class='neutral'></span>
 16 |     | <span class='unexecuted'>        locked = LOCKED;</span>
 17 |     | <span class='neutral'></span>
 18 |     | <span class='neutral'>        _;</span>
 19 |     | <span class='neutral'></span>
 20 |     | <span class='unexecuted'>        locked = OPEN;</span>
 21 |     | <span class='neutral'>    }</span>
 22 |     | <span class='neutral'>}</span>
 23 |     | <span class='neutral'></span>

</code>
<br />

<b>/mnt/c/Users/Lourens/Documents/Recon-Fuzz/collabs/ebtc/packages/contracts/contracts/Dependencies/RolesAuthority.sol</b>
<code>
   1 |     | <span class='neutral'>// SPDX-License-Identifier: AGPL-3.0-only</span>
   2 |     | <span class='neutral'>pragma solidity 0.8.17;</span>
   3 |     | <span class='neutral'></span>
   4 |     | <span class='neutral'>import {IRolesAuthority} from &quot;./IRolesAuthority.sol&quot;;</span>
   5 |     | <span class='neutral'>import {Auth, Authority} from &quot;./Auth.sol&quot;;</span>
   6 |     | <span class='neutral'>import &quot;./EnumerableSet.sol&quot;;</span>
   7 |     | <span class='neutral'></span>
   8 |     | <span class='neutral'>/// @notice Role based Authority that supports up to 256 roles.</span>
   9 |     | <span class='neutral'>/// @author BadgerDAO</span>
  10 |     | <span class='neutral'>/// @author Modified from Solmate (https://github.com/transmissions11/solmate/blob/main/src/auth/authorities/RolesAuthority.sol)</span>
  11 |     | <span class='neutral'>/// @author Modified from Dappsys (https://github.com/dapphub/ds-roles/blob/master/src/roles.sol)</span>
  12 |     | <span class='unexecuted'>contract RolesAuthority is IRolesAuthority, Auth, Authority {</span>
  13 |     | <span class='neutral'>    using EnumerableSet for EnumerableSet.Bytes32Set;</span>
  14 |     | <span class='neutral'>    using EnumerableSet for EnumerableSet.AddressSet;</span>
  15 |     | <span class='neutral'></span>
  16 |     | <span class='neutral'>    /*//////////////////////////////////////////////////////////////</span>
  17 |     | <span class='neutral'>                               CONSTRUCTOR</span>
  18 |     | <span class='neutral'>    //////////////////////////////////////////////////////////////*/</span>
  19 |     | <span class='neutral'></span>
  20 |     | <span class='unexecuted'>    constructor(address _owner, Authority _authority) Auth(_owner, _authority) {}</span>
  21 |     | <span class='neutral'></span>
  22 |     | <span class='neutral'>    /*//////////////////////////////////////////////////////////////</span>
  23 |     | <span class='neutral'>                            ROLE/USER STORAGE</span>
  24 |     | <span class='neutral'>    //////////////////////////////////////////////////////////////*/</span>
  25 |     | <span class='neutral'></span>
  26 |     | <span class='neutral'>    EnumerableSet.AddressSet internal users;</span>
  27 |     | <span class='neutral'>    EnumerableSet.AddressSet internal targets;</span>
  28 |     | <span class='neutral'>    mapping(address =&gt; EnumerableSet.Bytes32Set) internal enabledFunctionSigsByTarget;</span>
  29 |     | <span class='neutral'></span>
  30 |     | <span class='neutral'>    EnumerableSet.Bytes32Set internal enabledFunctionSigsPublic;</span>
  31 |     | <span class='neutral'></span>
  32 | *   | <span class='executed'>    mapping(address =&gt; bytes32) public getUserRoles;</span>
  33 |     | <span class='neutral'></span>
  34 |     | <span class='unexecuted'>    mapping(address =&gt; mapping(bytes4 =&gt; CapabilityFlag)) public capabilityFlag;</span>
  35 |     | <span class='neutral'></span>
  36 |     | <span class='unexecuted'>    mapping(address =&gt; mapping(bytes4 =&gt; bytes32)) public getRolesWithCapability;</span>
  37 |     | <span class='neutral'></span>
  38 |     | <span class='unexecuted'>    function doesUserHaveRole(address user, uint8 role) public view virtual returns (bool) {</span>
  39 |     | <span class='unexecuted'>        return (uint256(getUserRoles[user]) &gt;&gt; role) &amp; 1 != 0;</span>
  40 |     | <span class='neutral'>    }</span>
  41 |     | <span class='neutral'></span>
  42 | *   | <span class='executed'>    function doesRoleHaveCapability(</span>
  43 |     | <span class='neutral'>        uint8 role,</span>
  44 |     | <span class='neutral'>        address target,</span>
  45 |     | <span class='neutral'>        bytes4 functionSig</span>
  46 |     | <span class='unexecuted'>    ) public view virtual returns (bool) {</span>
  47 |     | <span class='unexecuted'>        return (uint256(getRolesWithCapability[target][functionSig]) &gt;&gt; role) &amp; 1 != 0;</span>
  48 |     | <span class='neutral'>    }</span>
  49 |     | <span class='neutral'></span>
  50 |     | <span class='unexecuted'>    function isPublicCapability(address target, bytes4 functionSig) public view returns (bool) {</span>
  51 |     | <span class='unexecuted'>        return capabilityFlag[target][functionSig] == CapabilityFlag.Public;</span>
  52 |     | <span class='neutral'>    }</span>
  53 |     | <span class='neutral'></span>
  54 |     | <span class='neutral'>    /*//////////////////////////////////////////////////////////////</span>
  55 |     | <span class='neutral'>                           AUTHORIZATION LOGIC</span>
  56 |     | <span class='neutral'>    //////////////////////////////////////////////////////////////*/</span>
  57 |     | <span class='neutral'></span>
  58 |     | <span class='neutral'>    /**</span>
  59 |     | <span class='neutral'>        @notice A user can call a given function signature on a given target address if:</span>
  60 |     | <span class='neutral'>            - The capability has not been burned</span>
  61 |     | <span class='neutral'>            - That capability is public, or the user has a role that has been granted the capability to call the function</span>
  62 |     | <span class='neutral'>     */</span>
  63 | *   | <span class='executed'>    function canCall(</span>
  64 |     | <span class='neutral'>        address user,</span>
  65 |     | <span class='neutral'>        address target,</span>
  66 |     | <span class='neutral'>        bytes4 functionSig</span>
  67 | *   | <span class='executed'>    ) public view virtual override returns (bool) {</span>
  68 | *   | <span class='executed'>        CapabilityFlag flag = capabilityFlag[target][functionSig];</span>
  69 |     | <span class='neutral'></span>
  70 | *   | <span class='executed'>        if (flag == CapabilityFlag.Burned) {</span>
  71 |     | <span class='unexecuted'>            return false;</span>
  72 | *   | <span class='executed'>        } else if (flag == CapabilityFlag.Public) {</span>
  73 |     | <span class='unexecuted'>            return true;</span>
  74 |     | <span class='neutral'>        } else {</span>
  75 | *   | <span class='executed'>            return bytes32(0) != getUserRoles[user] &amp; getRolesWithCapability[target][functionSig];</span>
  76 |     | <span class='neutral'>        }</span>
  77 |     | <span class='neutral'>    }</span>
  78 |     | <span class='neutral'></span>
  79 |     | <span class='neutral'>    /*//////////////////////////////////////////////////////////////</span>
  80 |     | <span class='neutral'>                   ROLE CAPABILITY CONFIGURATION LOGIC</span>
  81 |     | <span class='neutral'>    //////////////////////////////////////////////////////////////*/</span>
  82 |     | <span class='neutral'></span>
  83 |     | <span class='neutral'>    /// @notice Set a capability flag as public, meaning any account can call it. Or revoke this capability.</span>
  84 |     | <span class='neutral'>    /// @dev A capability cannot be made public if it has been burned.</span>
  85 |     | <span class='unexecuted'>    function setPublicCapability(</span>
  86 |     | <span class='neutral'>        address target,</span>
  87 |     | <span class='neutral'>        bytes4 functionSig,</span>
  88 |     | <span class='neutral'>        bool enabled</span>
  89 |     | <span class='neutral'>    ) public virtual requiresAuth {</span>
  90 |     | <span class='unexecuted'>        require(</span>
  91 |     | <span class='unexecuted'>            capabilityFlag[target][functionSig] != CapabilityFlag.Burned,</span>
  92 |     | <span class='neutral'>            &quot;RolesAuthority: Capability Burned&quot;</span>
  93 |     | <span class='neutral'>        );</span>
  94 |     | <span class='neutral'></span>
  95 |     | <span class='unexecuted'>        if (enabled) {</span>
  96 |     | <span class='unexecuted'>            capabilityFlag[target][functionSig] = CapabilityFlag.Public;</span>
  97 |     | <span class='neutral'>        } else {</span>
  98 |     | <span class='unexecuted'>            capabilityFlag[target][functionSig] = CapabilityFlag.None;</span>
  99 |     | <span class='neutral'>        }</span>
 100 |     | <span class='neutral'></span>
 101 |     | <span class='unexecuted'>        emit PublicCapabilityUpdated(target, functionSig, enabled);</span>
 102 |     | <span class='neutral'>    }</span>
 103 |     | <span class='neutral'></span>
 104 |     | <span class='neutral'>    /// @notice Grant a specified role the ability to call a function on a target.</span>
 105 |     | <span class='neutral'>    /// @notice Has no effect</span>
 106 |     | <span class='unexecuted'>    function setRoleCapability(</span>
 107 |     | <span class='neutral'>        uint8 role,</span>
 108 |     | <span class='neutral'>        address target,</span>
 109 |     | <span class='neutral'>        bytes4 functionSig,</span>
 110 |     | <span class='neutral'>        bool enabled</span>
 111 |     | <span class='neutral'>    ) public virtual requiresAuth {</span>
 112 |     | <span class='unexecuted'>        if (enabled) {</span>
 113 |     | <span class='unexecuted'>            getRolesWithCapability[target][functionSig] |= bytes32(1 &lt;&lt; role);</span>
 114 |     | <span class='unexecuted'>            enabledFunctionSigsByTarget[target].add(bytes32(functionSig));</span>
 115 |     | <span class='neutral'></span>
 116 |     | <span class='unexecuted'>            if (!targets.contains(target)) {</span>
 117 |     | <span class='unexecuted'>                targets.add(target);</span>
 118 |     | <span class='neutral'>            }</span>
 119 |     | <span class='neutral'>        } else {</span>
 120 |     | <span class='unexecuted'>            getRolesWithCapability[target][functionSig] &amp;= ~bytes32(1 &lt;&lt; role);</span>
 121 |     | <span class='neutral'></span>
 122 |     | <span class='neutral'>            // If no role exist for this target &amp; functionSig, mark it as disabled</span>
 123 |     | <span class='unexecuted'>            if (getRolesWithCapability[target][functionSig] == bytes32(0)) {</span>
 124 |     | <span class='unexecuted'>                enabledFunctionSigsByTarget[target].remove(bytes32(functionSig));</span>
 125 |     | <span class='neutral'>            }</span>
 126 |     | <span class='neutral'></span>
 127 |     | <span class='neutral'>            // If no enabled function signatures exist for this target, remove target</span>
 128 |     | <span class='unexecuted'>            if (enabledFunctionSigsByTarget[target].length() == 0) {</span>
 129 |     | <span class='unexecuted'>                targets.remove(target);</span>
 130 |     | <span class='neutral'>            }</span>
 131 |     | <span class='neutral'>        }</span>
 132 |     | <span class='neutral'></span>
 133 |     | <span class='unexecuted'>        emit RoleCapabilityUpdated(role, target, functionSig, enabled);</span>
 134 |     | <span class='neutral'>    }</span>
 135 |     | <span class='neutral'></span>
 136 |     | <span class='neutral'>    /// @notice Permanently burns a capability for a target.</span>
 137 |     | <span class='unexecuted'>    function burnCapability(address target, bytes4 functionSig) public virtual requiresAuth {</span>
 138 |     | <span class='unexecuted'>        require(</span>
 139 |     | <span class='unexecuted'>            capabilityFlag[target][functionSig] != CapabilityFlag.Burned,</span>
 140 |     | <span class='neutral'>            &quot;RolesAuthority: Capability Burned&quot;</span>
 141 |     | <span class='neutral'>        );</span>
 142 |     | <span class='unexecuted'>        capabilityFlag[target][functionSig] = CapabilityFlag.Burned;</span>
 143 |     | <span class='neutral'></span>
 144 |     | <span class='unexecuted'>        emit CapabilityBurned(target, functionSig);</span>
 145 |     | <span class='neutral'>    }</span>
 146 |     | <span class='neutral'></span>
 147 |     | <span class='neutral'>    /*//////////////////////////////////////////////////////////////</span>
 148 |     | <span class='neutral'>                       USER ROLE ASSIGNMENT LOGIC</span>
 149 |     | <span class='neutral'>    //////////////////////////////////////////////////////////////*/</span>
 150 |     | <span class='neutral'></span>
 151 |     | <span class='unexecuted'>    function setUserRole(address user, uint8 role, bool enabled) public virtual requiresAuth {</span>
 152 |     | <span class='unexecuted'>        if (enabled) {</span>
 153 |     | <span class='unexecuted'>            getUserRoles[user] |= bytes32(1 &lt;&lt; role);</span>
 154 |     | <span class='neutral'></span>
 155 |     | <span class='unexecuted'>            if (!users.contains(user)) {</span>
 156 |     | <span class='unexecuted'>                users.add(user);</span>
 157 |     | <span class='neutral'>            }</span>
 158 |     | <span class='neutral'>        } else {</span>
 159 |     | <span class='unexecuted'>            getUserRoles[user] &amp;= ~bytes32(1 &lt;&lt; role);</span>
 160 |     | <span class='neutral'></span>
 161 |     | <span class='neutral'>            // Remove user if no more roles</span>
 162 |     | <span class='unexecuted'>            if (getUserRoles[user] == bytes32(0)) {</span>
 163 |     | <span class='unexecuted'>                users.remove(user);</span>
 164 |     | <span class='neutral'>            }</span>
 165 |     | <span class='neutral'>        }</span>
 166 |     | <span class='neutral'></span>
 167 |     | <span class='unexecuted'>        emit UserRoleUpdated(user, role, enabled);</span>
 168 |     | <span class='neutral'>    }</span>
 169 |     | <span class='neutral'>}</span>
 170 |     | <span class='neutral'></span>

</code>
<br />

<b>/mnt/c/Users/Lourens/Documents/Recon-Fuzz/collabs/ebtc/packages/contracts/contracts/Dependencies/SafeERC20.sol</b>
<code>
  1 |     | <span class='neutral'>// SPDX-License-Identifier: MIT</span>
  2 |     | <span class='neutral'>// OpenZeppelin Contracts (last updated v4.8.0) (token/ERC20/utils/SafeERC20.sol)</span>
  3 |     | <span class='neutral'></span>
  4 |     | <span class='neutral'>pragma solidity 0.8.17;</span>
  5 |     | <span class='neutral'></span>
  6 |     | <span class='neutral'>import &quot;./IERC20.sol&quot;;</span>
  7 |     | <span class='neutral'>import &quot;./Address.sol&quot;;</span>
  8 |     | <span class='neutral'></span>
  9 |     | <span class='neutral'>/**</span>
 10 |     | <span class='neutral'> * @title SafeERC20</span>
 11 |     | <span class='neutral'> * @dev Wrappers around ERC20 operations that throw on failure (when the token</span>
 12 |     | <span class='neutral'> * contract returns false). Tokens that return no value (and instead revert or</span>
 13 |     | <span class='neutral'> * throw on failure) are also supported, non-reverting calls are assumed to be</span>
 14 |     | <span class='neutral'> * successful.</span>
 15 |     | <span class='neutral'> * To use this library you can add a `using SafeERC20 for IERC20;` statement to your contract,</span>
 16 |     | <span class='neutral'> * which allows you to call the safe operations as `token.safeTransfer(...)`, etc.</span>
 17 |     | <span class='neutral'> */</span>
 18 |     | <span class='unexecuted'>library SafeERC20 {</span>
 19 |     | <span class='neutral'>    using Address for address;</span>
 20 |     | <span class='neutral'></span>
 21 |     | <span class='neutral'>    /**</span>
 22 |     | <span class='neutral'>     * @dev Transfer `value` amount of `token` from the calling contract to `to`. If `token` returns no value,</span>
 23 |     | <span class='neutral'>     * non-reverting calls are assumed to be successful.</span>
 24 |     | <span class='neutral'>     */</span>
 25 |     | <span class='unexecuted'>    function safeTransfer(IERC20 token, address to, uint256 value) internal {</span>
 26 |     | <span class='unexecuted'>        _callOptionalReturn(token, abi.encodeWithSelector(token.transfer.selector, to, value));</span>
 27 |     | <span class='neutral'>    }</span>
 28 |     | <span class='neutral'></span>
 29 |     | <span class='neutral'>    /// @dev Calls approve while checking bool return value, handles no-return tokens</span>
 30 |     | <span class='neutral'>    function safeApprove(IERC20 token, address spender, uint256 amount) internal {</span>
 31 |     | <span class='neutral'>        _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, amount));</span>
 32 |     | <span class='neutral'>    }</span>
 33 |     | <span class='neutral'></span>
 34 |     | <span class='neutral'>    function safeTransferFrom(IERC20 token, address from, address to, uint256 value) internal {</span>
 35 |     | <span class='neutral'>        _callOptionalReturn(</span>
 36 |     | <span class='neutral'>            token,</span>
 37 |     | <span class='neutral'>            abi.encodeWithSelector(token.transferFrom.selector, from, to, value)</span>
 38 |     | <span class='neutral'>        );</span>
 39 |     | <span class='neutral'>    }</span>
 40 |     | <span class='neutral'></span>
 41 |     | <span class='neutral'>    /**</span>
 42 |     | <span class='neutral'>     * @dev Imitates a Solidity high-level call (i.e. a regular function call to a contract), relaxing the requirement</span>
 43 |     | <span class='neutral'>     * on the return value: the return value is optional (but if data is returned, it must not be false).</span>
 44 |     | <span class='neutral'>     * @param token The token targeted by the call.</span>
 45 |     | <span class='neutral'>     * @param data The call data (encoded using abi.encode or one of its variants).</span>
 46 |     | <span class='neutral'>     */</span>
 47 |     | <span class='unexecuted'>    function _callOptionalReturn(IERC20 token, bytes memory data) private {</span>
 48 |     | <span class='neutral'>        // We need to perform a low level call here, to bypass Solidity&#39;s return data size checking mechanism, since</span>
 49 |     | <span class='neutral'>        // we&#39;re implementing it ourselves. We use {Address-functionCall} to perform this call, which verifies that</span>
 50 |     | <span class='neutral'>        // the target address contains contract code and also asserts for success in the low-level call.</span>
 51 |     | <span class='neutral'></span>
 52 |     | <span class='unexecuted'>        bytes memory returndata = address(token).functionCall(</span>
 53 |     | <span class='unexecuted'>            data,</span>
 54 |     | <span class='neutral'>            &quot;SafeERC20: low-level call failed&quot;</span>
 55 |     | <span class='neutral'>        );</span>
 56 |     | <span class='unexecuted'>        require(</span>
 57 |     | <span class='unexecuted'>            returndata.length == 0 || abi.decode(returndata, (bool)),</span>
 58 |     | <span class='neutral'>            &quot;SafeERC20: ERC20 operation did not succeed&quot;</span>
 59 |     | <span class='neutral'>        );</span>
 60 |     | <span class='neutral'>    }</span>
 61 |     | <span class='neutral'>}</span>
 62 |     | <span class='neutral'></span>

</code>
<br />

<b>/mnt/c/Users/Lourens/Documents/Recon-Fuzz/collabs/ebtc/packages/contracts/contracts/Dependencies/SafeMath.sol</b>
<code>
   1 |     | <span class='neutral'>// SPDX-License-Identifier: MIT</span>
   2 |     | <span class='neutral'></span>
   3 |     | <span class='neutral'>pragma solidity 0.8.17;</span>
   4 |     | <span class='neutral'></span>
   5 |     | <span class='neutral'>/**</span>
   6 |     | <span class='neutral'> * Based on OpenZeppelin&#39;s SafeMath:</span>
   7 |     | <span class='neutral'> * https://github.com/OpenZeppelin/openzeppelin-contracts/blob/master/contracts/math/SafeMath.sol</span>
   8 |     | <span class='neutral'> *</span>
   9 |     | <span class='neutral'> * @dev Wrappers over Solidity&#39;s arithmetic operations with added overflow</span>
  10 |     | <span class='neutral'> * checks.</span>
  11 |     | <span class='neutral'> *</span>
  12 |     | <span class='neutral'> * Arithmetic operations in Solidity wrap on overflow. This can easily result</span>
  13 |     | <span class='neutral'> * in bugs, because programmers usually assume that an overflow raises an</span>
  14 |     | <span class='neutral'> * error, which is the standard behavior in high level programming languages.</span>
  15 |     | <span class='neutral'> * `SafeMath` restores this intuition by reverting the transaction when an</span>
  16 |     | <span class='neutral'> * operation overflows.</span>
  17 |     | <span class='neutral'> *</span>
  18 |     | <span class='neutral'> * Using this library instead of the unchecked operations eliminates an entire</span>
  19 |     | <span class='neutral'> * class of bugs, so it&#39;s recommended to use it always.</span>
  20 |     | <span class='neutral'> */</span>
  21 |     | <span class='unexecuted'>library SafeMath {</span>
  22 |     | <span class='neutral'>    /**</span>
  23 |     | <span class='neutral'>     * @dev Returns the addition of two unsigned integers, reverting on</span>
  24 |     | <span class='neutral'>     * overflow.</span>
  25 |     | <span class='neutral'>     *</span>
  26 |     | <span class='neutral'>     * Counterpart to Solidity&#39;s `+` operator.</span>
  27 |     | <span class='neutral'>     *</span>
  28 |     | <span class='neutral'>     * Requirements:</span>
  29 |     | <span class='neutral'>     * - Addition cannot overflow.</span>
  30 |     | <span class='neutral'>     */</span>
  31 |     | <span class='neutral'>    function add(uint256 a, uint256 b) internal pure returns (uint256) {</span>
  32 |     | <span class='neutral'>        uint256 c = a + b;</span>
  33 |     | <span class='neutral'>        require(c &gt;= a, &quot;SafeMath: addition overflow&quot;);</span>
  34 |     | <span class='neutral'></span>
  35 |     | <span class='neutral'>        return c;</span>
  36 |     | <span class='neutral'>    }</span>
  37 |     | <span class='neutral'></span>
  38 |     | <span class='neutral'>    /**</span>
  39 |     | <span class='neutral'>     * @dev Returns the subtraction of two unsigned integers, reverting on</span>
  40 |     | <span class='neutral'>     * overflow (when the result is negative).</span>
  41 |     | <span class='neutral'>     *</span>
  42 |     | <span class='neutral'>     * Counterpart to Solidity&#39;s `-` operator.</span>
  43 |     | <span class='neutral'>     *</span>
  44 |     | <span class='neutral'>     * Requirements:</span>
  45 |     | <span class='neutral'>     * - Subtraction cannot overflow.</span>
  46 |     | <span class='neutral'>     */</span>
  47 |     | <span class='neutral'>    function sub(uint256 a, uint256 b) internal pure returns (uint256) {</span>
  48 |     | <span class='neutral'>        return sub(a, b, &quot;SafeMath: subtraction overflow&quot;);</span>
  49 |     | <span class='neutral'>    }</span>
  50 |     | <span class='neutral'></span>
  51 |     | <span class='neutral'>    /**</span>
  52 |     | <span class='neutral'>     * @dev Returns the subtraction of two unsigned integers, reverting with custom message on</span>
  53 |     | <span class='neutral'>     * overflow (when the result is negative).</span>
  54 |     | <span class='neutral'>     *</span>
  55 |     | <span class='neutral'>     * Counterpart to Solidity&#39;s `-` operator.</span>
  56 |     | <span class='neutral'>     *</span>
  57 |     | <span class='neutral'>     * Requirements:</span>
  58 |     | <span class='neutral'>     * - Subtraction cannot overflow.</span>
  59 |     | <span class='neutral'>     *</span>
  60 |     | <span class='neutral'>     * _Available since v2.4.0._</span>
  61 |     | <span class='neutral'>     */</span>
  62 |     | <span class='neutral'>    function sub(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {</span>
  63 |     | <span class='neutral'>        require(b &lt;= a, errorMessage);</span>
  64 |     | <span class='neutral'>        uint256 c = a - b;</span>
  65 |     | <span class='neutral'></span>
  66 |     | <span class='neutral'>        return c;</span>
  67 |     | <span class='neutral'>    }</span>
  68 |     | <span class='neutral'></span>
  69 |     | <span class='neutral'>    /**</span>
  70 |     | <span class='neutral'>     * @dev Returns the multiplication of two unsigned integers, reverting on</span>
  71 |     | <span class='neutral'>     * overflow.</span>
  72 |     | <span class='neutral'>     *</span>
  73 |     | <span class='neutral'>     * Counterpart to Solidity&#39;s `*` operator.</span>
  74 |     | <span class='neutral'>     *</span>
  75 |     | <span class='neutral'>     * Requirements:</span>
  76 |     | <span class='neutral'>     * - Multiplication cannot overflow.</span>
  77 |     | <span class='neutral'>     */</span>
  78 |     | <span class='neutral'>    function mul(uint256 a, uint256 b) internal pure returns (uint256) {</span>
  79 |     | <span class='neutral'>        // Gas optimization: this is cheaper than requiring &#39;a&#39; not being zero, but the</span>
  80 |     | <span class='neutral'>        // benefit is lost if &#39;b&#39; is also tested.</span>
  81 |     | <span class='neutral'>        // See: https://github.com/OpenZeppelin/openzeppelin-contracts/pull/522</span>
  82 |     | <span class='neutral'>        if (a == 0) {</span>
  83 |     | <span class='neutral'>            return 0;</span>
  84 |     | <span class='neutral'>        }</span>
  85 |     | <span class='neutral'></span>
  86 |     | <span class='neutral'>        uint256 c = a * b;</span>
  87 |     | <span class='neutral'>        require(c / a == b, &quot;SafeMath: multiplication overflow&quot;);</span>
  88 |     | <span class='neutral'></span>
  89 |     | <span class='neutral'>        return c;</span>
  90 |     | <span class='neutral'>    }</span>
  91 |     | <span class='neutral'></span>
  92 |     | <span class='neutral'>    /**</span>
  93 |     | <span class='neutral'>     * @dev Returns the integer division of two unsigned integers. Reverts on</span>
  94 |     | <span class='neutral'>     * division by zero. The result is rounded towards zero.</span>
  95 |     | <span class='neutral'>     *</span>
  96 |     | <span class='neutral'>     * Counterpart to Solidity&#39;s `/` operator. Note: this function uses a</span>
  97 |     | <span class='neutral'>     * `revert` opcode (which leaves remaining gas untouched) while Solidity</span>
  98 |     | <span class='neutral'>     * uses an invalid opcode to revert (consuming all remaining gas).</span>
  99 |     | <span class='neutral'>     *</span>
 100 |     | <span class='neutral'>     * Requirements:</span>
 101 |     | <span class='neutral'>     * - The divisor cannot be zero.</span>
 102 |     | <span class='neutral'>     */</span>
 103 |     | <span class='neutral'>    function div(uint256 a, uint256 b) internal pure returns (uint256) {</span>
 104 |     | <span class='neutral'>        return div(a, b, &quot;SafeMath: division by zero&quot;);</span>
 105 |     | <span class='neutral'>    }</span>
 106 |     | <span class='neutral'></span>
 107 |     | <span class='neutral'>    /**</span>
 108 |     | <span class='neutral'>     * @dev Returns the integer division of two unsigned integers. Reverts with custom message on</span>
 109 |     | <span class='neutral'>     * division by zero. The result is rounded towards zero.</span>
 110 |     | <span class='neutral'>     *</span>
 111 |     | <span class='neutral'>     * Counterpart to Solidity&#39;s `/` operator. Note: this function uses a</span>
 112 |     | <span class='neutral'>     * `revert` opcode (which leaves remaining gas untouched) while Solidity</span>
 113 |     | <span class='neutral'>     * uses an invalid opcode to revert (consuming all remaining gas).</span>
 114 |     | <span class='neutral'>     *</span>
 115 |     | <span class='neutral'>     * Requirements:</span>
 116 |     | <span class='neutral'>     * - The divisor cannot be zero.</span>
 117 |     | <span class='neutral'>     *</span>
 118 |     | <span class='neutral'>     * _Available since v2.4.0._</span>
 119 |     | <span class='neutral'>     */</span>
 120 |     | <span class='neutral'>    function div(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {</span>
 121 |     | <span class='neutral'>        // Solidity only automatically asserts when dividing by 0</span>
 122 |     | <span class='neutral'>        require(b &gt; 0, errorMessage);</span>
 123 |     | <span class='neutral'>        uint256 c = a / b;</span>
 124 |     | <span class='neutral'>        // assert(a == b * c + a % b); // There is no case in which this doesn&#39;t hold</span>
 125 |     | <span class='neutral'></span>
 126 |     | <span class='neutral'>        return c;</span>
 127 |     | <span class='neutral'>    }</span>
 128 |     | <span class='neutral'></span>
 129 |     | <span class='neutral'>    /**</span>
 130 |     | <span class='neutral'>     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),</span>
 131 |     | <span class='neutral'>     * Reverts when dividing by zero.</span>
 132 |     | <span class='neutral'>     *</span>
 133 |     | <span class='neutral'>     * Counterpart to Solidity&#39;s `%` operator. This function uses a `revert`</span>
 134 |     | <span class='neutral'>     * opcode (which leaves remaining gas untouched) while Solidity uses an</span>
 135 |     | <span class='neutral'>     * invalid opcode to revert (consuming all remaining gas).</span>
 136 |     | <span class='neutral'>     *</span>
 137 |     | <span class='neutral'>     * Requirements:</span>
 138 |     | <span class='neutral'>     * - The divisor cannot be zero.</span>
 139 |     | <span class='neutral'>     */</span>
 140 |     | <span class='neutral'>    function mod(uint256 a, uint256 b) internal pure returns (uint256) {</span>
 141 |     | <span class='neutral'>        return mod(a, b, &quot;SafeMath: modulo by zero&quot;);</span>
 142 |     | <span class='neutral'>    }</span>
 143 |     | <span class='neutral'></span>
 144 |     | <span class='neutral'>    /**</span>
 145 |     | <span class='neutral'>     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),</span>
 146 |     | <span class='neutral'>     * Reverts with custom message when dividing by zero.</span>
 147 |     | <span class='neutral'>     *</span>
 148 |     | <span class='neutral'>     * Counterpart to Solidity&#39;s `%` operator. This function uses a `revert`</span>
 149 |     | <span class='neutral'>     * opcode (which leaves remaining gas untouched) while Solidity uses an</span>
 150 |     | <span class='neutral'>     * invalid opcode to revert (consuming all remaining gas).</span>
 151 |     | <span class='neutral'>     *</span>
 152 |     | <span class='neutral'>     * Requirements:</span>
 153 |     | <span class='neutral'>     * - The divisor cannot be zero.</span>
 154 |     | <span class='neutral'>     *</span>
 155 |     | <span class='neutral'>     * _Available since v2.4.0._</span>
 156 |     | <span class='neutral'>     */</span>
 157 |     | <span class='neutral'>    function mod(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {</span>
 158 |     | <span class='neutral'>        require(b != 0, errorMessage);</span>
 159 |     | <span class='neutral'>        return a % b;</span>
 160 |     | <span class='neutral'>    }</span>
 161 |     | <span class='neutral'>}</span>
 162 |     | <span class='neutral'></span>

</code>
<br />

<b>/mnt/c/Users/Lourens/Documents/Recon-Fuzz/collabs/ebtc/packages/contracts/contracts/Dependencies/TwapWeightedObserver.sol</b>
<code>
   1 |     | <span class='neutral'>// SPDX-License Identifier: MIT</span>
   2 |     | <span class='neutral'>pragma solidity 0.8.17;</span>
   3 |     | <span class='neutral'>import {ITwapWeightedObserver} from &quot;../Interfaces/ITwapWeightedObserver.sol&quot;;</span>
   4 |     | <span class='neutral'></span>
   5 |     | <span class='neutral'>/// @title TwapWeightedObserver</span>
   6 |     | <span class='neutral'>/// @notice Given a value, applies a time-weighted TWAP that smooths out changes over a 7 days period</span>
   7 |     | <span class='neutral'>/// @dev Used to get the lowest value of total supply to prevent underpaying redemptions</span>
   8 |     | <span class='unexecuted'>contract TwapWeightedObserver is ITwapWeightedObserver {</span>
   9 |     | <span class='unexecuted'>    PackedData public data;</span>
  10 |     | <span class='unexecuted'>    uint128 public valueToTrack;</span>
  11 |     | <span class='unexecuted'>    bool public twapDisabled;</span>
  12 |     | <span class='neutral'></span>
  13 |     | <span class='unexecuted'>    constructor(uint128 initialValue) {</span>
  14 |     | <span class='unexecuted'>        PackedData memory cachedData = PackedData({</span>
  15 |     | <span class='neutral'>            observerCumuVal: initialValue,</span>
  16 |     | <span class='neutral'>            accumulator: initialValue,</span>
  17 |     | <span class='unexecuted'>            lastObserved: uint64(block.timestamp),</span>
  18 |     | <span class='neutral'>            lastAccrued: uint64(block.timestamp),</span>
  19 |     | <span class='neutral'>            lastObservedAverage: initialValue</span>
  20 |     | <span class='neutral'>        });</span>
  21 |     | <span class='neutral'></span>
  22 |     | <span class='unexecuted'>        valueToTrack = initialValue;</span>
  23 |     | <span class='unexecuted'>        data = cachedData;</span>
  24 |     | <span class='neutral'>    }</span>
  25 |     | <span class='neutral'></span>
  26 |     | <span class='neutral'>    /// TWAP ///</span>
  27 |     | <span class='neutral'>    event NewTrackValue(uint256 _oldValue, uint256 _newValue, uint256 _ts, uint256 _newAcc);</span>
  28 |     | <span class='neutral'></span>
  29 |     | <span class='neutral'>    // Set to new value, sync accumulator to now with old value</span>
  30 |     | <span class='neutral'>    // Changes in same block have no impact, as no time has expired</span>
  31 |     | <span class='neutral'>    // Effectively we use the previous block value, and we magnify it by weight</span>
  32 |     | <span class='unexecuted'>    function _setValue(uint128 newValue) internal {</span>
  33 |     | <span class='unexecuted'>        uint128 _newAcc = _updateAcc(valueToTrack);</span>
  34 |     | <span class='neutral'></span>
  35 |     | <span class='unexecuted'>        data.lastAccrued = uint64(block.timestamp);</span>
  36 |     | <span class='unexecuted'>        emit NewTrackValue(valueToTrack, newValue, block.timestamp, _newAcc);</span>
  37 |     | <span class='unexecuted'>        valueToTrack = newValue;</span>
  38 |     | <span class='neutral'>    }</span>
  39 |     | <span class='neutral'></span>
  40 |     | <span class='neutral'>    // Update the accumulator based on time passed</span>
  41 |     | <span class='unexecuted'>    function _updateAcc(uint128 oldValue) internal returns (uint128) {</span>
  42 |     | <span class='unexecuted'>        uint128 _newAcc = data.accumulator + oldValue * (timeToAccrue());</span>
  43 |     | <span class='unexecuted'>        data.accumulator = _newAcc;</span>
  44 |     | <span class='neutral'>        return _newAcc;</span>
  45 |     | <span class='neutral'>    }</span>
  46 |     | <span class='neutral'></span>
  47 |     | <span class='neutral'>    /// @notice Returns the time since the last update</span>
  48 |     | <span class='neutral'>    /// @return Duration since last update</span>
  49 |     | <span class='neutral'>    /// @dev Safe from overflow for tens of thousands of years</span>
  50 |     | <span class='unexecuted'>    function timeToAccrue() public view returns (uint64) {</span>
  51 |     | <span class='unexecuted'>        return uint64(block.timestamp) - data.lastAccrued;</span>
  52 |     | <span class='neutral'>    }</span>
  53 |     | <span class='neutral'></span>
  54 |     | <span class='neutral'>    /// @notice Returns the accumulator value, adjusted according to the current value and block timestamp</span>
  55 |     | <span class='neutral'>    // Return the update value to now</span>
  56 |     | <span class='unexecuted'>    function _syncToNow() internal view returns (uint128) {</span>
  57 |     | <span class='unexecuted'>        return data.accumulator + (valueToTrack * (timeToAccrue()));</span>
  58 |     | <span class='neutral'>    }</span>
  59 |     | <span class='neutral'></span>
  60 |     | <span class='neutral'>    // == Getters == //</span>
  61 |     | <span class='neutral'></span>
  62 |     | <span class='neutral'>    /// @notice Returns the accumulator value, adjusted according to the current value and block timestamp</span>
  63 |     | <span class='unexecuted'>    function getLatestAccumulator() public view returns (uint128) {</span>
  64 |     | <span class='unexecuted'>        return _syncToNow();</span>
  65 |     | <span class='neutral'>    }</span>
  66 |     | <span class='neutral'></span>
  67 |     | <span class='neutral'>    /// END TWAP ///</span>
  68 |     | <span class='neutral'></span>
  69 |     | <span class='neutral'>    /// TWAP WEIGHTED OBSERVER ///</span>
  70 |     | <span class='neutral'></span>
  71 |     | <span class='neutral'>    // Hardcoded TWAP Period of 7 days</span>
  72 |     | <span class='unexecuted'>    uint256 public constant PERIOD = 7 days;</span>
  73 |     | <span class='neutral'></span>
  74 |     | <span class='neutral'>    // Look at last</span>
  75 |     | <span class='neutral'>    // Linear interpolate (or prob TWAP already does that for you)</span>
  76 |     | <span class='neutral'></span>
  77 |     | <span class='neutral'>    /// @notice Returns the current value, adjusted according to the current value and block timestamp</span>
  78 |     | <span class='unexecuted'>    function observe() external returns (uint256) {</span>
  79 |     | <span class='neutral'>        // Here, we need to apply the new accumulator to skew the price in some way</span>
  80 |     | <span class='neutral'>        // The weight of the skew should be proportional to the time passed</span>
  81 |     | <span class='unexecuted'>        uint256 futureWeight = block.timestamp - data.lastObserved;</span>
  82 |     | <span class='neutral'></span>
  83 |     | <span class='unexecuted'>        if (futureWeight == 0) {</span>
  84 |     | <span class='unexecuted'>            return data.lastObservedAverage;</span>
  85 |     | <span class='neutral'>        }</span>
  86 |     | <span class='neutral'></span>
  87 |     | <span class='neutral'>        // A reference period is 7 days</span>
  88 |     | <span class='neutral'>        // For each second passed after update</span>
  89 |     | <span class='neutral'>        // Let&#39;s virtally sync TWAP</span>
  90 |     | <span class='neutral'>        // With a weight, that is higher, the more time has passed</span>
  91 |     | <span class='unexecuted'>        (uint128 virtualAvgValue, uint128 obsAcc) = _calcUpdatedAvg();</span>
  92 |     | <span class='neutral'></span>
  93 |     | <span class='unexecuted'>        if (_checkUpdatePeriod()) {</span>
  94 |     | <span class='unexecuted'>            _update(virtualAvgValue, obsAcc); // May as well update</span>
  95 |     | <span class='neutral'>            // Return virtual</span>
  96 |     | <span class='unexecuted'>            return virtualAvgValue;</span>
  97 |     | <span class='neutral'>        }</span>
  98 |     | <span class='neutral'></span>
  99 |     | <span class='unexecuted'>        uint256 weightedAvg = uint256(data.lastObservedAverage) *</span>
 100 |     | <span class='unexecuted'>            (uint256(PERIOD) - uint256(futureWeight));</span>
 101 |     | <span class='unexecuted'>        uint256 weightedVirtual = uint256(virtualAvgValue) * (uint256(futureWeight));</span>
 102 |     | <span class='neutral'></span>
 103 |     | <span class='unexecuted'>        uint256 weightedMean = (weightedAvg + weightedVirtual) / PERIOD;</span>
 104 |     | <span class='neutral'></span>
 105 |     | <span class='neutral'>        return weightedMean;</span>
 106 |     | <span class='neutral'>    }</span>
 107 |     | <span class='neutral'></span>
 108 |     | <span class='neutral'>    /// @dev Usual Accumulator Math, (newAcc - acc0) / (now - t0)</span>
 109 |     | <span class='unexecuted'>    function _calcUpdatedAvg() internal view returns (uint128, uint128) {</span>
 110 |     | <span class='unexecuted'>        uint128 latestAcc = getLatestAccumulator();</span>
 111 |     | <span class='unexecuted'>        uint128 avgValue = (latestAcc - data.observerCumuVal) /</span>
 112 |     | <span class='unexecuted'>            (uint64(block.timestamp) - data.lastObserved);</span>
 113 |     | <span class='unexecuted'>        return (avgValue, latestAcc);</span>
 114 |     | <span class='neutral'>    }</span>
 115 |     | <span class='neutral'></span>
 116 |     | <span class='neutral'>    /// @dev Utility to update internal data</span>
 117 |     | <span class='unexecuted'>    function _update(uint128 avgValue, uint128 obsAcc) internal {</span>
 118 |     | <span class='unexecuted'>        data.lastObservedAverage = avgValue;</span>
 119 |     | <span class='unexecuted'>        data.observerCumuVal = obsAcc;</span>
 120 |     | <span class='unexecuted'>        data.lastObserved = uint64(block.timestamp);</span>
 121 |     | <span class='neutral'>    }</span>
 122 |     | <span class='neutral'></span>
 123 |     | <span class='neutral'>    /// @dev Should we update in observe?</span>
 124 |     | <span class='unexecuted'>    function _checkUpdatePeriod() internal returns (bool) {</span>
 125 |     | <span class='unexecuted'>        return block.timestamp &gt;= (data.lastObserved + PERIOD);</span>
 126 |     | <span class='neutral'>    }</span>
 127 |     | <span class='neutral'></span>
 128 |     | <span class='neutral'>    /// @dev update time-weighted Observer</span>
 129 |     | <span class='unexecuted'>    function update() public {</span>
 130 |     | <span class='unexecuted'>        if (_checkUpdatePeriod()) {</span>
 131 |     | <span class='unexecuted'>            (uint128 avgValue, uint128 latestAcc) = _calcUpdatedAvg();</span>
 132 |     | <span class='unexecuted'>            _update(avgValue, latestAcc);</span>
 133 |     | <span class='neutral'>        }</span>
 134 |     | <span class='neutral'>    }</span>
 135 |     | <span class='neutral'></span>
 136 |     | <span class='unexecuted'>    function setValueAndUpdate(uint128 value) external {</span>
 137 |     | <span class='unexecuted'>        require(msg.sender == address(this), &quot;TwapWeightedObserver: Only self call&quot;);</span>
 138 |     | <span class='unexecuted'>        _setValue(value);</span>
 139 |     | <span class='unexecuted'>        update();</span>
 140 |     | <span class='neutral'>    }</span>
 141 |     | <span class='neutral'></span>
 142 |     | <span class='unexecuted'>    function getData() external view returns (PackedData memory) {</span>
 143 |     | <span class='unexecuted'>        return data;</span>
 144 |     | <span class='neutral'>    }</span>
 145 |     | <span class='neutral'></span>
 146 |     | <span class='neutral'>    /// END TWAP WEIGHTED OBSERVER ///</span>
 147 |     | <span class='neutral'>}</span>
 148 |     | <span class='neutral'></span>

</code>
<br />

<b>/mnt/c/Users/Lourens/Documents/Recon-Fuzz/collabs/ebtc/packages/contracts/contracts/EBTCDeployer.sol</b>
<code>
   1 |     | <span class='neutral'>// SPDX-License-Identifier: MIT</span>
   2 |     | <span class='neutral'></span>
   3 |     | <span class='neutral'>pragma solidity 0.8.17;</span>
   4 |     | <span class='neutral'></span>
   5 |     | <span class='neutral'>import &quot;./Dependencies/Create3.sol&quot;;</span>
   6 |     | <span class='neutral'>import &quot;./Dependencies/Ownable.sol&quot;;</span>
   7 |     | <span class='neutral'></span>
   8 |     | <span class='unexecuted'>contract EBTCDeployer is Ownable {</span>
   9 |     | <span class='unexecuted'>    string public constant name = &quot;eBTC Deployer&quot;;</span>
  10 |     | <span class='neutral'></span>
  11 |     | <span class='unexecuted'>    string public constant AUTHORITY = &quot;ebtc.v1.authority&quot;;</span>
  12 |     | <span class='unexecuted'>    string public constant LIQUIDATION_LIBRARY = &quot;ebtc.v1.liquidationLibrary&quot;;</span>
  13 |     | <span class='unexecuted'>    string public constant CDP_MANAGER = &quot;ebtc.v1.cdpManager&quot;;</span>
  14 |     | <span class='unexecuted'>    string public constant BORROWER_OPERATIONS = &quot;ebtc.v1.borrowerOperations&quot;;</span>
  15 |     | <span class='neutral'></span>
  16 |     | <span class='unexecuted'>    string public constant PRICE_FEED = &quot;ebtc.v1.priceFeed&quot;;</span>
  17 |     | <span class='unexecuted'>    string public constant EBTC_FEED = &quot;ebtc.v1.ebtcFeed&quot;;</span>
  18 |     | <span class='unexecuted'>    string public constant SORTED_CDPS = &quot;ebtc.v1.sortedCdps&quot;;</span>
  19 |     | <span class='neutral'></span>
  20 |     | <span class='unexecuted'>    string public constant ACTIVE_POOL = &quot;ebtc.v1.activePool&quot;;</span>
  21 |     | <span class='unexecuted'>    string public constant COLL_SURPLUS_POOL = &quot;ebtc.v1.collSurplusPool&quot;;</span>
  22 |     | <span class='neutral'></span>
  23 |     | <span class='unexecuted'>    string public constant HINT_HELPERS = &quot;ebtc.v1.hintHelpers&quot;;</span>
  24 |     | <span class='unexecuted'>    string public constant EBTC_TOKEN = &quot;ebtc.v1.eBTCToken&quot;;</span>
  25 |     | <span class='unexecuted'>    string public constant FEE_RECIPIENT = &quot;ebtc.v1.feeRecipient&quot;;</span>
  26 |     | <span class='unexecuted'>    string public constant MULTI_CDP_GETTER = &quot;ebtc.v1.multiCdpGetter&quot;;</span>
  27 |     | <span class='neutral'></span>
  28 |     | <span class='neutral'>    event ContractDeployed(address indexed contractAddress, string contractName, bytes32 salt);</span>
  29 |     | <span class='neutral'></span>
  30 |     | <span class='neutral'>    struct EbtcAddresses {</span>
  31 |     | <span class='neutral'>        address authorityAddress;</span>
  32 |     | <span class='neutral'>        address liquidationLibraryAddress;</span>
  33 |     | <span class='neutral'>        address cdpManagerAddress;</span>
  34 |     | <span class='neutral'>        address borrowerOperationsAddress;</span>
  35 |     | <span class='neutral'>        address priceFeedAddress;</span>
  36 |     | <span class='neutral'>        address sortedCdpsAddress;</span>
  37 |     | <span class='neutral'>        address activePoolAddress;</span>
  38 |     | <span class='neutral'>        address collSurplusPoolAddress;</span>
  39 |     | <span class='neutral'>        address hintHelpersAddress;</span>
  40 |     | <span class='neutral'>        address ebtcTokenAddress;</span>
  41 |     | <span class='neutral'>        address feeRecipientAddress;</span>
  42 |     | <span class='neutral'>        address multiCdpGetterAddress;</span>
  43 |     | <span class='neutral'>        address ebtcFeedAddress;</span>
  44 |     | <span class='neutral'>    }</span>
  45 |     | <span class='neutral'></span>
  46 |     | <span class='neutral'>    /**</span>
  47 |     | <span class='neutral'>    @notice Helper method to return a set of future addresses for eBTC. Intended to be used in the order specified.</span>
  48 |     | <span class='neutral'>    </span>
  49 |     | <span class='neutral'>    @dev The order is as follows:</span>
  50 |     | <span class='neutral'>    0: authority</span>
  51 |     | <span class='neutral'>    1: liquidationLibrary</span>
  52 |     | <span class='neutral'>    2: cdpManager</span>
  53 |     | <span class='neutral'>    3: borrowerOperations</span>
  54 |     | <span class='neutral'>    4: priceFeed</span>
  55 |     | <span class='neutral'>    5; sortedCdps</span>
  56 |     | <span class='neutral'>    6: activePool</span>
  57 |     | <span class='neutral'>    7: collSurplusPool</span>
  58 |     | <span class='neutral'>    8: hintHelpers</span>
  59 |     | <span class='neutral'>    9: eBTCToken</span>
  60 |     | <span class='neutral'>    10: feeRecipient</span>
  61 |     | <span class='neutral'>    11: multiCdpGetter</span>
  62 |     | <span class='neutral'>    12: ebtcFeed</span>
  63 |     | <span class='neutral'></span>
  64 |     | <span class='neutral'></span>
  65 |     | <span class='neutral'>     */</span>
  66 |     | <span class='unexecuted'>    function getFutureEbtcAddresses() public view returns (EbtcAddresses memory) {</span>
  67 |     | <span class='unexecuted'>        EbtcAddresses memory addresses = EbtcAddresses(</span>
  68 |     | <span class='unexecuted'>            Create3.addressOf(keccak256(abi.encodePacked(AUTHORITY))),</span>
  69 |     | <span class='unexecuted'>            Create3.addressOf(keccak256(abi.encodePacked(LIQUIDATION_LIBRARY))),</span>
  70 |     | <span class='unexecuted'>            Create3.addressOf(keccak256(abi.encodePacked(CDP_MANAGER))),</span>
  71 |     | <span class='unexecuted'>            Create3.addressOf(keccak256(abi.encodePacked(BORROWER_OPERATIONS))),</span>
  72 |     | <span class='unexecuted'>            Create3.addressOf(keccak256(abi.encodePacked(PRICE_FEED))),</span>
  73 |     | <span class='unexecuted'>            Create3.addressOf(keccak256(abi.encodePacked(SORTED_CDPS))),</span>
  74 |     | <span class='unexecuted'>            Create3.addressOf(keccak256(abi.encodePacked(ACTIVE_POOL))),</span>
  75 |     | <span class='unexecuted'>            Create3.addressOf(keccak256(abi.encodePacked(COLL_SURPLUS_POOL))),</span>
  76 |     | <span class='unexecuted'>            Create3.addressOf(keccak256(abi.encodePacked(HINT_HELPERS))),</span>
  77 |     | <span class='unexecuted'>            Create3.addressOf(keccak256(abi.encodePacked(EBTC_TOKEN))),</span>
  78 |     | <span class='unexecuted'>            Create3.addressOf(keccak256(abi.encodePacked(FEE_RECIPIENT))),</span>
  79 |     | <span class='unexecuted'>            Create3.addressOf(keccak256(abi.encodePacked(MULTI_CDP_GETTER))),</span>
  80 |     | <span class='unexecuted'>            Create3.addressOf(keccak256(abi.encodePacked(EBTC_FEED)))</span>
  81 |     | <span class='neutral'>        );</span>
  82 |     | <span class='neutral'></span>
  83 |     | <span class='neutral'>        return addresses;</span>
  84 |     | <span class='neutral'>    }</span>
  85 |     | <span class='neutral'></span>
  86 |     | <span class='neutral'>    /**</span>
  87 |     | <span class='neutral'>        @notice Deploy a contract using salt in string format and arbitrary runtime code.</span>
  88 |     | <span class='neutral'>        @dev Intended use is: get the future eBTC addresses, then deploy the appropriate contract to each address via this method, building the constructor using the mapped addresses</span>
  89 |     | <span class='neutral'>        @dev no enforcment of bytecode at address as we can&#39;t know the runtime code in this contract due to space constraints</span>
  90 |     | <span class='neutral'>        @dev gated to given deployer EOA to ensure no interference with process, given proper actions by deployer</span>
  91 |     | <span class='neutral'>     */</span>
  92 |     | <span class='unexecuted'>    function deploy(</span>
  93 |     | <span class='neutral'>        string memory _saltString,</span>
  94 |     | <span class='neutral'>        bytes memory _creationCode</span>
  95 |     | <span class='unexecuted'>    ) public returns (address deployedAddress) {</span>
  96 |     | <span class='unexecuted'>        bytes32 _salt = keccak256(abi.encodePacked(_saltString));</span>
  97 |     | <span class='unexecuted'>        deployedAddress = Create3.create3(_salt, _creationCode);</span>
  98 |     | <span class='unexecuted'>        emit ContractDeployed(deployedAddress, _saltString, _salt);</span>
  99 |     | <span class='neutral'>    }</span>
 100 |     | <span class='neutral'></span>
 101 |     | <span class='unexecuted'>    function deployWithCreationCodeAndConstructorArgs(</span>
 102 |     | <span class='neutral'>        string memory _saltString,</span>
 103 |     | <span class='neutral'>        bytes memory creationCode,</span>
 104 |     | <span class='neutral'>        bytes memory constructionArgs</span>
 105 |     | <span class='unexecuted'>    ) external returns (address) {</span>
 106 |     | <span class='unexecuted'>        bytes memory _data = abi.encodePacked(creationCode, constructionArgs);</span>
 107 |     | <span class='unexecuted'>        return deploy(_saltString, _data);</span>
 108 |     | <span class='neutral'>    }</span>
 109 |     | <span class='neutral'></span>
 110 |     | <span class='unexecuted'>    function deployWithCreationCode(</span>
 111 |     | <span class='neutral'>        string memory _saltString,</span>
 112 |     | <span class='neutral'>        bytes memory creationCode</span>
 113 |     | <span class='unexecuted'>    ) external returns (address) {</span>
 114 |     | <span class='unexecuted'>        return deploy(_saltString, creationCode);</span>
 115 |     | <span class='neutral'>    }</span>
 116 |     | <span class='neutral'></span>
 117 |     | <span class='unexecuted'>    function addressOf(string memory _saltString) external view returns (address) {</span>
 118 |     | <span class='unexecuted'>        bytes32 _salt = keccak256(abi.encodePacked(_saltString));</span>
 119 |     | <span class='unexecuted'>        return Create3.addressOf(_salt);</span>
 120 |     | <span class='neutral'>    }</span>
 121 |     | <span class='neutral'></span>
 122 |     | <span class='unexecuted'>    function addressOfSalt(bytes32 _salt) external view returns (address) {</span>
 123 |     | <span class='unexecuted'>        return Create3.addressOf(_salt);</span>
 124 |     | <span class='neutral'>    }</span>
 125 |     | <span class='neutral'></span>
 126 |     | <span class='neutral'>    /**</span>
 127 |     | <span class='neutral'>        @notice Create the creation code for a contract with the given runtime code.</span>
 128 |     | <span class='neutral'>        @dev credit: https://github.com/0xsequence/create3/blob/master/contracts/test_utils/Create3Imp.sol</span>
 129 |     | <span class='neutral'>     */</span>
 130 |     | <span class='neutral'>    function creationCodeFor(bytes memory _code) internal pure returns (bytes memory) {</span>
 131 |     | <span class='neutral'>        /*</span>
 132 |     | <span class='neutral'>      0x00    0x63         0x63XXXXXX  PUSH4 _code.length  size</span>
 133 |     | <span class='neutral'>      0x01    0x80         0x80        DUP1                size size</span>
 134 |     | <span class='neutral'>      0x02    0x60         0x600e      PUSH1 14            14 size size</span>
 135 |     | <span class='neutral'>      0x03    0x60         0x6000      PUSH1 00            0 14 size size</span>
 136 |     | <span class='neutral'>      0x04    0x39         0x39        CODECOPY            size</span>
 137 |     | <span class='neutral'>      0x05    0x60         0x6000      PUSH1 00            0 size</span>
 138 |     | <span class='neutral'>      0x06    0xf3         0xf3        RETURN</span>
 139 |     | <span class='neutral'>      &lt;CODE&gt;</span>
 140 |     | <span class='neutral'>    */</span>
 141 |     | <span class='neutral'></span>
 142 |     | <span class='neutral'>        return</span>
 143 |     | <span class='neutral'>            abi.encodePacked(hex&quot;63&quot;, uint32(_code.length), hex&quot;80_60_0E_60_00_39_60_00_F3&quot;, _code);</span>
 144 |     | <span class='neutral'>    }</span>
 145 |     | <span class='neutral'>}</span>
 146 |     | <span class='neutral'></span>

</code>
<br />

<b>/mnt/c/Users/Lourens/Documents/Recon-Fuzz/collabs/ebtc/packages/contracts/contracts/EBTCToken.sol</b>
<code>
   1 |     | <span class='neutral'>// SPDX-License-Identifier: MIT</span>
   2 |     | <span class='neutral'></span>
   3 |     | <span class='neutral'>pragma solidity 0.8.17;</span>
   4 |     | <span class='neutral'></span>
   5 |     | <span class='neutral'>import &quot;./Interfaces/IEBTCToken.sol&quot;;</span>
   6 |     | <span class='neutral'></span>
   7 |     | <span class='neutral'>import &quot;./Dependencies/AuthNoOwner.sol&quot;;</span>
   8 |     | <span class='neutral'>import &quot;./Dependencies/PermitNonce.sol&quot;;</span>
   9 |     | <span class='neutral'></span>
  10 |     | <span class='neutral'>/*</span>
  11 |     | <span class='neutral'> *</span>
  12 |     | <span class='neutral'> * Based upon OpenZeppelin&#39;s ERC20 contract:</span>
  13 |     | <span class='neutral'> * https://github.com/OpenZeppelin/openzeppelin-contracts/blob/master/contracts/token/ERC20/ERC20.sol</span>
  14 |     | <span class='neutral'> *</span>
  15 |     | <span class='neutral'> * and their EIP2612 (ERC20Permit / ERC712) functionality:</span>
  16 |     | <span class='neutral'> * https://github.com/OpenZeppelin/openzeppelin-contracts/blob/53516bc555a454862470e7860a9b5254db4d00f5/contracts/token/ERC20/ERC20Permit.sol</span>
  17 |     | <span class='neutral'> *</span>
  18 |     | <span class='neutral'> *</span>
  19 |     | <span class='neutral'> * --- Functionality added specific to the EBTCToken ---</span>
  20 |     | <span class='neutral'> *</span>
  21 |     | <span class='neutral'> * 1) Transfer protection: blocklist of addresses that are invalid recipients (i.e. core Ebtc contracts) in external transfer() and transferFrom() calls.</span>
  22 |     | <span class='neutral'> * The purpose is to protect users from losing tokens by mistakenly sending EBTC directly to a Liquity.</span>
  23 |     | <span class='neutral'> * core contract, when they should rather call the right function.</span>
  24 |     | <span class='neutral'> */</span>
  25 |     | <span class='neutral'></span>
  26 |     | <span class='unexecuted'>contract EBTCToken is IEBTCToken, AuthNoOwner, PermitNonce {</span>
  27 |     | <span class='neutral'>    uint256 private _totalSupply;</span>
  28 |     | <span class='neutral'>    string internal constant _NAME = &quot;EBTC Stablecoin&quot;;</span>
  29 |     | <span class='neutral'>    string internal constant _SYMBOL = &quot;EBTC&quot;;</span>
  30 |     | <span class='neutral'>    string internal constant _VERSION = &quot;1&quot;;</span>
  31 |     | <span class='unexecuted'>    uint8 internal constant _DECIMALS = 18;</span>
  32 |     | <span class='neutral'></span>
  33 |     | <span class='neutral'>    // --- Data for EIP2612 ---</span>
  34 |     | <span class='neutral'></span>
  35 |     | <span class='neutral'>    // keccak256(&quot;Permit(address owner,address spender,uint256 value,uint256 nonce,uint256 deadline)&quot;);</span>
  36 |     | <span class='neutral'>    bytes32 private constant _PERMIT_TYPEHASH =</span>
  37 |     | <span class='unexecuted'>        0x6e71edae12b1b97f4d1f60370fef10105fa2faae0126114a169c64845d6126c9;</span>
  38 |     | <span class='neutral'>    // keccak256(&quot;EIP712Domain(string name,string version,uint256 chainId,address verifyingContract)&quot;);</span>
  39 |     | <span class='neutral'>    bytes32 private constant _TYPE_HASH =</span>
  40 |     | <span class='unexecuted'>        0x8b73c3c69bb8fe3d512ecc4cf759cc79239f7b179b0ffacaa9a75d522b39400f;</span>
  41 |     | <span class='neutral'></span>
  42 |     | <span class='neutral'>    // Cache the domain separator as an immutable value, but also store the chain id that it corresponds to, in order to</span>
  43 |     | <span class='neutral'>    // invalidate the cached domain separator if the chain id changes.</span>
  44 |     | <span class='neutral'>    bytes32 private immutable _CACHED_DOMAIN_SEPARATOR;</span>
  45 |     | <span class='neutral'>    uint256 private immutable _CACHED_CHAIN_ID;</span>
  46 |     | <span class='neutral'></span>
  47 |     | <span class='neutral'>    bytes32 private immutable _HASHED_NAME;</span>
  48 |     | <span class='neutral'>    bytes32 private immutable _HASHED_VERSION;</span>
  49 |     | <span class='neutral'></span>
  50 |     | <span class='neutral'>    // User data for EBTC token</span>
  51 |     | <span class='neutral'>    mapping(address =&gt; uint256) private _balances;</span>
  52 |     | <span class='neutral'>    mapping(address =&gt; mapping(address =&gt; uint256)) private _allowances;</span>
  53 |     | <span class='neutral'></span>
  54 |     | <span class='neutral'>    // --- Addresses ---</span>
  55 |     | <span class='unexecuted'>    address public immutable cdpManagerAddress;</span>
  56 |     | <span class='unexecuted'>    address public immutable borrowerOperationsAddress;</span>
  57 |     | <span class='neutral'></span>
  58 |     | <span class='neutral'>    /// @param _cdpManagerAddress Address of the CDP Manager</span>
  59 |     | <span class='neutral'>    /// @param _borrowerOperationsAddress Address of the Borrower Operations</span>
  60 |     | <span class='neutral'>    /// @param _authorityAddress Address of the authority for the contract</span>
  61 |     | <span class='unexecuted'>    constructor(</span>
  62 |     | <span class='neutral'>        address _cdpManagerAddress,</span>
  63 |     | <span class='neutral'>        address _borrowerOperationsAddress,</span>
  64 |     | <span class='neutral'>        address _authorityAddress</span>
  65 |     | <span class='neutral'>    ) {</span>
  66 |     | <span class='unexecuted'>        _initializeAuthority(_authorityAddress);</span>
  67 |     | <span class='neutral'></span>
  68 |     | <span class='unexecuted'>        cdpManagerAddress = _cdpManagerAddress;</span>
  69 |     | <span class='unexecuted'>        borrowerOperationsAddress = _borrowerOperationsAddress;</span>
  70 |     | <span class='neutral'></span>
  71 |     | <span class='unexecuted'>        bytes32 hashedName = keccak256(bytes(_NAME));</span>
  72 |     | <span class='unexecuted'>        bytes32 hashedVersion = keccak256(bytes(_VERSION));</span>
  73 |     | <span class='neutral'></span>
  74 |     | <span class='unexecuted'>        _HASHED_NAME = hashedName;</span>
  75 |     | <span class='unexecuted'>        _HASHED_VERSION = hashedVersion;</span>
  76 |     | <span class='unexecuted'>        _CACHED_CHAIN_ID = _chainID();</span>
  77 |     | <span class='unexecuted'>        _CACHED_DOMAIN_SEPARATOR = _buildDomainSeparator(_TYPE_HASH, hashedName, hashedVersion);</span>
  78 |     | <span class='neutral'>    }</span>
  79 |     | <span class='neutral'></span>
  80 |     | <span class='neutral'>    /// @notice Mint new tokens</span>
  81 |     | <span class='neutral'>    /// @dev Internal system function - only callable by BorrowerOperations or CDPManager</span>
  82 |     | <span class='neutral'>    /// @dev Governance can also expand the list of approved minters to enable other systems to mint tokens</span>
  83 |     | <span class='neutral'>    /// @param _account The address to receive the newly minted tokens</span>
  84 |     | <span class='neutral'>    /// @param _amount The amount of tokens to mint</span>
  85 |     | <span class='unexecuted'>    function mint(address _account, uint256 _amount) external override {</span>
  86 |     | <span class='unexecuted'>        _requireCallerIsBOorCdpMOrAuth();</span>
  87 |     | <span class='unexecuted'>        _mint(_account, _amount);</span>
  88 |     | <span class='neutral'>    }</span>
  89 |     | <span class='neutral'></span>
  90 |     | <span class='neutral'>    /// @notice Burn existing tokens</span>
  91 |     | <span class='neutral'>    /// @dev Internal system function - only callable by BorrowerOperations or CDPManager</span>
  92 |     | <span class='neutral'>    /// @dev Governance can also expand the list of approved burners to enable other systems to burn tokens</span>
  93 |     | <span class='neutral'>    /// @param _account The address to burn tokens from</span>
  94 |     | <span class='neutral'>    /// @param _amount The amount of tokens to burn</span>
  95 |     | <span class='unexecuted'>    function burn(address _account, uint256 _amount) external override {</span>
  96 |     | <span class='unexecuted'>        _requireCallerIsBOorCdpMOrAuth();</span>
  97 |     | <span class='unexecuted'>        _burn(_account, _amount);</span>
  98 |     | <span class='neutral'>    }</span>
  99 |     | <span class='neutral'></span>
 100 |     | <span class='neutral'>    /// @notice Burn existing tokens from caller</span>
 101 |     | <span class='neutral'>    /// @dev Internal system function - only callable by BorrowerOperations or CDPManager</span>
 102 |     | <span class='neutral'>    /// @dev Governance can also expand the list of approved burners to enable other systems to burn tokens</span>
 103 |     | <span class='neutral'>    /// @param _amount The amount of tokens to burn</span>
 104 |     | <span class='unexecuted'>    function burn(uint256 _amount) external {</span>
 105 |     | <span class='unexecuted'>        _requireCallerIsBOorCdpMOrAuth();</span>
 106 |     | <span class='unexecuted'>        _burn(msg.sender, _amount);</span>
 107 |     | <span class='neutral'>    }</span>
 108 |     | <span class='neutral'></span>
 109 |     | <span class='neutral'>    // --- External functions ---</span>
 110 |     | <span class='neutral'></span>
 111 |     | <span class='unexecuted'>    function totalSupply() external view override returns (uint256) {</span>
 112 |     | <span class='unexecuted'>        return _totalSupply;</span>
 113 |     | <span class='neutral'>    }</span>
 114 |     | <span class='neutral'></span>
 115 |     | <span class='unexecuted'>    function balanceOf(address account) external view override returns (uint256) {</span>
 116 |     | <span class='unexecuted'>        return _balances[account];</span>
 117 |     | <span class='neutral'>    }</span>
 118 |     | <span class='neutral'></span>
 119 |     | <span class='unexecuted'>    function transfer(address recipient, uint256 amount) external override returns (bool) {</span>
 120 |     | <span class='unexecuted'>        _requireValidRecipient(recipient);</span>
 121 |     | <span class='unexecuted'>        _transfer(msg.sender, recipient, amount);</span>
 122 |     | <span class='neutral'>        return true;</span>
 123 |     | <span class='neutral'>    }</span>
 124 |     | <span class='neutral'></span>
 125 |     | <span class='unexecuted'>    function allowance(address owner, address spender) external view override returns (uint256) {</span>
 126 |     | <span class='unexecuted'>        return _allowances[owner][spender];</span>
 127 |     | <span class='neutral'>    }</span>
 128 |     | <span class='neutral'></span>
 129 |     | <span class='unexecuted'>    function approve(address spender, uint256 amount) external override returns (bool) {</span>
 130 |     | <span class='unexecuted'>        _approve(msg.sender, spender, amount);</span>
 131 |     | <span class='unexecuted'>        return true;</span>
 132 |     | <span class='neutral'>    }</span>
 133 |     | <span class='neutral'></span>
 134 |     | <span class='unexecuted'>    function transferFrom(</span>
 135 |     | <span class='neutral'>        address sender,</span>
 136 |     | <span class='neutral'>        address recipient,</span>
 137 |     | <span class='neutral'>        uint256 amount</span>
 138 |     | <span class='unexecuted'>    ) external override returns (bool) {</span>
 139 |     | <span class='unexecuted'>        _requireValidRecipient(recipient);</span>
 140 |     | <span class='unexecuted'>        _transfer(sender, recipient, amount);</span>
 141 |     | <span class='neutral'></span>
 142 |     | <span class='unexecuted'>        uint256 cachedAllowance = _allowances[sender][msg.sender];</span>
 143 |     | <span class='unexecuted'>        if (cachedAllowance != type(uint256).max) {</span>
 144 |     | <span class='unexecuted'>            require(cachedAllowance &gt;= amount, &quot;ERC20: transfer amount exceeds allowance&quot;);</span>
 145 |     | <span class='neutral'>            unchecked {</span>
 146 |     | <span class='unexecuted'>                _approve(sender, msg.sender, cachedAllowance - amount);</span>
 147 |     | <span class='neutral'>            }</span>
 148 |     | <span class='neutral'>        }</span>
 149 |     | <span class='unexecuted'>        return true;</span>
 150 |     | <span class='neutral'>    }</span>
 151 |     | <span class='neutral'></span>
 152 |     | <span class='unexecuted'>    function increaseAllowance(</span>
 153 |     | <span class='neutral'>        address spender,</span>
 154 |     | <span class='neutral'>        uint256 addedValue</span>
 155 |     | <span class='unexecuted'>    ) external override returns (bool) {</span>
 156 |     | <span class='unexecuted'>        _approve(msg.sender, spender, _allowances[msg.sender][spender] + addedValue);</span>
 157 |     | <span class='neutral'>        return true;</span>
 158 |     | <span class='neutral'>    }</span>
 159 |     | <span class='neutral'></span>
 160 |     | <span class='unexecuted'>    function decreaseAllowance(</span>
 161 |     | <span class='neutral'>        address spender,</span>
 162 |     | <span class='neutral'>        uint256 subtractedValue</span>
 163 |     | <span class='unexecuted'>    ) external override returns (bool) {</span>
 164 |     | <span class='unexecuted'>        uint256 cachedAllowances = _allowances[msg.sender][spender];</span>
 165 |     | <span class='unexecuted'>        require(cachedAllowances &gt;= subtractedValue, &quot;ERC20: decreased allowance below zero&quot;);</span>
 166 |     | <span class='neutral'>        unchecked {</span>
 167 |     | <span class='unexecuted'>            _approve(msg.sender, spender, cachedAllowances - subtractedValue);</span>
 168 |     | <span class='neutral'>        }</span>
 169 |     | <span class='unexecuted'>        return true;</span>
 170 |     | <span class='neutral'>    }</span>
 171 |     | <span class='neutral'></span>
 172 |     | <span class='neutral'>    // --- EIP 2612 Functionality (https://eips.ethereum.org/EIPS/eip-2612) ---</span>
 173 |     | <span class='neutral'></span>
 174 |     | <span class='neutral'>    /// @notice This function returns the domain separator for current chain</span>
 175 |     | <span class='neutral'>    /// @return EIP712 compatible Domain definition</span>
 176 |     | <span class='unexecuted'>    function DOMAIN_SEPARATOR() external view returns (bytes32) {</span>
 177 |     | <span class='unexecuted'>        return domainSeparator();</span>
 178 |     | <span class='neutral'>    }</span>
 179 |     | <span class='neutral'></span>
 180 |     | <span class='neutral'>    /// @notice This function returns the domain separator for current chain</span>
 181 |     | <span class='neutral'>    /// @return EIP712 compatible Domain definition</span>
 182 |     | <span class='unexecuted'>    function domainSeparator() public view override returns (bytes32) {</span>
 183 |     | <span class='unexecuted'>        if (_chainID() == _CACHED_CHAIN_ID) {</span>
 184 |     | <span class='unexecuted'>            return _CACHED_DOMAIN_SEPARATOR;</span>
 185 |     | <span class='neutral'>        } else {</span>
 186 |     | <span class='unexecuted'>            return _buildDomainSeparator(_TYPE_HASH, _HASHED_NAME, _HASHED_VERSION);</span>
 187 |     | <span class='neutral'>        }</span>
 188 |     | <span class='neutral'>    }</span>
 189 |     | <span class='neutral'></span>
 190 |     | <span class='neutral'>    /// @notice This function approve given amount for specified owner and spender</span>
 191 |     | <span class='neutral'>    /// @notice by verifying the validity of given deadline and signature parameters (v, r, s).</span>
 192 |     | <span class='neutral'>    /// @param owner The token owner</span>
 193 |     | <span class='neutral'>    /// @param spender The consumer to which owner want to grant approval</span>
 194 |     | <span class='neutral'>    /// @param amount The token expenditure budget to be set</span>
 195 |     | <span class='neutral'>    /// @param deadline The permit valid deadline</span>
 196 |     | <span class='neutral'>    /// @param v The v part of signature from owner</span>
 197 |     | <span class='neutral'>    /// @param r The r part of signature from owner</span>
 198 |     | <span class='neutral'>    /// @param s The s part of signature from owner</span>
 199 |     | <span class='unexecuted'>    function permit(</span>
 200 |     | <span class='neutral'>        address owner,</span>
 201 |     | <span class='neutral'>        address spender,</span>
 202 |     | <span class='neutral'>        uint256 amount,</span>
 203 |     | <span class='neutral'>        uint256 deadline,</span>
 204 |     | <span class='neutral'>        uint8 v,</span>
 205 |     | <span class='neutral'>        bytes32 r,</span>
 206 |     | <span class='neutral'>        bytes32 s</span>
 207 |     | <span class='unexecuted'>    ) external override {</span>
 208 |     | <span class='unexecuted'>        require(deadline &gt;= block.timestamp, &quot;EBTC: expired deadline&quot;);</span>
 209 |     | <span class='unexecuted'>        bytes32 digest = keccak256(</span>
 210 |     | <span class='unexecuted'>            abi.encodePacked(</span>
 211 |     | <span class='neutral'>                &quot;\x19\x01&quot;,</span>
 212 |     | <span class='unexecuted'>                domainSeparator(),</span>
 213 |     | <span class='unexecuted'>                keccak256(</span>
 214 |     | <span class='unexecuted'>                    abi.encode(_PERMIT_TYPEHASH, owner, spender, amount, _nonces[owner]++, deadline)</span>
 215 |     | <span class='neutral'>                )</span>
 216 |     | <span class='neutral'>            )</span>
 217 |     | <span class='neutral'>        );</span>
 218 |     | <span class='unexecuted'>        address recoveredAddress = ecrecover(digest, v, r, s);</span>
 219 |     | <span class='unexecuted'>        require(recoveredAddress == owner, &quot;EBTC: invalid signature&quot;);</span>
 220 |     | <span class='unexecuted'>        _approve(owner, spender, amount);</span>
 221 |     | <span class='neutral'>    }</span>
 222 |     | <span class='neutral'></span>
 223 |     | <span class='neutral'>    /// @dev Return current nonce for specified owner fOR EIP-2612 compatibility</span>
 224 |     | <span class='neutral'>    /// @param owner The address whose nonce to be queried</span>
 225 |     | <span class='unexecuted'>    function nonces(address owner) external view override(IERC2612, PermitNonce) returns (uint256) {</span>
 226 |     | <span class='unexecuted'>        return _nonces[owner];</span>
 227 |     | <span class='neutral'>    }</span>
 228 |     | <span class='neutral'></span>
 229 |     | <span class='neutral'>    // --- Internal operations ---</span>
 230 |     | <span class='neutral'></span>
 231 |     | <span class='neutral'>    function _chainID() private view returns (uint256) {</span>
 232 |     | <span class='unexecuted'>        return block.chainid;</span>
 233 |     | <span class='neutral'>    }</span>
 234 |     | <span class='neutral'></span>
 235 |     | <span class='neutral'>    function _buildDomainSeparator(</span>
 236 |     | <span class='neutral'>        bytes32 typeHash,</span>
 237 |     | <span class='neutral'>        bytes32 name,</span>
 238 |     | <span class='neutral'>        bytes32 version</span>
 239 |     | <span class='neutral'>    ) private view returns (bytes32) {</span>
 240 |     | <span class='unexecuted'>        return keccak256(abi.encode(typeHash, name, version, _chainID(), address(this)));</span>
 241 |     | <span class='neutral'>    }</span>
 242 |     | <span class='neutral'></span>
 243 |     | <span class='neutral'>    // --- Internal operations ---</span>
 244 |     | <span class='neutral'>    // Warning: sanity checks (for sender and recipient) should have been done before calling these internal functions</span>
 245 |     | <span class='neutral'></span>
 246 |     | <span class='unexecuted'>    function _transfer(address sender, address recipient, uint256 amount) internal {</span>
 247 |     | <span class='unexecuted'>        require(sender != address(0), &quot;EBTCToken: zero sender!&quot;);</span>
 248 |     | <span class='unexecuted'>        require(recipient != address(0), &quot;EBTCToken: zero recipient!&quot;);</span>
 249 |     | <span class='neutral'></span>
 250 |     | <span class='unexecuted'>        uint256 cachedSenderBalances = _balances[sender];</span>
 251 |     | <span class='unexecuted'>        require(cachedSenderBalances &gt;= amount, &quot;ERC20: transfer amount exceeds balance&quot;);</span>
 252 |     | <span class='neutral'></span>
 253 |     | <span class='neutral'>        unchecked {</span>
 254 |     | <span class='neutral'>            // Safe because of the check above</span>
 255 |     | <span class='unexecuted'>            _balances[sender] = cachedSenderBalances - amount;</span>
 256 |     | <span class='neutral'>        }</span>
 257 |     | <span class='neutral'></span>
 258 |     | <span class='unexecuted'>        _balances[recipient] = _balances[recipient] + amount;</span>
 259 |     | <span class='unexecuted'>        emit Transfer(sender, recipient, amount);</span>
 260 |     | <span class='neutral'>    }</span>
 261 |     | <span class='neutral'></span>
 262 |     | <span class='unexecuted'>    function _mint(address account, uint256 amount) internal {</span>
 263 |     | <span class='unexecuted'>        require(account != address(0), &quot;EBTCToken: mint to zero recipient!&quot;);</span>
 264 |     | <span class='neutral'></span>
 265 |     | <span class='unexecuted'>        _totalSupply = _totalSupply + amount;</span>
 266 |     | <span class='unexecuted'>        _balances[account] = _balances[account] + amount;</span>
 267 |     | <span class='unexecuted'>        emit Transfer(address(0), account, amount);</span>
 268 |     | <span class='neutral'>    }</span>
 269 |     | <span class='neutral'></span>
 270 |     | <span class='unexecuted'>    function _burn(address account, uint256 amount) internal {</span>
 271 |     | <span class='unexecuted'>        require(account != address(0), &quot;EBTCToken: burn from zero account!&quot;);</span>
 272 |     | <span class='neutral'></span>
 273 |     | <span class='unexecuted'>        uint256 cachedBalance = _balances[account];</span>
 274 |     | <span class='unexecuted'>        require(cachedBalance &gt;= amount, &quot;ERC20: burn amount exceeds balance&quot;);</span>
 275 |     | <span class='neutral'></span>
 276 |     | <span class='neutral'>        unchecked {</span>
 277 |     | <span class='neutral'>            // Safe because of the check above</span>
 278 |     | <span class='unexecuted'>            _balances[account] = cachedBalance - amount;</span>
 279 |     | <span class='neutral'>        }</span>
 280 |     | <span class='neutral'></span>
 281 |     | <span class='unexecuted'>        _totalSupply = _totalSupply - amount;</span>
 282 |     | <span class='unexecuted'>        emit Transfer(account, address(0), amount);</span>
 283 |     | <span class='neutral'>    }</span>
 284 |     | <span class='neutral'></span>
 285 |     | <span class='unexecuted'>    function _approve(address owner, address spender, uint256 amount) internal {</span>
 286 |     | <span class='unexecuted'>        require(owner != address(0), &quot;EBTCToken: zero approve owner!&quot;);</span>
 287 |     | <span class='unexecuted'>        require(spender != address(0), &quot;EBTCToken: zero approve spender!&quot;);</span>
 288 |     | <span class='neutral'></span>
 289 |     | <span class='unexecuted'>        _allowances[owner][spender] = amount;</span>
 290 |     | <span class='unexecuted'>        emit Approval(owner, spender, amount);</span>
 291 |     | <span class='neutral'>    }</span>
 292 |     | <span class='neutral'></span>
 293 |     | <span class='neutral'>    // --- &#39;require&#39; functions ---</span>
 294 |     | <span class='neutral'></span>
 295 |     | <span class='unexecuted'>    function _requireValidRecipient(address _recipient) internal view {</span>
 296 |     | <span class='unexecuted'>        require(</span>
 297 |     | <span class='unexecuted'>            _recipient != address(0) &amp;&amp; _recipient != address(this),</span>
 298 |     | <span class='neutral'>            &quot;EBTC: Cannot transfer tokens directly to the EBTC token contract or the zero address&quot;</span>
 299 |     | <span class='neutral'>        );</span>
 300 |     | <span class='unexecuted'>        require(</span>
 301 |     | <span class='unexecuted'>            _recipient != cdpManagerAddress &amp;&amp; _recipient != borrowerOperationsAddress,</span>
 302 |     | <span class='neutral'>            &quot;EBTC: Cannot transfer tokens directly to the CdpManager or BorrowerOps&quot;</span>
 303 |     | <span class='neutral'>        );</span>
 304 |     | <span class='neutral'>    }</span>
 305 |     | <span class='neutral'></span>
 306 |     | <span class='neutral'>    function _requireCallerIsBorrowerOperations() internal view {</span>
 307 |     | <span class='neutral'>        require(</span>
 308 |     | <span class='neutral'>            msg.sender == borrowerOperationsAddress,</span>
 309 |     | <span class='neutral'>            &quot;EBTCToken: Caller is not BorrowerOperations&quot;</span>
 310 |     | <span class='neutral'>        );</span>
 311 |     | <span class='neutral'>    }</span>
 312 |     | <span class='neutral'></span>
 313 |     | <span class='neutral'>    /// @dev authority check last to short-circuit in the case of use by usual immutable addresses</span>
 314 |     | <span class='unexecuted'>    function _requireCallerIsBOorCdpMOrAuth() internal view {</span>
 315 |     | <span class='unexecuted'>        require(</span>
 316 |     | <span class='unexecuted'>            msg.sender == borrowerOperationsAddress ||</span>
 317 |     | <span class='unexecuted'>                msg.sender == cdpManagerAddress ||</span>
 318 |     | <span class='unexecuted'>                isAuthorized(msg.sender, msg.sig),</span>
 319 |     | <span class='neutral'>            &quot;EBTC: Caller is neither BorrowerOperations nor CdpManager nor authorized&quot;</span>
 320 |     | <span class='neutral'>        );</span>
 321 |     | <span class='neutral'>    }</span>
 322 |     | <span class='neutral'></span>
 323 |     | <span class='neutral'>    function _requireCallerIsCdpM() internal view {</span>
 324 |     | <span class='neutral'>        require(msg.sender == cdpManagerAddress, &quot;EBTC: Caller is not CdpManager&quot;);</span>
 325 |     | <span class='neutral'>    }</span>
 326 |     | <span class='neutral'></span>
 327 |     | <span class='neutral'>    // --- Optional functions ---</span>
 328 |     | <span class='neutral'></span>
 329 |     | <span class='neutral'>    /// @notice Returns the name of the token</span>
 330 |     | <span class='neutral'>    /// @return Name of the token</span>
 331 |     | <span class='unexecuted'>    function name() external pure override returns (string memory) {</span>
 332 |     | <span class='unexecuted'>        return _NAME;</span>
 333 |     | <span class='neutral'>    }</span>
 334 |     | <span class='neutral'></span>
 335 |     | <span class='neutral'>    /// @notice Returns the symbol of the token</span>
 336 |     | <span class='neutral'>    /// @return Symbol of the token</span>
 337 |     | <span class='unexecuted'>    function symbol() external pure override returns (string memory) {</span>
 338 |     | <span class='unexecuted'>        return _SYMBOL;</span>
 339 |     | <span class='neutral'>    }</span>
 340 |     | <span class='neutral'></span>
 341 |     | <span class='neutral'>    /// @notice Returns the number of decimals used to represent token amounts</span>
 342 |     | <span class='neutral'>    /// @return Number of decimals used by the token</span>
 343 |     | <span class='unexecuted'>    function decimals() external pure override returns (uint8) {</span>
 344 |     | <span class='neutral'>        return _DECIMALS;</span>
 345 |     | <span class='neutral'>    }</span>
 346 |     | <span class='neutral'></span>
 347 |     | <span class='neutral'>    /// @notice Returns the version of the token</span>
 348 |     | <span class='neutral'>    /// @return Version of the token</span>
 349 |     | <span class='unexecuted'>    function version() external pure override returns (string memory) {</span>
 350 |     | <span class='unexecuted'>        return _VERSION;</span>
 351 |     | <span class='neutral'>    }</span>
 352 |     | <span class='neutral'></span>
 353 |     | <span class='neutral'>    /// @notice Returns the type hash used for permit() function as per EIP-2612</span>
 354 |     | <span class='neutral'>    /// @return EIP-2612 permit type hash</span>
 355 |     | <span class='unexecuted'>    function permitTypeHash() external pure override returns (bytes32) {</span>
 356 |     | <span class='neutral'>        return _PERMIT_TYPEHASH;</span>
 357 |     | <span class='neutral'>    }</span>
 358 |     | <span class='neutral'>}</span>
 359 |     | <span class='neutral'></span>

</code>
<br />

<b>/mnt/c/Users/Lourens/Documents/Recon-Fuzz/collabs/ebtc/packages/contracts/contracts/EbtcFeed.sol</b>
<code>
   1 |     | <span class='neutral'>// SPDX-License-Identifier: MIT</span>
   2 |     | <span class='neutral'></span>
   3 |     | <span class='neutral'>pragma solidity 0.8.17;</span>
   4 |     | <span class='neutral'></span>
   5 |     | <span class='neutral'>import &quot;./Interfaces/IPriceFeed.sol&quot;;</span>
   6 |     | <span class='neutral'>import {IPriceFetcher} from &quot;./Interfaces/IOracleCaller.sol&quot;;</span>
   7 |     | <span class='neutral'>import &quot;./Dependencies/AuthNoOwner.sol&quot;;</span>
   8 |     | <span class='neutral'></span>
   9 |     | <span class='neutral'>/*</span>
  10 |     | <span class='neutral'> * PriceFeed for mainnet deployment, it connects to two Chainlink&#39;s live feeds, ETH:BTC and</span>
  11 |     | <span class='neutral'> * stETH:ETH, which are used to aggregate the price feed of stETH:BTC in conjuction.</span>
  12 |     | <span class='neutral'> * It also allows for a fallback oracle to intervene in case that the primary Chainlink oracle fails.</span>
  13 |     | <span class='neutral'> *</span>
  14 |     | <span class='neutral'> * The PriceFeed uses Chainlink as primary oracle and allows for an optional fallback source. It contains logic for</span>
  15 |     | <span class='neutral'> * switching oracles based on oracle failures, timeouts, and conditions for returning to the primary</span>
  16 |     | <span class='neutral'> * Chainlink oracle. In addition, it contains the mechanism to add or remove the fallback oracle through governance.</span>
  17 |     | <span class='neutral'> */</span>
  18 | *   | <span class='executed'>contract EbtcFeed is IPriceFeed, AuthNoOwner {</span>
  19 |     | <span class='unexecuted'>    string public constant NAME = &quot;EbtcFeed&quot;;</span>
  20 |     | <span class='neutral'></span>
  21 |     | <span class='neutral'>    // The last good price seen from an oracle by Liquity</span>
  22 | *   | <span class='executed'>    uint256 public lastGoodPrice;</span>
  23 |     | <span class='neutral'></span>
  24 |     | <span class='unexecuted'>    address public primaryOracle;</span>
  25 |     | <span class='unexecuted'>    address public secondaryOracle;</span>
  26 |     | <span class='neutral'></span>
  27 |     | <span class='unexecuted'>    uint256 constant INVALID_PRICE = 0;</span>
  28 |     | <span class='neutral'>    address constant UNSET_ADDRESS = address(0);</span>
  29 | *   | <span class='executed'>    uint256 constant GAS_LIMIT = 2_000_000;</span>
  30 |     | <span class='neutral'></span>
  31 |     | <span class='neutral'>    // --- Events ---</span>
  32 |     | <span class='neutral'></span>
  33 |     | <span class='neutral'>    event PrimaryOracleUpdated(address indexed _oldOracle, address indexed _newOracle);</span>
  34 |     | <span class='neutral'>    event SecondaryOracleUpdated(address indexed _oldOracle, address indexed _newOracle);</span>
  35 |     | <span class='neutral'></span>
  36 |     | <span class='neutral'>    // NOTE: Could still use Status to signal current FSM</span>
  37 |     | <span class='neutral'></span>
  38 |     | <span class='neutral'>    // --- Dependency setters ---</span>
  39 |     | <span class='neutral'></span>
  40 |     | <span class='neutral'>    /// @notice Sets the addresses of the contracts and initializes the system</span>
  41 |     | <span class='unexecuted'>    constructor(address _authorityAddress, address _primaryOracle, address _secondaryOracle) {</span>
  42 |     | <span class='unexecuted'>        _initializeAuthority(_authorityAddress);</span>
  43 |     | <span class='neutral'></span>
  44 |     | <span class='unexecuted'>        uint256 firstPrice = IPriceFetcher(_primaryOracle).fetchPrice();</span>
  45 |     | <span class='unexecuted'>        require(firstPrice != INVALID_PRICE, &quot;EbtcFeed: Primary Oracle Must Work&quot;);</span>
  46 |     | <span class='neutral'></span>
  47 |     | <span class='unexecuted'>        _storePrice(firstPrice);</span>
  48 |     | <span class='neutral'></span>
  49 |     | <span class='unexecuted'>        primaryOracle = _primaryOracle;</span>
  50 |     | <span class='neutral'></span>
  51 |     | <span class='neutral'>        // If secondaryOracle is known at deployment let&#39;s add it</span>
  52 |     | <span class='unexecuted'>        if (_secondaryOracle != UNSET_ADDRESS) {</span>
  53 |     | <span class='unexecuted'>            uint256 secondaryOraclePrice = IPriceFetcher(_secondaryOracle).fetchPrice();</span>
  54 |     | <span class='neutral'></span>
  55 |     | <span class='unexecuted'>            if (secondaryOraclePrice != INVALID_PRICE) {</span>
  56 |     | <span class='unexecuted'>                secondaryOracle = _secondaryOracle;</span>
  57 |     | <span class='neutral'>            }</span>
  58 |     | <span class='neutral'>        }</span>
  59 |     | <span class='neutral'>    }</span>
  60 |     | <span class='neutral'></span>
  61 |     | <span class='neutral'>    /// @notice Allows the owner to replace the primary oracle</span>
  62 |     | <span class='neutral'>    ///     The oracle must work (return non-zero value)</span>
  63 |     | <span class='unexecuted'>    function setPrimaryOracle(address _newPrimary) external requiresAuth {</span>
  64 |     | <span class='unexecuted'>        uint256 currentPrice = IPriceFetcher(_newPrimary).fetchPrice();</span>
  65 |     | <span class='unexecuted'>        require(currentPrice != INVALID_PRICE, &quot;EbtcFeed: Primary Oracle Must Work&quot;);</span>
  66 |     | <span class='neutral'></span>
  67 |     | <span class='unexecuted'>        emit PrimaryOracleUpdated(primaryOracle, _newPrimary);</span>
  68 |     | <span class='unexecuted'>        primaryOracle = _newPrimary;</span>
  69 |     | <span class='neutral'>    }</span>
  70 |     | <span class='neutral'></span>
  71 |     | <span class='neutral'>    /// @notice Allows the owner to replace the secondary oracle</span>
  72 |     | <span class='neutral'>    ///     The oracle must work (return non-zero value), unless removed</span>
  73 |     | <span class='unexecuted'>    function setSecondaryOracle(address _newSecondary) external requiresAuth {</span>
  74 |     | <span class='neutral'>        // Allow governance to remove the secondary oracle</span>
  75 |     | <span class='unexecuted'>        if (_newSecondary != UNSET_ADDRESS) {</span>
  76 |     | <span class='unexecuted'>            uint256 currentPrice = IPriceFetcher(_newSecondary).fetchPrice();</span>
  77 |     | <span class='unexecuted'>            require(currentPrice != INVALID_PRICE, &quot;EbtcFeed: Secondary Oracle Must Work&quot;);</span>
  78 |     | <span class='neutral'>        }</span>
  79 |     | <span class='neutral'></span>
  80 |     | <span class='unexecuted'>        emit SecondaryOracleUpdated(secondaryOracle, _newSecondary);</span>
  81 |     | <span class='unexecuted'>        secondaryOracle = _newSecondary;</span>
  82 |     | <span class='neutral'>    }</span>
  83 |     | <span class='neutral'></span>
  84 |     | <span class='neutral'>    /// @notice Fetch the Latest Valid Price</span>
  85 |     | <span class='neutral'>    ///     Assumes the oracle call will return 0 if the data is invalid</span>
  86 |     | <span class='neutral'>    ///     Any non-zero value will be interpreted as valid</span>
  87 |     | <span class='neutral'>    ///     The security checks must be performed by the OracleCallers</span>
  88 |     | <span class='neutral'>    ///</span>
  89 |     | <span class='neutral'>    ///     Logic Breakdown:</span>
  90 |     | <span class='neutral'>    ///</span>
  91 |     | <span class='neutral'>    ///     If primary works, use that and store it as last good price</span>
  92 |     | <span class='neutral'>    ///</span>
  93 |     | <span class='neutral'>    ///     If not, try using secondary, if secondary works, use that and store it as last good price</span>
  94 |     | <span class='neutral'>    ///</span>
  95 |     | <span class='neutral'>    ///     If neither work, use the last good price</span>
  96 |     | <span class='neutral'>    ///</span>
  97 |     | <span class='neutral'>    ///     @dev All calls are done via `tinfoilCall` to allow the maximum resiliency we are able to provide</span>
  98 |     | <span class='neutral'>    ///     Due to this, a OracleCaller has to be written, which will be responsible for calling the real oracle</span>
  99 |     | <span class='neutral'>    ///     this ensures all interfaces are the same and that the logic here is to handle:</span>
 100 |     | <span class='neutral'>    ///     - Functioning Case</span>
 101 |     | <span class='neutral'>    ///     - All types of DOSes by the Oracles</span>
 102 | *   | <span class='executed'>    function fetchPrice() external override returns (uint256) {</span>
 103 |     | <span class='neutral'>        // Tinfoil Call</span>
 104 | *   | <span class='executed'>        uint256 primaryResponse = tinfoilCall(</span>
 105 | *   | <span class='executed'>            primaryOracle,</span>
 106 | *   | <span class='executed'>            abi.encodeCall(IPriceFetcher.fetchPrice, ())</span>
 107 |     | <span class='neutral'>        );</span>
 108 |     | <span class='neutral'></span>
 109 | *   | <span class='executed'>        if (primaryResponse != INVALID_PRICE) {</span>
 110 | *   | <span class='executed'>            _storePrice(primaryResponse);</span>
 111 | *   | <span class='executed'>            return primaryResponse;</span>
 112 |     | <span class='neutral'>        }</span>
 113 |     | <span class='neutral'></span>
 114 | *   | <span class='executed'>        if (secondaryOracle == UNSET_ADDRESS) {</span>
 115 | *   | <span class='executed'>            return lastGoodPrice; // No fallback, just return latest</span>
 116 |     | <span class='neutral'>        }</span>
 117 |     | <span class='neutral'></span>
 118 |     | <span class='neutral'>        // Let&#39;s try secondary</span>
 119 |     | <span class='unexecuted'>        uint256 secondaryResponse = tinfoilCall(</span>
 120 |     | <span class='unexecuted'>            secondaryOracle,</span>
 121 |     | <span class='unexecuted'>            abi.encodeCall(IPriceFetcher.fetchPrice, ())</span>
 122 |     | <span class='neutral'>        );</span>
 123 |     | <span class='neutral'></span>
 124 |     | <span class='unexecuted'>        if (secondaryResponse != INVALID_PRICE) {</span>
 125 | *   | <span class='executed'>            _storePrice(secondaryResponse);</span>
 126 | *   | <span class='executed'>            return secondaryResponse;</span>
 127 |     | <span class='neutral'>        }</span>
 128 |     | <span class='neutral'></span>
 129 |     | <span class='neutral'>        // No valid price, return last</span>
 130 |     | <span class='neutral'>        // NOTE: We could emit something here as this means both oracles are dead</span>
 131 |     | <span class='unexecuted'>        return lastGoodPrice;</span>
 132 |     | <span class='neutral'>    }</span>
 133 |     | <span class='neutral'></span>
 134 |     | <span class='neutral'>    /// @notice Stores the latest valid price.</span>
 135 |     | <span class='neutral'>    /// @param _currentPrice The price to be stored.</span>
 136 | *   | <span class='executed'>    function _storePrice(uint256 _currentPrice) internal {</span>
 137 | *   | <span class='executed'>        lastGoodPrice = _currentPrice;</span>
 138 | *   | <span class='executed'>        emit LastGoodPriceUpdated(_currentPrice);</span>
 139 |     | <span class='neutral'>    }</span>
 140 |     | <span class='neutral'></span>
 141 |     | <span class='neutral'>    /// @dev Performs a TinfoilCall, with all known protections</span>
 142 |     | <span class='neutral'>    ///     Against:</span>
 143 |     | <span class='neutral'>    ///     GasGriefing (burning all the gas)</span>
 144 |     | <span class='neutral'>    ///     Return and Revert Bombing (sending insane amounts of data to trigger memory expansion)</span>
 145 |     | <span class='neutral'>    ///     Self-Destruction of contract</span>
 146 |     | <span class='neutral'>    ///</span>
 147 |     | <span class='neutral'>    ///     Also attempts to protect against returning incorrect data</span>
 148 |     | <span class='neutral'>    ///    `excessivelySafeCall` is modified to only load data if the length is the expected one</span>
 149 |     | <span class='neutral'>    ///     This would avoid against receiving gibberish data, most often arrays</span>
 150 | *   | <span class='executed'>    function tinfoilCall(address _target, bytes memory _calldata) public returns (uint256) {</span>
 151 |     | <span class='neutral'>        // Cap gas at 2 MLN, we don&#39;t care about 1/64 cause we expect oracles to consume way less than 200k gas</span>
 152 | *   | <span class='executed'>        uint256 gasLeft = gasleft();</span>
 153 | *   | <span class='executed'>        uint256 cappedGas = gasLeft &gt; GAS_LIMIT ? GAS_LIMIT : gasLeft;</span>
 154 |     | <span class='neutral'></span>
 155 |     | <span class='neutral'>        // NOTE: We could also just check for contract existence here to avoid more issues later</span>
 156 |     | <span class='neutral'></span>
 157 | *   | <span class='executed'>        (bool success, bytes memory res) = excessivelySafeCall(_target, cappedGas, 0, 32, _calldata);</span>
 158 |     | <span class='neutral'></span>
 159 |     | <span class='neutral'>        // Check of success and length allows to ignore checking for contract existence</span>
 160 |     | <span class='neutral'>        //  since non-existent contract cannot return value</span>
 161 | *   | <span class='executed'>        if (success &amp;&amp; res.length == 32) {</span>
 162 |     | <span class='neutral'>            // Parse return value as uint256</span>
 163 | *   | <span class='executed'>            return abi.decode(res, (uint256));</span>
 164 |     | <span class='neutral'>        }</span>
 165 |     | <span class='neutral'></span>
 166 |     | <span class='neutral'>        return INVALID_PRICE;</span>
 167 |     | <span class='neutral'>    }</span>
 168 |     | <span class='neutral'></span>
 169 |     | <span class='neutral'>    /// @dev MODIFIED excessivelySafeCall to perform generic calls without getting gas bombed</span>
 170 |     | <span class='neutral'>    ///     Modified to only load the response if it has the intended length</span>
 171 |     | <span class='neutral'>    /// @custom:credits to: https://github.com/nomad-xyz/ExcessivelySafeCall/blob/main/src/ExcessivelySafeCall.sol</span>
 172 | *   | <span class='executed'>    function excessivelySafeCall(</span>
 173 |     | <span class='neutral'>        address _target,</span>
 174 |     | <span class='neutral'>        uint256 _gas,</span>
 175 |     | <span class='neutral'>        uint256 _value,</span>
 176 |     | <span class='neutral'>        uint16 _expectedLength,</span>
 177 |     | <span class='neutral'>        bytes memory _calldata</span>
 178 | *   | <span class='executed'>    ) internal returns (bool, bytes memory) {</span>
 179 |     | <span class='neutral'>        // set up for assembly call</span>
 180 | *   | <span class='executed'>        uint256 _receivedLength; // Length of data we receive</span>
 181 | *   | <span class='executed'>        bool _success;</span>
 182 | *   | <span class='executed'>        bytes memory _returnData = new bytes(_expectedLength);</span>
 183 |     | <span class='neutral'>        // dispatch message to recipient</span>
 184 |     | <span class='neutral'>        // by assembly calling &quot;handle&quot; function</span>
 185 |     | <span class='neutral'>        // we call via assembly to avoid memcopying a very large returndata</span>
 186 |     | <span class='neutral'>        // returned by a malicious contract</span>
 187 |     | <span class='neutral'>        assembly {</span>
 188 | *   | <span class='executed'>            _success := call(</span>
 189 | *   | <span class='executed'>                _gas, // gas</span>
 190 | *   | <span class='executed'>                _target, // recipient</span>
 191 | *   | <span class='executed'>                _value, // ether value</span>
 192 | *   | <span class='executed'>                add(_calldata, 0x20), // inloc</span>
 193 | *   | <span class='executed'>                mload(_calldata), // inlen</span>
 194 | *   | <span class='executed'>                0, // outloc</span>
 195 | *   | <span class='executed'>                0 // outlen</span>
 196 |     | <span class='neutral'>            )</span>
 197 |     | <span class='neutral'>            // limit our copy to 256 bytes</span>
 198 | *   | <span class='executed'>            _receivedLength := returndatasize()</span>
 199 |     | <span class='neutral'>            // NOTE: Read the data only if it&#39;s the expected length, else it must be some weird stuff</span>
 200 | *   | <span class='executed'>            if eq(_receivedLength, _expectedLength) {</span>
 201 |     | <span class='neutral'>                // Store the length of the copied bytes</span>
 202 | *   | <span class='executed'>                mstore(_returnData, _receivedLength)</span>
 203 |     | <span class='neutral'>                // copy the bytes from returndata[0:_receivedLength]</span>
 204 | *   | <span class='executed'>                returndatacopy(add(_returnData, 0x20), 0, _receivedLength)</span>
 205 |     | <span class='neutral'>            }</span>
 206 |     | <span class='neutral'>        }</span>
 207 | *   | <span class='executed'>        return (_success, _returnData);</span>
 208 |     | <span class='neutral'>    }</span>
 209 |     | <span class='neutral'>}</span>
 210 |     | <span class='neutral'></span>

</code>
<br />

<b>/mnt/c/Users/Lourens/Documents/Recon-Fuzz/collabs/ebtc/packages/contracts/contracts/FeeRecipient.sol</b>
<code>
  1 |     | <span class='neutral'>// SPDX-License-Identifier: MIT</span>
  2 |     | <span class='neutral'></span>
  3 |     | <span class='neutral'>pragma solidity 0.8.17;</span>
  4 |     | <span class='neutral'></span>
  5 |     | <span class='neutral'>import &quot;./Dependencies/Ownable.sol&quot;;</span>
  6 |     | <span class='neutral'>import &quot;./Dependencies/AuthNoOwner.sol&quot;;</span>
  7 |     | <span class='neutral'>import &quot;./Dependencies/IERC20.sol&quot;;</span>
  8 |     | <span class='neutral'>import &quot;./Dependencies/SafeERC20.sol&quot;;</span>
  9 |     | <span class='neutral'></span>
 10 |     | <span class='neutral'>/// @notice Minimal fee recipient</span>
 11 |     | <span class='neutral'>/// @notice Tokens can be swept to owner address by authorized user</span>
 12 |     | <span class='unexecuted'>contract FeeRecipient is Ownable, AuthNoOwner {</span>
 13 |     | <span class='neutral'>    using SafeERC20 for IERC20;</span>
 14 |     | <span class='neutral'></span>
 15 |     | <span class='neutral'>    event SweepTokenSuccess(address indexed _token, uint256 _amount, address indexed _recipient);</span>
 16 |     | <span class='neutral'></span>
 17 |     | <span class='unexecuted'>    string public constant NAME = &quot;FeeRecipient&quot;;</span>
 18 |     | <span class='neutral'></span>
 19 |     | <span class='neutral'>    /// @dev Contract constructor that sets the owner and authority of the contract.</span>
 20 |     | <span class='neutral'>    /// @param _ownerAddress Address of the contract owner.</span>
 21 |     | <span class='neutral'>    /// @param _authorityAddress Address of the authority.</span>
 22 |     | <span class='unexecuted'>    constructor(address _ownerAddress, address _authorityAddress) {</span>
 23 |     | <span class='unexecuted'>        _transferOwnership(_ownerAddress);</span>
 24 |     | <span class='unexecuted'>        _initializeAuthority(_authorityAddress);</span>
 25 |     | <span class='neutral'>    }</span>
 26 |     | <span class='neutral'></span>
 27 |     | <span class='neutral'>    // === Governed Functions === //</span>
 28 |     | <span class='neutral'></span>
 29 |     | <span class='neutral'>    /// @dev Function to move unintended dust that are not protected</span>
 30 |     | <span class='neutral'>    /// @notice moves given amount of given token (collateral is NOT allowed)</span>
 31 |     | <span class='neutral'>    /// @notice because recipient are fixed, this function is safe to be called by anyone</span>
 32 |     | <span class='unexecuted'>    function sweepToken(address token, uint256 amount) public requiresAuth {</span>
 33 |     | <span class='unexecuted'>        uint256 balance = IERC20(token).balanceOf(address(this));</span>
 34 |     | <span class='unexecuted'>        require(amount &lt;= balance, &quot;FeeRecipient: Attempt to sweep more than balance&quot;);</span>
 35 |     | <span class='neutral'></span>
 36 |     | <span class='unexecuted'>        address _owner = owner();</span>
 37 |     | <span class='unexecuted'>        IERC20(token).safeTransfer(_owner, amount);</span>
 38 |     | <span class='neutral'></span>
 39 |     | <span class='unexecuted'>        emit SweepTokenSuccess(token, amount, _owner);</span>
 40 |     | <span class='neutral'>    }</span>
 41 |     | <span class='neutral'>}</span>
 42 |     | <span class='neutral'></span>

</code>
<br />

<b>/mnt/c/Users/Lourens/Documents/Recon-Fuzz/collabs/ebtc/packages/contracts/contracts/FixedAdapter.sol</b>
<code>
  1 |     | <span class='neutral'>// SPDX-License-Identifier: MIT</span>
  2 |     | <span class='neutral'>pragma solidity 0.8.17;</span>
  3 |     | <span class='neutral'></span>
  4 |     | <span class='neutral'>import {AggregatorV3Interface} from &quot;./Dependencies/AggregatorV3Interface.sol&quot;;</span>
  5 |     | <span class='neutral'></span>
  6 | *   | <span class='executed'>contract FixedAdapter is AggregatorV3Interface {</span>
  7 | *   | <span class='executed'>    uint8 public constant override decimals = 18;</span>
  8 |     | <span class='unexecuted'>    uint256 public constant override version = 1;</span>
  9 |     | <span class='neutral'></span>
 10 |     | <span class='neutral'>    /// @notice PriceFeed always fetches current and previous rounds. It&#39;s ok to</span>
 11 |     | <span class='neutral'>    /// hardcode round IDs as long as they are greater than 0.</span>
 12 | *   | <span class='executed'>    uint80 public constant CURRENT_ROUND = 2;</span>
 13 | *   | <span class='executed'>    uint80 public constant PREVIOUS_ROUND = 1;</span>
 14 | *   | <span class='executed'>    int256 internal constant ADAPTER_PRECISION = int256(10 ** decimals);</span>
 15 |     | <span class='neutral'></span>
 16 |     | <span class='unexecuted'>    function description() external view returns (string memory) {</span>
 17 |     | <span class='unexecuted'>        return &quot;stETH/ETH Fixed Adapter&quot;;</span>
 18 |     | <span class='neutral'>    }</span>
 19 |     | <span class='neutral'></span>
 20 |     | <span class='neutral'>    // getRoundData and latestRoundData should both raise &quot;No data present&quot;</span>
 21 |     | <span class='neutral'>    // if they do not have data to report, instead of returning unset values</span>
 22 |     | <span class='neutral'>    // which could be misinterpreted as actual reported values.</span>
 23 | *   | <span class='executed'>    function getRoundData(</span>
 24 |     | <span class='neutral'>        uint80 _roundId</span>
 25 |     | <span class='neutral'>    )</span>
 26 |     | <span class='neutral'>        external</span>
 27 |     | <span class='neutral'>        view</span>
 28 |     | <span class='neutral'>        returns (</span>
 29 | *   | <span class='executed'>            uint80 roundId,</span>
 30 |     | <span class='neutral'>            int256 answer,</span>
 31 |     | <span class='neutral'>            uint256 startedAt,</span>
 32 |     | <span class='neutral'>            uint256 updatedAt,</span>
 33 |     | <span class='neutral'>            uint80 answeredInRound</span>
 34 |     | <span class='neutral'>        )</span>
 35 |     | <span class='neutral'>    {</span>
 36 | *   | <span class='executed'>        require(_roundId == CURRENT_ROUND || _roundId == PREVIOUS_ROUND);</span>
 37 |     | <span class='neutral'></span>
 38 | *   | <span class='executed'>        roundId = _roundId;</span>
 39 | *   | <span class='executed'>        updatedAt = _roundId == CURRENT_ROUND ? block.timestamp : block.timestamp - 1;</span>
 40 | *   | <span class='executed'>        answer = ADAPTER_PRECISION;</span>
 41 |     | <span class='neutral'>    }</span>
 42 |     | <span class='neutral'></span>
 43 | *   | <span class='executed'>    function latestRoundData()</span>
 44 |     | <span class='neutral'>        external</span>
 45 |     | <span class='neutral'>        view</span>
 46 |     | <span class='neutral'>        returns (</span>
 47 | *   | <span class='executed'>            uint80 roundId,</span>
 48 |     | <span class='neutral'>            int256 answer,</span>
 49 |     | <span class='neutral'>            uint256 startedAt,</span>
 50 |     | <span class='neutral'>            uint256 updatedAt,</span>
 51 |     | <span class='neutral'>            uint80 answeredInRound</span>
 52 |     | <span class='neutral'>        )</span>
 53 |     | <span class='neutral'>    {</span>
 54 |     | <span class='neutral'>        roundId = CURRENT_ROUND;</span>
 55 | *   | <span class='executed'>        updatedAt = block.timestamp;</span>
 56 | *   | <span class='executed'>        answer = ADAPTER_PRECISION;</span>
 57 |     | <span class='neutral'>    }</span>
 58 |     | <span class='neutral'>}</span>
 59 |     | <span class='neutral'></span>

</code>
<br />

<b>/mnt/c/Users/Lourens/Documents/Recon-Fuzz/collabs/ebtc/packages/contracts/contracts/Governor.sol</b>
<code>
   1 |     | <span class='neutral'>// SPDX-License-Identifier: AGPL-3.0-only</span>
   2 |     | <span class='neutral'>pragma solidity 0.8.17;</span>
   3 |     | <span class='neutral'></span>
   4 |     | <span class='neutral'>import {EnumerableSet} from &quot;./Dependencies/EnumerableSet.sol&quot;;</span>
   5 |     | <span class='neutral'>import {Authority} from &quot;./Dependencies/Auth.sol&quot;;</span>
   6 |     | <span class='neutral'>import {RolesAuthority} from &quot;./Dependencies/RolesAuthority.sol&quot;;</span>
   7 |     | <span class='neutral'></span>
   8 |     | <span class='neutral'>/// @notice Role based Authority that supports up to 256 roles.</span>
   9 |     | <span class='neutral'>/// @notice We have taken the tradeoff of additional storage usage for easier readabiliy without using off-chain / indexing services.</span>
  10 |     | <span class='neutral'>/// @author BadgerDAO Expanded from Solmate RolesAuthority</span>
  11 |     | <span class='neutral'>/// @author Modified from Solmate (https://github.com/transmissions11/solmate/blob/main/src/auth/authorities/RolesAuthority.sol)</span>
  12 |     | <span class='neutral'>/// @author Modified from Dappsys (https://github.com/dapphub/ds-roles/blob/master/src/roles.sol)</span>
  13 | *   | <span class='executed'>contract Governor is RolesAuthority {</span>
  14 |     | <span class='neutral'>    using EnumerableSet for EnumerableSet.Bytes32Set;</span>
  15 |     | <span class='neutral'>    using EnumerableSet for EnumerableSet.AddressSet;</span>
  16 |     | <span class='neutral'></span>
  17 |     | <span class='unexecuted'>    bytes32 NO_ROLES = bytes32(0);</span>
  18 |     | <span class='neutral'></span>
  19 |     | <span class='neutral'>    struct Role {</span>
  20 |     | <span class='neutral'>        uint8 roleId;</span>
  21 |     | <span class='neutral'>        string roleName;</span>
  22 |     | <span class='neutral'>    }</span>
  23 |     | <span class='neutral'></span>
  24 |     | <span class='neutral'>    struct Capability {</span>
  25 |     | <span class='neutral'>        address target;</span>
  26 |     | <span class='neutral'>        bytes4 functionSig;</span>
  27 |     | <span class='neutral'>        uint8[] roles;</span>
  28 |     | <span class='neutral'>    }</span>
  29 |     | <span class='neutral'></span>
  30 |     | <span class='neutral'>    mapping(uint8 =&gt; string) internal roleNames;</span>
  31 |     | <span class='neutral'></span>
  32 |     | <span class='neutral'>    event RoleNameSet(uint8 indexed role, string indexed name);</span>
  33 |     | <span class='neutral'></span>
  34 |     | <span class='neutral'>    /// @notice The contract constructor initializes RolesAuthority with the given owner.</span>
  35 |     | <span class='neutral'>    /// @param _owner The address of the owner, who gains all permissions by default.</span>
  36 |     | <span class='unexecuted'>    constructor(address _owner) RolesAuthority(_owner, Authority(address(this))) {}</span>
  37 |     | <span class='neutral'></span>
  38 |     | <span class='neutral'>    /// @notice Returns a list of users that are assigned a specific role.</span>
  39 |     | <span class='neutral'>    /// @dev This function searches all users and checks if they are assigned the given role.</span>
  40 |     | <span class='neutral'>    /// @dev Intended for off-chain utility only due to inefficiency.</span>
  41 |     | <span class='neutral'>    /// @param role The role ID to find users for.</span>
  42 |     | <span class='neutral'>    /// @return usersWithRole An array of addresses that are assigned the given role.</span>
  43 |     | <span class='unexecuted'>    function getUsersByRole(uint8 role) external view returns (address[] memory usersWithRole) {</span>
  44 |     | <span class='neutral'>        // Search over all users: O(n) * 2</span>
  45 |     | <span class='unexecuted'>        uint256 count;</span>
  46 |     | <span class='unexecuted'>        for (uint256 i = 0; i &lt; users.length(); i++) {</span>
  47 |     | <span class='unexecuted'>            address user = users.at(i);</span>
  48 |     | <span class='unexecuted'>            bool _canCall = doesUserHaveRole(user, role);</span>
  49 |     | <span class='unexecuted'>            if (_canCall) {</span>
  50 |     | <span class='unexecuted'>                count += 1;</span>
  51 |     | <span class='neutral'>            }</span>
  52 |     | <span class='neutral'>        }</span>
  53 |     | <span class='unexecuted'>        if (count &gt; 0) {</span>
  54 |     | <span class='unexecuted'>            uint256 j = 0;</span>
  55 |     | <span class='unexecuted'>            usersWithRole = new address[](count);</span>
  56 |     | <span class='unexecuted'>            address[] memory _usrs = users.values();</span>
  57 |     | <span class='unexecuted'>            for (uint256 i = 0; i &lt; _usrs.length; i++) {</span>
  58 |     | <span class='unexecuted'>                address user = _usrs[i];</span>
  59 |     | <span class='unexecuted'>                bool _canCall = doesUserHaveRole(user, role);</span>
  60 |     | <span class='unexecuted'>                if (_canCall) {</span>
  61 |     | <span class='unexecuted'>                    usersWithRole[j] = user;</span>
  62 |     | <span class='unexecuted'>                    j++;</span>
  63 |     | <span class='neutral'>                }</span>
  64 |     | <span class='neutral'>            }</span>
  65 |     | <span class='neutral'>        }</span>
  66 |     | <span class='neutral'>    }</span>
  67 |     | <span class='neutral'></span>
  68 |     | <span class='neutral'>    /// @notice Returns a list of roles that an address has.</span>
  69 |     | <span class='neutral'>    /// @dev This function searches all roles and checks if they are assigned to the given user.</span>
  70 |     | <span class='neutral'>    /// @dev Intended for off-chain utility only due to inefficiency.</span>
  71 |     | <span class='neutral'>    /// @param user The address of the user.</span>
  72 |     | <span class='neutral'>    /// @return rolesForUser An array of role IDs that the user has.</span>
  73 |     | <span class='unexecuted'>    function getRolesForUser(address user) external view returns (uint8[] memory rolesForUser) {</span>
  74 |     | <span class='neutral'>        // Enumerate over all possible roles and check if enabled</span>
  75 |     | <span class='unexecuted'>        uint256 count;</span>
  76 |     | <span class='unexecuted'>        for (uint8 i = 0; i &lt;= type(uint8).max; ) {</span>
  77 |     | <span class='unexecuted'>            if (doesUserHaveRole(user, i)) {</span>
  78 |     | <span class='unexecuted'>                count += 1;</span>
  79 |     | <span class='neutral'>            }</span>
  80 |     | <span class='unexecuted'>            if (i &lt; type(uint8).max) {</span>
  81 |     | <span class='unexecuted'>                i = i + 1;</span>
  82 |     | <span class='neutral'>            } else {</span>
  83 |     | <span class='neutral'>                break;</span>
  84 |     | <span class='neutral'>            }</span>
  85 |     | <span class='neutral'>        }</span>
  86 |     | <span class='unexecuted'>        if (count &gt; 0) {</span>
  87 |     | <span class='unexecuted'>            uint256 j = 0;</span>
  88 |     | <span class='unexecuted'>            rolesForUser = new uint8[](count);</span>
  89 |     | <span class='unexecuted'>            for (uint8 i = 0; i &lt;= type(uint8).max; ) {</span>
  90 |     | <span class='unexecuted'>                if (doesUserHaveRole(user, i)) {</span>
  91 |     | <span class='unexecuted'>                    rolesForUser[j] = i;</span>
  92 |     | <span class='unexecuted'>                    j++;</span>
  93 |     | <span class='neutral'>                }</span>
  94 |     | <span class='unexecuted'>                if (i &lt; type(uint8).max) {</span>
  95 |     | <span class='unexecuted'>                    i = i + 1;</span>
  96 |     | <span class='neutral'>                } else {</span>
  97 |     | <span class='neutral'>                    break;</span>
  98 |     | <span class='neutral'>                }</span>
  99 |     | <span class='neutral'>            }</span>
 100 |     | <span class='neutral'>        }</span>
 101 |     | <span class='neutral'>    }</span>
 102 |     | <span class='neutral'></span>
 103 |     | <span class='neutral'>    /// @notice Converts a byte map representation to an array of role IDs.</span>
 104 |     | <span class='neutral'>    /// @param byteMap The bytes32 value encoding the roles.</span>
 105 |     | <span class='neutral'>    /// @return roleIds An array of role IDs extracted from the byte map.</span>
 106 |     | <span class='unexecuted'>    function getRolesFromByteMap(bytes32 byteMap) public pure returns (uint8[] memory roleIds) {</span>
 107 |     | <span class='unexecuted'>        uint256 count;</span>
 108 |     | <span class='unexecuted'>        for (uint8 i = 0; i &lt;= type(uint8).max; ) {</span>
 109 |     | <span class='unexecuted'>            bool roleEnabled = (uint256(byteMap &gt;&gt; i) &amp; 1) != 0;</span>
 110 |     | <span class='unexecuted'>            if (roleEnabled) {</span>
 111 |     | <span class='unexecuted'>                count += 1;</span>
 112 |     | <span class='neutral'>            }</span>
 113 |     | <span class='unexecuted'>            if (i &lt; type(uint8).max) {</span>
 114 |     | <span class='unexecuted'>                i = i + 1;</span>
 115 |     | <span class='neutral'>            } else {</span>
 116 |     | <span class='unexecuted'>                break;</span>
 117 |     | <span class='neutral'>            }</span>
 118 |     | <span class='neutral'>        }</span>
 119 |     | <span class='unexecuted'>        if (count &gt; 0) {</span>
 120 |     | <span class='unexecuted'>            uint256 j = 0;</span>
 121 |     | <span class='unexecuted'>            roleIds = new uint8[](count);</span>
 122 |     | <span class='unexecuted'>            for (uint8 i = 0; i &lt;= type(uint8).max; ) {</span>
 123 |     | <span class='unexecuted'>                bool roleEnabled = (uint256(byteMap &gt;&gt; i) &amp; 1) != 0;</span>
 124 |     | <span class='unexecuted'>                if (roleEnabled) {</span>
 125 |     | <span class='unexecuted'>                    roleIds[j] = i;</span>
 126 |     | <span class='unexecuted'>                    j++;</span>
 127 |     | <span class='neutral'>                }</span>
 128 |     | <span class='unexecuted'>                if (i &lt; type(uint8).max) {</span>
 129 |     | <span class='unexecuted'>                    i = i + 1;</span>
 130 |     | <span class='neutral'>                } else {</span>
 131 |     | <span class='unexecuted'>                    break;</span>
 132 |     | <span class='neutral'>                }</span>
 133 |     | <span class='neutral'>            }</span>
 134 |     | <span class='neutral'>        }</span>
 135 |     | <span class='neutral'>    }</span>
 136 |     | <span class='neutral'></span>
 137 |     | <span class='neutral'>    /// @notice Converts an array of role IDs to a byte map representation.</span>
 138 |     | <span class='neutral'>    /// @param roleIds An array of role IDs.</span>
 139 |     | <span class='neutral'>    /// @return A bytes32 value encoding the roles.</span>
 140 |     | <span class='unexecuted'>    function getByteMapFromRoles(uint8[] memory roleIds) public pure returns (bytes32) {</span>
 141 |     | <span class='unexecuted'>        bytes32 _data;</span>
 142 |     | <span class='unexecuted'>        for (uint256 i = 0; i &lt; roleIds.length; i++) {</span>
 143 |     | <span class='unexecuted'>            _data |= bytes32(1 &lt;&lt; uint256(roleIds[i]));</span>
 144 |     | <span class='neutral'>        }</span>
 145 |     | <span class='unexecuted'>        return _data;</span>
 146 |     | <span class='neutral'>    }</span>
 147 |     | <span class='neutral'></span>
 148 |     | <span class='neutral'>    /// @notice Retrieves all function signatures enabled for a target address.</span>
 149 |     | <span class='neutral'>    /// @param _target The target contract address.</span>
 150 |     | <span class='neutral'>    /// @return _funcs An array of function signatures enabled for the target.</span>
 151 |     | <span class='unexecuted'>    function getEnabledFunctionsInTarget(</span>
 152 |     | <span class='neutral'>        address _target</span>
 153 |     | <span class='unexecuted'>    ) public view returns (bytes4[] memory _funcs) {</span>
 154 |     | <span class='unexecuted'>        bytes32[] memory _sigs = enabledFunctionSigsByTarget[_target].values();</span>
 155 |     | <span class='unexecuted'>        if (_sigs.length &gt; 0) {</span>
 156 |     | <span class='unexecuted'>            _funcs = new bytes4[](_sigs.length);</span>
 157 |     | <span class='unexecuted'>            for (uint256 i = 0; i &lt; _sigs.length; ++i) {</span>
 158 |     | <span class='unexecuted'>                _funcs[i] = bytes4(_sigs[i]);</span>
 159 |     | <span class='neutral'>            }</span>
 160 |     | <span class='neutral'>        }</span>
 161 |     | <span class='neutral'>    }</span>
 162 |     | <span class='neutral'></span>
 163 |     | <span class='neutral'>    /// @notice Retrieves the name associated with a role ID</span>
 164 |     | <span class='neutral'>    /// @param role The role ID</span>
 165 |     | <span class='neutral'>    /// @return roleName The name of the role</span>
 166 |     | <span class='unexecuted'>    function getRoleName(uint8 role) external view returns (string memory roleName) {</span>
 167 |     | <span class='unexecuted'>        return roleNames[role];</span>
 168 |     | <span class='neutral'>    }</span>
 169 |     | <span class='neutral'></span>
 170 |     | <span class='neutral'>    /// @notice Sets the name for a specific role ID for better readability</span>
 171 |     | <span class='neutral'>    /// @dev This function requires authorization</span>
 172 |     | <span class='neutral'>    /// @param role The role ID</span>
 173 |     | <span class='neutral'>    /// @param roleName The name to assign to the role</span>
 174 |     | <span class='unexecuted'>    function setRoleName(uint8 role, string memory roleName) external requiresAuth {</span>
 175 |     | <span class='unexecuted'>        roleNames[role] = roleName;</span>
 176 |     | <span class='neutral'></span>
 177 |     | <span class='unexecuted'>        emit RoleNameSet(role, roleName);</span>
 178 |     | <span class='neutral'>    }</span>
 179 |     | <span class='neutral'>}</span>
 180 |     | <span class='neutral'></span>

</code>
<br />

<b>/mnt/c/Users/Lourens/Documents/Recon-Fuzz/collabs/ebtc/packages/contracts/contracts/HintHelpers.sol</b>
<code>
   1 |     | <span class='neutral'>// SPDX-License-Identifier: MIT</span>
   2 |     | <span class='neutral'></span>
   3 |     | <span class='neutral'>pragma solidity 0.8.17;</span>
   4 |     | <span class='neutral'></span>
   5 |     | <span class='neutral'>import &quot;./Interfaces/ICdpManager.sol&quot;;</span>
   6 |     | <span class='neutral'>import &quot;./Interfaces/ISortedCdps.sol&quot;;</span>
   7 |     | <span class='neutral'>import &quot;./Dependencies/EbtcBase.sol&quot;;</span>
   8 |     | <span class='neutral'></span>
   9 |     | <span class='neutral'>/// @title HintHelpers mainly serves to provide handy information to facilitate offchain integration like redemption bots.</span>
  10 |     | <span class='neutral'>/// @dev It is strongly recommended to use HintHelper for redemption purpose</span>
  11 |     | <span class='unexecuted'>contract HintHelpers is EbtcBase {</span>
  12 |     | <span class='unexecuted'>    string public constant NAME = &quot;HintHelpers&quot;;</span>
  13 |     | <span class='neutral'></span>
  14 |     | <span class='unexecuted'>    ISortedCdps public immutable sortedCdps;</span>
  15 |     | <span class='unexecuted'>    ICdpManager public immutable cdpManager;</span>
  16 |     | <span class='neutral'></span>
  17 |     | <span class='neutral'>    // --- Events ---</span>
  18 |     | <span class='neutral'></span>
  19 |     | <span class='neutral'>    struct LocalVariables_getRedemptionHints {</span>
  20 |     | <span class='neutral'>        uint256 remainingEbtcToRedeem;</span>
  21 |     | <span class='neutral'>        uint256 minNetDebtInBTC;</span>
  22 |     | <span class='neutral'>        bytes32 currentCdpId;</span>
  23 |     | <span class='neutral'>        address currentCdpUser;</span>
  24 |     | <span class='neutral'>    }</span>
  25 |     | <span class='neutral'></span>
  26 |     | <span class='neutral'>    // --- Dependency setters ---</span>
  27 |     | <span class='unexecuted'>    constructor(</span>
  28 |     | <span class='neutral'>        address _sortedCdpsAddress,</span>
  29 |     | <span class='neutral'>        address _cdpManagerAddress,</span>
  30 |     | <span class='neutral'>        address _collateralAddress,</span>
  31 |     | <span class='neutral'>        address _activePoolAddress,</span>
  32 |     | <span class='neutral'>        address _priceFeedAddress</span>
  33 |     | <span class='neutral'>    ) EbtcBase(_activePoolAddress, _priceFeedAddress, _collateralAddress) {</span>
  34 |     | <span class='unexecuted'>        sortedCdps = ISortedCdps(_sortedCdpsAddress);</span>
  35 |     | <span class='unexecuted'>        cdpManager = ICdpManager(_cdpManagerAddress);</span>
  36 |     | <span class='neutral'>    }</span>
  37 |     | <span class='neutral'></span>
  38 |     | <span class='neutral'>    // --- Functions ---</span>
  39 |     | <span class='neutral'></span>
  40 |     | <span class='neutral'>    /// @notice Get the redemption hints for the specified amount of eBTC, price and maximum number of iterations.</span>
  41 |     | <span class='neutral'>    /// @param _EBTCamount The amount of eBTC to be redeemed.</span>
  42 |     | <span class='neutral'>    /// @param _price The current price of the stETH:eBTC.</span>
  43 |     | <span class='neutral'>    /// @param _maxIterations The maximum number of iterations to be performed.</span>
  44 |     | <span class='neutral'>    /// @return firstRedemptionHint The identifier of the first CDP to be considered for redemption.</span>
  45 |     | <span class='neutral'>    /// @return partialRedemptionHintNICR The new Nominal Collateral Ratio (NICR) of the CDP after partial redemption.</span>
  46 |     | <span class='neutral'>    /// @return truncatedEBTCamount The actual amount of eBTC that can be redeemed.</span>
  47 |     | <span class='neutral'>    /// @return partialRedemptionNewColl The new collateral amount after partial redemption.</span>
  48 |     | <span class='unexecuted'>    function getRedemptionHints(</span>
  49 |     | <span class='neutral'>        uint256 _EBTCamount,</span>
  50 |     | <span class='neutral'>        uint256 _price,</span>
  51 |     | <span class='neutral'>        uint256 _maxIterations</span>
  52 |     | <span class='neutral'>    )</span>
  53 |     | <span class='neutral'>        external</span>
  54 |     | <span class='neutral'>        view</span>
  55 |     | <span class='neutral'>        returns (</span>
  56 |     | <span class='neutral'>            bytes32 firstRedemptionHint,</span>
  57 |     | <span class='neutral'>            uint256 partialRedemptionHintNICR,</span>
  58 |     | <span class='neutral'>            uint256 truncatedEBTCamount,</span>
  59 |     | <span class='neutral'>            uint256 partialRedemptionNewColl</span>
  60 |     | <span class='neutral'>        )</span>
  61 |     | <span class='unexecuted'>    {</span>
  62 |     | <span class='neutral'>        LocalVariables_getRedemptionHints memory vars;</span>
  63 |     | <span class='neutral'>        {</span>
  64 |     | <span class='unexecuted'>            vars.remainingEbtcToRedeem = _EBTCamount;</span>
  65 |     | <span class='unexecuted'>            vars.currentCdpId = sortedCdps.getLast();</span>
  66 |     | <span class='unexecuted'>            vars.currentCdpUser = sortedCdps.getOwnerAddress(vars.currentCdpId);</span>
  67 |     | <span class='neutral'></span>
  68 |     | <span class='unexecuted'>            while (</span>
  69 |     | <span class='unexecuted'>                vars.currentCdpUser != address(0) &amp;&amp;</span>
  70 |     | <span class='unexecuted'>                cdpManager.getSyncedICR(vars.currentCdpId, _price) &lt; MCR</span>
  71 |     | <span class='neutral'>            ) {</span>
  72 |     | <span class='unexecuted'>                vars.currentCdpId = sortedCdps.getPrev(vars.currentCdpId);</span>
  73 |     | <span class='unexecuted'>                vars.currentCdpUser = sortedCdps.getOwnerAddress(vars.currentCdpId);</span>
  74 |     | <span class='neutral'>            }</span>
  75 |     | <span class='unexecuted'>            firstRedemptionHint = vars.currentCdpId;</span>
  76 |     | <span class='neutral'>        }</span>
  77 |     | <span class='neutral'></span>
  78 |     | <span class='unexecuted'>        if (_maxIterations == 0) {</span>
  79 |     | <span class='unexecuted'>            _maxIterations = type(uint256).max;</span>
  80 |     | <span class='neutral'>        }</span>
  81 |     | <span class='neutral'></span>
  82 |     | <span class='neutral'>        // Underflow is intentionally used in _maxIterations-- &gt; 0</span>
  83 |     | <span class='neutral'>        unchecked {</span>
  84 |     | <span class='unexecuted'>            while (</span>
  85 |     | <span class='unexecuted'>                vars.currentCdpUser != address(0) &amp;&amp;</span>
  86 |     | <span class='unexecuted'>                vars.remainingEbtcToRedeem &gt; 0 &amp;&amp;</span>
  87 |     | <span class='unexecuted'>                _maxIterations-- &gt; 0</span>
  88 |     | <span class='neutral'>            ) {</span>
  89 |     | <span class='neutral'>                // Apply pending debt</span>
  90 |     | <span class='unexecuted'>                uint256 currentCdpDebt = cdpManager.getSyncedCdpDebt(vars.currentCdpId);</span>
  91 |     | <span class='neutral'></span>
  92 |     | <span class='neutral'>                // If this CDP has more debt than the remaining to redeem, attempt a partial redemption</span>
  93 |     | <span class='unexecuted'>                if (currentCdpDebt &gt; vars.remainingEbtcToRedeem) {</span>
  94 |     | <span class='unexecuted'>                    uint256 _cachedEbtcToRedeem = vars.remainingEbtcToRedeem;</span>
  95 |     | <span class='unexecuted'>                    (</span>
  96 |     | <span class='neutral'>                        partialRedemptionNewColl,</span>
  97 |     | <span class='neutral'>                        partialRedemptionHintNICR</span>
  98 |     | <span class='unexecuted'>                    ) = _calculateCdpStateAfterPartialRedemption(vars, currentCdpDebt, _price);</span>
  99 |     | <span class='neutral'></span>
 100 |     | <span class='neutral'>                    // If the partial redemption would leave the CDP with less than the minimum allowed coll, bail out of partial redemption and return only the fully redeemable</span>
 101 |     | <span class='unexecuted'>                    if (</span>
 102 |     | <span class='unexecuted'>                        collateral.getPooledEthByShares(partialRedemptionNewColl) &lt;</span>
 103 |     | <span class='neutral'>                        MIN_NET_STETH_BALANCE</span>
 104 |     | <span class='neutral'>                    ) {</span>
 105 |     | <span class='unexecuted'>                        partialRedemptionHintNICR = 0; //reset to 0 as there is no partial redemption in this case</span>
 106 |     | <span class='neutral'>                        partialRedemptionNewColl = 0;</span>
 107 |     | <span class='unexecuted'>                        vars.remainingEbtcToRedeem = _cachedEbtcToRedeem;</span>
 108 |     | <span class='neutral'>                    } else {</span>
 109 |     | <span class='unexecuted'>                        vars.remainingEbtcToRedeem = 0;</span>
 110 |     | <span class='neutral'>                    }</span>
 111 |     | <span class='unexecuted'>                    break;</span>
 112 |     | <span class='neutral'>                } else {</span>
 113 |     | <span class='unexecuted'>                    vars.remainingEbtcToRedeem = vars.remainingEbtcToRedeem - currentCdpDebt;</span>
 114 |     | <span class='neutral'>                }</span>
 115 |     | <span class='neutral'></span>
 116 |     | <span class='unexecuted'>                vars.currentCdpId = sortedCdps.getPrev(vars.currentCdpId);</span>
 117 |     | <span class='unexecuted'>                vars.currentCdpUser = sortedCdps.getOwnerAddress(vars.currentCdpId);</span>
 118 |     | <span class='neutral'>            }</span>
 119 |     | <span class='neutral'>        }</span>
 120 |     | <span class='neutral'></span>
 121 |     | <span class='unexecuted'>        truncatedEBTCamount = _EBTCamount - vars.remainingEbtcToRedeem;</span>
 122 |     | <span class='neutral'>    }</span>
 123 |     | <span class='neutral'></span>
 124 |     | <span class='neutral'>    /**</span>
 125 |     | <span class='neutral'>     * @notice Calculate the partial redemption information.</span>
 126 |     | <span class='neutral'>     * @dev This is an internal function used by getRedemptionHints.</span>
 127 |     | <span class='neutral'>     * @param vars The local variables of the getRedemptionHints function.</span>
 128 |     | <span class='neutral'>     * @param currentCdpDebt The net eBTC debt of the CDP.</span>
 129 |     | <span class='neutral'>     * @param _price The current price of the asset.</span>
 130 |     | <span class='neutral'>     * @return newCollShare The new collateral share amount after partial redemption.</span>
 131 |     | <span class='neutral'>     * @return newNICR The new Nominal Collateral Ratio (NICR) of the CDP after partial redemption.</span>
 132 |     | <span class='neutral'>     */</span>
 133 |     | <span class='unexecuted'>    function _calculateCdpStateAfterPartialRedemption(</span>
 134 |     | <span class='neutral'>        LocalVariables_getRedemptionHints memory vars,</span>
 135 |     | <span class='neutral'>        uint256 currentCdpDebt,</span>
 136 |     | <span class='neutral'>        uint256 _price</span>
 137 |     | <span class='unexecuted'>    ) internal view returns (uint256, uint256) {</span>
 138 |     | <span class='neutral'>        // maxReemable = min(remainingToRedeem, currentDebt)</span>
 139 |     | <span class='unexecuted'>        uint256 maxRedeemableEBTC = EbtcMath._min(vars.remainingEbtcToRedeem, currentCdpDebt);</span>
 140 |     | <span class='neutral'></span>
 141 |     | <span class='unexecuted'>        uint256 newCollShare = cdpManager.getSyncedCdpCollShares(vars.currentCdpId);</span>
 142 |     | <span class='neutral'></span>
 143 |     | <span class='unexecuted'>        vars.remainingEbtcToRedeem = vars.remainingEbtcToRedeem - maxRedeemableEBTC;</span>
 144 |     | <span class='unexecuted'>        uint256 collShareToReceive = collateral.getSharesByPooledEth(</span>
 145 |     | <span class='unexecuted'>            (maxRedeemableEBTC * DECIMAL_PRECISION) / _price</span>
 146 |     | <span class='neutral'>        );</span>
 147 |     | <span class='neutral'></span>
 148 |     | <span class='unexecuted'>        uint256 _newCollShareAfter = newCollShare - collShareToReceive;</span>
 149 |     | <span class='unexecuted'>        return (</span>
 150 |     | <span class='neutral'>            _newCollShareAfter,</span>
 151 |     | <span class='unexecuted'>            EbtcMath._computeNominalCR(_newCollShareAfter, currentCdpDebt - maxRedeemableEBTC)</span>
 152 |     | <span class='neutral'>        );</span>
 153 |     | <span class='neutral'>    }</span>
 154 |     | <span class='neutral'></span>
 155 |     | <span class='neutral'>    /* getApproxHint() - return address of a Cdp that is, on average, (length / numTrials) positions away in the </span>
 156 |     | <span class='neutral'>    sortedCdps list from the correct insert position of the Cdp to be inserted. </span>
 157 |     | <span class='neutral'>    </span>
 158 |     | <span class='neutral'>    Note: The output address is worst-case O(n) positions away from the correct insert position, however, the function </span>
 159 |     | <span class='neutral'>    is probabilistic. Input can be tuned to guarantee results to a high degree of confidence, e.g:</span>
 160 |     | <span class='neutral'></span>
 161 |     | <span class='neutral'>    Submitting numTrials = k * sqrt(length), with k = 15 makes it very, very likely that the ouput address will </span>
 162 |     | <span class='neutral'>    be &lt;= sqrt(length) positions away from the correct insert position.</span>
 163 |     | <span class='neutral'>    */</span>
 164 |     | <span class='unexecuted'>    function getApproxHint(</span>
 165 |     | <span class='neutral'>        uint256 _CR,</span>
 166 |     | <span class='neutral'>        uint256 _numTrials,</span>
 167 |     | <span class='neutral'>        uint256 _inputRandomSeed</span>
 168 |     | <span class='unexecuted'>    ) external view returns (bytes32 hint, uint256 diff, uint256 latestRandomSeed) {</span>
 169 |     | <span class='unexecuted'>        uint256 arrayLength = cdpManager.getActiveCdpsCount();</span>
 170 |     | <span class='neutral'></span>
 171 |     | <span class='unexecuted'>        if (arrayLength == 0) {</span>
 172 |     | <span class='unexecuted'>            return (sortedCdps.nonExistId(), 0, _inputRandomSeed);</span>
 173 |     | <span class='neutral'>        }</span>
 174 |     | <span class='neutral'></span>
 175 |     | <span class='unexecuted'>        hint = sortedCdps.getLast();</span>
 176 |     | <span class='unexecuted'>        diff = EbtcMath._getAbsoluteDifference(_CR, cdpManager.getSyncedNominalICR(hint));</span>
 177 |     | <span class='unexecuted'>        latestRandomSeed = _inputRandomSeed;</span>
 178 |     | <span class='neutral'></span>
 179 |     | <span class='unexecuted'>        uint256 i = 1;</span>
 180 |     | <span class='unexecuted'>        bytes32[] memory cdpIds = sortedCdpsToArray();</span>
 181 |     | <span class='neutral'></span>
 182 |     | <span class='unexecuted'>        while (i &lt; _numTrials) {</span>
 183 |     | <span class='unexecuted'>            latestRandomSeed = uint256(keccak256(abi.encodePacked(latestRandomSeed)));</span>
 184 |     | <span class='neutral'></span>
 185 |     | <span class='unexecuted'>            uint256 arrayIndex = latestRandomSeed % arrayLength;</span>
 186 |     | <span class='unexecuted'>            bytes32 _cId = cdpIds[arrayIndex];</span>
 187 |     | <span class='neutral'></span>
 188 |     | <span class='unexecuted'>            uint256 currentNICR = cdpManager.getSyncedNominalICR(_cId);</span>
 189 |     | <span class='neutral'></span>
 190 |     | <span class='neutral'>            // check if abs(current - CR) &gt; abs(closest - CR), and update closest if current is closer</span>
 191 |     | <span class='unexecuted'>            uint256 currentDiff = EbtcMath._getAbsoluteDifference(currentNICR, _CR);</span>
 192 |     | <span class='neutral'></span>
 193 |     | <span class='unexecuted'>            if (currentDiff &lt; diff) {</span>
 194 |     | <span class='unexecuted'>                diff = currentDiff;</span>
 195 |     | <span class='unexecuted'>                hint = _cId;</span>
 196 |     | <span class='neutral'>            }</span>
 197 |     | <span class='unexecuted'>            i++;</span>
 198 |     | <span class='neutral'>        }</span>
 199 |     | <span class='neutral'>    }</span>
 200 |     | <span class='neutral'></span>
 201 |     | <span class='unexecuted'>    function sortedCdpsToArray() public view returns (bytes32[] memory cdpIdArray) {</span>
 202 |     | <span class='unexecuted'>        uint256 size = sortedCdps.getSize();</span>
 203 |     | <span class='unexecuted'>        cdpIdArray = new bytes32[](size);</span>
 204 |     | <span class='neutral'></span>
 205 |     | <span class='unexecuted'>        if (size == 0) {</span>
 206 |     | <span class='neutral'>            // If the list is empty, return an empty array</span>
 207 |     | <span class='unexecuted'>            return cdpIdArray;</span>
 208 |     | <span class='neutral'>        }</span>
 209 |     | <span class='neutral'></span>
 210 |     | <span class='neutral'>        // Initialize the first CDP in the list</span>
 211 |     | <span class='unexecuted'>        bytes32 currentCdpId = sortedCdps.getFirst();</span>
 212 |     | <span class='neutral'></span>
 213 |     | <span class='unexecuted'>        for (uint256 i = 0; i &lt; size; ++i) {</span>
 214 |     | <span class='neutral'>            // Add the current CDP to the array</span>
 215 |     | <span class='unexecuted'>            cdpIdArray[i] = currentCdpId;</span>
 216 |     | <span class='neutral'></span>
 217 |     | <span class='neutral'>            // Move to the next CDP in the list</span>
 218 |     | <span class='unexecuted'>            currentCdpId = sortedCdps.getNext(currentCdpId);</span>
 219 |     | <span class='neutral'>        }</span>
 220 |     | <span class='neutral'></span>
 221 |     | <span class='unexecuted'>        return cdpIdArray;</span>
 222 |     | <span class='neutral'>    }</span>
 223 |     | <span class='neutral'></span>
 224 |     | <span class='neutral'>    /// @notice Compute nominal CR for a specified collateral and debt amount</span>
 225 |     | <span class='neutral'>    /// @param _coll The collateral amount, in shares</span>
 226 |     | <span class='neutral'>    /// @param _debt The debt amount</span>
 227 |     | <span class='neutral'>    /// @return The computed nominal CR for the given collateral and debt</span>
 228 |     | <span class='unexecuted'>    function computeNominalCR(uint256 _coll, uint256 _debt) external pure returns (uint256) {</span>
 229 |     | <span class='unexecuted'>        return EbtcMath._computeNominalCR(_coll, _debt);</span>
 230 |     | <span class='neutral'>    }</span>
 231 |     | <span class='neutral'></span>
 232 |     | <span class='neutral'>    /// @notice Compute CR for a specified collateral, debt amount, and price</span>
 233 |     | <span class='neutral'>    /// @param _coll The collateral amount, in shares</span>
 234 |     | <span class='neutral'>    /// @param _debt The debt amount</span>
 235 |     | <span class='neutral'>    /// @param _price The current price</span>
 236 |     | <span class='neutral'>    /// @return The computed CR for the given parameters</span>
 237 |     | <span class='unexecuted'>    function computeCR(</span>
 238 |     | <span class='neutral'>        uint256 _coll,</span>
 239 |     | <span class='neutral'>        uint256 _debt,</span>
 240 |     | <span class='neutral'>        uint256 _price</span>
 241 |     | <span class='unexecuted'>    ) external pure returns (uint256) {</span>
 242 |     | <span class='unexecuted'>        return EbtcMath._computeCR(_coll, _debt, _price);</span>
 243 |     | <span class='neutral'>    }</span>
 244 |     | <span class='neutral'>}</span>
 245 |     | <span class='neutral'></span>

</code>
<br />

<b>/mnt/c/Users/Lourens/Documents/Recon-Fuzz/collabs/ebtc/packages/contracts/contracts/Interfaces/IActivePool.sol</b>
<code>
  1 |     | <span class='neutral'>// SPDX-License-Identifier: MIT</span>
  2 |     | <span class='neutral'></span>
  3 |     | <span class='neutral'>pragma solidity 0.8.17;</span>
  4 |     | <span class='neutral'></span>
  5 |     | <span class='neutral'>import &quot;./IPool.sol&quot;;</span>
  6 |     | <span class='neutral'>import &quot;./ITwapWeightedObserver.sol&quot;;</span>
  7 |     | <span class='neutral'></span>
  8 |     | <span class='neutral'>interface IActivePool is IPool, ITwapWeightedObserver {</span>
  9 |     | <span class='neutral'>    // --- Events ---</span>
 10 |     | <span class='neutral'>    event ActivePoolEBTCDebtUpdated(uint256 _EBTCDebt);</span>
 11 |     | <span class='neutral'>    event SystemCollSharesUpdated(uint256 _coll);</span>
 12 |     | <span class='neutral'>    event FeeRecipientClaimableCollSharesIncreased(uint256 _coll, uint256 _fee);</span>
 13 |     | <span class='neutral'>    event FeeRecipientClaimableCollSharesDecreased(uint256 _coll, uint256 _fee);</span>
 14 |     | <span class='neutral'>    event FlashLoanSuccess(</span>
 15 |     | <span class='neutral'>        address indexed _receiver,</span>
 16 |     | <span class='neutral'>        address indexed _token,</span>
 17 |     | <span class='neutral'>        uint256 _amount,</span>
 18 |     | <span class='neutral'>        uint256 _fee</span>
 19 |     | <span class='neutral'>    );</span>
 20 |     | <span class='neutral'>    event SweepTokenSuccess(address indexed _token, uint256 _amount, address indexed _recipient);</span>
 21 |     | <span class='neutral'></span>
 22 |     | <span class='neutral'>    // --- Functions ---</span>
 23 |     | <span class='neutral'>    function transferSystemCollShares(address _account, uint256 _amount) external;</span>
 24 |     | <span class='neutral'></span>
 25 |     | <span class='neutral'>    function increaseSystemCollShares(uint256 _value) external;</span>
 26 |     | <span class='neutral'></span>
 27 |     | <span class='neutral'>    function transferSystemCollSharesAndLiquidatorReward(</span>
 28 |     | <span class='neutral'>        address _account,</span>
 29 |     | <span class='neutral'>        uint256 _shares,</span>
 30 |     | <span class='neutral'>        uint256 _liquidatorRewardShares</span>
 31 |     | <span class='neutral'>    ) external;</span>
 32 |     | <span class='neutral'></span>
 33 |     | <span class='neutral'>    function allocateSystemCollSharesToFeeRecipient(uint256 _shares) external;</span>
 34 |     | <span class='neutral'></span>
 35 |     | <span class='neutral'>    function claimFeeRecipientCollShares(uint256 _shares) external;</span>
 36 |     | <span class='neutral'></span>
 37 |     | <span class='neutral'>    function feeRecipientAddress() external view returns (address);</span>
 38 |     | <span class='neutral'></span>
 39 |     | <span class='neutral'>    function getFeeRecipientClaimableCollShares() external view returns (uint256);</span>
 40 |     | <span class='neutral'>}</span>
 41 |     | <span class='neutral'></span>

</code>
<br />

<b>/mnt/c/Users/Lourens/Documents/Recon-Fuzz/collabs/ebtc/packages/contracts/contracts/Interfaces/IBaseTwapWeightedObserver.sol</b>
<code>
  1 |     | <span class='neutral'>// SPDX-License Identifier: MIT</span>
  2 |     | <span class='neutral'>pragma solidity 0.8.17;</span>
  3 |     | <span class='neutral'></span>
  4 |     | <span class='neutral'>interface IBaseTwapWeightedObserver {</span>
  5 |     | <span class='neutral'>    // NOTE: Packing manually is cheaper, but this is simpler to understand and follow</span>
  6 |     | <span class='neutral'>    struct PackedData {</span>
  7 |     | <span class='neutral'>        // Slot 0</span>
  8 |     | <span class='neutral'>        // Seconds in a year: 3.154e+7</span>
  9 |     | <span class='neutral'>        /// @dev Accumulator value recorded for TWAP Observer until last update</span>
 10 |     | <span class='neutral'>        uint128 observerCumuVal; // 3.154e+7 * 80 * 100e27 = 2.5232e+38 | log_2(100e27 * 3.154e+7 * 80) = 127.568522171</span>
 11 |     | <span class='neutral'>        /// @dev Accumulator for TWAP globally</span>
 12 |     | <span class='neutral'>        uint128 accumulator; // 3.154e+7 * 80 * 100e27 = 2.5232e+38 | log_2(100e27 * 3.154e+7 * 80) = 127.568522171</span>
 13 |     | <span class='neutral'>        // NOTE: We can further compress this slot but we will not be able to use only one (see u72 impl)</span>
 14 |     | <span class='neutral'>        /// So what&#39;s the point of making the code more complex?</span>
 15 |     | <span class='neutral'></span>
 16 |     | <span class='neutral'>        // Slot 1</span>
 17 |     | <span class='neutral'>        /// @dev last update timestamp for TWAP Observer</span>
 18 |     | <span class='neutral'>        uint64 lastObserved; // Thousands of Years, if we use relative time we can use u32 | Relative to deploy time (as immutable)</span>
 19 |     | <span class='neutral'>        /// @dev last update timestamp for TWAP global track(spot) value</span>
 20 |     | <span class='neutral'>        uint64 lastAccrued; // Thousands of years</span>
 21 |     | <span class='neutral'>        // Expect eBTC debt to never surpass 100e27, which is 100 BILLION eBTC</span>
 22 |     | <span class='neutral'>        // log_2(100e27) = 96.3359147517 | log_2(100e27 / 1e18) = 36.5412090438</span>
 23 |     | <span class='neutral'>        // We could use a u64</span>
 24 |     | <span class='neutral'>        /// @dev average value since last observe</span>
 25 |     | <span class='neutral'>        uint128 lastObservedAverage;</span>
 26 |     | <span class='neutral'>    }</span>
 27 |     | <span class='neutral'>}</span>
 28 |     | <span class='neutral'></span>

</code>
<br />

<b>/mnt/c/Users/Lourens/Documents/Recon-Fuzz/collabs/ebtc/packages/contracts/contracts/Interfaces/IBorrowerOperations.sol</b>
<code>
  1 |     | <span class='neutral'>// SPDX-License-Identifier: MIT</span>
  2 |     | <span class='neutral'></span>
  3 |     | <span class='neutral'>pragma solidity 0.8.17;</span>
  4 |     | <span class='neutral'>import &quot;./IPositionManagers.sol&quot;;</span>
  5 |     | <span class='neutral'></span>
  6 |     | <span class='neutral'>// Common interface for the Cdp Manager.</span>
  7 |     | <span class='neutral'>interface IBorrowerOperations is IPositionManagers {</span>
  8 |     | <span class='neutral'>    // --- Events ---</span>
  9 |     | <span class='neutral'></span>
 10 |     | <span class='neutral'>    event FeeRecipientAddressChanged(address indexed _feeRecipientAddress);</span>
 11 |     | <span class='neutral'>    event FlashLoanSuccess(</span>
 12 |     | <span class='neutral'>        address indexed _receiver,</span>
 13 |     | <span class='neutral'>        address indexed _token,</span>
 14 |     | <span class='neutral'>        uint256 _amount,</span>
 15 |     | <span class='neutral'>        uint256 _fee</span>
 16 |     | <span class='neutral'>    );</span>
 17 |     | <span class='neutral'></span>
 18 |     | <span class='neutral'>    // --- Functions ---</span>
 19 |     | <span class='neutral'></span>
 20 |     | <span class='neutral'>    function openCdp(</span>
 21 |     | <span class='neutral'>        uint256 _EBTCAmount,</span>
 22 |     | <span class='neutral'>        bytes32 _upperHint,</span>
 23 |     | <span class='neutral'>        bytes32 _lowerHint,</span>
 24 |     | <span class='neutral'>        uint256 _stEthBalance</span>
 25 |     | <span class='neutral'>    ) external returns (bytes32);</span>
 26 |     | <span class='neutral'></span>
 27 |     | <span class='neutral'>    function openCdpFor(</span>
 28 |     | <span class='neutral'>        uint _EBTCAmount,</span>
 29 |     | <span class='neutral'>        bytes32 _upperHint,</span>
 30 |     | <span class='neutral'>        bytes32 _lowerHint,</span>
 31 |     | <span class='neutral'>        uint _collAmount,</span>
 32 |     | <span class='neutral'>        address _borrower</span>
 33 |     | <span class='neutral'>    ) external returns (bytes32);</span>
 34 |     | <span class='neutral'></span>
 35 |     | <span class='neutral'>    function addColl(</span>
 36 |     | <span class='neutral'>        bytes32 _cdpId,</span>
 37 |     | <span class='neutral'>        bytes32 _upperHint,</span>
 38 |     | <span class='neutral'>        bytes32 _lowerHint,</span>
 39 |     | <span class='neutral'>        uint256 _stEthBalanceIncrease</span>
 40 |     | <span class='neutral'>    ) external;</span>
 41 |     | <span class='neutral'></span>
 42 |     | <span class='neutral'>    function withdrawColl(</span>
 43 |     | <span class='neutral'>        bytes32 _cdpId,</span>
 44 |     | <span class='neutral'>        uint256 _stEthBalanceDecrease,</span>
 45 |     | <span class='neutral'>        bytes32 _upperHint,</span>
 46 |     | <span class='neutral'>        bytes32 _lowerHint</span>
 47 |     | <span class='neutral'>    ) external;</span>
 48 |     | <span class='neutral'></span>
 49 |     | <span class='neutral'>    function withdrawDebt(</span>
 50 |     | <span class='neutral'>        bytes32 _cdpId,</span>
 51 |     | <span class='neutral'>        uint256 _amount,</span>
 52 |     | <span class='neutral'>        bytes32 _upperHint,</span>
 53 |     | <span class='neutral'>        bytes32 _lowerHint</span>
 54 |     | <span class='neutral'>    ) external;</span>
 55 |     | <span class='neutral'></span>
 56 |     | <span class='neutral'>    function repayDebt(</span>
 57 |     | <span class='neutral'>        bytes32 _cdpId,</span>
 58 |     | <span class='neutral'>        uint256 _amount,</span>
 59 |     | <span class='neutral'>        bytes32 _upperHint,</span>
 60 |     | <span class='neutral'>        bytes32 _lowerHint</span>
 61 |     | <span class='neutral'>    ) external;</span>
 62 |     | <span class='neutral'></span>
 63 |     | <span class='neutral'>    function closeCdp(bytes32 _cdpId) external;</span>
 64 |     | <span class='neutral'></span>
 65 |     | <span class='neutral'>    function adjustCdp(</span>
 66 |     | <span class='neutral'>        bytes32 _cdpId,</span>
 67 |     | <span class='neutral'>        uint256 _stEthBalanceDecrease,</span>
 68 |     | <span class='neutral'>        uint256 _debtChange,</span>
 69 |     | <span class='neutral'>        bool isDebtIncrease,</span>
 70 |     | <span class='neutral'>        bytes32 _upperHint,</span>
 71 |     | <span class='neutral'>        bytes32 _lowerHint</span>
 72 |     | <span class='neutral'>    ) external;</span>
 73 |     | <span class='neutral'></span>
 74 |     | <span class='neutral'>    function adjustCdpWithColl(</span>
 75 |     | <span class='neutral'>        bytes32 _cdpId,</span>
 76 |     | <span class='neutral'>        uint256 _stEthBalanceDecrease,</span>
 77 |     | <span class='neutral'>        uint256 _debtChange,</span>
 78 |     | <span class='neutral'>        bool isDebtIncrease,</span>
 79 |     | <span class='neutral'>        bytes32 _upperHint,</span>
 80 |     | <span class='neutral'>        bytes32 _lowerHint,</span>
 81 |     | <span class='neutral'>        uint256 _stEthBalanceIncrease</span>
 82 |     | <span class='neutral'>    ) external;</span>
 83 |     | <span class='neutral'></span>
 84 |     | <span class='neutral'>    function claimSurplusCollShares() external;</span>
 85 |     | <span class='neutral'></span>
 86 |     | <span class='neutral'>    function feeRecipientAddress() external view returns (address);</span>
 87 |     | <span class='neutral'>}</span>
 88 |     | <span class='neutral'></span>

</code>
<br />

<b>/mnt/c/Users/Lourens/Documents/Recon-Fuzz/collabs/ebtc/packages/contracts/contracts/Interfaces/ICdpManager.sol</b>
<code>
  1 |     | <span class='neutral'>// SPDX-License-Identifier: MIT</span>
  2 |     | <span class='neutral'></span>
  3 |     | <span class='neutral'>pragma solidity 0.8.17;</span>
  4 |     | <span class='neutral'></span>
  5 |     | <span class='neutral'>import &quot;./IEbtcBase.sol&quot;;</span>
  6 |     | <span class='neutral'>import &quot;./ICdpManagerData.sol&quot;;</span>
  7 |     | <span class='neutral'></span>
  8 |     | <span class='neutral'>// Common interface for the Cdp Manager.</span>
  9 |     | <span class='neutral'>interface ICdpManager is IEbtcBase, ICdpManagerData {</span>
 10 |     | <span class='neutral'>    // --- Functions ---</span>
 11 |     | <span class='neutral'>    function liquidate(bytes32 _cdpId) external;</span>
 12 |     | <span class='neutral'></span>
 13 |     | <span class='neutral'>    function partiallyLiquidate(</span>
 14 |     | <span class='neutral'>        bytes32 _cdpId,</span>
 15 |     | <span class='neutral'>        uint256 _partialAmount,</span>
 16 |     | <span class='neutral'>        bytes32 _upperPartialHint,</span>
 17 |     | <span class='neutral'>        bytes32 _lowerPartialHint</span>
 18 |     | <span class='neutral'>    ) external;</span>
 19 |     | <span class='neutral'></span>
 20 |     | <span class='neutral'>    function batchLiquidateCdps(bytes32[] calldata _cdpArray) external;</span>
 21 |     | <span class='neutral'></span>
 22 |     | <span class='neutral'>    function redeemCollateral(</span>
 23 |     | <span class='neutral'>        uint256 _EBTCAmount,</span>
 24 |     | <span class='neutral'>        bytes32 _firstRedemptionHint,</span>
 25 |     | <span class='neutral'>        bytes32 _upperPartialRedemptionHint,</span>
 26 |     | <span class='neutral'>        bytes32 _lowerPartialRedemptionHint,</span>
 27 |     | <span class='neutral'>        uint256 _partialRedemptionHintNICR,</span>
 28 |     | <span class='neutral'>        uint256 _maxIterations,</span>
 29 |     | <span class='neutral'>        uint256 _maxFee</span>
 30 |     | <span class='neutral'>    ) external;</span>
 31 |     | <span class='neutral'></span>
 32 |     | <span class='neutral'>    function updateStakeAndTotalStakes(bytes32 _cdpId) external returns (uint256);</span>
 33 |     | <span class='neutral'></span>
 34 |     | <span class='neutral'>    function syncAccounting(bytes32 _cdpId) external;</span>
 35 |     | <span class='neutral'></span>
 36 |     | <span class='neutral'>    function closeCdp(bytes32 _cdpId, address _borrower, uint256 _debt, uint256 _coll) external;</span>
 37 |     | <span class='neutral'></span>
 38 |     | <span class='neutral'>    function getRedemptionRate() external view returns (uint256);</span>
 39 |     | <span class='neutral'></span>
 40 |     | <span class='neutral'>    function getRedemptionRateWithDecay() external view returns (uint256);</span>
 41 |     | <span class='neutral'></span>
 42 |     | <span class='neutral'>    function getRedemptionFeeWithDecay(uint256 _stETHToRedeem) external view returns (uint256);</span>
 43 |     | <span class='neutral'></span>
 44 |     | <span class='neutral'>    function getCdpStatus(bytes32 _cdpId) external view returns (uint256);</span>
 45 |     | <span class='neutral'></span>
 46 |     | <span class='neutral'>    function getCdpStake(bytes32 _cdpId) external view returns (uint256);</span>
 47 |     | <span class='neutral'></span>
 48 |     | <span class='neutral'>    function getCdpDebt(bytes32 _cdpId) external view returns (uint256);</span>
 49 |     | <span class='neutral'></span>
 50 |     | <span class='neutral'>    function getCdpCollShares(bytes32 _cdpId) external view returns (uint256);</span>
 51 |     | <span class='neutral'></span>
 52 |     | <span class='neutral'>    function getCdpLiquidatorRewardShares(bytes32 _cdpId) external view returns (uint);</span>
 53 |     | <span class='neutral'></span>
 54 |     | <span class='neutral'>    function initializeCdp(</span>
 55 |     | <span class='neutral'>        bytes32 _cdpId,</span>
 56 |     | <span class='neutral'>        uint256 _debt,</span>
 57 |     | <span class='neutral'>        uint256 _coll,</span>
 58 |     | <span class='neutral'>        uint256 _liquidatorRewardShares,</span>
 59 |     | <span class='neutral'>        address _borrower</span>
 60 |     | <span class='neutral'>    ) external;</span>
 61 |     | <span class='neutral'></span>
 62 |     | <span class='neutral'>    function updateCdp(</span>
 63 |     | <span class='neutral'>        bytes32 _cdpId,</span>
 64 |     | <span class='neutral'>        address _borrower,</span>
 65 |     | <span class='neutral'>        uint256 _coll,</span>
 66 |     | <span class='neutral'>        uint256 _debt,</span>
 67 |     | <span class='neutral'>        uint256 _newColl,</span>
 68 |     | <span class='neutral'>        uint256 _newDebt</span>
 69 |     | <span class='neutral'>    ) external;</span>
 70 |     | <span class='neutral'></span>
 71 |     | <span class='neutral'>    function getCachedTCR(uint256 _price) external view returns (uint256);</span>
 72 |     | <span class='neutral'></span>
 73 |     | <span class='neutral'>    function checkRecoveryMode(uint256 _price) external view returns (bool);</span>
 74 |     | <span class='neutral'>}</span>
 75 |     | <span class='neutral'></span>

</code>
<br />

<b>/mnt/c/Users/Lourens/Documents/Recon-Fuzz/collabs/ebtc/packages/contracts/contracts/Interfaces/ICdpManagerData.sol</b>
<code>
   1 |     | <span class='neutral'>// SPDX-License-Identifier: MIT</span>
   2 |     | <span class='neutral'></span>
   3 |     | <span class='neutral'>pragma solidity 0.8.17;</span>
   4 |     | <span class='neutral'></span>
   5 |     | <span class='neutral'>import &quot;./ICollSurplusPool.sol&quot;;</span>
   6 |     | <span class='neutral'>import &quot;./IEBTCToken.sol&quot;;</span>
   7 |     | <span class='neutral'>import &quot;./ISortedCdps.sol&quot;;</span>
   8 |     | <span class='neutral'>import &quot;./IActivePool.sol&quot;;</span>
   9 |     | <span class='neutral'>import &quot;./IRecoveryModeGracePeriod.sol&quot;;</span>
  10 |     | <span class='neutral'>import &quot;../Dependencies/ICollateralTokenOracle.sol&quot;;</span>
  11 |     | <span class='neutral'></span>
  12 |     | <span class='neutral'>// Common interface for the Cdp Manager.</span>
  13 |     | <span class='neutral'>interface ICdpManagerData is IRecoveryModeGracePeriod {</span>
  14 |     | <span class='neutral'>    // --- Events ---</span>
  15 |     | <span class='neutral'></span>
  16 |     | <span class='neutral'>    event StakingRewardSplitSet(uint256 _stakingRewardSplit);</span>
  17 |     | <span class='neutral'>    event RedemptionFeeFloorSet(uint256 _redemptionFeeFloor);</span>
  18 |     | <span class='neutral'>    event MinuteDecayFactorSet(uint256 _minuteDecayFactor);</span>
  19 |     | <span class='neutral'>    event BetaSet(uint256 _beta);</span>
  20 |     | <span class='neutral'>    event RedemptionsPaused(bool _paused);</span>
  21 |     | <span class='neutral'></span>
  22 |     | <span class='neutral'>    event Liquidation(uint256 _liquidatedDebt, uint256 _liquidatedColl, uint256 _liqReward);</span>
  23 |     | <span class='neutral'>    event Redemption(</span>
  24 |     | <span class='neutral'>        uint256 _debtToRedeemExpected,</span>
  25 |     | <span class='neutral'>        uint256 _debtToRedeemActual,</span>
  26 |     | <span class='neutral'>        uint256 _collSharesSent,</span>
  27 |     | <span class='neutral'>        uint256 _feeCollShares,</span>
  28 |     | <span class='neutral'>        address indexed _redeemer</span>
  29 |     | <span class='neutral'>    );</span>
  30 |     | <span class='neutral'>    event CdpUpdated(</span>
  31 |     | <span class='neutral'>        bytes32 indexed _cdpId,</span>
  32 |     | <span class='neutral'>        address indexed _borrower,</span>
  33 |     | <span class='neutral'>        address indexed _executor,</span>
  34 |     | <span class='neutral'>        uint256 _oldDebt,</span>
  35 |     | <span class='neutral'>        uint256 _oldCollShares,</span>
  36 |     | <span class='neutral'>        uint256 _debt,</span>
  37 |     | <span class='neutral'>        uint256 _collShares,</span>
  38 |     | <span class='neutral'>        uint256 _stake,</span>
  39 |     | <span class='neutral'>        CdpOperation _operation</span>
  40 |     | <span class='neutral'>    );</span>
  41 |     | <span class='neutral'>    event CdpLiquidated(</span>
  42 |     | <span class='neutral'>        bytes32 indexed _cdpId,</span>
  43 |     | <span class='neutral'>        address indexed _borrower,</span>
  44 |     | <span class='neutral'>        uint _debt,</span>
  45 |     | <span class='neutral'>        uint _collShares,</span>
  46 |     | <span class='neutral'>        CdpOperation _operation,</span>
  47 |     | <span class='neutral'>        address indexed _liquidator,</span>
  48 |     | <span class='neutral'>        uint _premiumToLiquidator</span>
  49 |     | <span class='neutral'>    );</span>
  50 |     | <span class='neutral'>    event CdpPartiallyLiquidated(</span>
  51 |     | <span class='neutral'>        bytes32 indexed _cdpId,</span>
  52 |     | <span class='neutral'>        address indexed _borrower,</span>
  53 |     | <span class='neutral'>        uint256 _debt,</span>
  54 |     | <span class='neutral'>        uint256 _collShares,</span>
  55 |     | <span class='neutral'>        CdpOperation operation,</span>
  56 |     | <span class='neutral'>        address indexed _liquidator,</span>
  57 |     | <span class='neutral'>        uint _premiumToLiquidator</span>
  58 |     | <span class='neutral'>    );</span>
  59 |     | <span class='neutral'>    event BaseRateUpdated(uint256 _baseRate);</span>
  60 |     | <span class='neutral'>    event LastRedemptionTimestampUpdated(uint256 _lastFeeOpTime);</span>
  61 |     | <span class='neutral'>    event TotalStakesUpdated(uint256 _newTotalStakes);</span>
  62 |     | <span class='neutral'>    event SystemSnapshotsUpdated(uint256 _totalStakesSnapshot, uint256 _totalCollateralSnapshot);</span>
  63 |     | <span class='neutral'>    event SystemDebtRedistributionIndexUpdated(uint256 _systemDebtRedistributionIndex);</span>
  64 |     | <span class='neutral'>    event CdpDebtRedistributionIndexUpdated(bytes32 _cdpId, uint256 _cdpDebtRedistributionIndex);</span>
  65 |     | <span class='neutral'>    event CdpArrayIndexUpdated(bytes32 _cdpId, uint256 _newIndex);</span>
  66 |     | <span class='neutral'>    event StEthIndexUpdated(uint256 _oldIndex, uint256 _newIndex, uint256 _updTimestamp);</span>
  67 |     | <span class='neutral'>    event CollateralFeePerUnitUpdated(uint256 _oldPerUnit, uint256 _newPerUnit, uint256 _feeTaken);</span>
  68 |     | <span class='neutral'>    event CdpFeeSplitApplied(</span>
  69 |     | <span class='neutral'>        bytes32 _cdpId,</span>
  70 |     | <span class='neutral'>        uint256 _oldPerUnitCdp,</span>
  71 |     | <span class='neutral'>        uint256 _newPerUnitCdp,</span>
  72 |     | <span class='neutral'>        uint256 _collReduced,</span>
  73 |     | <span class='neutral'>        uint256 _collLeft</span>
  74 |     | <span class='neutral'>    );</span>
  75 |     | <span class='neutral'></span>
  76 |     | <span class='neutral'>    enum CdpOperation {</span>
  77 |     | <span class='neutral'>        openCdp,</span>
  78 |     | <span class='neutral'>        closeCdp,</span>
  79 |     | <span class='neutral'>        adjustCdp,</span>
  80 |     | <span class='neutral'>        syncAccounting,</span>
  81 |     | <span class='neutral'>        liquidateInNormalMode,</span>
  82 |     | <span class='neutral'>        liquidateInRecoveryMode,</span>
  83 |     | <span class='neutral'>        redeemCollateral,</span>
  84 |     | <span class='neutral'>        partiallyLiquidate,</span>
  85 |     | <span class='neutral'>        failedPartialRedemption</span>
  86 |     | <span class='neutral'>    }</span>
  87 |     | <span class='neutral'></span>
  88 |     | <span class='neutral'>    enum Status {</span>
  89 |     | <span class='neutral'>        nonExistent,</span>
  90 |     | <span class='neutral'>        active,</span>
  91 |     | <span class='neutral'>        closedByOwner,</span>
  92 |     | <span class='neutral'>        closedByLiquidation,</span>
  93 |     | <span class='neutral'>        closedByRedemption</span>
  94 |     | <span class='neutral'>    }</span>
  95 |     | <span class='neutral'></span>
  96 |     | <span class='neutral'>    // Store the necessary data for a cdp</span>
  97 |     | <span class='neutral'>    struct Cdp {</span>
  98 |     | <span class='neutral'>        uint256 debt;</span>
  99 |     | <span class='neutral'>        uint256 coll;</span>
 100 |     | <span class='neutral'>        uint256 stake;</span>
 101 |     | <span class='neutral'>        uint128 liquidatorRewardShares;</span>
 102 |     | <span class='neutral'>        Status status;</span>
 103 |     | <span class='neutral'>    }</span>
 104 |     | <span class='neutral'></span>
 105 |     | <span class='neutral'>    /*</span>
 106 |     | <span class='neutral'>     * --- Variable container structs for liquidations ---</span>
 107 |     | <span class='neutral'>     *</span>
 108 |     | <span class='neutral'>     * These structs are used to hold, return and assign variables inside the liquidation functions,</span>
 109 |     | <span class='neutral'>     * in order to avoid the error: &quot;CompilerError: Stack too deep&quot;.</span>
 110 |     | <span class='neutral'>     **/</span>
 111 |     | <span class='neutral'></span>
 112 |     | <span class='neutral'>    struct CdpDebtAndCollShares {</span>
 113 |     | <span class='neutral'>        uint256 debt;</span>
 114 |     | <span class='neutral'>        uint256 collShares;</span>
 115 |     | <span class='neutral'>    }</span>
 116 |     | <span class='neutral'></span>
 117 |     | <span class='neutral'>    struct LiquidationLocals {</span>
 118 |     | <span class='neutral'>        bytes32 cdpId;</span>
 119 |     | <span class='neutral'>        uint256 partialAmount; // used only for partial liquidation, default 0 means full liquidation</span>
 120 |     | <span class='neutral'>        uint256 price;</span>
 121 |     | <span class='neutral'>        uint256 ICR;</span>
 122 |     | <span class='neutral'>        bytes32 upperPartialHint;</span>
 123 |     | <span class='neutral'>        bytes32 lowerPartialHint;</span>
 124 |     | <span class='neutral'>        bool recoveryModeAtStart;</span>
 125 |     | <span class='neutral'>        uint256 TCR;</span>
 126 |     | <span class='neutral'>        uint256 totalSurplusCollShares;</span>
 127 |     | <span class='neutral'>        uint256 totalCollSharesToSend;</span>
 128 |     | <span class='neutral'>        uint256 totalDebtToBurn;</span>
 129 |     | <span class='neutral'>        uint256 totalDebtToRedistribute;</span>
 130 |     | <span class='neutral'>        uint256 totalLiquidatorRewardCollShares;</span>
 131 |     | <span class='neutral'>    }</span>
 132 |     | <span class='neutral'></span>
 133 |     | <span class='neutral'>    struct LiquidationRecoveryModeLocals {</span>
 134 |     | <span class='neutral'>        uint256 entireSystemDebt;</span>
 135 |     | <span class='neutral'>        uint256 entireSystemColl;</span>
 136 |     | <span class='neutral'>        uint256 totalDebtToBurn;</span>
 137 |     | <span class='neutral'>        uint256 totalCollSharesToSend;</span>
 138 |     | <span class='neutral'>        uint256 totalSurplusCollShares;</span>
 139 |     | <span class='neutral'>        bytes32 cdpId;</span>
 140 |     | <span class='neutral'>        uint256 price;</span>
 141 |     | <span class='neutral'>        uint256 ICR;</span>
 142 |     | <span class='neutral'>        uint256 totalDebtToRedistribute;</span>
 143 |     | <span class='neutral'>        uint256 totalLiquidatorRewardCollShares;</span>
 144 |     | <span class='neutral'>    }</span>
 145 |     | <span class='neutral'></span>
 146 |     | <span class='neutral'>    struct LocalVariables_OuterLiquidationFunction {</span>
 147 |     | <span class='neutral'>        uint256 price;</span>
 148 |     | <span class='neutral'>        bool recoveryModeAtStart;</span>
 149 |     | <span class='neutral'>        uint256 liquidatedDebt;</span>
 150 |     | <span class='neutral'>        uint256 liquidatedColl;</span>
 151 |     | <span class='neutral'>    }</span>
 152 |     | <span class='neutral'></span>
 153 |     | <span class='neutral'>    struct LocalVariables_LiquidationSequence {</span>
 154 |     | <span class='neutral'>        uint256 i;</span>
 155 |     | <span class='neutral'>        uint256 ICR;</span>
 156 |     | <span class='neutral'>        bytes32 cdpId;</span>
 157 |     | <span class='neutral'>        bool backToNormalMode;</span>
 158 |     | <span class='neutral'>        uint256 entireSystemDebt;</span>
 159 |     | <span class='neutral'>        uint256 entireSystemColl;</span>
 160 |     | <span class='neutral'>        uint256 price;</span>
 161 |     | <span class='neutral'>        uint256 TCR;</span>
 162 |     | <span class='neutral'>    }</span>
 163 |     | <span class='neutral'></span>
 164 |     | <span class='neutral'>    struct SingleRedemptionInputs {</span>
 165 |     | <span class='neutral'>        bytes32 cdpId;</span>
 166 |     | <span class='neutral'>        uint256 maxEBTCamount;</span>
 167 |     | <span class='neutral'>        uint256 price;</span>
 168 |     | <span class='neutral'>        bytes32 upperPartialRedemptionHint;</span>
 169 |     | <span class='neutral'>        bytes32 lowerPartialRedemptionHint;</span>
 170 |     | <span class='neutral'>        uint256 partialRedemptionHintNICR;</span>
 171 |     | <span class='neutral'>    }</span>
 172 |     | <span class='neutral'></span>
 173 |     | <span class='neutral'>    struct LiquidationValues {</span>
 174 |     | <span class='neutral'>        uint256 entireCdpDebt;</span>
 175 |     | <span class='neutral'>        uint256 debtToBurn;</span>
 176 |     | <span class='neutral'>        uint256 totalCollToSendToLiquidator;</span>
 177 |     | <span class='neutral'>        uint256 debtToRedistribute;</span>
 178 |     | <span class='neutral'>        uint256 collSurplus;</span>
 179 |     | <span class='neutral'>        uint256 liquidatorCollSharesReward;</span>
 180 |     | <span class='neutral'>    }</span>
 181 |     | <span class='neutral'></span>
 182 |     | <span class='neutral'>    struct LiquidationTotals {</span>
 183 |     | <span class='neutral'>        uint256 totalDebtInSequence;</span>
 184 |     | <span class='neutral'>        uint256 totalDebtToBurn;</span>
 185 |     | <span class='neutral'>        uint256 totalCollToSendToLiquidator;</span>
 186 |     | <span class='neutral'>        uint256 totalDebtToRedistribute;</span>
 187 |     | <span class='neutral'>        uint256 totalCollSurplus;</span>
 188 |     | <span class='neutral'>        uint256 totalCollReward;</span>
 189 |     | <span class='neutral'>    }</span>
 190 |     | <span class='neutral'></span>
 191 |     | <span class='neutral'>    // --- Variable container structs for redemptions ---</span>
 192 |     | <span class='neutral'></span>
 193 |     | <span class='neutral'>    struct RedemptionTotals {</span>
 194 |     | <span class='neutral'>        uint256 remainingDebtToRedeem;</span>
 195 |     | <span class='neutral'>        uint256 debtToRedeem;</span>
 196 |     | <span class='neutral'>        uint256 collSharesDrawn;</span>
 197 |     | <span class='neutral'>        uint256 totalCollSharesSurplus;</span>
 198 |     | <span class='neutral'>        uint256 feeCollShares;</span>
 199 |     | <span class='neutral'>        uint256 collSharesToRedeemer;</span>
 200 |     | <span class='neutral'>        uint256 decayedBaseRate;</span>
 201 |     | <span class='neutral'>        uint256 price;</span>
 202 |     | <span class='neutral'>        uint256 systemDebtAtStart;</span>
 203 |     | <span class='neutral'>        uint256 twapSystemDebtAtStart;</span>
 204 |     | <span class='neutral'>        uint256 systemCollSharesAtStart;</span>
 205 |     | <span class='neutral'>        uint256 tcrAtStart;</span>
 206 |     | <span class='neutral'>    }</span>
 207 |     | <span class='neutral'></span>
 208 |     | <span class='neutral'>    struct SingleRedemptionValues {</span>
 209 |     | <span class='neutral'>        uint256 debtToRedeem;</span>
 210 |     | <span class='neutral'>        uint256 collSharesDrawn;</span>
 211 |     | <span class='neutral'>        uint256 collSurplus;</span>
 212 |     | <span class='neutral'>        uint256 liquidatorRewardShares;</span>
 213 |     | <span class='neutral'>        bool cancelledPartial;</span>
 214 |     | <span class='neutral'>        bool fullRedemption;</span>
 215 |     | <span class='neutral'>        uint256 newPartialNICR;</span>
 216 |     | <span class='neutral'>    }</span>
 217 |     | <span class='neutral'></span>
 218 |     | <span class='neutral'>    function getActiveCdpsCount() external view returns (uint256);</span>
 219 |     | <span class='neutral'></span>
 220 |     | <span class='neutral'>    function totalStakes() external view returns (uint256);</span>
 221 |     | <span class='neutral'></span>
 222 |     | <span class='neutral'>    function ebtcToken() external view returns (IEBTCToken);</span>
 223 |     | <span class='neutral'></span>
 224 |     | <span class='neutral'>    function systemStEthFeePerUnitIndex() external view returns (uint256);</span>
 225 |     | <span class='neutral'></span>
 226 |     | <span class='neutral'>    function systemStEthFeePerUnitIndexError() external view returns (uint256);</span>
 227 |     | <span class='neutral'></span>
 228 |     | <span class='neutral'>    function stEthIndex() external view returns (uint256);</span>
 229 |     | <span class='neutral'></span>
 230 |     | <span class='neutral'>    function calcFeeUponStakingReward(</span>
 231 |     | <span class='neutral'>        uint256 _newIndex,</span>
 232 |     | <span class='neutral'>        uint256 _prevIndex</span>
 233 |     | <span class='neutral'>    ) external view returns (uint256, uint256, uint256);</span>
 234 |     | <span class='neutral'></span>
 235 |     | <span class='neutral'>    function syncGlobalAccounting() external; // Accrues StEthFeeSplit without influencing Grace Period</span>
 236 |     | <span class='neutral'></span>
 237 |     | <span class='neutral'>    function syncGlobalAccountingAndGracePeriod() external; // Accrues StEthFeeSplit and influences Grace Period</span>
 238 |     | <span class='neutral'></span>
 239 |     | <span class='neutral'>    function getAccumulatedFeeSplitApplied(</span>
 240 |     | <span class='neutral'>        bytes32 _cdpId,</span>
 241 |     | <span class='neutral'>        uint256 _systemStEthFeePerUnitIndex</span>
 242 |     | <span class='neutral'>    ) external view returns (uint256, uint256);</span>
 243 |     | <span class='neutral'></span>
 244 |     | <span class='neutral'>    function getCachedNominalICR(bytes32 _cdpId) external view returns (uint256);</span>
 245 |     | <span class='neutral'></span>
 246 |     | <span class='neutral'>    function getCachedICR(bytes32 _cdpId, uint256 _price) external view returns (uint256);</span>
 247 |     | <span class='neutral'></span>
 248 |     | <span class='neutral'>    function getSyncedCdpDebt(bytes32 _cdpId) external view returns (uint256);</span>
 249 |     | <span class='neutral'></span>
 250 |     | <span class='neutral'>    function getSyncedCdpCollShares(bytes32 _cdpId) external view returns (uint256);</span>
 251 |     | <span class='neutral'></span>
 252 |     | <span class='neutral'>    function getSyncedICR(bytes32 _cdpId, uint256 _price) external view returns (uint256);</span>
 253 |     | <span class='neutral'></span>
 254 |     | <span class='neutral'>    function getSyncedTCR(uint256 _price) external view returns (uint256);</span>
 255 |     | <span class='neutral'></span>
 256 |     | <span class='neutral'>    function getSyncedSystemCollShares() external view returns (uint256);</span>
 257 |     | <span class='neutral'></span>
 258 |     | <span class='neutral'>    function getSyncedNominalICR(bytes32 _cdpId) external view returns (uint256);</span>
 259 |     | <span class='neutral'></span>
 260 |     | <span class='neutral'>    function getPendingRedistributedDebt(bytes32 _cdpId) external view returns (uint256);</span>
 261 |     | <span class='neutral'></span>
 262 |     | <span class='neutral'>    function hasPendingRedistributedDebt(bytes32 _cdpId) external view returns (bool);</span>
 263 |     | <span class='neutral'></span>
 264 |     | <span class='neutral'>    function getSyncedDebtAndCollShares(</span>
 265 |     | <span class='neutral'>        bytes32 _cdpId</span>
 266 |     | <span class='neutral'>    ) external view returns (uint256 debt, uint256 collShares);</span>
 267 |     | <span class='neutral'></span>
 268 |     | <span class='neutral'>    function canLiquidateRecoveryMode(uint256 icr, uint256 tcr) external view returns (bool);</span>
 269 |     | <span class='neutral'></span>
 270 |     | <span class='neutral'>    function totalCollateralSnapshot() external view returns (uint256);</span>
 271 |     | <span class='neutral'></span>
 272 |     | <span class='neutral'>    function totalStakesSnapshot() external view returns (uint256);</span>
 273 |     | <span class='neutral'>}</span>
 274 |     | <span class='neutral'></span>

</code>
<br />

<b>/mnt/c/Users/Lourens/Documents/Recon-Fuzz/collabs/ebtc/packages/contracts/contracts/Interfaces/ICollSurplusPool.sol</b>
<code>
  1 |     | <span class='neutral'>// SPDX-License-Identifier: MIT</span>
  2 |     | <span class='neutral'></span>
  3 |     | <span class='neutral'>pragma solidity 0.8.17;</span>
  4 |     | <span class='neutral'></span>
  5 |     | <span class='neutral'>interface ICollSurplusPool {</span>
  6 |     | <span class='neutral'>    // --- Events ---</span>
  7 |     | <span class='neutral'></span>
  8 |     | <span class='neutral'>    event SurplusCollSharesAdded(</span>
  9 |     | <span class='neutral'>        bytes32 indexed _cdpId,</span>
 10 |     | <span class='neutral'>        address indexed _account,</span>
 11 |     | <span class='neutral'>        uint256 _claimableSurplusCollShares,</span>
 12 |     | <span class='neutral'>        uint256 _surplusCollSharesAddedFromCollateral,</span>
 13 |     | <span class='neutral'>        uint256 _surplusCollSharesAddedFromLiquidatorReward</span>
 14 |     | <span class='neutral'>    );</span>
 15 |     | <span class='neutral'>    event CollSharesTransferred(address indexed _to, uint256 _amount);</span>
 16 |     | <span class='neutral'></span>
 17 |     | <span class='neutral'>    event SweepTokenSuccess(address indexed _token, uint256 _amount, address indexed _recipient);</span>
 18 |     | <span class='neutral'></span>
 19 |     | <span class='neutral'>    // --- Contract setters ---</span>
 20 |     | <span class='neutral'></span>
 21 |     | <span class='neutral'>    function getTotalSurplusCollShares() external view returns (uint256);</span>
 22 |     | <span class='neutral'></span>
 23 |     | <span class='neutral'>    function getSurplusCollShares(address _account) external view returns (uint256);</span>
 24 |     | <span class='neutral'></span>
 25 |     | <span class='neutral'>    function increaseSurplusCollShares(</span>
 26 |     | <span class='neutral'>        bytes32 _cdpId,</span>
 27 |     | <span class='neutral'>        address _account,</span>
 28 |     | <span class='neutral'>        uint256 _collateralShares,</span>
 29 |     | <span class='neutral'>        uint256 _liquidatorRewardShares</span>
 30 |     | <span class='neutral'>    ) external;</span>
 31 |     | <span class='neutral'></span>
 32 |     | <span class='neutral'>    function claimSurplusCollShares(address _account) external;</span>
 33 |     | <span class='neutral'></span>
 34 |     | <span class='neutral'>    function increaseTotalSurplusCollShares(uint256 _value) external;</span>
 35 |     | <span class='neutral'>}</span>
 36 |     | <span class='neutral'></span>

</code>
<br />

<b>/mnt/c/Users/Lourens/Documents/Recon-Fuzz/collabs/ebtc/packages/contracts/contracts/Interfaces/IEBTCToken.sol</b>
<code>
  1 |     | <span class='neutral'>// SPDX-License-Identifier: MIT</span>
  2 |     | <span class='neutral'></span>
  3 |     | <span class='neutral'>pragma solidity 0.8.17;</span>
  4 |     | <span class='neutral'></span>
  5 |     | <span class='neutral'>import &quot;../Dependencies/IERC20.sol&quot;;</span>
  6 |     | <span class='neutral'>import &quot;../Dependencies/IERC2612.sol&quot;;</span>
  7 |     | <span class='neutral'></span>
  8 |     | <span class='neutral'>interface IEBTCToken is IERC20, IERC2612 {</span>
  9 |     | <span class='neutral'>    // --- Functions ---</span>
 10 |     | <span class='neutral'></span>
 11 |     | <span class='neutral'>    function mint(address _account, uint256 _amount) external;</span>
 12 |     | <span class='neutral'></span>
 13 |     | <span class='neutral'>    function burn(address _account, uint256 _amount) external;</span>
 14 |     | <span class='neutral'>}</span>
 15 |     | <span class='neutral'></span>

</code>
<br />

<b>/mnt/c/Users/Lourens/Documents/Recon-Fuzz/collabs/ebtc/packages/contracts/contracts/Interfaces/IERC3156FlashBorrower.sol</b>
<code>
  1 |     | <span class='neutral'>// SPDX-License-Identifier: MIT</span>
  2 |     | <span class='neutral'></span>
  3 |     | <span class='neutral'>pragma solidity 0.8.17;</span>
  4 |     | <span class='neutral'></span>
  5 |     | <span class='neutral'>interface IERC3156FlashBorrower {</span>
  6 |     | <span class='neutral'>    /**</span>
  7 |     | <span class='neutral'>     * @dev Receive a flash loan.</span>
  8 |     | <span class='neutral'>     * @param initiator The initiator of the loan.</span>
  9 |     | <span class='neutral'>     * @param token The loan currency.</span>
 10 |     | <span class='neutral'>     * @param amount The amount of tokens lent.</span>
 11 |     | <span class='neutral'>     * @param fee The additional amount of tokens to repay.</span>
 12 |     | <span class='neutral'>     * @param data Arbitrary data structure, intended to contain user-defined parameters.</span>
 13 |     | <span class='neutral'>     * @return The keccak256 hash of &quot;ERC3156FlashBorrower.onFlashLoan&quot;</span>
 14 |     | <span class='neutral'>     */</span>
 15 |     | <span class='neutral'>    function onFlashLoan(</span>
 16 |     | <span class='neutral'>        address initiator,</span>
 17 |     | <span class='neutral'>        address token,</span>
 18 |     | <span class='neutral'>        uint256 amount,</span>
 19 |     | <span class='neutral'>        uint256 fee,</span>
 20 |     | <span class='neutral'>        bytes calldata data</span>
 21 |     | <span class='neutral'>    ) external returns (bytes32);</span>
 22 |     | <span class='neutral'>}</span>
 23 |     | <span class='neutral'></span>

</code>
<br />

<b>/mnt/c/Users/Lourens/Documents/Recon-Fuzz/collabs/ebtc/packages/contracts/contracts/Interfaces/IERC3156FlashLender.sol</b>
<code>
  1 |     | <span class='neutral'>// SPDX-License-Identifier: MIT</span>
  2 |     | <span class='neutral'></span>
  3 |     | <span class='neutral'>pragma solidity 0.8.17;</span>
  4 |     | <span class='neutral'></span>
  5 |     | <span class='neutral'>import &quot;./IERC3156FlashBorrower.sol&quot;;</span>
  6 |     | <span class='neutral'></span>
  7 |     | <span class='neutral'>interface IERC3156FlashLender {</span>
  8 |     | <span class='neutral'>    event FlashFeeSet(address indexed _setter, uint256 _oldFee, uint256 _newFee);</span>
  9 |     | <span class='neutral'>    event MaxFlashFeeSet(address indexed _setter, uint256 _oldMaxFee, uint256 _newMaxFee);</span>
 10 |     | <span class='neutral'>    event FlashLoansPaused(address indexed _setter, bool _paused);</span>
 11 |     | <span class='neutral'></span>
 12 |     | <span class='neutral'>    /// @dev The amount of currency available to be lent.</span>
 13 |     | <span class='neutral'>    /// @param token The loan currency.</span>
 14 |     | <span class='neutral'>    /// @return The amount of `token` that can be borrowed.</span>
 15 |     | <span class='neutral'>    function maxFlashLoan(address token) external view returns (uint256);</span>
 16 |     | <span class='neutral'></span>
 17 |     | <span class='neutral'>    /// @dev The fee to be charged for a given loan.</span>
 18 |     | <span class='neutral'>    /// @param token The loan currency.</span>
 19 |     | <span class='neutral'>    /// @param amount The amount of tokens lent.</span>
 20 |     | <span class='neutral'>    /// @return The amount of `token` to be charged for the loan, on top of the returned principal.</span>
 21 |     | <span class='neutral'>    function flashFee(address token, uint256 amount) external view returns (uint256);</span>
 22 |     | <span class='neutral'></span>
 23 |     | <span class='neutral'>    /// @dev Initiate a flash loan.</span>
 24 |     | <span class='neutral'>    /// @param receiver The receiver of the tokens in the loan, and the receiver of the callback.</span>
 25 |     | <span class='neutral'>    /// @param token The loan currency.</span>
 26 |     | <span class='neutral'>    /// @param amount The amount of tokens lent.</span>
 27 |     | <span class='neutral'>    /// @param data Arbitrary data structure, intended to contain user-defined parameters.</span>
 28 |     | <span class='neutral'>    function flashLoan(</span>
 29 |     | <span class='neutral'>        IERC3156FlashBorrower receiver,</span>
 30 |     | <span class='neutral'>        address token,</span>
 31 |     | <span class='neutral'>        uint256 amount,</span>
 32 |     | <span class='neutral'>        bytes calldata data</span>
 33 |     | <span class='neutral'>    ) external returns (bool);</span>
 34 |     | <span class='neutral'>}</span>
 35 |     | <span class='neutral'></span>

</code>
<br />

<b>/mnt/c/Users/Lourens/Documents/Recon-Fuzz/collabs/ebtc/packages/contracts/contracts/Interfaces/IEbtcBase.sol</b>
<code>
  1 |     | <span class='neutral'>// SPDX-License-Identifier: MIT</span>
  2 |     | <span class='neutral'></span>
  3 |     | <span class='neutral'>pragma solidity 0.8.17;</span>
  4 |     | <span class='neutral'></span>
  5 |     | <span class='neutral'>import &quot;./IPriceFeed.sol&quot;;</span>
  6 |     | <span class='neutral'></span>
  7 |     | <span class='neutral'>interface IEbtcBase {</span>
  8 |     | <span class='neutral'>    function priceFeed() external view returns (IPriceFeed);</span>
  9 |     | <span class='neutral'>}</span>
 10 |     | <span class='neutral'></span>

</code>
<br />

<b>/mnt/c/Users/Lourens/Documents/Recon-Fuzz/collabs/ebtc/packages/contracts/contracts/Interfaces/IFallbackCaller.sol</b>
<code>
  1 |     | <span class='neutral'>// SPDX-License-Identifier: MIT</span>
  2 |     | <span class='neutral'></span>
  3 |     | <span class='neutral'>pragma solidity 0.8.17;</span>
  4 |     | <span class='neutral'></span>
  5 |     | <span class='neutral'>interface IFallbackCaller {</span>
  6 |     | <span class='neutral'>    // --- Events ---</span>
  7 |     | <span class='neutral'>    event FallbackTimeOutChanged(uint256 _oldTimeOut, uint256 _newTimeOut);</span>
  8 |     | <span class='neutral'></span>
  9 |     | <span class='neutral'>    // --- Function External View ---</span>
 10 |     | <span class='neutral'></span>
 11 |     | <span class='neutral'>    // NOTE: The fallback oracle must always return its answer scaled to 18 decimals where applicable</span>
 12 |     | <span class='neutral'>    //       The system will assume an 18 decimal response for efficiency.</span>
 13 |     | <span class='neutral'>    function getFallbackResponse() external view returns (uint256, uint256, bool);</span>
 14 |     | <span class='neutral'></span>
 15 |     | <span class='neutral'>    // NOTE: this returns the timeout window interval for the fallback oracle instead</span>
 16 |     | <span class='neutral'>    // of storing in the `PriceFeed` contract is retrieve for the `FallbackCaller`</span>
 17 |     | <span class='neutral'>    function fallbackTimeout() external view returns (uint256);</span>
 18 |     | <span class='neutral'></span>
 19 |     | <span class='neutral'>    // --- Function External Setter ---</span>
 20 |     | <span class='neutral'></span>
 21 |     | <span class='neutral'>    function setFallbackTimeout(uint256 newFallbackTimeout) external;</span>
 22 |     | <span class='neutral'>}</span>
 23 |     | <span class='neutral'></span>

</code>
<br />

<b>/mnt/c/Users/Lourens/Documents/Recon-Fuzz/collabs/ebtc/packages/contracts/contracts/Interfaces/IOracleCaller.sol</b>
<code>
  1 |     | <span class='neutral'>// SPDX-License-Identifier: MIT</span>
  2 |     | <span class='neutral'></span>
  3 |     | <span class='neutral'>pragma solidity 0.8.17;</span>
  4 |     | <span class='neutral'></span>
  5 |     | <span class='neutral'>import &quot;./IPool.sol&quot;;</span>
  6 |     | <span class='neutral'></span>
  7 |     | <span class='neutral'>interface IOracleCaller {</span>
  8 |     | <span class='neutral'>    function getLatestPrice() external view returns (uint256);</span>
  9 |     | <span class='neutral'>}</span>
 10 |     | <span class='neutral'></span>
 11 |     | <span class='neutral'>interface IPriceFetcher {</span>
 12 |     | <span class='neutral'>    function fetchPrice() external returns (uint256);</span>
 13 |     | <span class='neutral'>}</span>
 14 |     | <span class='neutral'></span>

</code>
<br />

<b>/mnt/c/Users/Lourens/Documents/Recon-Fuzz/collabs/ebtc/packages/contracts/contracts/Interfaces/IPermitNonce.sol</b>
<code>
  1 |     | <span class='neutral'>// SPDX-License-Identifier: MIT</span>
  2 |     | <span class='neutral'></span>
  3 |     | <span class='neutral'>pragma solidity 0.8.17;</span>
  4 |     | <span class='neutral'></span>
  5 |     | <span class='neutral'>interface IPermitNonce {</span>
  6 |     | <span class='neutral'>    // --- Functions ---</span>
  7 |     | <span class='neutral'>    function increasePermitNonce() external returns (uint256);</span>
  8 |     | <span class='neutral'></span>
  9 |     | <span class='neutral'>    function nonces(address owner) external view returns (uint256);</span>
 10 |     | <span class='neutral'>}</span>
 11 |     | <span class='neutral'></span>

</code>
<br />

<b>/mnt/c/Users/Lourens/Documents/Recon-Fuzz/collabs/ebtc/packages/contracts/contracts/Interfaces/IPool.sol</b>
<code>
  1 |     | <span class='neutral'>// SPDX-License-Identifier: MIT</span>
  2 |     | <span class='neutral'></span>
  3 |     | <span class='neutral'>pragma solidity 0.8.17;</span>
  4 |     | <span class='neutral'></span>
  5 |     | <span class='neutral'>// Common interface for the Pools.</span>
  6 |     | <span class='neutral'>interface IPool {</span>
  7 |     | <span class='neutral'>    // --- Events ---</span>
  8 |     | <span class='neutral'></span>
  9 |     | <span class='neutral'>    event ETHBalanceUpdated(uint256 _newBalance);</span>
 10 |     | <span class='neutral'>    event EBTCBalanceUpdated(uint256 _newBalance);</span>
 11 |     | <span class='neutral'>    event CollSharesTransferred(address indexed _to, uint256 _amount);</span>
 12 |     | <span class='neutral'></span>
 13 |     | <span class='neutral'>    // --- Functions ---</span>
 14 |     | <span class='neutral'></span>
 15 |     | <span class='neutral'>    function getSystemCollShares() external view returns (uint256);</span>
 16 |     | <span class='neutral'></span>
 17 |     | <span class='neutral'>    function getSystemDebt() external view returns (uint256);</span>
 18 |     | <span class='neutral'></span>
 19 |     | <span class='neutral'>    function increaseSystemDebt(uint256 _amount) external;</span>
 20 |     | <span class='neutral'></span>
 21 |     | <span class='neutral'>    function decreaseSystemDebt(uint256 _amount) external;</span>
 22 |     | <span class='neutral'>}</span>
 23 |     | <span class='neutral'></span>

</code>
<br />

<b>/mnt/c/Users/Lourens/Documents/Recon-Fuzz/collabs/ebtc/packages/contracts/contracts/Interfaces/IPositionManagers.sol</b>
<code>
  1 |     | <span class='neutral'>// SPDX-License-Identifier: MIT</span>
  2 |     | <span class='neutral'></span>
  3 |     | <span class='neutral'>pragma solidity 0.8.17;</span>
  4 |     | <span class='neutral'></span>
  5 |     | <span class='neutral'>interface IPositionManagers {</span>
  6 |     | <span class='neutral'>    enum PositionManagerApproval {</span>
  7 |     | <span class='neutral'>        None,</span>
  8 |     | <span class='neutral'>        OneTime,</span>
  9 |     | <span class='neutral'>        Persistent</span>
 10 |     | <span class='neutral'>    }</span>
 11 |     | <span class='neutral'></span>
 12 |     | <span class='neutral'>    event PositionManagerApprovalSet(</span>
 13 |     | <span class='neutral'>        address indexed _borrower,</span>
 14 |     | <span class='neutral'>        address indexed _positionManager,</span>
 15 |     | <span class='neutral'>        PositionManagerApproval _approval</span>
 16 |     | <span class='neutral'>    );</span>
 17 |     | <span class='neutral'></span>
 18 |     | <span class='neutral'>    function getPositionManagerApproval(</span>
 19 |     | <span class='neutral'>        address _borrower,</span>
 20 |     | <span class='neutral'>        address _positionManager</span>
 21 |     | <span class='neutral'>    ) external view returns (PositionManagerApproval);</span>
 22 |     | <span class='neutral'></span>
 23 |     | <span class='neutral'>    function setPositionManagerApproval(</span>
 24 |     | <span class='neutral'>        address _positionManager,</span>
 25 |     | <span class='neutral'>        PositionManagerApproval _approval</span>
 26 |     | <span class='neutral'>    ) external;</span>
 27 |     | <span class='neutral'></span>
 28 |     | <span class='neutral'>    function revokePositionManagerApproval(address _positionManager) external;</span>
 29 |     | <span class='neutral'></span>
 30 |     | <span class='neutral'>    function renouncePositionManagerApproval(address _borrower) external;</span>
 31 |     | <span class='neutral'></span>
 32 |     | <span class='neutral'>    function permitPositionManagerApproval(</span>
 33 |     | <span class='neutral'>        address _borrower,</span>
 34 |     | <span class='neutral'>        address _positionManager,</span>
 35 |     | <span class='neutral'>        PositionManagerApproval _approval,</span>
 36 |     | <span class='neutral'>        uint _deadline,</span>
 37 |     | <span class='neutral'>        uint8 v,</span>
 38 |     | <span class='neutral'>        bytes32 r,</span>
 39 |     | <span class='neutral'>        bytes32 s</span>
 40 |     | <span class='neutral'>    ) external;</span>
 41 |     | <span class='neutral'></span>
 42 |     | <span class='neutral'>    function version() external view returns (string memory);</span>
 43 |     | <span class='neutral'></span>
 44 |     | <span class='neutral'>    function permitTypeHash() external view returns (bytes32);</span>
 45 |     | <span class='neutral'></span>
 46 |     | <span class='neutral'>    function domainSeparator() external view returns (bytes32);</span>
 47 |     | <span class='neutral'>}</span>
 48 |     | <span class='neutral'></span>

</code>
<br />

<b>/mnt/c/Users/Lourens/Documents/Recon-Fuzz/collabs/ebtc/packages/contracts/contracts/Interfaces/IPriceFeed.sol</b>
<code>
  1 |     | <span class='neutral'>// SPDX-License-Identifier: MIT</span>
  2 |     | <span class='neutral'></span>
  3 |     | <span class='neutral'>pragma solidity 0.8.17;</span>
  4 |     | <span class='neutral'></span>
  5 |     | <span class='neutral'>interface IPriceFeed {</span>
  6 |     | <span class='neutral'>    // --- Events ---</span>
  7 |     | <span class='neutral'>    event LastGoodPriceUpdated(uint256 _lastGoodPrice);</span>
  8 |     | <span class='neutral'>    event PriceFeedStatusChanged(Status newStatus);</span>
  9 |     | <span class='neutral'>    event FallbackCallerChanged(</span>
 10 |     | <span class='neutral'>        address indexed _oldFallbackCaller,</span>
 11 |     | <span class='neutral'>        address indexed _newFallbackCaller</span>
 12 |     | <span class='neutral'>    );</span>
 13 |     | <span class='neutral'>    event UnhealthyFallbackCaller(address indexed _fallbackCaller, uint256 timestamp);</span>
 14 |     | <span class='neutral'>    event CollateralFeedSourceUpdated(address indexed stEthFeed);</span>
 15 |     | <span class='neutral'></span>
 16 |     | <span class='neutral'>    // --- Structs ---</span>
 17 |     | <span class='neutral'></span>
 18 |     | <span class='neutral'>    struct ChainlinkResponse {</span>
 19 |     | <span class='neutral'>        uint80 roundEthBtcId;</span>
 20 |     | <span class='neutral'>        uint80 roundStEthEthId;</span>
 21 |     | <span class='neutral'>        uint256 answer;</span>
 22 |     | <span class='neutral'>        uint256 timestampEthBtc;</span>
 23 |     | <span class='neutral'>        uint256 timestampStEthEth;</span>
 24 |     | <span class='neutral'>        bool success;</span>
 25 |     | <span class='neutral'>    }</span>
 26 |     | <span class='neutral'></span>
 27 |     | <span class='neutral'>    struct FallbackResponse {</span>
 28 |     | <span class='neutral'>        uint256 answer;</span>
 29 |     | <span class='neutral'>        uint256 timestamp;</span>
 30 |     | <span class='neutral'>        bool success;</span>
 31 |     | <span class='neutral'>    }</span>
 32 |     | <span class='neutral'></span>
 33 |     | <span class='neutral'>    // --- Enum ---</span>
 34 |     | <span class='neutral'></span>
 35 |     | <span class='neutral'>    enum Status {</span>
 36 |     | <span class='neutral'>        chainlinkWorking,</span>
 37 |     | <span class='neutral'>        usingFallbackChainlinkUntrusted,</span>
 38 |     | <span class='neutral'>        bothOraclesUntrusted,</span>
 39 |     | <span class='neutral'>        usingFallbackChainlinkFrozen,</span>
 40 |     | <span class='neutral'>        usingChainlinkFallbackUntrusted</span>
 41 |     | <span class='neutral'>    }</span>
 42 |     | <span class='neutral'></span>
 43 |     | <span class='neutral'>    // --- Function ---</span>
 44 |     | <span class='neutral'>    function fetchPrice() external returns (uint256);</span>
 45 |     | <span class='neutral'>}</span>
 46 |     | <span class='neutral'></span>

</code>
<br />

<b>/mnt/c/Users/Lourens/Documents/Recon-Fuzz/collabs/ebtc/packages/contracts/contracts/Interfaces/IRecoveryModeGracePeriod.sol</b>
<code>
  1 |     | <span class='neutral'>// SPDX-License-Identifier: MIT</span>
  2 |     | <span class='neutral'>pragma solidity 0.8.17;</span>
  3 |     | <span class='neutral'></span>
  4 |     | <span class='neutral'>// Interface for State Updates that can trigger RM Liquidations</span>
  5 |     | <span class='neutral'>interface IRecoveryModeGracePeriod {</span>
  6 |     | <span class='neutral'>    event TCRNotified(uint256 TCR); /// NOTE: Mostly for debugging to ensure synch</span>
  7 |     | <span class='neutral'></span>
  8 |     | <span class='neutral'>    // NOTE: Ts is implicit in events (it&#39;s added by GETH)</span>
  9 |     | <span class='neutral'>    event GracePeriodStart();</span>
 10 |     | <span class='neutral'>    event GracePeriodEnd();</span>
 11 |     | <span class='neutral'>    event GracePeriodDurationSet(uint256 _recoveryModeGracePeriodDuration);</span>
 12 |     | <span class='neutral'></span>
 13 |     | <span class='neutral'>    function notifyStartGracePeriod(uint256 tcr) external;</span>
 14 |     | <span class='neutral'></span>
 15 |     | <span class='neutral'>    function notifyEndGracePeriod(uint256 tcr) external;</span>
 16 |     | <span class='neutral'>}</span>
 17 |     | <span class='neutral'></span>

</code>
<br />

<b>/mnt/c/Users/Lourens/Documents/Recon-Fuzz/collabs/ebtc/packages/contracts/contracts/Interfaces/ISortedCdps.sol</b>
<code>
  1 |     | <span class='neutral'>// SPDX-License-Identifier: MIT</span>
  2 |     | <span class='neutral'></span>
  3 |     | <span class='neutral'>pragma solidity 0.8.17;</span>
  4 |     | <span class='neutral'></span>
  5 |     | <span class='neutral'>// Common interface for the SortedCdps Doubly Linked List.</span>
  6 |     | <span class='neutral'>interface ISortedCdps {</span>
  7 |     | <span class='neutral'>    // --- Events ---</span>
  8 |     | <span class='neutral'></span>
  9 |     | <span class='neutral'>    event NodeAdded(bytes32 _id, uint _NICR);</span>
 10 |     | <span class='neutral'>    event NodeRemoved(bytes32 _id);</span>
 11 |     | <span class='neutral'></span>
 12 |     | <span class='neutral'>    // --- Functions ---</span>
 13 |     | <span class='neutral'></span>
 14 |     | <span class='neutral'>    function remove(bytes32 _id) external;</span>
 15 |     | <span class='neutral'></span>
 16 |     | <span class='neutral'>    function batchRemove(bytes32[] memory _ids) external;</span>
 17 |     | <span class='neutral'></span>
 18 |     | <span class='neutral'>    function reInsert(bytes32 _id, uint256 _newICR, bytes32 _prevId, bytes32 _nextId) external;</span>
 19 |     | <span class='neutral'></span>
 20 |     | <span class='neutral'>    function contains(bytes32 _id) external view returns (bool);</span>
 21 |     | <span class='neutral'></span>
 22 |     | <span class='neutral'>    function isFull() external view returns (bool);</span>
 23 |     | <span class='neutral'></span>
 24 |     | <span class='neutral'>    function isEmpty() external view returns (bool);</span>
 25 |     | <span class='neutral'></span>
 26 |     | <span class='neutral'>    function getSize() external view returns (uint256);</span>
 27 |     | <span class='neutral'></span>
 28 |     | <span class='neutral'>    function getMaxSize() external view returns (uint256);</span>
 29 |     | <span class='neutral'></span>
 30 |     | <span class='neutral'>    function getFirst() external view returns (bytes32);</span>
 31 |     | <span class='neutral'></span>
 32 |     | <span class='neutral'>    function getLast() external view returns (bytes32);</span>
 33 |     | <span class='neutral'></span>
 34 |     | <span class='neutral'>    function getNext(bytes32 _id) external view returns (bytes32);</span>
 35 |     | <span class='neutral'></span>
 36 |     | <span class='neutral'>    function getPrev(bytes32 _id) external view returns (bytes32);</span>
 37 |     | <span class='neutral'></span>
 38 |     | <span class='neutral'>    function validInsertPosition(</span>
 39 |     | <span class='neutral'>        uint256 _ICR,</span>
 40 |     | <span class='neutral'>        bytes32 _prevId,</span>
 41 |     | <span class='neutral'>        bytes32 _nextId</span>
 42 |     | <span class='neutral'>    ) external view returns (bool);</span>
 43 |     | <span class='neutral'></span>
 44 |     | <span class='neutral'>    function findInsertPosition(</span>
 45 |     | <span class='neutral'>        uint256 _ICR,</span>
 46 |     | <span class='neutral'>        bytes32 _prevId,</span>
 47 |     | <span class='neutral'>        bytes32 _nextId</span>
 48 |     | <span class='neutral'>    ) external view returns (bytes32, bytes32);</span>
 49 |     | <span class='neutral'></span>
 50 |     | <span class='neutral'>    function insert(</span>
 51 |     | <span class='neutral'>        address owner,</span>
 52 |     | <span class='neutral'>        uint256 _ICR,</span>
 53 |     | <span class='neutral'>        bytes32 _prevId,</span>
 54 |     | <span class='neutral'>        bytes32 _nextId</span>
 55 |     | <span class='neutral'>    ) external returns (bytes32);</span>
 56 |     | <span class='neutral'></span>
 57 |     | <span class='neutral'>    function getOwnerAddress(bytes32 _id) external pure returns (address);</span>
 58 |     | <span class='neutral'></span>
 59 |     | <span class='neutral'>    function nonExistId() external view returns (bytes32);</span>
 60 |     | <span class='neutral'></span>
 61 |     | <span class='neutral'>    function cdpCountOf(address owner) external view returns (uint256);</span>
 62 |     | <span class='neutral'></span>
 63 |     | <span class='neutral'>    function getCdpCountOf(</span>
 64 |     | <span class='neutral'>        address owner,</span>
 65 |     | <span class='neutral'>        bytes32 startNodeId,</span>
 66 |     | <span class='neutral'>        uint maxNodes</span>
 67 |     | <span class='neutral'>    ) external view returns (uint256, bytes32);</span>
 68 |     | <span class='neutral'></span>
 69 |     | <span class='neutral'>    function getCdpsOf(address owner) external view returns (bytes32[] memory);</span>
 70 |     | <span class='neutral'></span>
 71 |     | <span class='neutral'>    function getAllCdpsOf(</span>
 72 |     | <span class='neutral'>        address owner,</span>
 73 |     | <span class='neutral'>        bytes32 startNodeId,</span>
 74 |     | <span class='neutral'>        uint maxNodes</span>
 75 |     | <span class='neutral'>    ) external view returns (bytes32[] memory, uint256, bytes32);</span>
 76 |     | <span class='neutral'></span>
 77 |     | <span class='neutral'>    function cdpOfOwnerByIndex(address owner, uint256 index) external view returns (bytes32);</span>
 78 |     | <span class='neutral'></span>
 79 |     | <span class='neutral'>    function cdpOfOwnerByIdx(</span>
 80 |     | <span class='neutral'>        address owner,</span>
 81 |     | <span class='neutral'>        uint256 index,</span>
 82 |     | <span class='neutral'>        bytes32 startNodeId,</span>
 83 |     | <span class='neutral'>        uint maxNodes</span>
 84 |     | <span class='neutral'>    ) external view returns (bytes32, bool);</span>
 85 |     | <span class='neutral'></span>
 86 |     | <span class='neutral'>    function toCdpId(</span>
 87 |     | <span class='neutral'>        address owner,</span>
 88 |     | <span class='neutral'>        uint256 blockHeight,</span>
 89 |     | <span class='neutral'>        uint256 nonce</span>
 90 |     | <span class='neutral'>    ) external pure returns (bytes32);</span>
 91 |     | <span class='neutral'></span>
 92 |     | <span class='neutral'>    function nextCdpNonce() external view returns (uint256);</span>
 93 |     | <span class='neutral'>}</span>
 94 |     | <span class='neutral'></span>

</code>
<br />

<b>/mnt/c/Users/Lourens/Documents/Recon-Fuzz/collabs/ebtc/packages/contracts/contracts/Interfaces/ITwapWeightedObserver.sol</b>
<code>
  1 |     | <span class='neutral'>// SPDX-License Identifier: MIT</span>
  2 |     | <span class='neutral'>pragma solidity 0.8.17;</span>
  3 |     | <span class='neutral'>import {IBaseTwapWeightedObserver} from &quot;./IBaseTwapWeightedObserver.sol&quot;;</span>
  4 |     | <span class='neutral'></span>
  5 |     | <span class='neutral'>interface ITwapWeightedObserver is IBaseTwapWeightedObserver {</span>
  6 |     | <span class='neutral'>    event TwapDisabled();</span>
  7 |     | <span class='neutral'></span>
  8 |     | <span class='neutral'>    function PERIOD() external view returns (uint256);</span>
  9 |     | <span class='neutral'></span>
 10 |     | <span class='neutral'>    function valueToTrack() external view returns (uint128);</span>
 11 |     | <span class='neutral'></span>
 12 |     | <span class='neutral'>    function timeToAccrue() external view returns (uint64);</span>
 13 |     | <span class='neutral'></span>
 14 |     | <span class='neutral'>    function getLatestAccumulator() external view returns (uint128);</span>
 15 |     | <span class='neutral'></span>
 16 |     | <span class='neutral'>    function observe() external returns (uint256);</span>
 17 |     | <span class='neutral'></span>
 18 |     | <span class='neutral'>    function update() external;</span>
 19 |     | <span class='neutral'></span>
 20 |     | <span class='neutral'>    function twapDisabled() external view returns (bool);</span>
 21 |     | <span class='neutral'>}</span>
 22 |     | <span class='neutral'></span>

</code>
<br />

<b>/mnt/c/Users/Lourens/Documents/Recon-Fuzz/collabs/ebtc/packages/contracts/contracts/Interfaces/IWETH.sol</b>
<code>
  1 |     | <span class='neutral'>// SPDX-License-Identifier: MIT</span>
  2 |     | <span class='neutral'></span>
  3 |     | <span class='neutral'>pragma solidity 0.8.17;</span>
  4 |     | <span class='neutral'></span>
  5 |     | <span class='neutral'>interface IWETH {</span>
  6 |     | <span class='neutral'>    function deposit() external payable;</span>
  7 |     | <span class='neutral'></span>
  8 |     | <span class='neutral'>    function withdraw(uint256) external;</span>
  9 |     | <span class='neutral'></span>
 10 |     | <span class='neutral'>    function transfer(address to, uint256 amount) external returns (bool);</span>
 11 |     | <span class='neutral'></span>
 12 |     | <span class='neutral'>    function transferFrom(address from, address to, uint256 amount) external returns (bool);</span>
 13 |     | <span class='neutral'>}</span>
 14 |     | <span class='neutral'></span>

</code>
<br />

<b>/mnt/c/Users/Lourens/Documents/Recon-Fuzz/collabs/ebtc/packages/contracts/contracts/LiquidationLibrary.sol</b>
<code>
   1 |     | <span class='neutral'>// SPDX-License-Identifier: MIT</span>
   2 |     | <span class='neutral'></span>
   3 |     | <span class='neutral'>pragma solidity 0.8.17;</span>
   4 |     | <span class='neutral'>import &quot;./Interfaces/ICdpManagerData.sol&quot;;</span>
   5 |     | <span class='neutral'>import &quot;./Interfaces/ICollSurplusPool.sol&quot;;</span>
   6 |     | <span class='neutral'>import &quot;./Interfaces/IEBTCToken.sol&quot;;</span>
   7 |     | <span class='neutral'>import &quot;./Interfaces/ISortedCdps.sol&quot;;</span>
   8 |     | <span class='neutral'>import &quot;./Dependencies/ICollateralTokenOracle.sol&quot;;</span>
   9 |     | <span class='neutral'>import &quot;./CdpManagerStorage.sol&quot;;</span>
  10 |     | <span class='neutral'></span>
  11 |     | <span class='neutral'>/// @title LiquidationLibrary mainly provide necessary logic to fulfill liquidation for eBTC Cdps.</span>
  12 |     | <span class='neutral'>/// @dev This contract shares same base and storage layout with CdpManager and is the delegatecall destination from CdpManager</span>
  13 |     | <span class='unexecuted'>contract LiquidationLibrary is CdpManagerStorage {</span>
  14 |     | <span class='unexecuted'>    constructor(</span>
  15 |     | <span class='neutral'>        address _borrowerOperationsAddress,</span>
  16 |     | <span class='neutral'>        address _collSurplusPool,</span>
  17 |     | <span class='neutral'>        address _ebtcToken,</span>
  18 |     | <span class='neutral'>        address _sortedCdps,</span>
  19 |     | <span class='neutral'>        address _activePool,</span>
  20 |     | <span class='neutral'>        address _priceFeed,</span>
  21 |     | <span class='neutral'>        address _collateral</span>
  22 |     | <span class='neutral'>    )</span>
  23 |     | <span class='neutral'>        CdpManagerStorage(</span>
  24 |     | <span class='unexecuted'>            address(0),</span>
  25 |     | <span class='neutral'>            address(0),</span>
  26 |     | <span class='unexecuted'>            _borrowerOperationsAddress,</span>
  27 |     | <span class='unexecuted'>            _collSurplusPool,</span>
  28 |     | <span class='unexecuted'>            _ebtcToken,</span>
  29 |     | <span class='unexecuted'>            _sortedCdps,</span>
  30 |     | <span class='unexecuted'>            _activePool,</span>
  31 |     | <span class='unexecuted'>            _priceFeed,</span>
  32 |     | <span class='unexecuted'>            _collateral</span>
  33 |     | <span class='neutral'>        )</span>
  34 |     | <span class='neutral'>    {}</span>
  35 |     | <span class='neutral'></span>
  36 |     | <span class='neutral'>    /// @notice Fully liquidate a single Cdp by ID. Cdp must meet the criteria for liquidation at the time of execution.</span>
  37 |     | <span class='neutral'>    /// @notice callable by anyone, attempts to liquidate the CdpId. Executes successfully if Cdp meets the conditions for liquidation (e.g. in Normal Mode, it liquidates if the Cdp&#39;s ICR &lt; the system MCR).</span>
  38 |     | <span class='neutral'>    /// @dev forwards msg.data directly to the liquidation library using OZ proxy core delegation function</span>
  39 |     | <span class='neutral'>    /// @param _cdpId ID of the Cdp to liquidate.</span>
  40 |     | <span class='unexecuted'>    function liquidate(bytes32 _cdpId) external nonReentrantSelfAndBOps {</span>
  41 |     | <span class='unexecuted'>        _liquidateIndividualCdpSetup(_cdpId, 0, _cdpId, _cdpId);</span>
  42 |     | <span class='neutral'>    }</span>
  43 |     | <span class='neutral'></span>
  44 |     | <span class='neutral'>    /// @notice Partially liquidate a single Cdp.</span>
  45 |     | <span class='neutral'>    /// @dev forwards msg.data directly to the liquidation library using OZ proxy core delegation function</span>
  46 |     | <span class='neutral'>    /// @param _cdpId ID of the Cdp to partially liquidate.</span>
  47 |     | <span class='neutral'>    /// @param _partialAmount Amount to partially liquidate.</span>
  48 |     | <span class='neutral'>    /// @param _upperPartialHint Upper hint for reinsertion of the Cdp into the linked list.</span>
  49 |     | <span class='neutral'>    /// @param _lowerPartialHint Lower hint for reinsertion of the Cdp into the linked list.</span>
  50 |     | <span class='unexecuted'>    function partiallyLiquidate(</span>
  51 |     | <span class='neutral'>        bytes32 _cdpId,</span>
  52 |     | <span class='neutral'>        uint256 _partialAmount,</span>
  53 |     | <span class='neutral'>        bytes32 _upperPartialHint,</span>
  54 |     | <span class='neutral'>        bytes32 _lowerPartialHint</span>
  55 |     | <span class='neutral'>    ) external nonReentrantSelfAndBOps {</span>
  56 |     | <span class='unexecuted'>        require(_partialAmount != 0, &quot;LiquidationLibrary: use `liquidate` for 100%&quot;);</span>
  57 |     | <span class='unexecuted'>        _liquidateIndividualCdpSetup(_cdpId, _partialAmount, _upperPartialHint, _lowerPartialHint);</span>
  58 |     | <span class='neutral'>    }</span>
  59 |     | <span class='neutral'></span>
  60 |     | <span class='neutral'>    // Single CDP liquidation function.</span>
  61 |     | <span class='unexecuted'>    function _liquidateIndividualCdpSetup(</span>
  62 |     | <span class='neutral'>        bytes32 _cdpId,</span>
  63 |     | <span class='neutral'>        uint256 _partialAmount,</span>
  64 |     | <span class='neutral'>        bytes32 _upperPartialHint,</span>
  65 |     | <span class='neutral'>        bytes32 _lowerPartialHint</span>
  66 |     | <span class='unexecuted'>    ) internal {</span>
  67 |     | <span class='unexecuted'>        _requireCdpIsActive(_cdpId);</span>
  68 |     | <span class='neutral'></span>
  69 |     | <span class='unexecuted'>        _syncAccounting(_cdpId);</span>
  70 |     | <span class='neutral'></span>
  71 |     | <span class='unexecuted'>        uint256 _price = priceFeed.fetchPrice();</span>
  72 |     | <span class='neutral'></span>
  73 |     | <span class='neutral'>        // prepare local variables</span>
  74 |     | <span class='unexecuted'>        uint256 _ICR = getCachedICR(_cdpId, _price); // @audit syncAccounting already called, guarenteed to be synced</span>
  75 |     | <span class='unexecuted'>        (uint256 _TCR, uint256 systemColl, uint256 systemDebt) = _getTCRWithSystemDebtAndCollShares(</span>
  76 |     | <span class='unexecuted'>            _price</span>
  77 |     | <span class='neutral'>        );</span>
  78 |     | <span class='neutral'></span>
  79 |     | <span class='neutral'>        // If CDP is above MCR</span>
  80 |     | <span class='unexecuted'>        if (_ICR &gt;= MCR) {</span>
  81 |     | <span class='neutral'>            // We must be in RM</span>
  82 |     | <span class='unexecuted'>            require(</span>
  83 |     | <span class='unexecuted'>                _checkICRAgainstLiqThreshold(_ICR, _TCR),</span>
  84 |     | <span class='neutral'>                &quot;LiquidationLibrary: ICR is not below liquidation threshold in current mode&quot;</span>
  85 |     | <span class='neutral'>            );</span>
  86 |     | <span class='neutral'></span>
  87 |     | <span class='neutral'>            // == Grace Period == //</span>
  88 |     | <span class='unexecuted'>            uint128 cachedLastGracePeriodStartTimestamp = lastGracePeriodStartTimestamp;</span>
  89 |     | <span class='unexecuted'>            require(</span>
  90 |     | <span class='unexecuted'>                cachedLastGracePeriodStartTimestamp != UNSET_TIMESTAMP,</span>
  91 |     | <span class='neutral'>                &quot;LiquidationLibrary: Recovery Mode grace period not started&quot;</span>
  92 |     | <span class='neutral'>            );</span>
  93 |     | <span class='unexecuted'>            require(</span>
  94 |     | <span class='unexecuted'>                block.timestamp &gt;</span>
  95 |     | <span class='unexecuted'>                    cachedLastGracePeriodStartTimestamp + recoveryModeGracePeriodDuration,</span>
  96 |     | <span class='neutral'>                &quot;LiquidationLibrary: Recovery mode grace period still in effect&quot;</span>
  97 |     | <span class='neutral'>            );</span>
  98 |     | <span class='neutral'>        } // Implicit Else Case, Implies ICR &lt; MRC, meaning the CDP is liquidatable</span>
  99 |     | <span class='neutral'></span>
 100 |     | <span class='unexecuted'>        bool _recoveryModeAtStart = _TCR &lt; CCR ? true : false;</span>
 101 |     | <span class='unexecuted'>        LiquidationLocals memory _liqState = LiquidationLocals(</span>
 102 |     | <span class='unexecuted'>            _cdpId,</span>
 103 |     | <span class='unexecuted'>            _partialAmount,</span>
 104 |     | <span class='unexecuted'>            _price,</span>
 105 |     | <span class='unexecuted'>            _ICR,</span>
 106 |     | <span class='unexecuted'>            _upperPartialHint,</span>
 107 |     | <span class='unexecuted'>            _lowerPartialHint,</span>
 108 |     | <span class='unexecuted'>            (_recoveryModeAtStart),</span>
 109 |     | <span class='unexecuted'>            _TCR,</span>
 110 |     | <span class='unexecuted'>            0,</span>
 111 |     | <span class='unexecuted'>            0,</span>
 112 |     | <span class='unexecuted'>            0,</span>
 113 |     | <span class='unexecuted'>            0,</span>
 114 |     | <span class='unexecuted'>            0</span>
 115 |     | <span class='neutral'>        );</span>
 116 |     | <span class='neutral'></span>
 117 |     | <span class='unexecuted'>        LiquidationRecoveryModeLocals memory _rs = LiquidationRecoveryModeLocals(</span>
 118 |     | <span class='unexecuted'>            systemDebt,</span>
 119 |     | <span class='unexecuted'>            systemColl,</span>
 120 |     | <span class='unexecuted'>            0,</span>
 121 |     | <span class='unexecuted'>            0,</span>
 122 |     | <span class='unexecuted'>            0,</span>
 123 |     | <span class='unexecuted'>            _cdpId,</span>
 124 |     | <span class='unexecuted'>            _price,</span>
 125 |     | <span class='unexecuted'>            _ICR,</span>
 126 |     | <span class='unexecuted'>            0,</span>
 127 |     | <span class='unexecuted'>            0</span>
 128 |     | <span class='neutral'>        );</span>
 129 |     | <span class='neutral'></span>
 130 |     | <span class='unexecuted'>        _liquidateIndividualCdpSetupCDP(_liqState, _rs);</span>
 131 |     | <span class='neutral'>    }</span>
 132 |     | <span class='neutral'></span>
 133 |     | <span class='neutral'>    // liquidate given CDP by repaying debt in full or partially if its ICR is below MCR or TCR in recovery mode.</span>
 134 |     | <span class='neutral'>    // For partial liquidation, caller should use HintHelper smart contract to get correct hints for reinsertion into sorted CDP list</span>
 135 |     | <span class='unexecuted'>    function _liquidateIndividualCdpSetupCDP(</span>
 136 |     | <span class='neutral'>        LiquidationLocals memory _liqState,</span>
 137 |     | <span class='neutral'>        LiquidationRecoveryModeLocals memory _recoveryState</span>
 138 |     | <span class='neutral'>    ) internal {</span>
 139 |     | <span class='unexecuted'>        LiquidationValues memory liquidationValues;</span>
 140 |     | <span class='neutral'></span>
 141 |     | <span class='unexecuted'>        uint256 startingSystemDebt = _recoveryState.entireSystemDebt;</span>
 142 |     | <span class='unexecuted'>        uint256 startingSystemColl = _recoveryState.entireSystemColl;</span>
 143 |     | <span class='neutral'></span>
 144 |     | <span class='unexecuted'>        if (_liqState.partialAmount == 0) {</span>
 145 |     | <span class='unexecuted'>            (</span>
 146 |     | <span class='unexecuted'>                liquidationValues.debtToBurn,</span>
 147 |     | <span class='unexecuted'>                liquidationValues.totalCollToSendToLiquidator,</span>
 148 |     | <span class='unexecuted'>                liquidationValues.debtToRedistribute,</span>
 149 |     | <span class='unexecuted'>                liquidationValues.liquidatorCollSharesReward,</span>
 150 |     | <span class='unexecuted'>                liquidationValues.collSurplus</span>
 151 |     | <span class='unexecuted'>            ) = _liquidateCdpInGivenMode(_liqState, _recoveryState);</span>
 152 |     | <span class='neutral'>        } else {</span>
 153 |     | <span class='unexecuted'>            (</span>
 154 |     | <span class='unexecuted'>                liquidationValues.debtToBurn,</span>
 155 |     | <span class='unexecuted'>                liquidationValues.totalCollToSendToLiquidator</span>
 156 |     | <span class='unexecuted'>            ) = _liquidateCDPPartially(_liqState);</span>
 157 |     | <span class='unexecuted'>            if (</span>
 158 |     | <span class='unexecuted'>                liquidationValues.totalCollToSendToLiquidator == 0 &amp;&amp;</span>
 159 |     | <span class='unexecuted'>                liquidationValues.debtToBurn == 0</span>
 160 |     | <span class='neutral'>            ) {</span>
 161 |     | <span class='neutral'>                // retry with fully liquidation</span>
 162 |     | <span class='unexecuted'>                (</span>
 163 |     | <span class='unexecuted'>                    liquidationValues.debtToBurn,</span>
 164 |     | <span class='unexecuted'>                    liquidationValues.totalCollToSendToLiquidator,</span>
 165 |     | <span class='unexecuted'>                    liquidationValues.debtToRedistribute,</span>
 166 |     | <span class='unexecuted'>                    liquidationValues.liquidatorCollSharesReward,</span>
 167 |     | <span class='unexecuted'>                    liquidationValues.collSurplus</span>
 168 |     | <span class='unexecuted'>                ) = _liquidateCdpInGivenMode(_liqState, _recoveryState);</span>
 169 |     | <span class='neutral'>            }</span>
 170 |     | <span class='neutral'>        }</span>
 171 |     | <span class='neutral'></span>
 172 |     | <span class='unexecuted'>        _finalizeLiquidation(</span>
 173 |     | <span class='unexecuted'>            liquidationValues.debtToBurn,</span>
 174 |     | <span class='unexecuted'>            liquidationValues.totalCollToSendToLiquidator,</span>
 175 |     | <span class='unexecuted'>            liquidationValues.debtToRedistribute,</span>
 176 |     | <span class='unexecuted'>            liquidationValues.liquidatorCollSharesReward,</span>
 177 |     | <span class='unexecuted'>            liquidationValues.collSurplus,</span>
 178 |     | <span class='unexecuted'>            startingSystemColl,</span>
 179 |     | <span class='unexecuted'>            startingSystemDebt,</span>
 180 |     | <span class='unexecuted'>            _liqState.price</span>
 181 |     | <span class='neutral'>        );</span>
 182 |     | <span class='neutral'>    }</span>
 183 |     | <span class='neutral'></span>
 184 |     | <span class='neutral'>    // liquidate (and close) the CDP from an external liquidator</span>
 185 |     | <span class='neutral'>    // this function would return the liquidated debt and collateral of the given CDP</span>
 186 |     | <span class='unexecuted'>    function _liquidateCdpInGivenMode(</span>
 187 |     | <span class='neutral'>        LiquidationLocals memory _liqState,</span>
 188 |     | <span class='neutral'>        LiquidationRecoveryModeLocals memory _recoveryState</span>
 189 |     | <span class='unexecuted'>    ) private returns (uint256, uint256, uint256, uint256, uint256) {</span>
 190 |     | <span class='unexecuted'>        if (_liqState.recoveryModeAtStart) {</span>
 191 |     | <span class='unexecuted'>            LiquidationRecoveryModeLocals</span>
 192 |     | <span class='unexecuted'>                memory _outputState = _liquidateIndividualCdpSetupCDPInRecoveryMode(_recoveryState);</span>
 193 |     | <span class='neutral'></span>
 194 |     | <span class='neutral'>            // housekeeping leftover collateral for liquidated CDP</span>
 195 |     | <span class='unexecuted'>            if (_outputState.totalSurplusCollShares &gt; 0) {</span>
 196 |     | <span class='unexecuted'>                activePool.transferSystemCollShares(</span>
 197 |     | <span class='unexecuted'>                    address(collSurplusPool),</span>
 198 |     | <span class='unexecuted'>                    _outputState.totalSurplusCollShares</span>
 199 |     | <span class='neutral'>                );</span>
 200 |     | <span class='neutral'>            }</span>
 201 |     | <span class='neutral'></span>
 202 |     | <span class='unexecuted'>            return (</span>
 203 |     | <span class='unexecuted'>                _outputState.totalDebtToBurn,</span>
 204 |     | <span class='unexecuted'>                _outputState.totalCollSharesToSend,</span>
 205 |     | <span class='unexecuted'>                _outputState.totalDebtToRedistribute,</span>
 206 |     | <span class='unexecuted'>                _outputState.totalLiquidatorRewardCollShares,</span>
 207 |     | <span class='unexecuted'>                _outputState.totalSurplusCollShares</span>
 208 |     | <span class='neutral'>            );</span>
 209 |     | <span class='neutral'>        } else {</span>
 210 |     | <span class='unexecuted'>            LiquidationLocals memory _outputState = _liquidateIndividualCdpSetupCDPInNormalMode(</span>
 211 |     | <span class='unexecuted'>                _liqState</span>
 212 |     | <span class='neutral'>            );</span>
 213 |     | <span class='unexecuted'>            return (</span>
 214 |     | <span class='unexecuted'>                _outputState.totalDebtToBurn,</span>
 215 |     | <span class='unexecuted'>                _outputState.totalCollSharesToSend,</span>
 216 |     | <span class='unexecuted'>                _outputState.totalDebtToRedistribute,</span>
 217 |     | <span class='unexecuted'>                _outputState.totalLiquidatorRewardCollShares,</span>
 218 |     | <span class='unexecuted'>                _outputState.totalSurplusCollShares</span>
 219 |     | <span class='neutral'>            );</span>
 220 |     | <span class='neutral'>        }</span>
 221 |     | <span class='neutral'>    }</span>
 222 |     | <span class='neutral'></span>
 223 |     | <span class='unexecuted'>    function _liquidateIndividualCdpSetupCDPInNormalMode(</span>
 224 |     | <span class='neutral'>        LiquidationLocals memory _liqState</span>
 225 |     | <span class='unexecuted'>    ) private returns (LiquidationLocals memory) {</span>
 226 |     | <span class='neutral'>        // liquidate entire debt</span>
 227 |     | <span class='unexecuted'>        (</span>
 228 |     | <span class='unexecuted'>            uint256 _totalDebtToBurn,</span>
 229 |     | <span class='unexecuted'>            uint256 _totalColToSend,</span>
 230 |     | <span class='unexecuted'>            uint256 _liquidatorReward</span>
 231 |     | <span class='unexecuted'>        ) = _closeCdpByLiquidation(_liqState.cdpId);</span>
 232 |     | <span class='unexecuted'>        uint256 _cappedColPortion;</span>
 233 |     | <span class='unexecuted'>        uint256 _collSurplus;</span>
 234 |     | <span class='unexecuted'>        uint256 _debtToRedistribute;</span>
 235 |     | <span class='unexecuted'>        address _borrower = sortedCdps.getOwnerAddress(_liqState.cdpId);</span>
 236 |     | <span class='neutral'></span>
 237 |     | <span class='neutral'>        // I don&#39;t see an issue emitting the CdpUpdated() event up here and avoiding this extra cache, any objections?</span>
 238 |     | <span class='unexecuted'>        emit CdpUpdated(</span>
 239 |     | <span class='unexecuted'>            _liqState.cdpId,</span>
 240 |     | <span class='unexecuted'>            _borrower,</span>
 241 |     | <span class='unexecuted'>            msg.sender,</span>
 242 |     | <span class='unexecuted'>            _totalDebtToBurn,</span>
 243 |     | <span class='unexecuted'>            _totalColToSend,</span>
 244 |     | <span class='unexecuted'>            0,</span>
 245 |     | <span class='unexecuted'>            0,</span>
 246 |     | <span class='unexecuted'>            0,</span>
 247 |     | <span class='unexecuted'>            CdpOperation.liquidateInNormalMode</span>
 248 |     | <span class='neutral'>        );</span>
 249 |     | <span class='neutral'></span>
 250 |     | <span class='neutral'>        {</span>
 251 |     | <span class='unexecuted'>            (</span>
 252 |     | <span class='neutral'>                _cappedColPortion,</span>
 253 |     | <span class='neutral'>                _collSurplus,</span>
 254 |     | <span class='neutral'>                _debtToRedistribute</span>
 255 |     | <span class='unexecuted'>            ) = _calculateFullLiquidationSurplusAndCap(</span>
 256 |     | <span class='unexecuted'>                _liqState.ICR,</span>
 257 |     | <span class='unexecuted'>                _liqState.price,</span>
 258 |     | <span class='unexecuted'>                _totalDebtToBurn,</span>
 259 |     | <span class='unexecuted'>                _totalColToSend</span>
 260 |     | <span class='neutral'>            );</span>
 261 |     | <span class='unexecuted'>            if (_collSurplus &gt; 0) {</span>
 262 |     | <span class='neutral'>                // due to division precision loss, should be zero surplus in normal mode</span>
 263 |     | <span class='unexecuted'>                _cappedColPortion = _cappedColPortion + _collSurplus;</span>
 264 |     | <span class='unexecuted'>                _collSurplus = 0;</span>
 265 |     | <span class='neutral'>            }</span>
 266 |     | <span class='unexecuted'>            if (_debtToRedistribute &gt; 0) {</span>
 267 |     | <span class='unexecuted'>                _totalDebtToBurn = _totalDebtToBurn - _debtToRedistribute;</span>
 268 |     | <span class='neutral'>            }</span>
 269 |     | <span class='neutral'>        }</span>
 270 |     | <span class='unexecuted'>        _liqState.totalDebtToBurn = _liqState.totalDebtToBurn + _totalDebtToBurn;</span>
 271 |     | <span class='unexecuted'>        _liqState.totalCollSharesToSend = _liqState.totalCollSharesToSend + _cappedColPortion;</span>
 272 |     | <span class='unexecuted'>        _liqState.totalDebtToRedistribute = _liqState.totalDebtToRedistribute + _debtToRedistribute;</span>
 273 |     | <span class='unexecuted'>        _liqState.totalLiquidatorRewardCollShares =</span>
 274 |     | <span class='unexecuted'>            _liqState.totalLiquidatorRewardCollShares +</span>
 275 |     | <span class='unexecuted'>            _liquidatorReward;</span>
 276 |     | <span class='neutral'></span>
 277 |     | <span class='neutral'>        // Emit events</span>
 278 |     | <span class='unexecuted'>        uint _debtToColl = (_totalDebtToBurn * DECIMAL_PRECISION) / _liqState.price;</span>
 279 |     | <span class='unexecuted'>        uint _cappedColl = collateral.getPooledEthByShares(_cappedColPortion + _liquidatorReward);</span>
 280 |     | <span class='neutral'></span>
 281 |     | <span class='unexecuted'>        emit CdpLiquidated(</span>
 282 |     | <span class='unexecuted'>            _liqState.cdpId,</span>
 283 |     | <span class='neutral'>            _borrower,</span>
 284 |     | <span class='unexecuted'>            _totalDebtToBurn,</span>
 285 |     | <span class='neutral'>            // please note this is the collateral share of the liquidated CDP</span>
 286 |     | <span class='unexecuted'>            _cappedColPortion,</span>
 287 |     | <span class='unexecuted'>            CdpOperation.liquidateInNormalMode,</span>
 288 |     | <span class='unexecuted'>            msg.sender,</span>
 289 |     | <span class='unexecuted'>            _cappedColl &gt; _debtToColl ? (_cappedColl - _debtToColl) : 0</span>
 290 |     | <span class='neutral'>        );</span>
 291 |     | <span class='neutral'></span>
 292 |     | <span class='neutral'>        return _liqState;</span>
 293 |     | <span class='neutral'>    }</span>
 294 |     | <span class='neutral'></span>
 295 |     | <span class='unexecuted'>    function _liquidateIndividualCdpSetupCDPInRecoveryMode(</span>
 296 |     | <span class='neutral'>        LiquidationRecoveryModeLocals memory _recoveryState</span>
 297 |     | <span class='unexecuted'>    ) private returns (LiquidationRecoveryModeLocals memory) {</span>
 298 |     | <span class='neutral'>        // liquidate entire debt</span>
 299 |     | <span class='unexecuted'>        (</span>
 300 |     | <span class='unexecuted'>            uint256 _totalDebtToBurn,</span>
 301 |     | <span class='unexecuted'>            uint256 _totalColToSend,</span>
 302 |     | <span class='unexecuted'>            uint256 _liquidatorReward</span>
 303 |     | <span class='unexecuted'>        ) = _closeCdpByLiquidation(_recoveryState.cdpId);</span>
 304 |     | <span class='neutral'></span>
 305 |     | <span class='neutral'>        // cap the liquidated collateral if required</span>
 306 |     | <span class='unexecuted'>        uint256 _cappedColPortion;</span>
 307 |     | <span class='unexecuted'>        uint256 _collSurplus;</span>
 308 |     | <span class='unexecuted'>        uint256 _debtToRedistribute;</span>
 309 |     | <span class='unexecuted'>        address _borrower = sortedCdps.getOwnerAddress(_recoveryState.cdpId);</span>
 310 |     | <span class='neutral'></span>
 311 |     | <span class='neutral'>        // I don&#39;t see an issue emitting the CdpUpdated() event up here and avoiding an extra cache of the values, any objections?</span>
 312 |     | <span class='unexecuted'>        emit CdpUpdated(</span>
 313 |     | <span class='unexecuted'>            _recoveryState.cdpId,</span>
 314 |     | <span class='unexecuted'>            _borrower,</span>
 315 |     | <span class='unexecuted'>            msg.sender,</span>
 316 |     | <span class='unexecuted'>            _totalDebtToBurn,</span>
 317 |     | <span class='unexecuted'>            _totalColToSend,</span>
 318 |     | <span class='unexecuted'>            0,</span>
 319 |     | <span class='unexecuted'>            0,</span>
 320 |     | <span class='unexecuted'>            0,</span>
 321 |     | <span class='unexecuted'>            CdpOperation.liquidateInRecoveryMode</span>
 322 |     | <span class='neutral'>        );</span>
 323 |     | <span class='neutral'></span>
 324 |     | <span class='neutral'>        // avoid stack too deep</span>
 325 |     | <span class='neutral'>        {</span>
 326 |     | <span class='unexecuted'>            (</span>
 327 |     | <span class='neutral'>                _cappedColPortion,</span>
 328 |     | <span class='neutral'>                _collSurplus,</span>
 329 |     | <span class='neutral'>                _debtToRedistribute</span>
 330 |     | <span class='unexecuted'>            ) = _calculateFullLiquidationSurplusAndCap(</span>
 331 |     | <span class='unexecuted'>                _recoveryState.ICR,</span>
 332 |     | <span class='unexecuted'>                _recoveryState.price,</span>
 333 |     | <span class='unexecuted'>                _totalDebtToBurn,</span>
 334 |     | <span class='unexecuted'>                _totalColToSend</span>
 335 |     | <span class='neutral'>            );</span>
 336 |     | <span class='unexecuted'>            if (_collSurplus &gt; 0) {</span>
 337 |     | <span class='unexecuted'>                if (_checkICRAgainstMCR(_recoveryState.ICR)) {</span>
 338 |     | <span class='unexecuted'>                    _cappedColPortion = _collSurplus + _cappedColPortion;</span>
 339 |     | <span class='unexecuted'>                    _collSurplus = 0;</span>
 340 |     | <span class='neutral'>                } else {</span>
 341 |     | <span class='unexecuted'>                    collSurplusPool.increaseSurplusCollShares(</span>
 342 |     | <span class='unexecuted'>                        _recoveryState.cdpId,</span>
 343 |     | <span class='neutral'>                        _borrower,</span>
 344 |     | <span class='neutral'>                        _collSurplus,</span>
 345 |     | <span class='unexecuted'>                        0</span>
 346 |     | <span class='neutral'>                    );</span>
 347 |     | <span class='unexecuted'>                    _recoveryState.totalSurplusCollShares =</span>
 348 |     | <span class='unexecuted'>                        _recoveryState.totalSurplusCollShares +</span>
 349 |     | <span class='unexecuted'>                        _collSurplus;</span>
 350 |     | <span class='neutral'>                }</span>
 351 |     | <span class='neutral'>            }</span>
 352 |     | <span class='unexecuted'>            if (_debtToRedistribute &gt; 0) {</span>
 353 |     | <span class='unexecuted'>                _totalDebtToBurn = _totalDebtToBurn - _debtToRedistribute;</span>
 354 |     | <span class='neutral'>            }</span>
 355 |     | <span class='neutral'>        }</span>
 356 |     | <span class='unexecuted'>        _recoveryState.totalDebtToBurn = _recoveryState.totalDebtToBurn + _totalDebtToBurn;</span>
 357 |     | <span class='unexecuted'>        _recoveryState.totalCollSharesToSend =</span>
 358 |     | <span class='unexecuted'>            _recoveryState.totalCollSharesToSend +</span>
 359 |     | <span class='unexecuted'>            _cappedColPortion;</span>
 360 |     | <span class='unexecuted'>        _recoveryState.totalDebtToRedistribute =</span>
 361 |     | <span class='unexecuted'>            _recoveryState.totalDebtToRedistribute +</span>
 362 |     | <span class='unexecuted'>            _debtToRedistribute;</span>
 363 |     | <span class='unexecuted'>        _recoveryState.totalLiquidatorRewardCollShares =</span>
 364 |     | <span class='unexecuted'>            _recoveryState.totalLiquidatorRewardCollShares +</span>
 365 |     | <span class='unexecuted'>            _liquidatorReward;</span>
 366 |     | <span class='neutral'></span>
 367 |     | <span class='neutral'>        // check if system back to normal mode</span>
 368 |     | <span class='unexecuted'>        _recoveryState.entireSystemDebt = _recoveryState.entireSystemDebt &gt; _totalDebtToBurn</span>
 369 |     | <span class='unexecuted'>            ? _recoveryState.entireSystemDebt - _totalDebtToBurn</span>
 370 |     | <span class='unexecuted'>            : 0;</span>
 371 |     | <span class='unexecuted'>        _recoveryState.entireSystemColl = _recoveryState.entireSystemColl &gt; _totalColToSend</span>
 372 |     | <span class='unexecuted'>            ? _recoveryState.entireSystemColl - _totalColToSend</span>
 373 |     | <span class='unexecuted'>            : 0;</span>
 374 |     | <span class='neutral'></span>
 375 |     | <span class='unexecuted'>        uint _debtToColl = (_totalDebtToBurn * DECIMAL_PRECISION) / _recoveryState.price;</span>
 376 |     | <span class='unexecuted'>        uint _cappedColl = collateral.getPooledEthByShares(_cappedColPortion + _liquidatorReward);</span>
 377 |     | <span class='unexecuted'>        emit CdpLiquidated(</span>
 378 |     | <span class='unexecuted'>            _recoveryState.cdpId,</span>
 379 |     | <span class='unexecuted'>            _borrower,</span>
 380 |     | <span class='unexecuted'>            _totalDebtToBurn,</span>
 381 |     | <span class='neutral'>            // please note this is the collateral share of the liquidated CDP</span>
 382 |     | <span class='unexecuted'>            _cappedColPortion,</span>
 383 |     | <span class='unexecuted'>            CdpOperation.liquidateInRecoveryMode,</span>
 384 |     | <span class='unexecuted'>            msg.sender,</span>
 385 |     | <span class='unexecuted'>            _cappedColl &gt; _debtToColl ? (_cappedColl - _debtToColl) : 0</span>
 386 |     | <span class='neutral'>        );</span>
 387 |     | <span class='neutral'></span>
 388 |     | <span class='unexecuted'>        return _recoveryState;</span>
 389 |     | <span class='neutral'>    }</span>
 390 |     | <span class='neutral'></span>
 391 |     | <span class='neutral'>    // liquidate (and close) the CDP from an external liquidator</span>
 392 |     | <span class='neutral'>    // this function would return the liquidated debt and collateral of the given CDP</span>
 393 |     | <span class='neutral'>    // without emmiting events</span>
 394 |     | <span class='unexecuted'>    function _closeCdpByLiquidation(bytes32 _cdpId) private returns (uint256, uint256, uint256) {</span>
 395 |     | <span class='neutral'>        // calculate entire debt to repay</span>
 396 |     | <span class='unexecuted'>        (uint256 entireDebt, uint256 entireColl) = getSyncedDebtAndCollShares(_cdpId);</span>
 397 |     | <span class='neutral'></span>
 398 |     | <span class='neutral'>        // housekeeping after liquidation by closing the CDP</span>
 399 |     | <span class='unexecuted'>        uint256 _liquidatorReward = uint256(Cdps[_cdpId].liquidatorRewardShares);</span>
 400 |     | <span class='unexecuted'>        _closeCdp(_cdpId, Status.closedByLiquidation);</span>
 401 |     | <span class='neutral'></span>
 402 |     | <span class='unexecuted'>        return (entireDebt, entireColl, _liquidatorReward);</span>
 403 |     | <span class='neutral'>    }</span>
 404 |     | <span class='neutral'></span>
 405 |     | <span class='neutral'>    // Liquidate partially the CDP by an external liquidator</span>
 406 |     | <span class='neutral'>    // This function would return the liquidated debt and collateral of the given CDP</span>
 407 |     | <span class='unexecuted'>    function _liquidateCDPPartially(</span>
 408 |     | <span class='neutral'>        LiquidationLocals memory _partialState</span>
 409 |     | <span class='unexecuted'>    ) private returns (uint256, uint256) {</span>
 410 |     | <span class='unexecuted'>        bytes32 _cdpId = _partialState.cdpId;</span>
 411 |     | <span class='unexecuted'>        uint256 _partialDebt = _partialState.partialAmount;</span>
 412 |     | <span class='neutral'></span>
 413 |     | <span class='neutral'>        // calculate entire debt to repay</span>
 414 |     | <span class='unexecuted'>        CdpDebtAndCollShares memory _debtAndColl = _getSyncedDebtAndCollShares(_cdpId);</span>
 415 |     | <span class='unexecuted'>        _requirePartialLiqDebtSize(_partialDebt, _debtAndColl.debt, _partialState.price);</span>
 416 |     | <span class='unexecuted'>        uint256 newDebt = _debtAndColl.debt - _partialDebt;</span>
 417 |     | <span class='neutral'></span>
 418 |     | <span class='neutral'>        // credit to https://arxiv.org/pdf/2212.07306.pdf for details</span>
 419 |     | <span class='unexecuted'>        (uint256 _partialColl, uint256 newColl, ) = _calculatePartialLiquidationSurplusAndCap(</span>
 420 |     | <span class='unexecuted'>            _partialState.ICR,</span>
 421 |     | <span class='unexecuted'>            _partialState.price,</span>
 422 |     | <span class='unexecuted'>            _partialDebt,</span>
 423 |     | <span class='unexecuted'>            _debtAndColl.collShares</span>
 424 |     | <span class='neutral'>        );</span>
 425 |     | <span class='neutral'></span>
 426 |     | <span class='neutral'>        // early return: if new collateral is zero, we have a full liqudiation</span>
 427 |     | <span class='unexecuted'>        if (newColl == 0) {</span>
 428 |     | <span class='unexecuted'>            return (0, 0);</span>
 429 |     | <span class='neutral'>        }</span>
 430 |     | <span class='neutral'></span>
 431 |     | <span class='neutral'>        // If we have coll remaining, it must meet minimum CDP size requirements</span>
 432 |     | <span class='unexecuted'>        _requirePartialLiqCollSize(collateral.getPooledEthByShares(newColl));</span>
 433 |     | <span class='neutral'></span>
 434 |     | <span class='neutral'>        // updating the CDP accounting for partial liquidation</span>
 435 |     | <span class='unexecuted'>        _partiallyReduceCdpDebt(_cdpId, _partialDebt, _partialColl);</span>
 436 |     | <span class='neutral'></span>
 437 |     | <span class='neutral'>        // reInsert into sorted CDP list after partial liquidation</span>
 438 |     | <span class='neutral'>        {</span>
 439 |     | <span class='unexecuted'>            _reInsertPartialLiquidation(</span>
 440 |     | <span class='unexecuted'>                _partialState,</span>
 441 |     | <span class='unexecuted'>                EbtcMath._computeNominalCR(newColl, newDebt),</span>
 442 |     | <span class='unexecuted'>                _debtAndColl.debt,</span>
 443 |     | <span class='unexecuted'>                _debtAndColl.collShares</span>
 444 |     | <span class='neutral'>            );</span>
 445 |     | <span class='unexecuted'>            uint _debtToColl = (_partialDebt * DECIMAL_PRECISION) / _partialState.price;</span>
 446 |     | <span class='unexecuted'>            uint _cappedColl = collateral.getPooledEthByShares(_partialColl);</span>
 447 |     | <span class='unexecuted'>            emit CdpPartiallyLiquidated(</span>
 448 |     | <span class='unexecuted'>                _cdpId,</span>
 449 |     | <span class='unexecuted'>                sortedCdps.getOwnerAddress(_cdpId),</span>
 450 |     | <span class='unexecuted'>                _partialDebt,</span>
 451 |     | <span class='unexecuted'>                _partialColl,</span>
 452 |     | <span class='unexecuted'>                CdpOperation.partiallyLiquidate,</span>
 453 |     | <span class='unexecuted'>                msg.sender,</span>
 454 |     | <span class='unexecuted'>                _cappedColl &gt; _debtToColl ? (_cappedColl - _debtToColl) : 0</span>
 455 |     | <span class='neutral'>            );</span>
 456 |     | <span class='neutral'>        }</span>
 457 |     | <span class='unexecuted'>        return (_partialDebt, _partialColl);</span>
 458 |     | <span class='neutral'>    }</span>
 459 |     | <span class='neutral'></span>
 460 |     | <span class='unexecuted'>    function _partiallyReduceCdpDebt(</span>
 461 |     | <span class='neutral'>        bytes32 _cdpId,</span>
 462 |     | <span class='neutral'>        uint256 _partialDebt,</span>
 463 |     | <span class='neutral'>        uint256 _partialColl</span>
 464 |     | <span class='neutral'>    ) internal {</span>
 465 |     | <span class='unexecuted'>        Cdp storage _cdp = Cdps[_cdpId];</span>
 466 |     | <span class='neutral'></span>
 467 |     | <span class='unexecuted'>        uint256 _coll = _cdp.coll;</span>
 468 |     | <span class='unexecuted'>        uint256 _debt = _cdp.debt;</span>
 469 |     | <span class='neutral'></span>
 470 |     | <span class='unexecuted'>        uint256 newDebt = _debt - _partialDebt;</span>
 471 |     | <span class='neutral'></span>
 472 |     | <span class='unexecuted'>        _requireMinDebt(newDebt);</span>
 473 |     | <span class='neutral'></span>
 474 |     | <span class='unexecuted'>        _cdp.coll = _coll - _partialColl;</span>
 475 |     | <span class='unexecuted'>        _cdp.debt = newDebt;</span>
 476 |     | <span class='unexecuted'>        _updateStakeAndTotalStakes(_cdpId);</span>
 477 |     | <span class='neutral'>    }</span>
 478 |     | <span class='neutral'></span>
 479 |     | <span class='neutral'>    // Re-Insertion into SortedCdp list after partial liquidation</span>
 480 |     | <span class='unexecuted'>    function _reInsertPartialLiquidation(</span>
 481 |     | <span class='neutral'>        LiquidationLocals memory _partialState,</span>
 482 |     | <span class='neutral'>        uint256 _newNICR,</span>
 483 |     | <span class='neutral'>        uint256 _oldDebt,</span>
 484 |     | <span class='neutral'>        uint256 _oldColl</span>
 485 |     | <span class='unexecuted'>    ) internal {</span>
 486 |     | <span class='unexecuted'>        bytes32 _cdpId = _partialState.cdpId;</span>
 487 |     | <span class='neutral'></span>
 488 |     | <span class='neutral'>        // ensure new ICR does NOT decrease due to partial liquidation</span>
 489 |     | <span class='neutral'>        // if original ICR is above LICR</span>
 490 |     | <span class='unexecuted'>        if (_partialState.ICR &gt; LICR) {</span>
 491 |     | <span class='unexecuted'>            require(</span>
 492 |     | <span class='unexecuted'>                getCachedICR(_cdpId, _partialState.price) &gt;= _partialState.ICR,</span>
 493 |     | <span class='neutral'>                &quot;LiquidationLibrary: !_newICR&gt;=_ICR&quot;</span>
 494 |     | <span class='neutral'>            );</span>
 495 |     | <span class='neutral'>        }</span>
 496 |     | <span class='neutral'></span>
 497 |     | <span class='neutral'>        // reInsert into sorted CDP list</span>
 498 |     | <span class='unexecuted'>        sortedCdps.reInsert(</span>
 499 |     | <span class='neutral'>            _cdpId,</span>
 500 |     | <span class='neutral'>            _newNICR,</span>
 501 |     | <span class='unexecuted'>            _partialState.upperPartialHint,</span>
 502 |     | <span class='unexecuted'>            _partialState.lowerPartialHint</span>
 503 |     | <span class='neutral'>        );</span>
 504 |     | <span class='unexecuted'>        emit CdpUpdated(</span>
 505 |     | <span class='unexecuted'>            _cdpId,</span>
 506 |     | <span class='unexecuted'>            sortedCdps.getOwnerAddress(_cdpId),</span>
 507 |     | <span class='unexecuted'>            msg.sender,</span>
 508 |     | <span class='unexecuted'>            _oldDebt,</span>
 509 |     | <span class='unexecuted'>            _oldColl,</span>
 510 |     | <span class='unexecuted'>            Cdps[_cdpId].debt,</span>
 511 |     | <span class='unexecuted'>            Cdps[_cdpId].coll,</span>
 512 |     | <span class='unexecuted'>            Cdps[_cdpId].stake,</span>
 513 |     | <span class='unexecuted'>            CdpOperation.partiallyLiquidate</span>
 514 |     | <span class='neutral'>        );</span>
 515 |     | <span class='neutral'>    }</span>
 516 |     | <span class='neutral'></span>
 517 |     | <span class='unexecuted'>    function _finalizeLiquidation(</span>
 518 |     | <span class='neutral'>        uint256 totalDebtToBurn,</span>
 519 |     | <span class='neutral'>        uint256 totalCollSharesToSend,</span>
 520 |     | <span class='neutral'>        uint256 totalDebtToRedistribute,</span>
 521 |     | <span class='neutral'>        uint256 totalLiquidatorRewardCollShares,</span>
 522 |     | <span class='neutral'>        uint256 totalSurplusCollShares,</span>
 523 |     | <span class='neutral'>        uint256 systemInitialCollShares,</span>
 524 |     | <span class='neutral'>        uint256 systemInitialDebt,</span>
 525 |     | <span class='neutral'>        uint256 price</span>
 526 |     | <span class='neutral'>    ) internal {</span>
 527 |     | <span class='neutral'>        // update the staking and collateral snapshots</span>
 528 |     | <span class='unexecuted'>        _updateSystemSnapshotsExcludeCollRemainder(totalCollSharesToSend);</span>
 529 |     | <span class='neutral'></span>
 530 |     | <span class='unexecuted'>        emit Liquidation(totalDebtToBurn, totalCollSharesToSend, totalLiquidatorRewardCollShares);</span>
 531 |     | <span class='neutral'></span>
 532 |     | <span class='unexecuted'>        _syncGracePeriodForGivenValues(</span>
 533 |     | <span class='unexecuted'>            systemInitialCollShares - totalCollSharesToSend - totalSurplusCollShares,</span>
 534 |     | <span class='unexecuted'>            systemInitialDebt - totalDebtToBurn,</span>
 535 |     | <span class='unexecuted'>            price</span>
 536 |     | <span class='neutral'>        );</span>
 537 |     | <span class='neutral'></span>
 538 |     | <span class='neutral'>        // redistribute debt if any</span>
 539 |     | <span class='unexecuted'>        if (totalDebtToRedistribute &gt; 0) {</span>
 540 |     | <span class='unexecuted'>            _redistributeDebt(totalDebtToRedistribute);</span>
 541 |     | <span class='neutral'>        }</span>
 542 |     | <span class='neutral'></span>
 543 |     | <span class='neutral'>        // burn the debt from liquidator</span>
 544 |     | <span class='unexecuted'>        ebtcToken.burn(msg.sender, totalDebtToBurn);</span>
 545 |     | <span class='neutral'></span>
 546 |     | <span class='neutral'>        // offset debt from Active Pool</span>
 547 |     | <span class='unexecuted'>        activePool.decreaseSystemDebt(totalDebtToBurn);</span>
 548 |     | <span class='neutral'></span>
 549 |     | <span class='neutral'>        // CEI: ensure sending back collateral to liquidator is last thing to do</span>
 550 |     | <span class='unexecuted'>        activePool.transferSystemCollSharesAndLiquidatorReward(</span>
 551 |     | <span class='unexecuted'>            msg.sender,</span>
 552 |     | <span class='neutral'>            totalCollSharesToSend,</span>
 553 |     | <span class='neutral'>            totalLiquidatorRewardCollShares</span>
 554 |     | <span class='neutral'>        );</span>
 555 |     | <span class='neutral'>    }</span>
 556 |     | <span class='neutral'></span>
 557 |     | <span class='neutral'>    // Partial Liquidation Cap Logic</span>
 558 |     | <span class='unexecuted'>    function _calculatePartialLiquidationSurplusAndCap(</span>
 559 |     | <span class='neutral'>        uint256 _ICR,</span>
 560 |     | <span class='neutral'>        uint256 _price,</span>
 561 |     | <span class='neutral'>        uint256 _totalDebtToBurn,</span>
 562 |     | <span class='neutral'>        uint256 _totalColToSend</span>
 563 |     | <span class='unexecuted'>    ) private view returns (uint256 toLiquidator, uint256 collSurplus, uint256 debtToRedistribute) {</span>
 564 |     | <span class='unexecuted'>        uint256 _incentiveColl;</span>
 565 |     | <span class='neutral'></span>
 566 |     | <span class='neutral'>        // CLAMP</span>
 567 |     | <span class='unexecuted'>        if (_ICR &gt; LICR) {</span>
 568 |     | <span class='neutral'>            // Cap at 10%</span>
 569 |     | <span class='unexecuted'>            _incentiveColl = (_totalDebtToBurn * (_ICR &gt; MCR ? MCR : _ICR)) / _price;</span>
 570 |     | <span class='neutral'>        } else {</span>
 571 |     | <span class='neutral'>            // Min 103%</span>
 572 |     | <span class='unexecuted'>            _incentiveColl = (_totalDebtToBurn * LICR) / _price;</span>
 573 |     | <span class='neutral'>        }</span>
 574 |     | <span class='neutral'></span>
 575 |     | <span class='unexecuted'>        toLiquidator = collateral.getSharesByPooledEth(_incentiveColl);</span>
 576 |     | <span class='neutral'></span>
 577 |     | <span class='neutral'>        /// @audit MUST be like so, else we have debt redistribution, which we assume cannot happen in partial</span>
 578 |     | <span class='unexecuted'>        assert(toLiquidator &lt; _totalColToSend); // Assert is correct here for Echidna</span>
 579 |     | <span class='neutral'></span>
 580 |     | <span class='neutral'>        /// Because of above we can subtract</span>
 581 |     | <span class='unexecuted'>        collSurplus = _totalColToSend - toLiquidator; // Can use unchecked but w/e</span>
 582 |     | <span class='neutral'>    }</span>
 583 |     | <span class='neutral'></span>
 584 |     | <span class='unexecuted'>    function _calculateFullLiquidationSurplusAndCap(</span>
 585 |     | <span class='neutral'>        uint256 _ICR,</span>
 586 |     | <span class='neutral'>        uint256 _price,</span>
 587 |     | <span class='neutral'>        uint256 _totalDebtToBurn,</span>
 588 |     | <span class='neutral'>        uint256 _totalColToSend</span>
 589 |     | <span class='unexecuted'>    ) private view returns (uint256 toLiquidator, uint256 collSurplus, uint256 debtToRedistribute) {</span>
 590 |     | <span class='unexecuted'>        uint256 _incentiveColl;</span>
 591 |     | <span class='neutral'></span>
 592 |     | <span class='unexecuted'>        if (_ICR &gt; LICR) {</span>
 593 |     | <span class='unexecuted'>            _incentiveColl = (_totalDebtToBurn * (_ICR &gt; MCR ? MCR : _ICR)) / _price;</span>
 594 |     | <span class='neutral'></span>
 595 |     | <span class='neutral'>            // Convert back to shares</span>
 596 |     | <span class='unexecuted'>            toLiquidator = collateral.getSharesByPooledEth(_incentiveColl);</span>
 597 |     | <span class='unexecuted'>        } else {</span>
 598 |     | <span class='neutral'>            // for full liquidation, there would be some bad debt to redistribute</span>
 599 |     | <span class='unexecuted'>            _incentiveColl = collateral.getPooledEthByShares(_totalColToSend);</span>
 600 |     | <span class='neutral'></span>
 601 |     | <span class='neutral'>            // Since it&#39;s full and there&#39;s bad debt we use spot conversion to</span>
 602 |     | <span class='neutral'>            // Determine the amount of debt that willl be repaid after adding the LICR discount</span>
 603 |     | <span class='neutral'>            // Basically this is buying underwater Coll</span>
 604 |     | <span class='neutral'>            // By repaying debt at 3% discount</span>
 605 |     | <span class='neutral'>            // Can there be a rounding error where the _debtToRepay &gt; debtToBurn?</span>
 606 |     | <span class='unexecuted'>            uint256 _debtToRepay = (_incentiveColl * _price) / LICR;</span>
 607 |     | <span class='neutral'></span>
 608 |     | <span class='unexecuted'>            debtToRedistribute = _debtToRepay &lt; _totalDebtToBurn</span>
 609 |     | <span class='unexecuted'>                ? _totalDebtToBurn - _debtToRepay //  Bad Debt (to be redistributed) is (CdpDebt - Repaid)</span>
 610 |     | <span class='unexecuted'>                : 0; // Else 0 (note we may underpay per the comment above, althought that may be imaginary)</span>
 611 |     | <span class='neutral'></span>
 612 |     | <span class='neutral'>            // now CDP owner should have zero surplus to claim</span>
 613 |     | <span class='unexecuted'>            toLiquidator = _totalColToSend;</span>
 614 |     | <span class='neutral'>        }</span>
 615 |     | <span class='neutral'></span>
 616 |     | <span class='unexecuted'>        toLiquidator = toLiquidator &lt; _totalColToSend ? toLiquidator : _totalColToSend;</span>
 617 |     | <span class='unexecuted'>        collSurplus = (toLiquidator == _totalColToSend) ? 0 : _totalColToSend - toLiquidator;</span>
 618 |     | <span class='neutral'>    }</span>
 619 |     | <span class='neutral'></span>
 620 |     | <span class='neutral'>    // --- Batch liquidation functions ---</span>
 621 |     | <span class='neutral'></span>
 622 |     | <span class='unexecuted'>    function _getLiquidationValuesNormalMode(</span>
 623 |     | <span class='neutral'>        uint256 _price,</span>
 624 |     | <span class='neutral'>        uint256 _TCR,</span>
 625 |     | <span class='neutral'>        LocalVariables_LiquidationSequence memory vars,</span>
 626 |     | <span class='neutral'>        LiquidationValues memory singleLiquidation</span>
 627 |     | <span class='neutral'>    ) internal {</span>
 628 |     | <span class='unexecuted'>        LiquidationLocals memory _liqState = LiquidationLocals(</span>
 629 |     | <span class='unexecuted'>            vars.cdpId,</span>
 630 |     | <span class='unexecuted'>            0,</span>
 631 |     | <span class='unexecuted'>            _price,</span>
 632 |     | <span class='unexecuted'>            vars.ICR,</span>
 633 |     | <span class='unexecuted'>            vars.cdpId,</span>
 634 |     | <span class='unexecuted'>            vars.cdpId,</span>
 635 |     | <span class='unexecuted'>            (false),</span>
 636 |     | <span class='unexecuted'>            _TCR,</span>
 637 |     | <span class='unexecuted'>            0,</span>
 638 |     | <span class='unexecuted'>            0,</span>
 639 |     | <span class='unexecuted'>            0,</span>
 640 |     | <span class='unexecuted'>            0,</span>
 641 |     | <span class='unexecuted'>            0</span>
 642 |     | <span class='neutral'>        );</span>
 643 |     | <span class='neutral'></span>
 644 |     | <span class='unexecuted'>        LiquidationLocals memory _outputState = _liquidateIndividualCdpSetupCDPInNormalMode(</span>
 645 |     | <span class='unexecuted'>            _liqState</span>
 646 |     | <span class='neutral'>        );</span>
 647 |     | <span class='neutral'></span>
 648 |     | <span class='unexecuted'>        singleLiquidation.entireCdpDebt = _outputState.totalDebtToBurn;</span>
 649 |     | <span class='unexecuted'>        singleLiquidation.debtToBurn = _outputState.totalDebtToBurn;</span>
 650 |     | <span class='unexecuted'>        singleLiquidation.totalCollToSendToLiquidator = _outputState.totalCollSharesToSend;</span>
 651 |     | <span class='unexecuted'>        singleLiquidation.collSurplus = _outputState.totalSurplusCollShares;</span>
 652 |     | <span class='unexecuted'>        singleLiquidation.debtToRedistribute = _outputState.totalDebtToRedistribute;</span>
 653 |     | <span class='unexecuted'>        singleLiquidation.liquidatorCollSharesReward = _outputState.totalLiquidatorRewardCollShares;</span>
 654 |     | <span class='neutral'>    }</span>
 655 |     | <span class='neutral'></span>
 656 |     | <span class='unexecuted'>    function _getLiquidationValuesRecoveryMode(</span>
 657 |     | <span class='neutral'>        uint256 _price,</span>
 658 |     | <span class='neutral'>        uint256 _systemDebt,</span>
 659 |     | <span class='neutral'>        uint256 _systemCollShares,</span>
 660 |     | <span class='neutral'>        LocalVariables_LiquidationSequence memory vars,</span>
 661 |     | <span class='neutral'>        LiquidationValues memory singleLiquidation</span>
 662 |     | <span class='neutral'>    ) internal {</span>
 663 |     | <span class='unexecuted'>        LiquidationRecoveryModeLocals memory _recState = LiquidationRecoveryModeLocals(</span>
 664 |     | <span class='unexecuted'>            _systemDebt,</span>
 665 |     | <span class='unexecuted'>            _systemCollShares,</span>
 666 |     | <span class='unexecuted'>            0,</span>
 667 |     | <span class='unexecuted'>            0,</span>
 668 |     | <span class='unexecuted'>            0,</span>
 669 |     | <span class='unexecuted'>            vars.cdpId,</span>
 670 |     | <span class='unexecuted'>            _price,</span>
 671 |     | <span class='unexecuted'>            vars.ICR,</span>
 672 |     | <span class='unexecuted'>            0,</span>
 673 |     | <span class='unexecuted'>            0</span>
 674 |     | <span class='neutral'>        );</span>
 675 |     | <span class='neutral'></span>
 676 |     | <span class='unexecuted'>        LiquidationRecoveryModeLocals</span>
 677 |     | <span class='unexecuted'>            memory _outputState = _liquidateIndividualCdpSetupCDPInRecoveryMode(_recState);</span>
 678 |     | <span class='neutral'></span>
 679 |     | <span class='unexecuted'>        singleLiquidation.entireCdpDebt = _outputState.totalDebtToBurn;</span>
 680 |     | <span class='unexecuted'>        singleLiquidation.debtToBurn = _outputState.totalDebtToBurn;</span>
 681 |     | <span class='unexecuted'>        singleLiquidation.totalCollToSendToLiquidator = _outputState.totalCollSharesToSend;</span>
 682 |     | <span class='unexecuted'>        singleLiquidation.collSurplus = _outputState.totalSurplusCollShares;</span>
 683 |     | <span class='unexecuted'>        singleLiquidation.debtToRedistribute = _outputState.totalDebtToRedistribute;</span>
 684 |     | <span class='unexecuted'>        singleLiquidation.liquidatorCollSharesReward = _outputState.totalLiquidatorRewardCollShares;</span>
 685 |     | <span class='neutral'>    }</span>
 686 |     | <span class='neutral'></span>
 687 |     | <span class='neutral'>    /// @notice Attempt to liquidate a custom list of Cdps provided by the caller</span>
 688 |     | <span class='neutral'>    /// @notice Callable by anyone, accepts a custom list of Cdps addresses as an argument.</span>
 689 |     | <span class='neutral'>    /// @notice Steps through the provided list and attempts to liquidate every Cdp, until it reaches the end or it runs out of gas.</span>
 690 |     | <span class='neutral'>    /// @notice A Cdp is liquidated only if it meets the conditions for liquidation.</span>
 691 |     | <span class='neutral'>    /// @dev forwards msg.data directly to the liquidation library using OZ proxy core delegation function</span>
 692 |     | <span class='neutral'>    /// @param _cdpArray Array of Cdps to liquidate.</span>
 693 |     | <span class='unexecuted'>    function batchLiquidateCdps(bytes32[] memory _cdpArray) external nonReentrantSelfAndBOps {</span>
 694 |     | <span class='unexecuted'>        require(</span>
 695 |     | <span class='unexecuted'>            _cdpArray.length != 0,</span>
 696 |     | <span class='neutral'>            &quot;LiquidationLibrary: Calldata address array must not be empty&quot;</span>
 697 |     | <span class='neutral'>        );</span>
 698 |     | <span class='neutral'></span>
 699 |     | <span class='unexecuted'>        LocalVariables_OuterLiquidationFunction memory vars;</span>
 700 |     | <span class='unexecuted'>        LiquidationTotals memory totals;</span>
 701 |     | <span class='neutral'></span>
 702 |     | <span class='neutral'>        // taking fee to avoid accounted for the calculation of the TCR</span>
 703 |     | <span class='unexecuted'>        _syncGlobalAccounting();</span>
 704 |     | <span class='neutral'></span>
 705 |     | <span class='unexecuted'>        vars.price = priceFeed.fetchPrice();</span>
 706 |     | <span class='unexecuted'>        (uint256 _TCR, uint256 systemColl, uint256 systemDebt) = _getTCRWithSystemDebtAndCollShares(</span>
 707 |     | <span class='neutral'>            vars.price</span>
 708 |     | <span class='neutral'>        );</span>
 709 |     | <span class='unexecuted'>        vars.recoveryModeAtStart = _TCR &lt; CCR ? true : false;</span>
 710 |     | <span class='neutral'></span>
 711 |     | <span class='neutral'>        // Perform the appropriate batch liquidation - tally values and obtain their totals.</span>
 712 |     | <span class='unexecuted'>        if (vars.recoveryModeAtStart) {</span>
 713 |     | <span class='unexecuted'>            totals = _getTotalFromBatchLiquidate_RecoveryMode(</span>
 714 |     | <span class='unexecuted'>                vars.price,</span>
 715 |     | <span class='unexecuted'>                systemColl,</span>
 716 |     | <span class='unexecuted'>                systemDebt,</span>
 717 |     | <span class='unexecuted'>                _cdpArray</span>
 718 |     | <span class='neutral'>            );</span>
 719 |     | <span class='neutral'>        } else {</span>
 720 |     | <span class='neutral'>            //  if !vars.recoveryModeAtStart</span>
 721 |     | <span class='unexecuted'>            totals = _getTotalsFromBatchLiquidate_NormalMode(vars.price, _TCR, _cdpArray);</span>
 722 |     | <span class='neutral'>        }</span>
 723 |     | <span class='neutral'></span>
 724 |     | <span class='unexecuted'>        require(totals.totalDebtInSequence &gt; 0, &quot;LiquidationLibrary: nothing to liquidate&quot;);</span>
 725 |     | <span class='neutral'></span>
 726 |     | <span class='neutral'>        // housekeeping leftover collateral for liquidated CDPs</span>
 727 |     | <span class='unexecuted'>        if (totals.totalCollSurplus &gt; 0) {</span>
 728 |     | <span class='unexecuted'>            activePool.transferSystemCollShares(address(collSurplusPool), totals.totalCollSurplus);</span>
 729 |     | <span class='neutral'>        }</span>
 730 |     | <span class='neutral'></span>
 731 |     | <span class='unexecuted'>        _finalizeLiquidation(</span>
 732 |     | <span class='unexecuted'>            totals.totalDebtToBurn,</span>
 733 |     | <span class='unexecuted'>            totals.totalCollToSendToLiquidator,</span>
 734 |     | <span class='unexecuted'>            totals.totalDebtToRedistribute,</span>
 735 |     | <span class='unexecuted'>            totals.totalCollReward,</span>
 736 |     | <span class='unexecuted'>            totals.totalCollSurplus,</span>
 737 |     | <span class='unexecuted'>            systemColl,</span>
 738 |     | <span class='unexecuted'>            systemDebt,</span>
 739 |     | <span class='unexecuted'>            vars.price</span>
 740 |     | <span class='neutral'>        );</span>
 741 |     | <span class='neutral'>    }</span>
 742 |     | <span class='neutral'></span>
 743 |     | <span class='neutral'>    /*</span>
 744 |     | <span class='neutral'>     * This function is used when the batch liquidation starts during Recovery Mode. However, it</span>
 745 |     | <span class='neutral'>     * handle the case where the system *leaves* Recovery Mode, part way through the liquidation processing</span>
 746 |     | <span class='neutral'>     */</span>
 747 |     | <span class='unexecuted'>    function _getTotalFromBatchLiquidate_RecoveryMode(</span>
 748 |     | <span class='neutral'>        uint256 _price,</span>
 749 |     | <span class='neutral'>        uint256 _systemCollShares,</span>
 750 |     | <span class='neutral'>        uint256 _systemDebt,</span>
 751 |     | <span class='neutral'>        bytes32[] memory _cdpArray</span>
 752 |     | <span class='unexecuted'>    ) internal returns (LiquidationTotals memory totals) {</span>
 753 |     | <span class='unexecuted'>        LocalVariables_LiquidationSequence memory vars;</span>
 754 |     | <span class='unexecuted'>        LiquidationValues memory singleLiquidation;</span>
 755 |     | <span class='neutral'></span>
 756 |     | <span class='unexecuted'>        vars.backToNormalMode = false;</span>
 757 |     | <span class='unexecuted'>        vars.entireSystemDebt = _systemDebt;</span>
 758 |     | <span class='unexecuted'>        vars.entireSystemColl = _systemCollShares;</span>
 759 |     | <span class='unexecuted'>        uint256 _TCR = _computeTCRWithGivenSystemValues(</span>
 760 |     | <span class='neutral'>            vars.entireSystemColl,</span>
 761 |     | <span class='neutral'>            vars.entireSystemDebt,</span>
 762 |     | <span class='unexecuted'>            _price</span>
 763 |     | <span class='neutral'>        );</span>
 764 |     | <span class='unexecuted'>        uint256 _cnt = _cdpArray.length;</span>
 765 |     | <span class='unexecuted'>        bool[] memory _liqFlags = new bool[](_cnt);</span>
 766 |     | <span class='unexecuted'>        uint256 _start;</span>
 767 |     | <span class='unexecuted'>        for (vars.i = _start; ; ) {</span>
 768 |     | <span class='unexecuted'>            vars.cdpId = _cdpArray[vars.i];</span>
 769 |     | <span class='neutral'>            // only for active cdps</span>
 770 |     | <span class='unexecuted'>            if (vars.cdpId != bytes32(0) &amp;&amp; Cdps[vars.cdpId].status == Status.active) {</span>
 771 |     | <span class='unexecuted'>                vars.ICR = getSyncedICR(vars.cdpId, _price);</span>
 772 |     | <span class='neutral'></span>
 773 |     | <span class='unexecuted'>                if (</span>
 774 |     | <span class='unexecuted'>                    !vars.backToNormalMode &amp;&amp;</span>
 775 |     | <span class='unexecuted'>                    (_checkICRAgainstMCR(vars.ICR) || canLiquidateRecoveryMode(vars.ICR, _TCR))</span>
 776 |     | <span class='neutral'>                ) {</span>
 777 |     | <span class='unexecuted'>                    vars.price = _price;</span>
 778 |     | <span class='unexecuted'>                    _syncAccounting(vars.cdpId);</span>
 779 |     | <span class='unexecuted'>                    _getLiquidationValuesRecoveryMode(</span>
 780 |     | <span class='unexecuted'>                        _price,</span>
 781 |     | <span class='unexecuted'>                        vars.entireSystemDebt,</span>
 782 |     | <span class='unexecuted'>                        vars.entireSystemColl,</span>
 783 |     | <span class='unexecuted'>                        vars,</span>
 784 |     | <span class='unexecuted'>                        singleLiquidation</span>
 785 |     | <span class='neutral'>                    );</span>
 786 |     | <span class='neutral'></span>
 787 |     | <span class='neutral'>                    // Update aggregate trackers</span>
 788 |     | <span class='unexecuted'>                    vars.entireSystemDebt = vars.entireSystemDebt - singleLiquidation.debtToBurn;</span>
 789 |     | <span class='unexecuted'>                    vars.entireSystemColl =</span>
 790 |     | <span class='unexecuted'>                        vars.entireSystemColl -</span>
 791 |     | <span class='unexecuted'>                        singleLiquidation.totalCollToSendToLiquidator -</span>
 792 |     | <span class='unexecuted'>                        singleLiquidation.collSurplus;</span>
 793 |     | <span class='neutral'></span>
 794 |     | <span class='neutral'>                    // Add liquidation values to their respective running totals</span>
 795 |     | <span class='unexecuted'>                    totals = _addLiquidationValuesToTotals(totals, singleLiquidation);</span>
 796 |     | <span class='neutral'></span>
 797 |     | <span class='unexecuted'>                    _TCR = _computeTCRWithGivenSystemValues(</span>
 798 |     | <span class='unexecuted'>                        vars.entireSystemColl,</span>
 799 |     | <span class='unexecuted'>                        vars.entireSystemDebt,</span>
 800 |     | <span class='unexecuted'>                        _price</span>
 801 |     | <span class='neutral'>                    );</span>
 802 |     | <span class='unexecuted'>                    vars.backToNormalMode = _TCR &lt; CCR ? false : true;</span>
 803 |     | <span class='unexecuted'>                    _liqFlags[vars.i] = true;</span>
 804 |     | <span class='unexecuted'>                } else if (vars.backToNormalMode &amp;&amp; _checkICRAgainstMCR(vars.ICR)) {</span>
 805 |     | <span class='unexecuted'>                    _syncAccounting(vars.cdpId);</span>
 806 |     | <span class='unexecuted'>                    _getLiquidationValuesNormalMode(_price, _TCR, vars, singleLiquidation);</span>
 807 |     | <span class='neutral'></span>
 808 |     | <span class='neutral'>                    // Add liquidation values to their respective running totals</span>
 809 |     | <span class='unexecuted'>                    totals = _addLiquidationValuesToTotals(totals, singleLiquidation);</span>
 810 |     | <span class='unexecuted'>                    _liqFlags[vars.i] = true;</span>
 811 |     | <span class='neutral'>                }</span>
 812 |     | <span class='neutral'>                // In Normal Mode skip cdps with ICR &gt;= MCR</span>
 813 |     | <span class='neutral'>            }</span>
 814 |     | <span class='unexecuted'>            ++vars.i;</span>
 815 |     | <span class='unexecuted'>            if (vars.i == _cnt) {</span>
 816 |     | <span class='neutral'>                break;</span>
 817 |     | <span class='neutral'>            }</span>
 818 |     | <span class='neutral'>        }</span>
 819 |     | <span class='neutral'>    }</span>
 820 |     | <span class='neutral'></span>
 821 |     | <span class='unexecuted'>    function _getTotalsFromBatchLiquidate_NormalMode(</span>
 822 |     | <span class='neutral'>        uint256 _price,</span>
 823 |     | <span class='neutral'>        uint256 _TCR,</span>
 824 |     | <span class='neutral'>        bytes32[] memory _cdpArray</span>
 825 |     | <span class='unexecuted'>    ) internal returns (LiquidationTotals memory totals) {</span>
 826 |     | <span class='unexecuted'>        LocalVariables_LiquidationSequence memory vars;</span>
 827 |     | <span class='unexecuted'>        LiquidationValues memory singleLiquidation;</span>
 828 |     | <span class='unexecuted'>        uint256 _cnt = _cdpArray.length;</span>
 829 |     | <span class='neutral'>        uint256 _start;</span>
 830 |     | <span class='unexecuted'>        for (vars.i = _start; ; ) {</span>
 831 |     | <span class='unexecuted'>            vars.cdpId = _cdpArray[vars.i];</span>
 832 |     | <span class='neutral'>            // only for active cdps</span>
 833 |     | <span class='unexecuted'>            if (vars.cdpId != bytes32(0) &amp;&amp; Cdps[vars.cdpId].status == Status.active) {</span>
 834 |     | <span class='unexecuted'>                vars.ICR = getSyncedICR(vars.cdpId, _price);</span>
 835 |     | <span class='neutral'></span>
 836 |     | <span class='unexecuted'>                if (_checkICRAgainstMCR(vars.ICR)) {</span>
 837 |     | <span class='unexecuted'>                    _syncAccounting(vars.cdpId);</span>
 838 |     | <span class='unexecuted'>                    _getLiquidationValuesNormalMode(_price, _TCR, vars, singleLiquidation);</span>
 839 |     | <span class='neutral'></span>
 840 |     | <span class='neutral'>                    // Add liquidation values to their respective running totals</span>
 841 |     | <span class='unexecuted'>                    totals = _addLiquidationValuesToTotals(totals, singleLiquidation);</span>
 842 |     | <span class='neutral'>                }</span>
 843 |     | <span class='neutral'>            }</span>
 844 |     | <span class='unexecuted'>            ++vars.i;</span>
 845 |     | <span class='unexecuted'>            if (vars.i == _cnt) {</span>
 846 |     | <span class='neutral'>                break;</span>
 847 |     | <span class='neutral'>            }</span>
 848 |     | <span class='neutral'>        }</span>
 849 |     | <span class='neutral'>    }</span>
 850 |     | <span class='neutral'></span>
 851 |     | <span class='neutral'>    // --- Liquidation helper functions ---</span>
 852 |     | <span class='neutral'></span>
 853 |     | <span class='unexecuted'>    function _addLiquidationValuesToTotals(</span>
 854 |     | <span class='neutral'>        LiquidationTotals memory oldTotals,</span>
 855 |     | <span class='neutral'>        LiquidationValues memory singleLiquidation</span>
 856 |     | <span class='unexecuted'>    ) internal pure returns (LiquidationTotals memory newTotals) {</span>
 857 |     | <span class='neutral'>        // Tally all the values with their respective running totals</span>
 858 |     | <span class='unexecuted'>        newTotals.totalDebtInSequence =</span>
 859 |     | <span class='unexecuted'>            oldTotals.totalDebtInSequence +</span>
 860 |     | <span class='unexecuted'>            singleLiquidation.entireCdpDebt;</span>
 861 |     | <span class='unexecuted'>        newTotals.totalDebtToBurn = oldTotals.totalDebtToBurn + singleLiquidation.debtToBurn;</span>
 862 |     | <span class='unexecuted'>        newTotals.totalCollToSendToLiquidator =</span>
 863 |     | <span class='unexecuted'>            oldTotals.totalCollToSendToLiquidator +</span>
 864 |     | <span class='unexecuted'>            singleLiquidation.totalCollToSendToLiquidator;</span>
 865 |     | <span class='unexecuted'>        newTotals.totalDebtToRedistribute =</span>
 866 |     | <span class='unexecuted'>            oldTotals.totalDebtToRedistribute +</span>
 867 |     | <span class='unexecuted'>            singleLiquidation.debtToRedistribute;</span>
 868 |     | <span class='unexecuted'>        newTotals.totalCollSurplus = oldTotals.totalCollSurplus + singleLiquidation.collSurplus;</span>
 869 |     | <span class='unexecuted'>        newTotals.totalCollReward =</span>
 870 |     | <span class='unexecuted'>            oldTotals.totalCollReward +</span>
 871 |     | <span class='unexecuted'>            singleLiquidation.liquidatorCollSharesReward;</span>
 872 |     | <span class='neutral'></span>
 873 |     | <span class='neutral'>        return newTotals;</span>
 874 |     | <span class='neutral'>    }</span>
 875 |     | <span class='neutral'></span>
 876 |     | <span class='unexecuted'>    function _redistributeDebt(uint256 _debt) internal {</span>
 877 |     | <span class='unexecuted'>        if (_debt == 0) {</span>
 878 |     | <span class='neutral'>            return;</span>
 879 |     | <span class='neutral'>        }</span>
 880 |     | <span class='neutral'></span>
 881 |     | <span class='neutral'>        /*</span>
 882 |     | <span class='neutral'>         * Add distributed debt rewards-per-unit-staked to the running totals. Division uses a &quot;feedback&quot;</span>
 883 |     | <span class='neutral'>         * error correction, to keep the cumulative error low in the running totals systemDebtRedistributionIndex:</span>
 884 |     | <span class='neutral'>         *</span>
 885 |     | <span class='neutral'>         * 1) Form numerators which compensate for the floor division errors that occurred the last time this</span>
 886 |     | <span class='neutral'>         * function was called.</span>
 887 |     | <span class='neutral'>         * 2) Calculate &quot;per-unit-staked&quot; ratios.</span>
 888 |     | <span class='neutral'>         * 3) Multiply each ratio back by its denominator, to reveal the current floor division error.</span>
 889 |     | <span class='neutral'>         * 4) Store these errors for use in the next correction when this function is called.</span>
 890 |     | <span class='neutral'>         * 5) Note: static analysis tools complain about this &quot;division before multiplication&quot;, however, it is intended.</span>
 891 |     | <span class='neutral'>         */</span>
 892 |     | <span class='unexecuted'>        uint256 EBTCDebtNumerator = (_debt * DECIMAL_PRECISION) + lastEBTCDebtErrorRedistribution;</span>
 893 |     | <span class='neutral'></span>
 894 |     | <span class='neutral'>        // Get the per-unit-staked terms</span>
 895 |     | <span class='unexecuted'>        uint256 _totalStakes = totalStakes;</span>
 896 |     | <span class='unexecuted'>        uint256 EBTCDebtRewardPerUnitStaked = EBTCDebtNumerator / _totalStakes;</span>
 897 |     | <span class='neutral'></span>
 898 |     | <span class='unexecuted'>        lastEBTCDebtErrorRedistribution =</span>
 899 |     | <span class='unexecuted'>            EBTCDebtNumerator -</span>
 900 |     | <span class='unexecuted'>            (EBTCDebtRewardPerUnitStaked * _totalStakes);</span>
 901 |     | <span class='neutral'></span>
 902 |     | <span class='neutral'>        // Add per-unit-staked terms to the running totals</span>
 903 |     | <span class='unexecuted'>        systemDebtRedistributionIndex = systemDebtRedistributionIndex + EBTCDebtRewardPerUnitStaked;</span>
 904 |     | <span class='neutral'></span>
 905 |     | <span class='unexecuted'>        emit SystemDebtRedistributionIndexUpdated(systemDebtRedistributionIndex);</span>
 906 |     | <span class='neutral'>    }</span>
 907 |     | <span class='neutral'></span>
 908 |     | <span class='neutral'>    // --- &#39;require&#39; wrapper functions ---</span>
 909 |     | <span class='neutral'></span>
 910 |     | <span class='unexecuted'>    function _requirePartialLiqDebtSize(</span>
 911 |     | <span class='neutral'>        uint256 _partialDebt,</span>
 912 |     | <span class='neutral'>        uint256 _entireDebt,</span>
 913 |     | <span class='neutral'>        uint256 _price</span>
 914 |     | <span class='neutral'>    ) internal view {</span>
 915 |     | <span class='unexecuted'>        require(</span>
 916 |     | <span class='unexecuted'>            (_partialDebt + _convertDebtDenominationToBtc(MIN_NET_STETH_BALANCE, _price)) &lt;=</span>
 917 |     | <span class='unexecuted'>                _entireDebt,</span>
 918 |     | <span class='neutral'>            &quot;LiquidationLibrary: Partial debt liquidated must be less than total debt&quot;</span>
 919 |     | <span class='neutral'>        );</span>
 920 |     | <span class='neutral'>    }</span>
 921 |     | <span class='neutral'></span>
 922 |     | <span class='unexecuted'>    function _requirePartialLiqCollSize(uint256 _entireColl) internal pure {</span>
 923 |     | <span class='unexecuted'>        require(</span>
 924 |     | <span class='unexecuted'>            _entireColl &gt;= MIN_NET_STETH_BALANCE,</span>
 925 |     | <span class='neutral'>            &quot;LiquidationLibrary: Coll remaining in partially liquidated CDP must be &gt;= minimum&quot;</span>
 926 |     | <span class='neutral'>        );</span>
 927 |     | <span class='neutral'>    }</span>
 928 |     | <span class='neutral'></span>
 929 |     | <span class='unexecuted'>    function _requireMinDebt(uint256 _debt) internal pure {</span>
 930 |     | <span class='unexecuted'>        require(_debt &gt;= MIN_CHANGE, &quot;LiquidationLibrary: Debt must be above min&quot;);</span>
 931 |     | <span class='neutral'>    }</span>
 932 |     | <span class='neutral'>}</span>
 933 |     | <span class='neutral'></span>

</code>
<br />

<b>/mnt/c/Users/Lourens/Documents/Recon-Fuzz/collabs/ebtc/packages/contracts/contracts/LiquidationSequencer.sol</b>
<code>
   1 |     | <span class='neutral'>// SPDX-License-Identifier: MIT</span>
   2 |     | <span class='neutral'></span>
   3 |     | <span class='neutral'>pragma solidity 0.8.17;</span>
   4 |     | <span class='neutral'></span>
   5 |     | <span class='neutral'>import &quot;./Interfaces/IPriceFeed.sol&quot;;</span>
   6 |     | <span class='neutral'>import &quot;./Interfaces/ICdpManager.sol&quot;;</span>
   7 |     | <span class='neutral'>import &quot;./Interfaces/ISortedCdps.sol&quot;;</span>
   8 |     | <span class='neutral'>import &quot;./Interfaces/ICdpManagerData.sol&quot;;</span>
   9 |     | <span class='neutral'>import &quot;./Dependencies/EbtcBase.sol&quot;;</span>
  10 |     | <span class='neutral'></span>
  11 |     | <span class='neutral'>/// @notice Helper contract to turn a sequence into CDP id array for batch liquidation</span>
  12 |     | <span class='neutral'>/// @dev Note this sequencer only serves as an approximation tool to provide &quot;best-effort&quot;</span>
  13 |     | <span class='neutral'>/// @dev that return a list of CDP ids which could be consumed by &quot;CdpManager.batchLiquidateCdps()&quot;.</span>
  14 |     | <span class='neutral'>/// @dev It is possible that some of the returned Cdps might be skipped (not liquidatable any more)</span>
  15 |     | <span class='neutral'>/// @dev during liquidation execution due to change of the system states</span>
  16 |     | <span class='neutral'>/// @dev e.g., TCR brought back from Recovery Mode to Normal Mode</span>
  17 | *   | <span class='executed'>contract LiquidationSequencer is EbtcBase {</span>
  18 |     | <span class='unexecuted'>    ICdpManager public immutable cdpManager;</span>
  19 |     | <span class='unexecuted'>    ISortedCdps public immutable sortedCdps;</span>
  20 |     | <span class='neutral'></span>
  21 |     | <span class='unexecuted'>    constructor(</span>
  22 |     | <span class='neutral'>        address _cdpManagerAddress,</span>
  23 |     | <span class='neutral'>        address _sortedCdpsAddress,</span>
  24 |     | <span class='neutral'>        address _priceFeedAddress,</span>
  25 |     | <span class='neutral'>        address _activePoolAddress,</span>
  26 |     | <span class='neutral'>        address _collateralAddress</span>
  27 |     | <span class='neutral'>    ) EbtcBase(_activePoolAddress, _priceFeedAddress, _collateralAddress) {</span>
  28 |     | <span class='unexecuted'>        cdpManager = ICdpManager(_cdpManagerAddress);</span>
  29 |     | <span class='unexecuted'>        sortedCdps = ISortedCdps(_sortedCdpsAddress);</span>
  30 |     | <span class='neutral'>    }</span>
  31 |     | <span class='neutral'></span>
  32 |     | <span class='neutral'>    /// @dev Get first N batch of liquidatable Cdps at current price</span>
  33 |     | <span class='neutral'>    /// @dev Non-view function that updates and returns live price at execution time</span>
  34 |     | <span class='neutral'>    /// @dev could use callStatic offline to save gas</span>
  35 |     | <span class='neutral'>    /// @param _n The number for sequential liquidation to be converted into a CdpId array batch</span>
  36 |     | <span class='neutral'>    /// @return _array The CdpId array batch converted from the specified sequential number</span>
  37 | *   | <span class='executed'>    function sequenceLiqToBatchLiq(uint256 _n) external returns (bytes32[] memory _array) {</span>
  38 |     | <span class='unexecuted'>        uint256 _price = priceFeed.fetchPrice();</span>
  39 | *   | <span class='executed'>        return sequenceLiqToBatchLiqWithPrice(_n, _price);</span>
  40 |     | <span class='neutral'>    }</span>
  41 |     | <span class='neutral'></span>
  42 |     | <span class='neutral'>    /// @dev Get first N batch of liquidatable Cdps at specified price</span>
  43 |     | <span class='neutral'>    /// @dev Non-view function that will sync global state</span>
  44 |     | <span class='neutral'>    /// @dev could use callStatic offline to save gas</span>
  45 |     | <span class='neutral'>    /// @param _n The number for sequential liquidation to be converted into a CdpId array batch</span>
  46 |     | <span class='neutral'>    /// @param _price The price of stETH:eBTC to be used to check if Cdp is liquidatable</span>
  47 |     | <span class='neutral'>    /// @return _array The CdpId array batch converted from the specified sequential number</span>
  48 | *   | <span class='executed'>    function sequenceLiqToBatchLiqWithPrice(</span>
  49 |     | <span class='neutral'>        uint256 _n,</span>
  50 |     | <span class='neutral'>        uint256 _price</span>
  51 | *   | <span class='executed'>    ) public returns (bytes32[] memory _array) {</span>
  52 | *   | <span class='executed'>        cdpManager.syncGlobalAccountingAndGracePeriod();</span>
  53 | *   | <span class='executed'>        (uint256 _TCR, , ) = _getTCRWithSystemDebtAndCollShares(_price);</span>
  54 | *   | <span class='executed'>        return _sequenceLiqToBatchLiq(_n, _price, _TCR);</span>
  55 |     | <span class='neutral'>    }</span>
  56 |     | <span class='neutral'></span>
  57 |     | <span class='neutral'>    // return CdpId array (in NICR-decreasing order same as SortedCdps)</span>
  58 |     | <span class='neutral'>    // including the last N Cdps in sortedCdps for batch liquidation</span>
  59 | *   | <span class='executed'>    function _sequenceLiqToBatchLiq(</span>
  60 |     | <span class='neutral'>        uint256 _n,</span>
  61 |     | <span class='neutral'>        uint256 _price,</span>
  62 |     | <span class='neutral'>        uint256 _TCR</span>
  63 | *   | <span class='executed'>    ) internal view returns (bytes32[] memory _array) {</span>
  64 | *   | <span class='executed'>        if (_n &gt; 0) {</span>
  65 |     | <span class='neutral'>            // get count of liquidatable Cdps with 1st iteration</span>
  66 | *   | <span class='executed'>            (uint256 _cnt, ) = _iterateOverSortedCdps(0, _TCR, _n, _price);</span>
  67 |     | <span class='neutral'></span>
  68 |     | <span class='neutral'>            // retrieve liquidatable Cdps with 2nd iteration</span>
  69 | *   | <span class='executed'>            (uint256 _j, bytes32[] memory _returnedArray) = _iterateOverSortedCdps(</span>
  70 | *   | <span class='executed'>                _cnt,</span>
  71 | *   | <span class='executed'>                _TCR,</span>
  72 | *   | <span class='executed'>                _n,</span>
  73 | *   | <span class='executed'>                _price</span>
  74 |     | <span class='neutral'>            );</span>
  75 | *   | <span class='executed'>            require(_j == _cnt, &quot;LiquidationSequencer: wrong sequence conversion!&quot;);</span>
  76 | *   | <span class='executed'>            _array = _returnedArray;</span>
  77 |     | <span class='neutral'>        }</span>
  78 |     | <span class='neutral'>    }</span>
  79 |     | <span class='neutral'></span>
  80 | *   | <span class='executed'>    function _iterateOverSortedCdps(</span>
  81 |     | <span class='neutral'>        uint256 _realCount,</span>
  82 |     | <span class='neutral'>        uint256 _TCR,</span>
  83 |     | <span class='neutral'>        uint256 _n,</span>
  84 |     | <span class='neutral'>        uint256 _price</span>
  85 | *   | <span class='executed'>    ) internal view returns (uint256 _cnt, bytes32[] memory _array) {</span>
  86 |     | <span class='neutral'>        // if there is already a count (calculated from previous iteration)</span>
  87 |     | <span class='neutral'>        // we use the value to initialize CDP id array for return</span>
  88 | *   | <span class='executed'>        if (_realCount &gt; 0) {</span>
  89 | *   | <span class='executed'>            _array = new bytes32[](_realCount);</span>
  90 |     | <span class='neutral'>        }</span>
  91 |     | <span class='neutral'></span>
  92 |     | <span class='neutral'>        // initialize variables for this iteration</span>
  93 | *   | <span class='executed'>        bytes32 _last = sortedCdps.getLast();</span>
  94 | *   | <span class='executed'>        bytes32 _first = sortedCdps.getFirst();</span>
  95 | *   | <span class='executed'>        bytes32 _cdpId = _last;</span>
  96 |     | <span class='neutral'></span>
  97 | *   | <span class='executed'>        for (uint256 i = 0; i &lt; (_realCount &gt; 0 ? _realCount : _n) &amp;&amp; _cdpId != _first; ) {</span>
  98 | *   | <span class='executed'>            bool _liquidatable = _checkICRAgainstLiqThreshold(</span>
  99 | *   | <span class='executed'>                cdpManager.getSyncedICR(_cdpId, _price),</span>
 100 | *   | <span class='executed'>                _TCR</span>
 101 |     | <span class='neutral'>            );</span>
 102 | *   | <span class='executed'>            if (_liquidatable) {</span>
 103 | *   | <span class='executed'>                if (_realCount &gt; 0) {</span>
 104 | *   | <span class='executed'>                    _array[_realCount - _cnt - 1] = _cdpId;</span>
 105 |     | <span class='neutral'>                }</span>
 106 |     | <span class='neutral'>                unchecked {</span>
 107 | *   | <span class='executed'>                    ++_cnt;</span>
 108 |     | <span class='neutral'>                }</span>
 109 | *   | <span class='executed'>                _cdpId = sortedCdps.getPrev(_cdpId);</span>
 110 |     | <span class='neutral'>            } else {</span>
 111 |     | <span class='neutral'>                // breaking loop early if not liquidatable due to sorted (descending) list of Cdps</span>
 112 | *   | <span class='executed'>                break;</span>
 113 |     | <span class='neutral'>            }</span>
 114 |     | <span class='neutral'>            unchecked {</span>
 115 | *   | <span class='executed'>                ++i;</span>
 116 |     | <span class='neutral'>            }</span>
 117 |     | <span class='neutral'>        }</span>
 118 |     | <span class='neutral'>    }</span>
 119 |     | <span class='neutral'>}</span>
 120 |     | <span class='neutral'></span>

</code>
<br />

<b>/mnt/c/Users/Lourens/Documents/Recon-Fuzz/collabs/ebtc/packages/contracts/contracts/PriceFeed.sol</b>
<code>
   1 |     | <span class='neutral'>// SPDX-License-Identifier: MIT</span>
   2 |     | <span class='neutral'></span>
   3 |     | <span class='neutral'>pragma solidity 0.8.17;</span>
   4 |     | <span class='neutral'></span>
   5 |     | <span class='neutral'>import &quot;./Interfaces/IPriceFeed.sol&quot;;</span>
   6 |     | <span class='neutral'>import &quot;./Interfaces/IFallbackCaller.sol&quot;;</span>
   7 |     | <span class='neutral'>import &quot;./Dependencies/AggregatorV3Interface.sol&quot;;</span>
   8 |     | <span class='neutral'>import &quot;./Dependencies/BaseMath.sol&quot;;</span>
   9 |     | <span class='neutral'>import &quot;./Dependencies/EbtcMath.sol&quot;;</span>
  10 |     | <span class='neutral'>import &quot;./Dependencies/AuthNoOwner.sol&quot;;</span>
  11 |     | <span class='neutral'>import &quot;./FixedAdapter.sol&quot;;</span>
  12 |     | <span class='neutral'></span>
  13 |     | <span class='neutral'>/*</span>
  14 |     | <span class='neutral'> * PriceFeed for mainnet deployment, it connects to two Chainlink&#39;s live feeds, ETH:BTC and</span>
  15 |     | <span class='neutral'> * stETH:ETH, which are used to aggregate the price feed of stETH:BTC in conjuction.</span>
  16 |     | <span class='neutral'> * It also allows for a fallback oracle to intervene in case that the primary Chainlink oracle fails.</span>
  17 |     | <span class='neutral'> *</span>
  18 |     | <span class='neutral'> * The PriceFeed uses Chainlink as primary oracle and allows for an optional fallback source. It contains logic for</span>
  19 |     | <span class='neutral'> * switching oracles based on oracle failures, timeouts, and conditions for returning to the primary</span>
  20 |     | <span class='neutral'> * Chainlink oracle. In addition, it contains the mechanism to add or remove the fallback oracle through governance.</span>
  21 |     | <span class='neutral'> */</span>
  22 |     | <span class='unexecuted'>contract PriceFeed is BaseMath, IPriceFeed, AuthNoOwner {</span>
  23 |     | <span class='unexecuted'>    string public constant NAME = &quot;PriceFeed&quot;;</span>
  24 |     | <span class='neutral'></span>
  25 |     | <span class='neutral'>    // Chainlink oracles in mainnet</span>
  26 |     | <span class='unexecuted'>    AggregatorV3Interface public immutable ETH_BTC_CL_FEED;</span>
  27 |     | <span class='unexecuted'>    AggregatorV3Interface public immutable STETH_ETH_CL_FEED;</span>
  28 |     | <span class='neutral'>    // STETH_ETH_FIXED_FEED must have the same decimals as STETH_ETH_CL_FEED</span>
  29 |     | <span class='unexecuted'>    AggregatorV3Interface public immutable STETH_ETH_FIXED_FEED;</span>
  30 |     | <span class='neutral'></span>
  31 |     | <span class='unexecuted'>    uint256 public immutable DENOMINATOR;</span>
  32 |     | <span class='unexecuted'>    uint256 public immutable SCALED_DECIMAL;</span>
  33 |     | <span class='neutral'></span>
  34 |     | <span class='neutral'>    // Fallback feed</span>
  35 |     | <span class='unexecuted'>    IFallbackCaller public fallbackCaller; // Wrapper contract that calls the fallback system</span>
  36 |     | <span class='neutral'></span>
  37 |     | <span class='neutral'>    // Maximum time period allowed since Chainlink&#39;s latest round data timestamp, beyond which Chainlink is considered frozen.</span>
  38 |     | <span class='unexecuted'>    uint256 public constant TIMEOUT_ETH_BTC_FEED = 4800; // 1 hours &amp; 20min: 60 * 80</span>
  39 |     | <span class='unexecuted'>    uint256 public constant TIMEOUT_STETH_ETH_FEED = 90000; // 25 hours: 60 * 60 * 25</span>
  40 |     | <span class='unexecuted'>    uint256 constant INVALID_PRICE = 0;</span>
  41 |     | <span class='neutral'></span>
  42 |     | <span class='neutral'>    /**</span>
  43 |     | <span class='neutral'>     * @notice Maximum number of resulting and feed decimals</span>
  44 |     | <span class='neutral'>     */</span>
  45 |     | <span class='unexecuted'>    uint8 public constant MAX_DECIMALS = 18;</span>
  46 |     | <span class='neutral'></span>
  47 |     | <span class='neutral'>    // Maximum deviation allowed between two consecutive Chainlink oracle prices. 18-digit precision.</span>
  48 |     | <span class='unexecuted'>    uint256 public constant MAX_PRICE_DEVIATION_FROM_PREVIOUS_ROUND = 5e17; // 50%</span>
  49 |     | <span class='neutral'></span>
  50 |     | <span class='neutral'>    /*</span>
  51 |     | <span class='neutral'>     * The maximum relative price difference between two oracle responses allowed in order for the PriceFeed</span>
  52 |     | <span class='neutral'>     * to return to using the Chainlink oracle. 18-digit precision.</span>
  53 |     | <span class='neutral'>     */</span>
  54 |     | <span class='unexecuted'>    uint256 public constant MAX_PRICE_DIFFERENCE_BETWEEN_ORACLES = 5e16; // 5%</span>
  55 |     | <span class='neutral'></span>
  56 |     | <span class='neutral'>    // The last good price seen from an oracle by eBTC</span>
  57 |     | <span class='unexecuted'>    uint256 public lastGoodPrice;</span>
  58 |     | <span class='neutral'></span>
  59 |     | <span class='neutral'>    // The current status of the PriceFeed, which determines the conditions for the next price fetch attempt</span>
  60 |     | <span class='unexecuted'>    Status public status;</span>
  61 |     | <span class='neutral'></span>
  62 |     | <span class='neutral'>    // Dynamic feed = Chainlink stETH/ETH feed</span>
  63 |     | <span class='neutral'>    // Static feed = 1:1 FixedAdapter</span>
  64 |     | <span class='neutral'>    // defaults to static feed</span>
  65 |     | <span class='unexecuted'>    bool public useDynamicFeed;</span>
  66 |     | <span class='neutral'></span>
  67 |     | <span class='neutral'>    // --- Dependency setters ---</span>
  68 |     | <span class='neutral'></span>
  69 |     | <span class='neutral'>    /// @notice Sets the addresses of the contracts and initializes the system</span>
  70 |     | <span class='neutral'>    /// @param _fallbackCallerAddress The address of the Fallback oracle contract</span>
  71 |     | <span class='neutral'>    /// @param _authorityAddress The address of the Authority contract</span>
  72 |     | <span class='neutral'>    /// @param _collEthCLFeed The address of the collateral-ETH ChainLink feed</span>
  73 |     | <span class='neutral'>    /// @param _ethBtcCLFeed The address of the ETH-BTC ChainLink feed</span>
  74 |     | <span class='unexecuted'>    constructor(</span>
  75 |     | <span class='neutral'>        address _fallbackCallerAddress,</span>
  76 |     | <span class='neutral'>        address _authorityAddress,</span>
  77 |     | <span class='neutral'>        address _collEthCLFeed,</span>
  78 |     | <span class='neutral'>        address _ethBtcCLFeed,</span>
  79 |     | <span class='neutral'>        bool _useDynamicFeed</span>
  80 |     | <span class='unexecuted'>    ) {</span>
  81 |     | <span class='unexecuted'>        fallbackCaller = IFallbackCaller(_fallbackCallerAddress);</span>
  82 |     | <span class='neutral'></span>
  83 |     | <span class='unexecuted'>        _initializeAuthority(_authorityAddress);</span>
  84 |     | <span class='neutral'></span>
  85 |     | <span class='unexecuted'>        emit FallbackCallerChanged(address(0), _fallbackCallerAddress);</span>
  86 |     | <span class='neutral'></span>
  87 |     | <span class='unexecuted'>        ETH_BTC_CL_FEED = AggregatorV3Interface(_ethBtcCLFeed);</span>
  88 |     | <span class='unexecuted'>        STETH_ETH_CL_FEED = AggregatorV3Interface(_collEthCLFeed);</span>
  89 |     | <span class='unexecuted'>        STETH_ETH_FIXED_FEED = new FixedAdapter();</span>
  90 |     | <span class='neutral'></span>
  91 |     | <span class='unexecuted'>        uint8 ethBtcDecimals = ETH_BTC_CL_FEED.decimals();</span>
  92 |     | <span class='unexecuted'>        require(ethBtcDecimals &lt;= MAX_DECIMALS);</span>
  93 |     | <span class='unexecuted'>        uint8 stEthEthDecimals = STETH_ETH_CL_FEED.decimals();</span>
  94 |     | <span class='unexecuted'>        require(stEthEthDecimals &lt;= MAX_DECIMALS);</span>
  95 |     | <span class='unexecuted'>        require(stEthEthDecimals == STETH_ETH_FIXED_FEED.decimals());</span>
  96 |     | <span class='neutral'></span>
  97 |     | <span class='unexecuted'>        DENOMINATOR =</span>
  98 |     | <span class='unexecuted'>            10 ** ((stEthEthDecimals &gt; ethBtcDecimals ? stEthEthDecimals : ethBtcDecimals) * 2);</span>
  99 |     | <span class='unexecuted'>        SCALED_DECIMAL = stEthEthDecimals &gt; ethBtcDecimals</span>
 100 |     | <span class='unexecuted'>            ? 10 ** (stEthEthDecimals - ethBtcDecimals)</span>
 101 |     | <span class='unexecuted'>            : 10 ** (ethBtcDecimals - stEthEthDecimals);</span>
 102 |     | <span class='neutral'></span>
 103 |     | <span class='unexecuted'>        useDynamicFeed = _useDynamicFeed;</span>
 104 |     | <span class='neutral'></span>
 105 |     | <span class='neutral'>        // Get an initial price from Chainlink to serve as first reference for lastGoodPrice</span>
 106 |     | <span class='unexecuted'>        ChainlinkResponse memory chainlinkResponse = _getCurrentChainlinkResponse();</span>
 107 |     | <span class='unexecuted'>        ChainlinkResponse memory prevChainlinkResponse = _getPrevChainlinkResponse(</span>
 108 |     | <span class='unexecuted'>            chainlinkResponse.roundEthBtcId,</span>
 109 |     | <span class='unexecuted'>            chainlinkResponse.roundStEthEthId</span>
 110 |     | <span class='neutral'>        );</span>
 111 |     | <span class='neutral'></span>
 112 |     | <span class='unexecuted'>        require(</span>
 113 |     | <span class='unexecuted'>            !_chainlinkIsBroken(chainlinkResponse, prevChainlinkResponse) &amp;&amp;</span>
 114 |     | <span class='unexecuted'>                !_chainlinkIsFrozen(chainlinkResponse),</span>
 115 |     | <span class='neutral'>            &quot;PriceFeed: Chainlink must be working and current&quot;</span>
 116 |     | <span class='neutral'>        );</span>
 117 |     | <span class='neutral'></span>
 118 |     | <span class='unexecuted'>        _storeChainlinkPrice(chainlinkResponse.answer);</span>
 119 |     | <span class='neutral'></span>
 120 |     | <span class='neutral'>        // Explicitly set initial system status after `require` checks</span>
 121 |     | <span class='unexecuted'>        status = Status.chainlinkWorking;</span>
 122 |     | <span class='neutral'></span>
 123 |     | <span class='neutral'>        // emit STETH_ETH_FIXED_FEED address</span>
 124 |     | <span class='unexecuted'>        emit CollateralFeedSourceUpdated(address(_collateralFeed()));</span>
 125 |     | <span class='neutral'>    }</span>
 126 |     | <span class='neutral'></span>
 127 |     | <span class='neutral'>    // --- Functions ---</span>
 128 |     | <span class='neutral'></span>
 129 |     | <span class='unexecuted'>    function setCollateralFeedSource(bool _useDynamicFeed) external requiresAuth {</span>
 130 |     | <span class='unexecuted'>        useDynamicFeed = _useDynamicFeed;</span>
 131 |     | <span class='unexecuted'>        emit CollateralFeedSourceUpdated(address(_collateralFeed()));</span>
 132 |     | <span class='neutral'>    }</span>
 133 |     | <span class='neutral'></span>
 134 |     | <span class='neutral'>    /// @notice Returns the latest price obtained from the Oracle</span>
 135 |     | <span class='neutral'>    /// @dev Called by eBTC functions that require a current price. Also callable permissionlessly.</span>
 136 |     | <span class='neutral'>    /// @dev Non-view function - it updates and stores the last good price seen by eBTC.</span>
 137 |     | <span class='neutral'>    /// @dev Uses a main oracle (Chainlink) and a fallback oracle in case Chainlink fails. If both fail, it uses the last good price seen by eBTC.</span>
 138 |     | <span class='neutral'>    /// @dev The fallback oracle address can be swapped by the Authority. The fallback oracle must conform to the IFallbackCaller interface.</span>
 139 |     | <span class='neutral'>    /// @return The latest price fetched from the Oracle</span>
 140 |     | <span class='unexecuted'>    function fetchPrice() external override returns (uint256) {</span>
 141 |     | <span class='neutral'>        // Get current and previous price data from Chainlink, and current price data from Fallback</span>
 142 |     | <span class='unexecuted'>        ChainlinkResponse memory chainlinkResponse = _getCurrentChainlinkResponse();</span>
 143 |     | <span class='unexecuted'>        ChainlinkResponse memory prevChainlinkResponse = _getPrevChainlinkResponse(</span>
 144 |     | <span class='unexecuted'>            chainlinkResponse.roundEthBtcId,</span>
 145 |     | <span class='unexecuted'>            chainlinkResponse.roundStEthEthId</span>
 146 |     | <span class='neutral'>        );</span>
 147 |     | <span class='unexecuted'>        FallbackResponse memory fallbackResponse = _getCurrentFallbackResponse();</span>
 148 |     | <span class='neutral'></span>
 149 |     | <span class='neutral'>        // --- CASE 1: System fetched last price from Chainlink  ---</span>
 150 |     | <span class='unexecuted'>        if (status == Status.chainlinkWorking) {</span>
 151 |     | <span class='neutral'>            // If Chainlink is broken, try Fallback</span>
 152 |     | <span class='unexecuted'>            if (_chainlinkIsBroken(chainlinkResponse, prevChainlinkResponse)) {</span>
 153 |     | <span class='neutral'>                // If Fallback is broken then both oracles are untrusted, so return the last good price</span>
 154 |     | <span class='unexecuted'>                if (_fallbackIsBroken(fallbackResponse)) {</span>
 155 |     | <span class='unexecuted'>                    _changeStatus(Status.bothOraclesUntrusted);</span>
 156 |     | <span class='unexecuted'>                    return INVALID_PRICE;</span>
 157 |     | <span class='neutral'>                }</span>
 158 |     | <span class='neutral'>                /*</span>
 159 |     | <span class='neutral'>                 * If Fallback is only frozen but otherwise returning valid data, return the last good price.</span>
 160 |     | <span class='neutral'>                 * Fallback may need to be tipped to return current data.</span>
 161 |     | <span class='neutral'>                 */</span>
 162 |     | <span class='unexecuted'>                if (_fallbackIsFrozen(fallbackResponse)) {</span>
 163 |     | <span class='unexecuted'>                    _changeStatus(Status.usingFallbackChainlinkUntrusted);</span>
 164 |     | <span class='neutral'>                    return INVALID_PRICE;</span>
 165 |     | <span class='neutral'>                }</span>
 166 |     | <span class='neutral'></span>
 167 |     | <span class='neutral'>                // If Chainlink is broken and Fallback is working, switch to Fallback and return current Fallback price</span>
 168 |     | <span class='unexecuted'>                _changeStatus(Status.usingFallbackChainlinkUntrusted);</span>
 169 |     | <span class='unexecuted'>                return _storeFallbackPrice(fallbackResponse);</span>
 170 |     | <span class='neutral'>            }</span>
 171 |     | <span class='neutral'></span>
 172 |     | <span class='neutral'>            // If Chainlink is frozen, try Fallback</span>
 173 |     | <span class='unexecuted'>            if (_chainlinkIsFrozen(chainlinkResponse)) {</span>
 174 |     | <span class='neutral'>                // If Fallback is broken too, remember Fallback broke, and return last good price</span>
 175 |     | <span class='unexecuted'>                if (_fallbackIsBroken(fallbackResponse)) {</span>
 176 |     | <span class='unexecuted'>                    _changeStatus(Status.usingChainlinkFallbackUntrusted);</span>
 177 |     | <span class='neutral'>                    return INVALID_PRICE;</span>
 178 |     | <span class='neutral'>                }</span>
 179 |     | <span class='neutral'></span>
 180 |     | <span class='neutral'>                // If Fallback is frozen or working, remember Chainlink froze, and switch to Fallback</span>
 181 |     | <span class='unexecuted'>                _changeStatus(Status.usingFallbackChainlinkFrozen);</span>
 182 |     | <span class='neutral'></span>
 183 |     | <span class='unexecuted'>                if (_fallbackIsFrozen(fallbackResponse)) {</span>
 184 |     | <span class='unexecuted'>                    return INVALID_PRICE;</span>
 185 |     | <span class='neutral'>                }</span>
 186 |     | <span class='neutral'></span>
 187 |     | <span class='neutral'>                // If Fallback is working, use it</span>
 188 |     | <span class='neutral'>                return _storeFallbackPrice(fallbackResponse);</span>
 189 |     | <span class='neutral'>            }</span>
 190 |     | <span class='neutral'></span>
 191 |     | <span class='neutral'>            // If Chainlink price has changed by &gt; 50% between two consecutive rounds, compare it to Fallback&#39;s price</span>
 192 |     | <span class='unexecuted'>            if (_chainlinkPriceChangeAboveMax(chainlinkResponse, prevChainlinkResponse)) {</span>
 193 |     | <span class='neutral'>                // If Fallback is broken, both oracles are untrusted, and return last good price</span>
 194 |     | <span class='neutral'>                // We don&#39;t trust CL for now given this large price differential</span>
 195 |     | <span class='unexecuted'>                if (_fallbackIsBroken(fallbackResponse)) {</span>
 196 |     | <span class='unexecuted'>                    _changeStatus(Status.bothOraclesUntrusted);</span>
 197 |     | <span class='neutral'>                    return INVALID_PRICE;</span>
 198 |     | <span class='neutral'>                }</span>
 199 |     | <span class='neutral'></span>
 200 |     | <span class='neutral'>                // If Fallback is frozen, switch to Fallback and return last good price</span>
 201 |     | <span class='neutral'>                // We don&#39;t trust CL for now given this large price differential</span>
 202 |     | <span class='unexecuted'>                if (_fallbackIsFrozen(fallbackResponse)) {</span>
 203 |     | <span class='unexecuted'>                    _changeStatus(Status.usingFallbackChainlinkUntrusted);</span>
 204 |     | <span class='neutral'>                    return INVALID_PRICE;</span>
 205 |     | <span class='neutral'>                }</span>
 206 |     | <span class='neutral'></span>
 207 |     | <span class='neutral'>                /*</span>
 208 |     | <span class='neutral'>                 * If Fallback is live and both oracles have a similar price, conclude that Chainlink&#39;s large price deviation between</span>
 209 |     | <span class='neutral'>                 * two consecutive rounds was likely a legitmate market price movement, and so continue using Chainlink</span>
 210 |     | <span class='neutral'>                 */</span>
 211 |     | <span class='unexecuted'>                if (_bothOraclesSimilarPrice(chainlinkResponse, fallbackResponse)) {</span>
 212 |     | <span class='unexecuted'>                    return _storeChainlinkPrice(chainlinkResponse.answer);</span>
 213 |     | <span class='neutral'>                }</span>
 214 |     | <span class='neutral'></span>
 215 |     | <span class='neutral'>                // If Fallback is live but the oracles differ too much in price, conclude that Chainlink&#39;s initial price deviation was</span>
 216 |     | <span class='neutral'>                // an oracle failure. Switch to Fallback, and use Fallback price</span>
 217 |     | <span class='neutral'>                _changeStatus(Status.usingFallbackChainlinkUntrusted);</span>
 218 |     | <span class='neutral'>                return _storeFallbackPrice(fallbackResponse);</span>
 219 |     | <span class='neutral'>            }</span>
 220 |     | <span class='neutral'></span>
 221 |     | <span class='neutral'>            // If Chainlink is working and Fallback is broken, remember Fallback is broken</span>
 222 |     | <span class='unexecuted'>            if (_fallbackIsBroken(fallbackResponse)) {</span>
 223 |     | <span class='unexecuted'>                _changeStatus(Status.usingChainlinkFallbackUntrusted);</span>
 224 |     | <span class='neutral'>            }</span>
 225 |     | <span class='neutral'></span>
 226 |     | <span class='neutral'>            // If Chainlink is working, return Chainlink current price (no status change)</span>
 227 |     | <span class='unexecuted'>            return _storeChainlinkPrice(chainlinkResponse.answer);</span>
 228 |     | <span class='neutral'>        }</span>
 229 |     | <span class='neutral'></span>
 230 |     | <span class='neutral'>        // --- CASE 2: The system fetched last price from Fallback ---</span>
 231 |     | <span class='unexecuted'>        if (status == Status.usingFallbackChainlinkUntrusted) {</span>
 232 |     | <span class='unexecuted'>            if (_fallbackIsBroken(fallbackResponse)) {</span>
 233 |     | <span class='unexecuted'>                _changeStatus(Status.bothOraclesUntrusted);</span>
 234 |     | <span class='neutral'>                return INVALID_PRICE;</span>
 235 |     | <span class='neutral'>            }</span>
 236 |     | <span class='neutral'></span>
 237 |     | <span class='neutral'>            /*</span>
 238 |     | <span class='neutral'>             * If Fallback is only frozen but otherwise returning valid data, just return the last good price.</span>
 239 |     | <span class='neutral'>             * Fallback may need to be tipped to return current data.</span>
 240 |     | <span class='neutral'>             */</span>
 241 |     | <span class='unexecuted'>            if (_fallbackIsFrozen(fallbackResponse)) {</span>
 242 |     | <span class='unexecuted'>                return INVALID_PRICE;</span>
 243 |     | <span class='neutral'>            }</span>
 244 |     | <span class='neutral'></span>
 245 |     | <span class='neutral'>            // If both Fallback and Chainlink are live, unbroken, and reporting similar prices, switch back to Chainlink</span>
 246 |     | <span class='unexecuted'>            if (</span>
 247 |     | <span class='unexecuted'>                _bothOraclesLiveAndUnbrokenAndSimilarPrice(</span>
 248 |     | <span class='unexecuted'>                    chainlinkResponse,</span>
 249 |     | <span class='unexecuted'>                    prevChainlinkResponse,</span>
 250 |     | <span class='unexecuted'>                    fallbackResponse</span>
 251 |     | <span class='neutral'>                )</span>
 252 |     | <span class='neutral'>            ) {</span>
 253 |     | <span class='unexecuted'>                _changeStatus(Status.chainlinkWorking);</span>
 254 |     | <span class='neutral'>                return _storeChainlinkPrice(chainlinkResponse.answer);</span>
 255 |     | <span class='neutral'>            }</span>
 256 |     | <span class='neutral'></span>
 257 |     | <span class='neutral'>            // Otherwise, use Fallback price</span>
 258 |     | <span class='neutral'>            return _storeFallbackPrice(fallbackResponse);</span>
 259 |     | <span class='neutral'>        }</span>
 260 |     | <span class='neutral'></span>
 261 |     | <span class='neutral'>        // --- CASE 3: Both oracles were untrusted at the last price fetch ---</span>
 262 |     | <span class='unexecuted'>        if (status == Status.bothOraclesUntrusted) {</span>
 263 |     | <span class='neutral'>            /*</span>
 264 |     | <span class='neutral'>             * If there&#39;s no fallback, only use Chainlink</span>
 265 |     | <span class='neutral'>             */</span>
 266 |     | <span class='unexecuted'>            if (address(fallbackCaller) == address(0)) {</span>
 267 |     | <span class='neutral'>                // If CL has resumed working</span>
 268 |     | <span class='unexecuted'>                if (</span>
 269 |     | <span class='unexecuted'>                    !_chainlinkIsBroken(chainlinkResponse, prevChainlinkResponse) &amp;&amp;</span>
 270 |     | <span class='unexecuted'>                    !_chainlinkIsFrozen(chainlinkResponse) &amp;&amp;</span>
 271 |     | <span class='unexecuted'>                    !_chainlinkPriceChangeAboveMax(chainlinkResponse, prevChainlinkResponse)</span>
 272 |     | <span class='neutral'>                ) {</span>
 273 |     | <span class='unexecuted'>                    _changeStatus(Status.usingChainlinkFallbackUntrusted);</span>
 274 |     | <span class='neutral'>                    return _storeChainlinkPrice(chainlinkResponse.answer);</span>
 275 |     | <span class='neutral'>                } else {</span>
 276 |     | <span class='neutral'>                    return INVALID_PRICE;</span>
 277 |     | <span class='neutral'>                }</span>
 278 |     | <span class='neutral'>            }</span>
 279 |     | <span class='neutral'></span>
 280 |     | <span class='neutral'>            /*</span>
 281 |     | <span class='neutral'>             * If both oracles are now live, unbroken and similar price, we assume that they are reporting</span>
 282 |     | <span class='neutral'>             * accurately, and so we switch back to Chainlink.</span>
 283 |     | <span class='neutral'>             */</span>
 284 |     | <span class='unexecuted'>            if (</span>
 285 |     | <span class='unexecuted'>                _bothOraclesLiveAndUnbrokenAndSimilarPrice(</span>
 286 |     | <span class='unexecuted'>                    chainlinkResponse,</span>
 287 |     | <span class='unexecuted'>                    prevChainlinkResponse,</span>
 288 |     | <span class='unexecuted'>                    fallbackResponse</span>
 289 |     | <span class='neutral'>                )</span>
 290 |     | <span class='neutral'>            ) {</span>
 291 |     | <span class='unexecuted'>                _changeStatus(Status.chainlinkWorking);</span>
 292 |     | <span class='neutral'>                return _storeChainlinkPrice(chainlinkResponse.answer);</span>
 293 |     | <span class='neutral'>            }</span>
 294 |     | <span class='neutral'></span>
 295 |     | <span class='neutral'>            // Otherwise, return the last good price - both oracles are still untrusted (no status change)</span>
 296 |     | <span class='neutral'>            return INVALID_PRICE;</span>
 297 |     | <span class='neutral'>        }</span>
 298 |     | <span class='neutral'></span>
 299 |     | <span class='neutral'>        // --- CASE 4: Using Fallback, and Chainlink is frozen ---</span>
 300 |     | <span class='unexecuted'>        if (status == Status.usingFallbackChainlinkFrozen) {</span>
 301 |     | <span class='unexecuted'>            if (_chainlinkIsBroken(chainlinkResponse, prevChainlinkResponse)) {</span>
 302 |     | <span class='neutral'>                // If both Oracles are broken, return last good price</span>
 303 |     | <span class='unexecuted'>                if (_fallbackIsBroken(fallbackResponse)) {</span>
 304 |     | <span class='unexecuted'>                    _changeStatus(Status.bothOraclesUntrusted);</span>
 305 |     | <span class='neutral'>                    return INVALID_PRICE;</span>
 306 |     | <span class='neutral'>                }</span>
 307 |     | <span class='neutral'></span>
 308 |     | <span class='neutral'>                // If Chainlink is broken, remember it and switch to using Fallback</span>
 309 |     | <span class='unexecuted'>                _changeStatus(Status.usingFallbackChainlinkUntrusted);</span>
 310 |     | <span class='neutral'></span>
 311 |     | <span class='neutral'>                if (_fallbackIsFrozen(fallbackResponse)) {</span>
 312 |     | <span class='neutral'>                    return INVALID_PRICE;</span>
 313 |     | <span class='neutral'>                }</span>
 314 |     | <span class='neutral'></span>
 315 |     | <span class='neutral'>                // If Fallback is working, return Fallback current price</span>
 316 |     | <span class='neutral'>                return _storeFallbackPrice(fallbackResponse);</span>
 317 |     | <span class='neutral'>            }</span>
 318 |     | <span class='neutral'></span>
 319 |     | <span class='unexecuted'>            if (_chainlinkIsFrozen(chainlinkResponse)) {</span>
 320 |     | <span class='neutral'>                // if Chainlink is frozen and Fallback is broken, remember Fallback broke, and return last good price</span>
 321 |     | <span class='unexecuted'>                if (_fallbackIsBroken(fallbackResponse)) {</span>
 322 |     | <span class='unexecuted'>                    _changeStatus(Status.usingChainlinkFallbackUntrusted);</span>
 323 |     | <span class='neutral'>                    return INVALID_PRICE;</span>
 324 |     | <span class='neutral'>                }</span>
 325 |     | <span class='neutral'></span>
 326 |     | <span class='neutral'>                // If both are frozen, just use lastGoodPrice</span>
 327 |     | <span class='neutral'>                if (_fallbackIsFrozen(fallbackResponse)) {</span>
 328 |     | <span class='neutral'>                    return INVALID_PRICE;</span>
 329 |     | <span class='neutral'>                }</span>
 330 |     | <span class='neutral'></span>
 331 |     | <span class='neutral'>                // if Chainlink is frozen and Fallback is working, keep using Fallback (no status change)</span>
 332 |     | <span class='neutral'>                return _storeFallbackPrice(fallbackResponse);</span>
 333 |     | <span class='neutral'>            }</span>
 334 |     | <span class='neutral'></span>
 335 |     | <span class='unexecuted'>            if (_chainlinkPriceChangeAboveMax(chainlinkResponse, prevChainlinkResponse)) {</span>
 336 |     | <span class='neutral'>                // if Chainlink price is deviated between rounds and fallback is broken, just use lastGoodPrice</span>
 337 |     | <span class='unexecuted'>                if (_fallbackIsBroken(fallbackResponse)) {</span>
 338 |     | <span class='neutral'>                    _changeStatus(Status.bothOraclesUntrusted);</span>
 339 |     | <span class='neutral'>                    return INVALID_PRICE;</span>
 340 |     | <span class='neutral'>                }</span>
 341 |     | <span class='neutral'></span>
 342 |     | <span class='neutral'>                // If Chainlink price is deviated between rounds, remember it and keep using fallback</span>
 343 |     | <span class='neutral'>                _changeStatus(Status.usingFallbackChainlinkUntrusted);</span>
 344 |     | <span class='neutral'></span>
 345 |     | <span class='neutral'>                // If fallback is frozen, just use lastGoodPrice</span>
 346 |     | <span class='neutral'>                if (_fallbackIsFrozen(fallbackResponse)) {</span>
 347 |     | <span class='neutral'>                    return INVALID_PRICE;</span>
 348 |     | <span class='neutral'>                }</span>
 349 |     | <span class='neutral'></span>
 350 |     | <span class='neutral'>                // otherwise fallback is working and keep using its latest response</span>
 351 |     | <span class='neutral'>                return _storeFallbackPrice(fallbackResponse);</span>
 352 |     | <span class='neutral'>            }</span>
 353 |     | <span class='neutral'></span>
 354 |     | <span class='neutral'>            // if Chainlink is live and Fallback is broken, remember Fallback broke, and return Chainlink price</span>
 355 |     | <span class='unexecuted'>            if (_fallbackIsBroken(fallbackResponse)) {</span>
 356 |     | <span class='unexecuted'>                _changeStatus(Status.usingChainlinkFallbackUntrusted);</span>
 357 |     | <span class='neutral'>                return _storeChainlinkPrice(chainlinkResponse.answer);</span>
 358 |     | <span class='neutral'>            }</span>
 359 |     | <span class='neutral'></span>
 360 |     | <span class='neutral'>            // If Chainlink is live and Fallback is frozen, just use last good price (no status change) since we have no basis for comparison</span>
 361 |     | <span class='unexecuted'>            if (_fallbackIsFrozen(fallbackResponse)) {</span>
 362 |     | <span class='unexecuted'>                return INVALID_PRICE;</span>
 363 |     | <span class='neutral'>            }</span>
 364 |     | <span class='neutral'></span>
 365 |     | <span class='neutral'>            // If Chainlink is live and Fallback is working, compare prices. Switch to Chainlink</span>
 366 |     | <span class='neutral'>            // if prices are within 5%, and return Chainlink price.</span>
 367 |     | <span class='unexecuted'>            if (_bothOraclesSimilarPrice(chainlinkResponse, fallbackResponse)) {</span>
 368 |     | <span class='unexecuted'>                _changeStatus(Status.chainlinkWorking);</span>
 369 |     | <span class='neutral'>                return _storeChainlinkPrice(chainlinkResponse.answer);</span>
 370 |     | <span class='neutral'>            }</span>
 371 |     | <span class='neutral'></span>
 372 |     | <span class='neutral'>            // Otherwise if Chainlink is live but price not within 5% of Fallback, distrust Chainlink, and return Fallback price</span>
 373 |     | <span class='neutral'>            _changeStatus(Status.usingFallbackChainlinkUntrusted);</span>
 374 |     | <span class='neutral'>            return _storeFallbackPrice(fallbackResponse);</span>
 375 |     | <span class='neutral'>        }</span>
 376 |     | <span class='neutral'></span>
 377 |     | <span class='neutral'>        // --- CASE 5: Using Chainlink, Fallback is untrusted ---</span>
 378 |     | <span class='unexecuted'>        if (status == Status.usingChainlinkFallbackUntrusted) {</span>
 379 |     | <span class='neutral'>            // If Chainlink breaks, now both oracles are untrusted</span>
 380 |     | <span class='unexecuted'>            if (_chainlinkIsBroken(chainlinkResponse, prevChainlinkResponse)) {</span>
 381 |     | <span class='unexecuted'>                _changeStatus(Status.bothOraclesUntrusted);</span>
 382 |     | <span class='neutral'>                return INVALID_PRICE;</span>
 383 |     | <span class='neutral'>            }</span>
 384 |     | <span class='neutral'></span>
 385 |     | <span class='neutral'>            // If Chainlink is frozen, return last good price (no status change)</span>
 386 |     | <span class='unexecuted'>            if (_chainlinkIsFrozen(chainlinkResponse)) {</span>
 387 |     | <span class='unexecuted'>                return INVALID_PRICE;</span>
 388 |     | <span class='neutral'>            }</span>
 389 |     | <span class='neutral'></span>
 390 |     | <span class='neutral'>            // If Chainlink is live but deviated &gt;50% from it&#39;s previous price and Fallback is still untrusted, switch</span>
 391 |     | <span class='neutral'>            // to bothOraclesUntrusted and return last good price</span>
 392 |     | <span class='unexecuted'>            if (_chainlinkPriceChangeAboveMax(chainlinkResponse, prevChainlinkResponse)) {</span>
 393 |     | <span class='unexecuted'>                _changeStatus(Status.bothOraclesUntrusted);</span>
 394 |     | <span class='neutral'>                return INVALID_PRICE;</span>
 395 |     | <span class='neutral'>            }</span>
 396 |     | <span class='neutral'></span>
 397 |     | <span class='neutral'>            // If Chainlink and Fallback are both live, unbroken and similar price, switch back to chainlinkWorking and return Chainlink price</span>
 398 |     | <span class='unexecuted'>            if (</span>
 399 |     | <span class='unexecuted'>                _bothOraclesLiveAndUnbrokenAndSimilarPrice(</span>
 400 |     | <span class='unexecuted'>                    chainlinkResponse,</span>
 401 |     | <span class='unexecuted'>                    prevChainlinkResponse,</span>
 402 |     | <span class='unexecuted'>                    fallbackResponse</span>
 403 |     | <span class='neutral'>                )</span>
 404 |     | <span class='neutral'>            ) {</span>
 405 |     | <span class='unexecuted'>                if (address(fallbackCaller) != address(0)) {</span>
 406 |     | <span class='unexecuted'>                    _changeStatus(Status.chainlinkWorking);</span>
 407 |     | <span class='neutral'>                }</span>
 408 |     | <span class='neutral'>                return _storeChainlinkPrice(chainlinkResponse.answer);</span>
 409 |     | <span class='neutral'>            }</span>
 410 |     | <span class='neutral'></span>
 411 |     | <span class='neutral'>            // Otherwise if Chainlink is live and deviated &lt;50% from it&#39;s previous price and Fallback is still untrusted,</span>
 412 |     | <span class='neutral'>            // return Chainlink price (no status change)</span>
 413 |     | <span class='neutral'>            return _storeChainlinkPrice(chainlinkResponse.answer);</span>
 414 |     | <span class='neutral'>        }</span>
 415 |     | <span class='neutral'></span>
 416 |     | <span class='neutral'>        /// @audit This should never be used, but we added it for the Certora Prover</span>
 417 |     | <span class='neutral'>        return INVALID_PRICE;</span>
 418 |     | <span class='neutral'>    }</span>
 419 |     | <span class='neutral'></span>
 420 |     | <span class='neutral'>    // --- Governance Functions ---</span>
 421 |     | <span class='neutral'>    /// @notice Sets a new fallback oracle</span>
 422 |     | <span class='neutral'>    /// @dev Healthy response of new oracle is checked, with extra event emitted on failure</span>
 423 |     | <span class='neutral'>    /// @param _fallbackCaller The address of the new IFallbackCaller compliant oracle\</span>
 424 |     | <span class='unexecuted'>    function setFallbackCaller(address _fallbackCaller) external requiresAuth {</span>
 425 |     | <span class='neutral'>        // health check-up before officially set it up</span>
 426 |     | <span class='unexecuted'>        IFallbackCaller newFallbackCaler = IFallbackCaller(_fallbackCaller);</span>
 427 |     | <span class='neutral'>        FallbackResponse memory fallbackResponse;</span>
 428 |     | <span class='neutral'></span>
 429 |     | <span class='unexecuted'>        if (_fallbackCaller != address(0)) {</span>
 430 |     | <span class='unexecuted'>            try newFallbackCaler.getFallbackResponse() returns (</span>
 431 |     | <span class='neutral'>                uint256 answer,</span>
 432 |     | <span class='neutral'>                uint256 timestampRetrieved,</span>
 433 |     | <span class='neutral'>                bool success</span>
 434 |     | <span class='neutral'>            ) {</span>
 435 |     | <span class='unexecuted'>                fallbackResponse.answer = answer;</span>
 436 |     | <span class='unexecuted'>                fallbackResponse.timestamp = timestampRetrieved;</span>
 437 |     | <span class='unexecuted'>                fallbackResponse.success = success;</span>
 438 |     | <span class='unexecuted'>                if (</span>
 439 |     | <span class='unexecuted'>                    !_fallbackIsBroken(fallbackResponse) &amp;&amp;</span>
 440 |     | <span class='unexecuted'>                    !_responseTimeout(fallbackResponse.timestamp, newFallbackCaler.fallbackTimeout())</span>
 441 |     | <span class='unexecuted'>                ) {</span>
 442 |     | <span class='unexecuted'>                    address oldFallbackCaller = address(fallbackCaller);</span>
 443 |     | <span class='unexecuted'>                    fallbackCaller = newFallbackCaler;</span>
 444 |     | <span class='unexecuted'>                    emit FallbackCallerChanged(oldFallbackCaller, _fallbackCaller);</span>
 445 |     | <span class='neutral'>                }</span>
 446 |     | <span class='neutral'>            } catch {</span>
 447 |     | <span class='unexecuted'>                emit UnhealthyFallbackCaller(_fallbackCaller, block.timestamp);</span>
 448 |     | <span class='neutral'>            }</span>
 449 |     | <span class='unexecuted'>        } else {</span>
 450 |     | <span class='unexecuted'>            address oldFallbackCaller = address(fallbackCaller);</span>
 451 |     | <span class='neutral'>            // NOTE: assume intentionally bricking fallback!!!</span>
 452 |     | <span class='unexecuted'>            fallbackCaller = newFallbackCaler;</span>
 453 |     | <span class='unexecuted'>            emit FallbackCallerChanged(oldFallbackCaller, _fallbackCaller);</span>
 454 |     | <span class='neutral'>        }</span>
 455 |     | <span class='neutral'>    }</span>
 456 |     | <span class='neutral'></span>
 457 |     | <span class='neutral'>    // --- Helper functions ---</span>
 458 |     | <span class='neutral'></span>
 459 |     | <span class='neutral'>    /// @notice Checks if Chainlink oracle is broken by checking both the current and previous responses</span>
 460 |     | <span class='neutral'>    /// @dev Chainlink is considered broken if its current or previous round data is in any way bad. We check the previous round for two reasons.</span>
 461 |     | <span class='neutral'>    /// @dev 1. It is necessary data for the price deviation check in case 1</span>
 462 |     | <span class='neutral'>    /// @dev 2. Chainlink is the PriceFeed&#39;s preferred primary oracle - having two consecutive valid round responses adds peace of mind when using or returning to Chainlink.</span>
 463 |     | <span class='neutral'>    /// @param _currentResponse The latest response from the Chainlink oracle</span>
 464 |     | <span class='neutral'>    /// @param _prevResponse The previous response from the Chainlink oracle</span>
 465 |     | <span class='neutral'>    /// @return A boolean indicating whether the Chainlink oracle is broken</span>
 466 |     | <span class='unexecuted'>    function _chainlinkIsBroken(</span>
 467 |     | <span class='neutral'>        ChainlinkResponse memory _currentResponse,</span>
 468 |     | <span class='neutral'>        ChainlinkResponse memory _prevResponse</span>
 469 |     | <span class='unexecuted'>    ) internal view returns (bool) {</span>
 470 |     | <span class='unexecuted'>        return _badChainlinkResponse(_currentResponse) || _badChainlinkResponse(_prevResponse);</span>
 471 |     | <span class='neutral'>    }</span>
 472 |     | <span class='neutral'></span>
 473 |     | <span class='neutral'>    /// @notice Checks for a bad response from the Chainlink oracle</span>
 474 |     | <span class='neutral'>    /// @dev A response is considered bad if the success value reports failure, or if the timestamp is invalid (0 or in the future)</span>
 475 |     | <span class='neutral'>    /// @param _response The response from the Chainlink oracle to evaluate</span>
 476 |     | <span class='neutral'>    /// @return A boolean indicating whether the Chainlink oracle response is bad</span>
 477 |     | <span class='neutral'></span>
 478 |     | <span class='unexecuted'>    function _badChainlinkResponse(ChainlinkResponse memory _response) internal view returns (bool) {</span>
 479 |     | <span class='neutral'>        // Check for response call reverted</span>
 480 |     | <span class='unexecuted'>        if (!_response.success) {</span>
 481 |     | <span class='unexecuted'>            return true;</span>
 482 |     | <span class='neutral'>        }</span>
 483 |     | <span class='neutral'></span>
 484 |     | <span class='neutral'>        // Check for an invalid timestamp that is 0, or in the future</span>
 485 |     | <span class='unexecuted'>        if (</span>
 486 |     | <span class='unexecuted'>            _response.timestampEthBtc == 0 ||</span>
 487 |     | <span class='unexecuted'>            _response.timestampEthBtc &gt; block.timestamp ||</span>
 488 |     | <span class='unexecuted'>            _response.timestampStEthEth == 0 ||</span>
 489 |     | <span class='unexecuted'>            _response.timestampStEthEth &gt; block.timestamp</span>
 490 |     | <span class='neutral'>        ) {</span>
 491 |     | <span class='unexecuted'>            return true;</span>
 492 |     | <span class='neutral'>        }</span>
 493 |     | <span class='neutral'></span>
 494 |     | <span class='unexecuted'>        return false;</span>
 495 |     | <span class='neutral'>    }</span>
 496 |     | <span class='neutral'></span>
 497 |     | <span class='neutral'>    /// @notice Checks if the Chainlink oracle is frozen</span>
 498 |     | <span class='neutral'>    /// @dev The oracle is considered frozen if either of the feed timestamps are older than the threshold specified by the static timeout thresholds</span>
 499 |     | <span class='neutral'>    /// @param _response The response from the Chainlink oracle to evaluate</span>
 500 |     | <span class='neutral'>    /// @return A boolean indicating whether the Chainlink oracle is frozen</span>
 501 |     | <span class='unexecuted'>    function _chainlinkIsFrozen(ChainlinkResponse memory _response) internal view returns (bool) {</span>
 502 |     | <span class='neutral'>        return</span>
 503 |     | <span class='unexecuted'>            _responseTimeout(_response.timestampEthBtc, TIMEOUT_ETH_BTC_FEED) ||</span>
 504 |     | <span class='unexecuted'>            _responseTimeout(_response.timestampStEthEth, TIMEOUT_STETH_ETH_FEED);</span>
 505 |     | <span class='neutral'>    }</span>
 506 |     | <span class='neutral'></span>
 507 |     | <span class='neutral'>    /// @notice Checks if the price change between Chainlink oracle rounds is above the maximum threshold allowed</span>
 508 |     | <span class='neutral'>    /// @param _currentResponse The latest response from the Chainlink oracle</span>
 509 |     | <span class='neutral'>    /// @param _prevResponse The previous response from the Chainlink oracle</span>
 510 |     | <span class='neutral'>    /// @return A boolean indicating whether the price change from Chainlink oracle is above the maximum threshold allowed</span>
 511 |     | <span class='unexecuted'>    function _chainlinkPriceChangeAboveMax(</span>
 512 |     | <span class='neutral'>        ChainlinkResponse memory _currentResponse,</span>
 513 |     | <span class='neutral'>        ChainlinkResponse memory _prevResponse</span>
 514 |     | <span class='unexecuted'>    ) internal pure returns (bool) {</span>
 515 |     | <span class='unexecuted'>        uint256 minPrice = EbtcMath._min(_currentResponse.answer, _prevResponse.answer);</span>
 516 |     | <span class='unexecuted'>        uint256 maxPrice = EbtcMath._max(_currentResponse.answer, _prevResponse.answer);</span>
 517 |     | <span class='neutral'></span>
 518 |     | <span class='neutral'>        /*</span>
 519 |     | <span class='neutral'>         * Use the larger price as the denominator:</span>
 520 |     | <span class='neutral'>         * - If price decreased, the percentage deviation is in relation to the the previous price.</span>
 521 |     | <span class='neutral'>         * - If price increased, the percentage deviation is in relation to the current price.</span>
 522 |     | <span class='neutral'>         */</span>
 523 |     | <span class='unexecuted'>        uint256 percentDeviation = maxPrice &gt; 0</span>
 524 |     | <span class='unexecuted'>            ? ((maxPrice - minPrice) * EbtcMath.DECIMAL_PRECISION) / maxPrice</span>
 525 |     | <span class='unexecuted'>            : 0;</span>
 526 |     | <span class='neutral'></span>
 527 |     | <span class='neutral'>        // Return true if price has more than doubled, or more than halved.</span>
 528 |     | <span class='neutral'>        return percentDeviation &gt; MAX_PRICE_DEVIATION_FROM_PREVIOUS_ROUND;</span>
 529 |     | <span class='neutral'>    }</span>
 530 |     | <span class='neutral'></span>
 531 |     | <span class='unexecuted'>    function _fallbackIsBroken(FallbackResponse memory _response) internal view returns (bool) {</span>
 532 |     | <span class='neutral'>        // Check for response call reverted</span>
 533 |     | <span class='unexecuted'>        if (!_response.success) {</span>
 534 |     | <span class='unexecuted'>            return true;</span>
 535 |     | <span class='neutral'>        }</span>
 536 |     | <span class='neutral'>        // Check for an invalid timeStamp that is 0, or in the future</span>
 537 |     | <span class='unexecuted'>        if (_response.timestamp == 0 || _response.timestamp &gt; block.timestamp) {</span>
 538 |     | <span class='unexecuted'>            return true;</span>
 539 |     | <span class='neutral'>        }</span>
 540 |     | <span class='neutral'>        // Check for zero price (FallbackCaller must ensure that the price is not negative and return 0 if it is)</span>
 541 |     | <span class='unexecuted'>        if (_response.answer == 0) {</span>
 542 |     | <span class='unexecuted'>            return true;</span>
 543 |     | <span class='neutral'>        }</span>
 544 |     | <span class='neutral'></span>
 545 |     | <span class='unexecuted'>        return false;</span>
 546 |     | <span class='neutral'>    }</span>
 547 |     | <span class='neutral'></span>
 548 |     | <span class='neutral'>    /// @notice Checks if the fallback oracle is frozen by comparing the current timestamp with the timeout value.</span>
 549 |     | <span class='neutral'>    /// @param _fallbackResponse Response from the fallback oracle to check</span>
 550 |     | <span class='neutral'>    /// @return A boolean indicating whether the fallback oracle is frozen.</span>
 551 |     | <span class='unexecuted'>    function _fallbackIsFrozen(</span>
 552 |     | <span class='neutral'>        FallbackResponse memory _fallbackResponse</span>
 553 |     | <span class='unexecuted'>    ) internal view returns (bool) {</span>
 554 |     | <span class='neutral'>        return</span>
 555 |     | <span class='unexecuted'>            _fallbackResponse.timestamp &gt; 0 &amp;&amp;</span>
 556 |     | <span class='unexecuted'>            _responseTimeout(_fallbackResponse.timestamp, fallbackCaller.fallbackTimeout());</span>
 557 |     | <span class='neutral'>    }</span>
 558 |     | <span class='neutral'></span>
 559 |     | <span class='unexecuted'>    function _responseTimeout(uint256 _timestamp, uint256 _timeout) internal view returns (bool) {</span>
 560 |     | <span class='unexecuted'>        return block.timestamp - _timestamp &gt; _timeout;</span>
 561 |     | <span class='neutral'>    }</span>
 562 |     | <span class='neutral'></span>
 563 |     | <span class='neutral'>    /// @notice Checks if both the Chainlink and fallback oracles are live, unbroken, and reporting similar prices.</span>
 564 |     | <span class='neutral'>    /// @param _chainlinkResponse The latest response from the Chainlink oracle.</span>
 565 |     | <span class='neutral'>    /// @param _prevChainlinkResponse The previous response from the Chainlink oracle.</span>
 566 |     | <span class='neutral'>    /// @param _fallbackResponse The latest response from the fallback oracle.</span>
 567 |     | <span class='neutral'>    /// @return A boolean indicating whether both oracles are live, unbroken, and reporting similar prices.</span>
 568 |     | <span class='neutral'></span>
 569 |     | <span class='unexecuted'>    function _bothOraclesLiveAndUnbrokenAndSimilarPrice(</span>
 570 |     | <span class='neutral'>        ChainlinkResponse memory _chainlinkResponse,</span>
 571 |     | <span class='neutral'>        ChainlinkResponse memory _prevChainlinkResponse,</span>
 572 |     | <span class='neutral'>        FallbackResponse memory _fallbackResponse</span>
 573 |     | <span class='unexecuted'>    ) internal view returns (bool) {</span>
 574 |     | <span class='neutral'>        // Return false if either oracle is broken or frozen</span>
 575 |     | <span class='unexecuted'>        if (</span>
 576 |     | <span class='unexecuted'>            (address(fallbackCaller) != address(0) &amp;&amp;</span>
 577 |     | <span class='unexecuted'>                (_fallbackIsBroken(_fallbackResponse) || _fallbackIsFrozen(_fallbackResponse))) ||</span>
 578 |     | <span class='unexecuted'>            _chainlinkIsBroken(_chainlinkResponse, _prevChainlinkResponse) ||</span>
 579 |     | <span class='unexecuted'>            _chainlinkIsFrozen(_chainlinkResponse)</span>
 580 |     | <span class='neutral'>        ) {</span>
 581 |     | <span class='unexecuted'>            return false;</span>
 582 |     | <span class='neutral'>        }</span>
 583 |     | <span class='neutral'></span>
 584 |     | <span class='unexecuted'>        return _bothOraclesSimilarPrice(_chainlinkResponse, _fallbackResponse);</span>
 585 |     | <span class='neutral'>    }</span>
 586 |     | <span class='neutral'></span>
 587 |     | <span class='neutral'>    /// @notice Checks if the prices reported by the Chainlink and fallback oracles are similar, within the maximum deviation specified by MAX_PRICE_DIFFERENCE_BETWEEN_ORACLES.</span>
 588 |     | <span class='neutral'>    /// @param _chainlinkResponse The response from the Chainlink oracle.</span>
 589 |     | <span class='neutral'>    /// @param _fallbackResponse The response from the fallback oracle.</span>
 590 |     | <span class='neutral'>    /// @return A boolean indicating whether the prices reported by both oracles are similar.</span>
 591 |     | <span class='neutral'></span>
 592 |     | <span class='unexecuted'>    function _bothOraclesSimilarPrice(</span>
 593 |     | <span class='neutral'>        ChainlinkResponse memory _chainlinkResponse,</span>
 594 |     | <span class='neutral'>        FallbackResponse memory _fallbackResponse</span>
 595 |     | <span class='unexecuted'>    ) internal view returns (bool) {</span>
 596 |     | <span class='unexecuted'>        if (address(fallbackCaller) == address(0)) {</span>
 597 |     | <span class='unexecuted'>            return true;</span>
 598 |     | <span class='neutral'>        }</span>
 599 |     | <span class='neutral'>        // Get the relative price difference between the oracles. Use the lower price as the denominator, i.e. the reference for the calculation.</span>
 600 |     | <span class='unexecuted'>        uint256 minPrice = EbtcMath._min(_fallbackResponse.answer, _chainlinkResponse.answer);</span>
 601 |     | <span class='unexecuted'>        if (minPrice == 0) return false;</span>
 602 |     | <span class='unexecuted'>        uint256 maxPrice = EbtcMath._max(_fallbackResponse.answer, _chainlinkResponse.answer);</span>
 603 |     | <span class='unexecuted'>        uint256 percentPriceDifference = ((maxPrice - minPrice) * EbtcMath.DECIMAL_PRECISION) /</span>
 604 |     | <span class='unexecuted'>            minPrice;</span>
 605 |     | <span class='neutral'></span>
 606 |     | <span class='neutral'>        /*</span>
 607 |     | <span class='neutral'>         * Return true if the relative price difference is &lt;= MAX_PRICE_DIFFERENCE_BETWEEN_ORACLES: if so, we assume both oracles are probably reporting</span>
 608 |     | <span class='neutral'>         * the honest market price, as it is unlikely that both have been broken/hacked and are still in-sync.</span>
 609 |     | <span class='neutral'>         */</span>
 610 |     | <span class='unexecuted'>        return percentPriceDifference &lt;= MAX_PRICE_DIFFERENCE_BETWEEN_ORACLES;</span>
 611 |     | <span class='neutral'>    }</span>
 612 |     | <span class='neutral'></span>
 613 |     | <span class='neutral'>    /// @notice Changes the status of the oracle state machine</span>
 614 |     | <span class='neutral'>    /// @param _status The new status of the contract.</span>
 615 |     | <span class='unexecuted'>    function _changeStatus(Status _status) internal {</span>
 616 |     | <span class='unexecuted'>        status = _status;</span>
 617 |     | <span class='unexecuted'>        emit PriceFeedStatusChanged(_status);</span>
 618 |     | <span class='neutral'>    }</span>
 619 |     | <span class='neutral'></span>
 620 |     | <span class='neutral'>    /// @notice Stores the latest valid price.</span>
 621 |     | <span class='neutral'>    /// @param _currentPrice The price to be stored.</span>
 622 |     | <span class='unexecuted'>    function _storePrice(uint256 _currentPrice) internal {</span>
 623 |     | <span class='unexecuted'>        emit LastGoodPriceUpdated(_currentPrice);</span>
 624 |     | <span class='neutral'>    }</span>
 625 |     | <span class='neutral'></span>
 626 |     | <span class='neutral'>    /// @notice Stores the price reported by the fallback oracle.</span>
 627 |     | <span class='neutral'>    /// @param _fallbackResponse The latest response from the fallback oracle.</span>
 628 |     | <span class='neutral'>    /// @return The price reported by the fallback oracle.</span>
 629 |     | <span class='unexecuted'>    function _storeFallbackPrice(</span>
 630 |     | <span class='neutral'>        FallbackResponse memory _fallbackResponse</span>
 631 |     | <span class='unexecuted'>    ) internal returns (uint256) {</span>
 632 |     | <span class='unexecuted'>        _storePrice(_fallbackResponse.answer);</span>
 633 |     | <span class='unexecuted'>        return _fallbackResponse.answer;</span>
 634 |     | <span class='neutral'>    }</span>
 635 |     | <span class='neutral'></span>
 636 |     | <span class='neutral'>    /// @notice Stores the price reported by the Chainlink oracle.</span>
 637 |     | <span class='neutral'>    /// @param _answer The latest price reported by the Chainlink oracle.</span>
 638 |     | <span class='neutral'>    /// @return The price reported by the Chainlink oracle.</span>
 639 |     | <span class='unexecuted'>    function _storeChainlinkPrice(uint256 _answer) internal returns (uint256) {</span>
 640 |     | <span class='unexecuted'>        _storePrice(_answer);</span>
 641 |     | <span class='unexecuted'>        return _answer;</span>
 642 |     | <span class='neutral'>    }</span>
 643 |     | <span class='neutral'></span>
 644 |     | <span class='neutral'>    // --- Oracle response wrapper functions ---</span>
 645 |     | <span class='neutral'></span>
 646 |     | <span class='neutral'>    /// @notice Retrieves the latest response from the fallback oracle. If the fallback oracle address is set to the zero address, it returns a failing struct.</span>
 647 |     | <span class='neutral'>    /// @return fallbackResponse The latest response from the fallback oracle.</span>
 648 |     | <span class='neutral'></span>
 649 |     | <span class='unexecuted'>    function _getCurrentFallbackResponse()</span>
 650 |     | <span class='neutral'>        internal</span>
 651 |     | <span class='neutral'>        view</span>
 652 |     | <span class='unexecuted'>        returns (FallbackResponse memory fallbackResponse)</span>
 653 |     | <span class='neutral'>    {</span>
 654 |     | <span class='unexecuted'>        if (address(fallbackCaller) != address(0)) {</span>
 655 |     | <span class='unexecuted'>            try fallbackCaller.getFallbackResponse() returns (</span>
 656 |     | <span class='neutral'>                uint256 answer,</span>
 657 |     | <span class='neutral'>                uint256 timestampRetrieved,</span>
 658 |     | <span class='neutral'>                bool success</span>
 659 |     | <span class='neutral'>            ) {</span>
 660 |     | <span class='unexecuted'>                fallbackResponse.answer = answer;</span>
 661 |     | <span class='unexecuted'>                fallbackResponse.timestamp = timestampRetrieved;</span>
 662 |     | <span class='unexecuted'>                fallbackResponse.success = success;</span>
 663 |     | <span class='neutral'>            } catch {</span>
 664 |     | <span class='neutral'>                // If call to Fallback reverts, return a zero response with success = false</span>
 665 |     | <span class='neutral'>            }</span>
 666 |     | <span class='neutral'>        } // If unset we return a zero response with success = false</span>
 667 |     | <span class='neutral'></span>
 668 |     | <span class='neutral'>        // Return is implicit</span>
 669 |     | <span class='neutral'>    }</span>
 670 |     | <span class='neutral'></span>
 671 |     | <span class='unexecuted'>    function _collateralFeed() private view returns (AggregatorV3Interface) {</span>
 672 |     | <span class='unexecuted'>        return useDynamicFeed ? STETH_ETH_CL_FEED : STETH_ETH_FIXED_FEED;</span>
 673 |     | <span class='neutral'>    }</span>
 674 |     | <span class='neutral'></span>
 675 |     | <span class='neutral'>    /// @notice Fetches Chainlink responses for the current round of data for both ETH-BTC and stETH-ETH price feeds.</span>
 676 |     | <span class='neutral'>    /// @return chainlinkResponse A struct containing data retrieved from the price feeds, including the round IDs, timestamps, aggregated price, and a success flag.</span>
 677 |     | <span class='unexecuted'>    function _getCurrentChainlinkResponse()</span>
 678 |     | <span class='neutral'>        internal</span>
 679 |     | <span class='neutral'>        view</span>
 680 |     | <span class='unexecuted'>        returns (ChainlinkResponse memory chainlinkResponse)</span>
 681 |     | <span class='neutral'>    {</span>
 682 |     | <span class='neutral'>        // Try to get latest prices data:</span>
 683 |     | <span class='unexecuted'>        int256 ethBtcAnswer;</span>
 684 |     | <span class='unexecuted'>        int256 stEthEthAnswer;</span>
 685 |     | <span class='unexecuted'>        try ETH_BTC_CL_FEED.latestRoundData() returns (</span>
 686 |     | <span class='neutral'>            uint80 roundId,</span>
 687 |     | <span class='neutral'>            int256 answer,</span>
 688 |     | <span class='neutral'>            uint256,</span>
 689 |     | <span class='neutral'>            /* startedAt */</span>
 690 |     | <span class='neutral'>            uint256 timestamp,</span>
 691 |     | <span class='neutral'>            uint80 /* answeredInRound */</span>
 692 |     | <span class='neutral'>        ) {</span>
 693 |     | <span class='unexecuted'>            ethBtcAnswer = answer;</span>
 694 |     | <span class='unexecuted'>            chainlinkResponse.roundEthBtcId = roundId;</span>
 695 |     | <span class='unexecuted'>            chainlinkResponse.timestampEthBtc = timestamp;</span>
 696 |     | <span class='neutral'>        } catch {</span>
 697 |     | <span class='neutral'>            // If call to Chainlink aggregator reverts, return a zero response with success = false</span>
 698 |     | <span class='unexecuted'>            return chainlinkResponse;</span>
 699 |     | <span class='neutral'>        }</span>
 700 |     | <span class='neutral'></span>
 701 |     | <span class='unexecuted'>        try _collateralFeed().latestRoundData() returns (</span>
 702 |     | <span class='neutral'>            uint80 roundId,</span>
 703 |     | <span class='neutral'>            int256 answer,</span>
 704 |     | <span class='neutral'>            uint256,</span>
 705 |     | <span class='neutral'>            /* startedAt */</span>
 706 |     | <span class='neutral'>            uint256 timestamp,</span>
 707 |     | <span class='neutral'>            uint80 /* answeredInRound */</span>
 708 |     | <span class='neutral'>        ) {</span>
 709 |     | <span class='unexecuted'>            stEthEthAnswer = answer;</span>
 710 |     | <span class='unexecuted'>            chainlinkResponse.roundStEthEthId = roundId;</span>
 711 |     | <span class='unexecuted'>            chainlinkResponse.timestampStEthEth = timestamp;</span>
 712 |     | <span class='neutral'>        } catch {</span>
 713 |     | <span class='neutral'>            // If call to Chainlink aggregator reverts, return a zero response with success = false</span>
 714 |     | <span class='unexecuted'>            return chainlinkResponse;</span>
 715 |     | <span class='neutral'>        }</span>
 716 |     | <span class='neutral'></span>
 717 |     | <span class='unexecuted'>        if (</span>
 718 |     | <span class='unexecuted'>            _checkHealthyCLResponse(chainlinkResponse.roundEthBtcId, ethBtcAnswer) &amp;&amp;</span>
 719 |     | <span class='unexecuted'>            _checkHealthyCLResponse(chainlinkResponse.roundStEthEthId, stEthEthAnswer)</span>
 720 |     | <span class='neutral'>        ) {</span>
 721 |     | <span class='unexecuted'>            chainlinkResponse.answer = _formatClAggregateAnswer(ethBtcAnswer, stEthEthAnswer);</span>
 722 |     | <span class='neutral'>        } else {</span>
 723 |     | <span class='unexecuted'>            return chainlinkResponse;</span>
 724 |     | <span class='neutral'>        }</span>
 725 |     | <span class='neutral'></span>
 726 |     | <span class='unexecuted'>        chainlinkResponse.success = true;</span>
 727 |     | <span class='neutral'>    }</span>
 728 |     | <span class='neutral'></span>
 729 |     | <span class='neutral'>    /// @notice Returns if the CL feed is healthy or not, based on: negative value and null round id. For price aggregation</span>
 730 |     | <span class='neutral'>    /// @param _roundId The aggregator round of the target CL feed</span>
 731 |     | <span class='neutral'>    /// @param _answer CL price price reported for target feeds</span>
 732 |     | <span class='neutral'>    /// @return The boolean state indicating CL response health for aggregation</span>
 733 |     | <span class='unexecuted'>    function _checkHealthyCLResponse(uint80 _roundId, int256 _answer) internal view returns (bool) {</span>
 734 |     | <span class='unexecuted'>        if (_answer &lt;= 0) return false;</span>
 735 |     | <span class='unexecuted'>        if (_roundId == 0) return false;</span>
 736 |     | <span class='neutral'></span>
 737 |     | <span class='unexecuted'>        return true;</span>
 738 |     | <span class='neutral'>    }</span>
 739 |     | <span class='neutral'></span>
 740 |     | <span class='neutral'>    /// @notice Fetches Chainlink responses for the previous round of data for both ETH-BTC and stETH-ETH price feeds.</span>
 741 |     | <span class='neutral'>    /// @param _currentRoundEthBtcId The current round ID for the ETH-BTC price feed.</span>
 742 |     | <span class='neutral'>    /// @param _currentRoundStEthEthId The current round ID for the stETH-ETH price feed.</span>
 743 |     | <span class='neutral'>    /// @return prevChainlinkResponse A struct containing data retrieved from the price feeds, including the round IDs, timestamps, aggregated price, and a success flag.</span>
 744 |     | <span class='unexecuted'>    function _getPrevChainlinkResponse(</span>
 745 |     | <span class='neutral'>        uint80 _currentRoundEthBtcId,</span>
 746 |     | <span class='neutral'>        uint80 _currentRoundStEthEthId</span>
 747 |     | <span class='unexecuted'>    ) internal view returns (ChainlinkResponse memory prevChainlinkResponse) {</span>
 748 |     | <span class='neutral'>        // If first round, early return</span>
 749 |     | <span class='neutral'>        // Handles revert from underflow in _currentRoundEthBtcId - 1</span>
 750 |     | <span class='neutral'>        // and _currentRoundStEthEthId - 1</span>
 751 |     | <span class='neutral'>        // Behavior should be indentical to following block if this revert was caught</span>
 752 |     | <span class='unexecuted'>        if (_currentRoundEthBtcId == 0 || _currentRoundStEthEthId == 0) {</span>
 753 |     | <span class='unexecuted'>            return prevChainlinkResponse;</span>
 754 |     | <span class='neutral'>        }</span>
 755 |     | <span class='neutral'></span>
 756 |     | <span class='neutral'>        // Try to get latest prices data from prev round:</span>
 757 |     | <span class='unexecuted'>        int256 ethBtcAnswer;</span>
 758 |     | <span class='unexecuted'>        int256 stEthEthAnswer;</span>
 759 |     | <span class='unexecuted'>        try ETH_BTC_CL_FEED.getRoundData(_currentRoundEthBtcId - 1) returns (</span>
 760 |     | <span class='neutral'>            uint80 roundId,</span>
 761 |     | <span class='neutral'>            int256 answer,</span>
 762 |     | <span class='neutral'>            uint256,</span>
 763 |     | <span class='neutral'>            /* startedAt */</span>
 764 |     | <span class='neutral'>            uint256 timestamp,</span>
 765 |     | <span class='neutral'>            uint80 /* answeredInRound */</span>
 766 |     | <span class='neutral'>        ) {</span>
 767 |     | <span class='unexecuted'>            ethBtcAnswer = answer;</span>
 768 |     | <span class='unexecuted'>            prevChainlinkResponse.roundEthBtcId = roundId;</span>
 769 |     | <span class='unexecuted'>            prevChainlinkResponse.timestampEthBtc = timestamp;</span>
 770 |     | <span class='neutral'>        } catch {</span>
 771 |     | <span class='neutral'>            // If call to Chainlink aggregator reverts, return a zero response with success = false</span>
 772 |     | <span class='unexecuted'>            return prevChainlinkResponse;</span>
 773 |     | <span class='neutral'>        }</span>
 774 |     | <span class='neutral'></span>
 775 |     | <span class='unexecuted'>        try _collateralFeed().getRoundData(_currentRoundStEthEthId - 1) returns (</span>
 776 |     | <span class='neutral'>            uint80 roundId,</span>
 777 |     | <span class='neutral'>            int256 answer,</span>
 778 |     | <span class='neutral'>            uint256,</span>
 779 |     | <span class='neutral'>            /* startedAt */</span>
 780 |     | <span class='neutral'>            uint256 timestamp,</span>
 781 |     | <span class='neutral'>            uint80 /* answeredInRound */</span>
 782 |     | <span class='neutral'>        ) {</span>
 783 |     | <span class='unexecuted'>            stEthEthAnswer = answer;</span>
 784 |     | <span class='unexecuted'>            prevChainlinkResponse.roundStEthEthId = roundId;</span>
 785 |     | <span class='unexecuted'>            prevChainlinkResponse.timestampStEthEth = timestamp;</span>
 786 |     | <span class='neutral'>        } catch {</span>
 787 |     | <span class='neutral'>            // If call to Chainlink aggregator reverts, return a zero response with success = false</span>
 788 |     | <span class='unexecuted'>            return prevChainlinkResponse;</span>
 789 |     | <span class='neutral'>        }</span>
 790 |     | <span class='neutral'></span>
 791 |     | <span class='unexecuted'>        if (</span>
 792 |     | <span class='unexecuted'>            _checkHealthyCLResponse(prevChainlinkResponse.roundEthBtcId, ethBtcAnswer) &amp;&amp;</span>
 793 |     | <span class='unexecuted'>            _checkHealthyCLResponse(prevChainlinkResponse.roundStEthEthId, stEthEthAnswer)</span>
 794 |     | <span class='neutral'>        ) {</span>
 795 |     | <span class='unexecuted'>            prevChainlinkResponse.answer = _formatClAggregateAnswer(ethBtcAnswer, stEthEthAnswer);</span>
 796 |     | <span class='neutral'>        } else {</span>
 797 |     | <span class='unexecuted'>            return prevChainlinkResponse;</span>
 798 |     | <span class='neutral'>        }</span>
 799 |     | <span class='neutral'></span>
 800 |     | <span class='unexecuted'>        prevChainlinkResponse.success = true;</span>
 801 |     | <span class='neutral'>    }</span>
 802 |     | <span class='neutral'></span>
 803 |     | <span class='neutral'>    // @notice Returns the price of stETH:BTC in 18 decimals denomination</span>
 804 |     | <span class='neutral'>    // @param _ethBtcAnswer CL price retrieve from ETH:BTC feed</span>
 805 |     | <span class='neutral'>    // @param _stEthEthAnswer CL price retrieve from stETH:BTC feed</span>
 806 |     | <span class='neutral'>    // @return The aggregated calculated price for stETH:BTC</span>
 807 |     | <span class='unexecuted'>    function _formatClAggregateAnswer(</span>
 808 |     | <span class='neutral'>        int256 _ethBtcAnswer,</span>
 809 |     | <span class='neutral'>        int256 _stEthEthAnswer</span>
 810 |     | <span class='unexecuted'>    ) internal view returns (uint256) {</span>
 811 |     | <span class='neutral'>        return</span>
 812 |     | <span class='unexecuted'>            (SCALED_DECIMAL *</span>
 813 |     | <span class='unexecuted'>                uint256(_ethBtcAnswer) *</span>
 814 |     | <span class='unexecuted'>                uint256(_stEthEthAnswer) *</span>
 815 |     | <span class='unexecuted'>                EbtcMath.DECIMAL_PRECISION) / DENOMINATOR;</span>
 816 |     | <span class='neutral'>    }</span>
 817 |     | <span class='neutral'>}</span>
 818 |     | <span class='neutral'></span>

</code>
<br />

<b>/mnt/c/Users/Lourens/Documents/Recon-Fuzz/collabs/ebtc/packages/contracts/contracts/SortedCdps.sol</b>
<code>
   1 |     | <span class='neutral'>// SPDX-License-Identifier: MIT</span>
   2 |     | <span class='neutral'></span>
   3 |     | <span class='neutral'>pragma solidity 0.8.17;</span>
   4 |     | <span class='neutral'></span>
   5 |     | <span class='neutral'>import &quot;./Interfaces/ISortedCdps.sol&quot;;</span>
   6 |     | <span class='neutral'>import &quot;./Interfaces/ICdpManager.sol&quot;;</span>
   7 |     | <span class='neutral'>import &quot;./Interfaces/IBorrowerOperations.sol&quot;;</span>
   8 |     | <span class='neutral'></span>
   9 |     | <span class='neutral'>/*</span>
  10 |     | <span class='neutral'> * A sorted doubly linked list with nodes sorted in descending order.</span>
  11 |     | <span class='neutral'> *</span>
  12 |     | <span class='neutral'> * Nodes map to active Cdps in the system by Id.</span>
  13 |     | <span class='neutral'> * Nodes are ordered according to their current nominal individual collateral ratio (NICR),</span>
  14 |     | <span class='neutral'> * which is like the ICR but without the price, i.e., just collateral / debt.</span>
  15 |     | <span class='neutral'> *</span>
  16 |     | <span class='neutral'> * The list optionally accepts insert position hints.</span>
  17 |     | <span class='neutral'> *</span>
  18 |     | <span class='neutral'> * NICRs are computed dynamically at runtime, and not stored on the Node. This is because NICRs of active Cdps</span>
  19 |     | <span class='neutral'> * change dynamically as liquidation events occur.</span>
  20 |     | <span class='neutral'> *</span>
  21 |     | <span class='neutral'> * The list relies on the fact that liquidation events preserve ordering: a liquidation decreases the NICRs of all active Cdps,</span>
  22 |     | <span class='neutral'> * but maintains their order. A node inserted based on current NICR will maintain the correct position,</span>
  23 |     | <span class='neutral'> * relative to it&#39;s peers, as rewards accumulate, as long as it&#39;s raw collateral and debt have not changed.</span>
  24 |     | <span class='neutral'> * Thus, Nodes remain sorted by current NICR.</span>
  25 |     | <span class='neutral'> *</span>
  26 |     | <span class='neutral'> * Nodes need only be re-inserted upon a CDP operation - when the owner adds or removes collateral or debt</span>
  27 |     | <span class='neutral'> * to their position.</span>
  28 |     | <span class='neutral'> *</span>
  29 |     | <span class='neutral'> * The list is a modification of the following audited SortedDoublyLinkedList:</span>
  30 |     | <span class='neutral'> * https://github.com/livepeer/protocol/blob/master/contracts/libraries/SortedDoublyLL.sol</span>
  31 |     | <span class='neutral'> *</span>
  32 |     | <span class='neutral'> *</span>
  33 |     | <span class='neutral'> * Changes made in the Liquity implementation:</span>
  34 |     | <span class='neutral'> *</span>
  35 |     | <span class='neutral'> * - Keys have been removed from nodes</span>
  36 |     | <span class='neutral'> *</span>
  37 |     | <span class='neutral'> * - Ordering checks for insertion are performed by comparing an NICR argument to the current NICR, calculated at runtime.</span>
  38 |     | <span class='neutral'> *   The list relies on the property that ordering by ICR is maintained as the stETH:BTC price varies.</span>
  39 |     | <span class='neutral'> *</span>
  40 |     | <span class='neutral'> * - Public functions with parameters have been made internal to save gas, and given an external wrapper function for external access</span>
  41 |     | <span class='neutral'> *</span>
  42 |     | <span class='neutral'> *</span>
  43 |     | <span class='neutral'> * Changes made in the Ebtc implementation:</span>
  44 |     | <span class='neutral'> *</span>
  45 |     | <span class='neutral'> * - Positions are now indexed by Ids, not addresses. Functions to generate Ids are provided.</span>
  46 |     | <span class='neutral'> *</span>
  47 |     | <span class='neutral'> * - Added batchRemove functions to optimize redemptions.</span>
  48 |     | <span class='neutral'> *</span>
  49 |     | <span class='neutral'> * - Added more O(n) getter functions and pagination-flavor variants, intended for off-chain use.</span>
  50 |     | <span class='neutral'> */</span>
  51 |     | <span class='unexecuted'>contract SortedCdps is ISortedCdps {</span>
  52 |     | <span class='unexecuted'>    string public constant NAME = &quot;SortedCdps&quot;;</span>
  53 |     | <span class='neutral'></span>
  54 |     | <span class='unexecuted'>    address public immutable borrowerOperationsAddress;</span>
  55 |     | <span class='neutral'></span>
  56 |     | <span class='unexecuted'>    ICdpManager public immutable cdpManager;</span>
  57 |     | <span class='neutral'></span>
  58 |     | <span class='unexecuted'>    uint256 public immutable maxSize;</span>
  59 |     | <span class='neutral'></span>
  60 |     | <span class='unexecuted'>    uint256 constant ADDRESS_SHIFT = 96; // 8 * 12; Puts the address at leftmost bytes32 position</span>
  61 |     | <span class='unexecuted'>    uint256 constant BLOCK_SHIFT = 64; // 8 * 8; Puts the block value after the address</span>
  62 |     | <span class='neutral'></span>
  63 |     | <span class='neutral'>    // Information for a node in the list</span>
  64 |     | <span class='neutral'>    struct Node {</span>
  65 |     | <span class='neutral'>        bytes32 nextId; // Id of next node (smaller NICR) in the list</span>
  66 |     | <span class='neutral'>        bytes32 prevId; // Id of previous node (larger NICR) in the list</span>
  67 |     | <span class='neutral'>    }</span>
  68 |     | <span class='neutral'></span>
  69 |     | <span class='neutral'>    // Information for the list</span>
  70 |     | <span class='neutral'>    struct Data {</span>
  71 |     | <span class='neutral'>        bytes32 head; // Head of the list. Also the node in the list with the largest NICR</span>
  72 |     | <span class='neutral'>        bytes32 tail; // Tail of the list. Also the node in the list with the smallest NICR</span>
  73 |     | <span class='neutral'>        mapping(bytes32 =&gt; Node) nodes; // Track the corresponding ids for each node in the list</span>
  74 |     | <span class='neutral'>    }</span>
  75 |     | <span class='neutral'></span>
  76 |     | <span class='unexecuted'>    uint256 public size; // Current size of the list</span>
  77 |     | <span class='neutral'></span>
  78 |     | <span class='unexecuted'>    Data public data;</span>
  79 |     | <span class='neutral'></span>
  80 |     | <span class='unexecuted'>    uint256 public nextCdpNonce;</span>
  81 |     | <span class='unexecuted'>    bytes32 public constant dummyId =</span>
  82 |     | <span class='unexecuted'>        0x0000000000000000000000000000000000000000000000000000000000000000;</span>
  83 |     | <span class='neutral'></span>
  84 |     | <span class='neutral'>    /// @notice Constructor</span>
  85 |     | <span class='neutral'>    /// @dev Sets max list size</span>
  86 |     | <span class='neutral'>    /// @param _size Max number of nodes allowed in the list</span>
  87 |     | <span class='neutral'>    /// @param _cdpManagerAddress Address of CdpManager contract</span>
  88 |     | <span class='neutral'>    /// @param _borrowerOperationsAddress Address of BorrowerOperations contract</span>
  89 |     | <span class='unexecuted'>    constructor(uint256 _size, address _cdpManagerAddress, address _borrowerOperationsAddress) {</span>
  90 |     | <span class='unexecuted'>        if (_size == 0) {</span>
  91 |     | <span class='unexecuted'>            _size = type(uint256).max;</span>
  92 |     | <span class='neutral'>        }</span>
  93 |     | <span class='neutral'></span>
  94 |     | <span class='unexecuted'>        maxSize = _size;</span>
  95 |     | <span class='neutral'></span>
  96 |     | <span class='unexecuted'>        cdpManager = ICdpManager(_cdpManagerAddress);</span>
  97 |     | <span class='unexecuted'>        borrowerOperationsAddress = _borrowerOperationsAddress;</span>
  98 |     | <span class='neutral'>    }</span>
  99 |     | <span class='neutral'></span>
 100 |     | <span class='neutral'>    /// @notice Encodes a unique CDP Id from owner, block and nonce</span>
 101 |     | <span class='neutral'>    /// @dev Inspired https://github.com/balancer-labs/balancer-v2-monorepo/blob/18bd5fb5d87b451cc27fbd30b276d1fb2987b529/pkg/vault/contracts/PoolRegistry.sol</span>
 102 |     | <span class='neutral'>    /// @param owner Owner address of the CDP</span>
 103 |     | <span class='neutral'>    /// @param blockHeight Block number when CDP opened</span>
 104 |     | <span class='neutral'>    /// @param nonce Unique nonce for CDP</span>
 105 |     | <span class='neutral'>    /// @return Unique bytes32 CDP Id</span>
 106 |     | <span class='unexecuted'>    function toCdpId(</span>
 107 |     | <span class='neutral'>        address owner,</span>
 108 |     | <span class='neutral'>        uint256 blockHeight,</span>
 109 |     | <span class='neutral'>        uint256 nonce</span>
 110 |     | <span class='neutral'>    ) public pure returns (bytes32) {</span>
 111 |     | <span class='neutral'>        bytes32 serialized;</span>
 112 |     | <span class='neutral'></span>
 113 |     | <span class='neutral'>        serialized |= bytes32(nonce);</span>
 114 |     | <span class='unexecuted'>        serialized |= bytes32(blockHeight) &lt;&lt; BLOCK_SHIFT; // to accommendate more than 4.2 billion blocks</span>
 115 |     | <span class='unexecuted'>        serialized |= bytes32(uint256(uint160(owner))) &lt;&lt; ADDRESS_SHIFT;</span>
 116 |     | <span class='neutral'></span>
 117 |     | <span class='neutral'>        return serialized;</span>
 118 |     | <span class='neutral'>    }</span>
 119 |     | <span class='neutral'></span>
 120 |     | <span class='neutral'>    /// @notice Get owner address of a given CDP, given CdpId.</span>
 121 |     | <span class='neutral'>    /// @dev The owner address is stored in the first 20 bytes of the CdpId</span>
 122 |     | <span class='neutral'>    /// @param cdpId cdpId of CDP to get owner of</span>
 123 |     | <span class='neutral'>    /// @return owner address of the CDP</span>
 124 |     | <span class='unexecuted'>    function getOwnerAddress(bytes32 cdpId) public pure override returns (address) {</span>
 125 |     | <span class='unexecuted'>        uint256 _tmp = uint256(cdpId) &gt;&gt; ADDRESS_SHIFT;</span>
 126 |     | <span class='neutral'>        return address(uint160(_tmp));</span>
 127 |     | <span class='neutral'>    }</span>
 128 |     | <span class='neutral'></span>
 129 |     | <span class='neutral'>    /// @notice Get dummy non-existent CDP Id</span>
 130 |     | <span class='neutral'>    /// @return Dummy non-existent CDP Id</span>
 131 |     | <span class='unexecuted'>    function nonExistId() public pure override returns (bytes32) {</span>
 132 |     | <span class='neutral'>        return dummyId;</span>
 133 |     | <span class='neutral'>    }</span>
 134 |     | <span class='neutral'></span>
 135 |     | <span class='neutral'>    /// @notice Find a specific CDP for a given owner, indexed by it&#39;s place in the linked list relative to other Cdps owned by the same address</span>
 136 |     | <span class='neutral'>    /// @notice Reverts if the index exceeds the number of active Cdps owned by the given owner</span>
 137 |     | <span class='neutral'>    /// @dev Intended for off-chain use, O(n) operation on size of SortedCdps linked list</span>
 138 |     | <span class='neutral'>    /// @param owner address of CDP owner</span>
 139 |     | <span class='neutral'>    /// @param index index of CDP, ordered by position in linked list relative to Cdps of the same owner</span>
 140 |     | <span class='neutral'>    /// @return CDP Id if found</span>
 141 |     | <span class='unexecuted'>    function cdpOfOwnerByIndex(</span>
 142 |     | <span class='neutral'>        address owner,</span>
 143 |     | <span class='neutral'>        uint256 index</span>
 144 |     | <span class='unexecuted'>    ) external view override returns (bytes32) {</span>
 145 |     | <span class='unexecuted'>        (bytes32 _cdpId, ) = _cdpOfOwnerByIndex(owner, index, dummyId, 0);</span>
 146 |     | <span class='neutral'>        return _cdpId;</span>
 147 |     | <span class='neutral'>    }</span>
 148 |     | <span class='neutral'></span>
 149 |     | <span class='neutral'>    /// @dev a pagination-flavor search (from least ICR to biggest ICR) for CDP owned by given owner and specified index (starting at given CDP)</span>
 150 |     | <span class='neutral'>    /// @param owner address of CDP owner</span>
 151 |     | <span class='neutral'>    /// @param index index of CDP, ordered by position in linked list relative to Cdps of the same owner</span>
 152 |     | <span class='neutral'>    /// @param startNodeId the seach traversal will start at this given CDP instead of the tail of the list</span>
 153 |     | <span class='neutral'>    /// @param maxNodes the traversal will go through the list by this given maximum limit of number of Cdps</span>
 154 |     | <span class='neutral'>    /// @return CDP Id if found, else return last seen CDP</span>
 155 |     | <span class='neutral'>    /// @return True if CDP found, false otherwise</span>
 156 |     | <span class='unexecuted'>    function cdpOfOwnerByIdx(</span>
 157 |     | <span class='neutral'>        address owner,</span>
 158 |     | <span class='neutral'>        uint256 index,</span>
 159 |     | <span class='neutral'>        bytes32 startNodeId,</span>
 160 |     | <span class='neutral'>        uint maxNodes</span>
 161 |     | <span class='unexecuted'>    ) external view override returns (bytes32, bool) {</span>
 162 |     | <span class='unexecuted'>        return _cdpOfOwnerByIndex(owner, index, startNodeId, maxNodes);</span>
 163 |     | <span class='neutral'>    }</span>
 164 |     | <span class='neutral'></span>
 165 |     | <span class='neutral'>    /// @notice Get a user CDP by index using pagination</span>
 166 |     | <span class='neutral'>    /// @dev return EITHER the found CDP owned by given owner &amp; index with a true indicator OR</span>
 167 |     | <span class='neutral'>    /// @dev current lastly-visited CDP as the startNode for next pagination with a false indicator</span>
 168 |     | <span class='neutral'>    /// @param owner Owner address to get CDP for</span>
 169 |     | <span class='neutral'>    /// @param index Index of CDP amongst user&#39;s Cdps</span>
 170 |     | <span class='neutral'>    /// @param startNodeId Start position CDP Id</span>
 171 |     | <span class='neutral'>    /// @param maxNodes Max number of Cdps to traverse</span>
 172 |     | <span class='neutral'>    /// @return cdpId The CDP Id if found, otherwise return current lastly-visited CDP as the startNode for next pagination</span>
 173 |     | <span class='neutral'>    /// @return found True if the CDP was found, false otherwise</span>
 174 |     | <span class='unexecuted'>    function _cdpOfOwnerByIndex(</span>
 175 |     | <span class='neutral'>        address owner,</span>
 176 |     | <span class='neutral'>        uint256 index,</span>
 177 |     | <span class='neutral'>        bytes32 startNodeId,</span>
 178 |     | <span class='neutral'>        uint maxNodes</span>
 179 |     | <span class='unexecuted'>    ) internal view returns (bytes32, bool) {</span>
 180 |     | <span class='neutral'>        // walk the list, until we get to the indexed CDP</span>
 181 |     | <span class='neutral'>        // start at the given node or from the tail of list</span>
 182 |     | <span class='unexecuted'>        bytes32 _currentCdpId = (startNodeId == dummyId ? data.tail : startNodeId);</span>
 183 |     | <span class='unexecuted'>        uint _currentIndex = 0;</span>
 184 |     | <span class='unexecuted'>        uint i;</span>
 185 |     | <span class='neutral'></span>
 186 |     | <span class='unexecuted'>        while (_currentCdpId != dummyId) {</span>
 187 |     | <span class='neutral'>            // if the current CDP is owned by specified owner</span>
 188 |     | <span class='unexecuted'>            if (getOwnerAddress(_currentCdpId) == owner) {</span>
 189 |     | <span class='neutral'>                // if the current index of the owner CDP matches specified index</span>
 190 |     | <span class='unexecuted'>                if (_currentIndex == index) {</span>
 191 |     | <span class='unexecuted'>                    return (_currentCdpId, true);</span>
 192 |     | <span class='neutral'>                } else {</span>
 193 |     | <span class='neutral'>                    // if not, increment the owner index as we&#39;ve seen a CDP owned by them</span>
 194 |     | <span class='unexecuted'>                    _currentIndex = _currentIndex + 1;</span>
 195 |     | <span class='neutral'>                }</span>
 196 |     | <span class='neutral'>            }</span>
 197 |     | <span class='unexecuted'>            ++i;</span>
 198 |     | <span class='neutral'></span>
 199 |     | <span class='neutral'>            // move to the next CDP in the list</span>
 200 |     | <span class='unexecuted'>            _currentCdpId = data.nodes[_currentCdpId].prevId;</span>
 201 |     | <span class='neutral'></span>
 202 |     | <span class='neutral'>            // cut the run if we exceed expected iterations through the loop</span>
 203 |     | <span class='unexecuted'>            if (maxNodes &gt; 0 &amp;&amp; i &gt;= maxNodes) {</span>
 204 |     | <span class='neutral'>                break;</span>
 205 |     | <span class='neutral'>            }</span>
 206 |     | <span class='neutral'>        }</span>
 207 |     | <span class='neutral'>        // if we reach maximum iteration or end of list</span>
 208 |     | <span class='neutral'>        // without seeing the specified index for the owner</span>
 209 |     | <span class='neutral'>        // then maybe a new pagination is needed</span>
 210 |     | <span class='unexecuted'>        return (_currentCdpId, false);</span>
 211 |     | <span class='neutral'>    }</span>
 212 |     | <span class='neutral'></span>
 213 |     | <span class='neutral'>    /// @notice Get active CDP count for an owner address</span>
 214 |     | <span class='neutral'>    /// @dev Intended for off-chain use, O(n) operation on size of linked list</span>
 215 |     | <span class='neutral'>    /// @param owner Owner address to count Cdps for</span>
 216 |     | <span class='neutral'>    /// @return count Number of active Cdps owned by the address</span>
 217 |     | <span class='unexecuted'>    function cdpCountOf(address owner) external view override returns (uint256) {</span>
 218 |     | <span class='unexecuted'>        (uint256 _cnt, ) = _cdpCountOf(owner, dummyId, 0);</span>
 219 |     | <span class='neutral'>        return _cnt;</span>
 220 |     | <span class='neutral'>    }</span>
 221 |     | <span class='neutral'></span>
 222 |     | <span class='neutral'>    /// @notice a Pagination-flavor search for the count of Cdps owned by given owner</span>
 223 |     | <span class='neutral'>    /// @notice Starts from a given CdpId in the sorted list, and moves from lowest ICR to highest ICR</span>
 224 |     | <span class='neutral'>    /// @param startNodeId the count traversal will start at this given CDP instead of the tail of the list</span>
 225 |     | <span class='neutral'>    /// @param maxNodes the traversal will go through the list by this given maximum limit of number of Cdps</span>
 226 |     | <span class='neutral'>    /// @return count Number of active Cdps owned by the address in the segment of the list traversed</span>
 227 |     | <span class='neutral'>    /// @return last seen CDP for the startNode for next pagination</span>
 228 |     | <span class='unexecuted'>    function getCdpCountOf(</span>
 229 |     | <span class='neutral'>        address owner,</span>
 230 |     | <span class='neutral'>        bytes32 startNodeId,</span>
 231 |     | <span class='neutral'>        uint maxNodes</span>
 232 |     | <span class='unexecuted'>    ) external view override returns (uint256, bytes32) {</span>
 233 |     | <span class='unexecuted'>        return _cdpCountOf(owner, startNodeId, maxNodes);</span>
 234 |     | <span class='neutral'>    }</span>
 235 |     | <span class='neutral'></span>
 236 |     | <span class='neutral'>    /// @dev return the found CDP count owned by given owner with</span>
 237 |     | <span class='neutral'>    /// @dev current lastly-visited CDP as the startNode for next pagination</span>
 238 |     | <span class='unexecuted'>    function _cdpCountOf(</span>
 239 |     | <span class='neutral'>        address owner,</span>
 240 |     | <span class='neutral'>        bytes32 startNodeId,</span>
 241 |     | <span class='neutral'>        uint maxNodes</span>
 242 |     | <span class='unexecuted'>    ) internal view returns (uint256, bytes32) {</span>
 243 |     | <span class='neutral'>        // walk the list, until we get to the count</span>
 244 |     | <span class='neutral'>        // start at the given node or from the tail of list</span>
 245 |     | <span class='unexecuted'>        bytes32 _currentCdpId = (startNodeId == dummyId ? data.tail : startNodeId);</span>
 246 |     | <span class='unexecuted'>        uint _ownedCount = 0;</span>
 247 |     | <span class='unexecuted'>        uint i = 0;</span>
 248 |     | <span class='neutral'></span>
 249 |     | <span class='unexecuted'>        while (_currentCdpId != dummyId) {</span>
 250 |     | <span class='neutral'>            // if the current CDP is owned by specified owner</span>
 251 |     | <span class='unexecuted'>            if (getOwnerAddress(_currentCdpId) == owner) {</span>
 252 |     | <span class='unexecuted'>                _ownedCount = _ownedCount + 1;</span>
 253 |     | <span class='neutral'>            }</span>
 254 |     | <span class='unexecuted'>            ++i;</span>
 255 |     | <span class='neutral'></span>
 256 |     | <span class='neutral'>            // move to the next CDP in the list</span>
 257 |     | <span class='unexecuted'>            _currentCdpId = data.nodes[_currentCdpId].prevId;</span>
 258 |     | <span class='neutral'></span>
 259 |     | <span class='neutral'>            // cut the run if we exceed expected iterations through the loop</span>
 260 |     | <span class='unexecuted'>            if (maxNodes &gt; 0 &amp;&amp; i &gt;= maxNodes) {</span>
 261 |     | <span class='neutral'>                break;</span>
 262 |     | <span class='neutral'>            }</span>
 263 |     | <span class='neutral'>        }</span>
 264 |     | <span class='unexecuted'>        return (_ownedCount, _currentCdpId);</span>
 265 |     | <span class='neutral'>    }</span>
 266 |     | <span class='neutral'></span>
 267 |     | <span class='neutral'>    /// @notice Get all active Cdps for a given address</span>
 268 |     | <span class='neutral'>    /// @dev Intended for off-chain use, O(n) operation on size of linked list</span>
 269 |     | <span class='neutral'>    /// @param owner address of CDP owner</span>
 270 |     | <span class='neutral'>    /// @return cdps all CdpIds of the specified owner</span>
 271 |     | <span class='unexecuted'>    function getCdpsOf(address owner) external view override returns (bytes32[] memory cdps) {</span>
 272 |     | <span class='neutral'>        // Naive method uses two-pass strategy to determine exactly how many Cdps are owned by owner</span>
 273 |     | <span class='neutral'>        // This roughly halves the amount of Cdps we can process before relying on pagination or off-chain methods</span>
 274 |     | <span class='unexecuted'>        (uint _ownedCount, ) = _cdpCountOf(owner, dummyId, 0);</span>
 275 |     | <span class='unexecuted'>        if (_ownedCount &gt; 0) {</span>
 276 |     | <span class='unexecuted'>            (bytes32[] memory _allCdps, , ) = _getCdpsOf(owner, dummyId, 0, _ownedCount);</span>
 277 |     | <span class='neutral'>            cdps = _allCdps;</span>
 278 |     | <span class='neutral'>        }</span>
 279 |     | <span class='neutral'>    }</span>
 280 |     | <span class='neutral'></span>
 281 |     | <span class='neutral'>    /// @dev a pagination-flavor search retrieval of (from least ICR to biggest ICR) Cdps owned by given owner (starting at given CDP)</span>
 282 |     | <span class='neutral'>    /// @param startNodeId the traversal will start at this given CDP instead of the tail of the list</span>
 283 |     | <span class='neutral'>    /// @param maxNodes the traversal will go through the list by this given maximum limit of number of Cdps</span>
 284 |     | <span class='neutral'>    /// @return all CdpIds of the specified owner found by search starting at the specified startNodeId for the specified maximum iteration count</span>
 285 |     | <span class='neutral'>    /// @return found number of Cdp for the owner</span>
 286 |     | <span class='neutral'>    /// @return starting CdpId for next pagination within current SortedCdps</span>
 287 |     | <span class='unexecuted'>    function getAllCdpsOf(</span>
 288 |     | <span class='neutral'>        address owner,</span>
 289 |     | <span class='neutral'>        bytes32 startNodeId,</span>
 290 |     | <span class='neutral'>        uint maxNodes</span>
 291 |     | <span class='unexecuted'>    ) external view override returns (bytes32[] memory, uint256, bytes32) {</span>
 292 |     | <span class='neutral'>        // Naive method uses two-pass strategy to determine exactly how many Cdps are owned by owner</span>
 293 |     | <span class='neutral'>        // This roughly halves the amount of Cdps we can process before relying on pagination or off-chain methods</span>
 294 |     | <span class='unexecuted'>        (uint _ownedCount, ) = _cdpCountOf(owner, startNodeId, maxNodes);</span>
 295 |     | <span class='unexecuted'>        return _getCdpsOf(owner, startNodeId, maxNodes, _ownedCount);</span>
 296 |     | <span class='neutral'>    }</span>
 297 |     | <span class='neutral'></span>
 298 |     | <span class='neutral'>    /// @dev return EITHER the found Cdps (also the count) owned by given owner OR empty array with</span>
 299 |     | <span class='neutral'>    /// @dev current lastly-visited CDP as the startNode for next pagination</span>
 300 |     | <span class='unexecuted'>    function _getCdpsOf(</span>
 301 |     | <span class='neutral'>        address owner,</span>
 302 |     | <span class='neutral'>        bytes32 startNodeId,</span>
 303 |     | <span class='neutral'>        uint maxNodes,</span>
 304 |     | <span class='neutral'>        uint maxArraySize</span>
 305 |     | <span class='unexecuted'>    ) internal view returns (bytes32[] memory, uint256, bytes32) {</span>
 306 |     | <span class='unexecuted'>        if (maxArraySize == 0) {</span>
 307 |     | <span class='unexecuted'>            return (new bytes32[](0), 0, dummyId);</span>
 308 |     | <span class='neutral'>        }</span>
 309 |     | <span class='neutral'></span>
 310 |     | <span class='neutral'>        // Two-pass strategy, halving the amount of Cdps we can process before relying on pagination or off-chain methods</span>
 311 |     | <span class='unexecuted'>        bytes32[] memory userCdps = new bytes32[](maxArraySize);</span>
 312 |     | <span class='unexecuted'>        uint i = 0;</span>
 313 |     | <span class='neutral'>        uint _cdpRetrieved;</span>
 314 |     | <span class='neutral'></span>
 315 |     | <span class='neutral'>        // walk the list, until we get to the index</span>
 316 |     | <span class='neutral'>        // start at the given node or from the tail of list</span>
 317 |     | <span class='unexecuted'>        bytes32 _currentCdpId = (startNodeId == dummyId ? data.tail : startNodeId);</span>
 318 |     | <span class='neutral'></span>
 319 |     | <span class='unexecuted'>        while (_currentCdpId != dummyId) {</span>
 320 |     | <span class='neutral'>            // if the current CDP is owned by specified owner</span>
 321 |     | <span class='unexecuted'>            if (getOwnerAddress(_currentCdpId) == owner) {</span>
 322 |     | <span class='unexecuted'>                userCdps[_cdpRetrieved] = _currentCdpId;</span>
 323 |     | <span class='unexecuted'>                ++_cdpRetrieved;</span>
 324 |     | <span class='neutral'>            }</span>
 325 |     | <span class='unexecuted'>            ++i;</span>
 326 |     | <span class='neutral'></span>
 327 |     | <span class='neutral'>            // move to the next CDP in the list</span>
 328 |     | <span class='unexecuted'>            _currentCdpId = data.nodes[_currentCdpId].prevId;</span>
 329 |     | <span class='neutral'></span>
 330 |     | <span class='neutral'>            // cut the run if we exceed expected iterations through the loop</span>
 331 |     | <span class='unexecuted'>            if (maxNodes &gt; 0 &amp;&amp; i &gt;= maxNodes) {</span>
 332 |     | <span class='neutral'>                break;</span>
 333 |     | <span class='neutral'>            }</span>
 334 |     | <span class='neutral'>        }</span>
 335 |     | <span class='neutral'></span>
 336 |     | <span class='unexecuted'>        return (userCdps, _cdpRetrieved, _currentCdpId);</span>
 337 |     | <span class='neutral'>    }</span>
 338 |     | <span class='neutral'></span>
 339 |     | <span class='neutral'>    /// @notice Add a node to the list</span>
 340 |     | <span class='neutral'>    /// @param owner CDP owner for corresponding Id</span>
 341 |     | <span class='neutral'>    /// @param _NICR Node&#39;s NICR</span>
 342 |     | <span class='neutral'>    /// @param _prevId Id of previous node for the insert position</span>
 343 |     | <span class='neutral'>    /// @param _nextId Id of next node for the insert position</span>
 344 |     | <span class='neutral'>    /// @return _id Id of the new node</span>
 345 |     | <span class='unexecuted'>    function insert(</span>
 346 |     | <span class='neutral'>        address owner,</span>
 347 |     | <span class='neutral'>        uint256 _NICR,</span>
 348 |     | <span class='neutral'>        bytes32 _prevId,</span>
 349 |     | <span class='neutral'>        bytes32 _nextId</span>
 350 |     | <span class='unexecuted'>    ) external override returns (bytes32) {</span>
 351 |     | <span class='unexecuted'>        _requireCallerIsBOorCdpM();</span>
 352 |     | <span class='unexecuted'>        bytes32 _id = toCdpId(owner, block.number, nextCdpNonce);</span>
 353 |     | <span class='unexecuted'>        require(cdpManager.getCdpStatus(_id) == 0, &quot;SortedCdps: new id is NOT nonExistent!&quot;);</span>
 354 |     | <span class='neutral'></span>
 355 |     | <span class='unexecuted'>        _insert(_id, _NICR, _prevId, _nextId);</span>
 356 |     | <span class='neutral'></span>
 357 |     | <span class='neutral'>        unchecked {</span>
 358 |     | <span class='unexecuted'>            ++nextCdpNonce;</span>
 359 |     | <span class='neutral'>        }</span>
 360 |     | <span class='neutral'></span>
 361 |     | <span class='unexecuted'>        return _id;</span>
 362 |     | <span class='neutral'>    }</span>
 363 |     | <span class='neutral'></span>
 364 |     | <span class='unexecuted'>    function _insert(bytes32 _id, uint256 _NICR, bytes32 _prevId, bytes32 _nextId) internal {</span>
 365 |     | <span class='neutral'>        // List must not be full</span>
 366 |     | <span class='unexecuted'>        require(!isFull(), &quot;SortedCdps: List is full&quot;);</span>
 367 |     | <span class='neutral'>        // List must not already contain node</span>
 368 |     | <span class='unexecuted'>        require(!contains(_id), &quot;SortedCdps: List already contains the node&quot;);</span>
 369 |     | <span class='neutral'>        // Node id must not be null</span>
 370 |     | <span class='unexecuted'>        require(_id != dummyId, &quot;SortedCdps: Id cannot be zero&quot;);</span>
 371 |     | <span class='neutral'>        // NICR must be non-zero</span>
 372 |     | <span class='unexecuted'>        require(_NICR &gt; 0, &quot;SortedCdps: NICR must be positive&quot;);</span>
 373 |     | <span class='neutral'></span>
 374 |     | <span class='unexecuted'>        bytes32 prevId = _prevId;</span>
 375 |     | <span class='unexecuted'>        bytes32 nextId = _nextId;</span>
 376 |     | <span class='neutral'></span>
 377 |     | <span class='unexecuted'>        if (!_validInsertPosition(_NICR, prevId, nextId)) {</span>
 378 |     | <span class='neutral'>            // Sender&#39;s hint was not a valid insert position</span>
 379 |     | <span class='neutral'>            // Use sender&#39;s hint to find a valid insert position</span>
 380 |     | <span class='unexecuted'>            (prevId, nextId) = _findInsertPosition(_NICR, prevId, nextId);</span>
 381 |     | <span class='neutral'>        }</span>
 382 |     | <span class='neutral'></span>
 383 |     | <span class='unexecuted'>        if (prevId == dummyId &amp;&amp; nextId == dummyId) {</span>
 384 |     | <span class='neutral'>            // Insert as head and tail</span>
 385 |     | <span class='unexecuted'>            data.head = _id;</span>
 386 |     | <span class='unexecuted'>            data.tail = _id;</span>
 387 |     | <span class='unexecuted'>        } else if (prevId == dummyId) {</span>
 388 |     | <span class='neutral'>            // Insert before `prevId` as the head</span>
 389 |     | <span class='unexecuted'>            data.nodes[_id].nextId = data.head;</span>
 390 |     | <span class='unexecuted'>            data.nodes[data.head].prevId = _id;</span>
 391 |     | <span class='unexecuted'>            data.head = _id;</span>
 392 |     | <span class='unexecuted'>        } else if (nextId == dummyId) {</span>
 393 |     | <span class='neutral'>            // Insert after `nextId` as the tail</span>
 394 |     | <span class='unexecuted'>            data.nodes[_id].prevId = data.tail;</span>
 395 |     | <span class='unexecuted'>            data.nodes[data.tail].nextId = _id;</span>
 396 |     | <span class='unexecuted'>            data.tail = _id;</span>
 397 |     | <span class='neutral'>        } else {</span>
 398 |     | <span class='neutral'>            // Insert at insert position between `prevId` and `nextId`</span>
 399 |     | <span class='unexecuted'>            data.nodes[_id].nextId = nextId;</span>
 400 |     | <span class='unexecuted'>            data.nodes[_id].prevId = prevId;</span>
 401 |     | <span class='unexecuted'>            data.nodes[prevId].nextId = _id;</span>
 402 |     | <span class='unexecuted'>            data.nodes[nextId].prevId = _id;</span>
 403 |     | <span class='neutral'>        }</span>
 404 |     | <span class='neutral'></span>
 405 |     | <span class='unexecuted'>        size = size + 1;</span>
 406 |     | <span class='unexecuted'>        emit NodeAdded(_id, _NICR);</span>
 407 |     | <span class='neutral'>    }</span>
 408 |     | <span class='neutral'></span>
 409 |     | <span class='neutral'>    /// @notice Remove a node from the sorted list, by Id</span>
 410 |     | <span class='neutral'>    /// @param _id The CdpId to be removed</span>
 411 |     | <span class='unexecuted'>    function remove(bytes32 _id) external override {</span>
 412 |     | <span class='unexecuted'>        _requireCallerIsCdpManager();</span>
 413 |     | <span class='unexecuted'>        _remove(_id);</span>
 414 |     | <span class='neutral'>    }</span>
 415 |     | <span class='neutral'></span>
 416 |     | <span class='neutral'>    /// @notice Batch a node from the sorted list, by Id</span>
 417 |     | <span class='neutral'>    /// @notice Strong trust assumption that the specified nodes are sorted in the same order as in the input array</span>
 418 |     | <span class='neutral'>    /// @dev Optimization to reduce gas cost for removing multiple nodes on redemption</span>
 419 |     | <span class='neutral'>    /// @param _ids Array of CdpIds to remove</span>
 420 |     | <span class='unexecuted'>    function batchRemove(bytes32[] memory _ids) external override {</span>
 421 |     | <span class='unexecuted'>        _requireCallerIsCdpManager();</span>
 422 |     | <span class='unexecuted'>        uint256 _len = _ids.length;</span>
 423 |     | <span class='unexecuted'>        require(_len &gt; 1, &quot;SortedCdps: batchRemove() only apply to multiple cdpIds!&quot;);</span>
 424 |     | <span class='neutral'></span>
 425 |     | <span class='unexecuted'>        bytes32 _firstPrev = data.nodes[_ids[0]].prevId;</span>
 426 |     | <span class='unexecuted'>        bytes32 _lastNext = data.nodes[_ids[_len - 1]].nextId;</span>
 427 |     | <span class='neutral'></span>
 428 |     | <span class='unexecuted'>        require(</span>
 429 |     | <span class='unexecuted'>            _firstPrev != dummyId || _lastNext != dummyId,</span>
 430 |     | <span class='neutral'>            &quot;SortedCdps: batchRemove() leave ZERO node left!&quot;</span>
 431 |     | <span class='neutral'>        );</span>
 432 |     | <span class='neutral'></span>
 433 |     | <span class='unexecuted'>        for (uint256 i = 0; i &lt; _len; ++i) {</span>
 434 |     | <span class='unexecuted'>            require(contains(_ids[i]), &quot;SortedCdps: List does not contain the id&quot;);</span>
 435 |     | <span class='neutral'>        }</span>
 436 |     | <span class='neutral'></span>
 437 |     | <span class='neutral'>        // orphan nodes in between to save gas</span>
 438 |     | <span class='unexecuted'>        if (_firstPrev != dummyId) {</span>
 439 |     | <span class='unexecuted'>            data.nodes[_firstPrev].nextId = _lastNext;</span>
 440 |     | <span class='neutral'>        } else {</span>
 441 |     | <span class='unexecuted'>            data.head = _lastNext;</span>
 442 |     | <span class='neutral'>        }</span>
 443 |     | <span class='unexecuted'>        if (_lastNext != dummyId) {</span>
 444 |     | <span class='unexecuted'>            data.nodes[_lastNext].prevId = _firstPrev;</span>
 445 |     | <span class='neutral'>        } else {</span>
 446 |     | <span class='unexecuted'>            data.tail = _firstPrev;</span>
 447 |     | <span class='neutral'>        }</span>
 448 |     | <span class='neutral'></span>
 449 |     | <span class='neutral'>        // delete node &amp; owner storages to get gas refund</span>
 450 |     | <span class='unexecuted'>        for (uint i = 0; i &lt; _len; ++i) {</span>
 451 |     | <span class='unexecuted'>            delete data.nodes[_ids[i]];</span>
 452 |     | <span class='unexecuted'>            emit NodeRemoved(_ids[i]);</span>
 453 |     | <span class='neutral'>        }</span>
 454 |     | <span class='unexecuted'>        size = size - _len;</span>
 455 |     | <span class='neutral'>    }</span>
 456 |     | <span class='neutral'></span>
 457 |     | <span class='unexecuted'>    function _remove(bytes32 _id) internal {</span>
 458 |     | <span class='neutral'>        // List must contain the node</span>
 459 |     | <span class='unexecuted'>        require(contains(_id), &quot;SortedCdps: List does not contain the id&quot;);</span>
 460 |     | <span class='neutral'></span>
 461 |     | <span class='unexecuted'>        if (size &gt; 1) {</span>
 462 |     | <span class='neutral'>            // List contains more than a single node</span>
 463 |     | <span class='unexecuted'>            if (_id == data.head) {</span>
 464 |     | <span class='neutral'>                // The removed node is the head</span>
 465 |     | <span class='neutral'>                // Set head to next node</span>
 466 |     | <span class='unexecuted'>                data.head = data.nodes[_id].nextId;</span>
 467 |     | <span class='neutral'>                // Set prev pointer of new head to null</span>
 468 |     | <span class='unexecuted'>                data.nodes[data.head].prevId = dummyId;</span>
 469 |     | <span class='unexecuted'>            } else if (_id == data.tail) {</span>
 470 |     | <span class='neutral'>                // The removed node is the tail</span>
 471 |     | <span class='neutral'>                // Set tail to previous node</span>
 472 |     | <span class='unexecuted'>                data.tail = data.nodes[_id].prevId;</span>
 473 |     | <span class='neutral'>                // Set next pointer of new tail to null</span>
 474 |     | <span class='unexecuted'>                data.nodes[data.tail].nextId = dummyId;</span>
 475 |     | <span class='neutral'>            } else {</span>
 476 |     | <span class='neutral'>                // The removed node is neither the head nor the tail</span>
 477 |     | <span class='neutral'>                // Set next pointer of previous node to the next node</span>
 478 |     | <span class='unexecuted'>                data.nodes[data.nodes[_id].prevId].nextId = data.nodes[_id].nextId;</span>
 479 |     | <span class='neutral'>                // Set prev pointer of next node to the previous node</span>
 480 |     | <span class='unexecuted'>                data.nodes[data.nodes[_id].nextId].prevId = data.nodes[_id].prevId;</span>
 481 |     | <span class='neutral'>            }</span>
 482 |     | <span class='neutral'>        } else {</span>
 483 |     | <span class='neutral'>            // List contains a single node</span>
 484 |     | <span class='neutral'>            // Set the head and tail to null</span>
 485 |     | <span class='unexecuted'>            data.head = dummyId;</span>
 486 |     | <span class='unexecuted'>            data.tail = dummyId;</span>
 487 |     | <span class='neutral'>        }</span>
 488 |     | <span class='neutral'></span>
 489 |     | <span class='unexecuted'>        delete data.nodes[_id];</span>
 490 |     | <span class='unexecuted'>        size = size - 1;</span>
 491 |     | <span class='unexecuted'>        emit NodeRemoved(_id);</span>
 492 |     | <span class='neutral'>    }</span>
 493 |     | <span class='neutral'></span>
 494 |     | <span class='neutral'>    /// @notice Re-insert an existing node at a new position, based on its new NICR</span>
 495 |     | <span class='neutral'>    /// @param _id Node&#39;s id</span>
 496 |     | <span class='neutral'>    /// @param _newNICR Node&#39;s new NICR</span>
 497 |     | <span class='neutral'>    /// @param _prevId Id of previous node for the new insert position</span>
 498 |     | <span class='neutral'>    /// @param _nextId Id of next node for the new insert position</span>
 499 |     | <span class='unexecuted'>    function reInsert(</span>
 500 |     | <span class='neutral'>        bytes32 _id,</span>
 501 |     | <span class='neutral'>        uint256 _newNICR,</span>
 502 |     | <span class='neutral'>        bytes32 _prevId,</span>
 503 |     | <span class='neutral'>        bytes32 _nextId</span>
 504 |     | <span class='neutral'>    ) external override {</span>
 505 |     | <span class='unexecuted'>        _requireCallerIsBOorCdpM();</span>
 506 |     | <span class='neutral'>        // List must contain the node</span>
 507 |     | <span class='unexecuted'>        require(contains(_id), &quot;SortedCdps: List does not contain the id&quot;);</span>
 508 |     | <span class='neutral'>        // NICR must be non-zero</span>
 509 |     | <span class='unexecuted'>        require(_newNICR &gt; 0, &quot;SortedCdps: NICR must be positive&quot;);</span>
 510 |     | <span class='neutral'></span>
 511 |     | <span class='neutral'>        // Remove node from the list</span>
 512 |     | <span class='unexecuted'>        _remove(_id);</span>
 513 |     | <span class='neutral'></span>
 514 |     | <span class='unexecuted'>        _insert(_id, _newNICR, _prevId, _nextId);</span>
 515 |     | <span class='neutral'>    }</span>
 516 |     | <span class='neutral'></span>
 517 |     | <span class='neutral'>    /// @dev Checks if the list contains a given node Id</span>
 518 |     | <span class='neutral'>    /// @param _id The Id of the node</span>
 519 |     | <span class='neutral'>    /// @return true if the node exists, false otherwise</span>
 520 |     | <span class='unexecuted'>    function contains(bytes32 _id) public view override returns (bool) {</span>
 521 |     | <span class='unexecuted'>        bool _exist = _id != dummyId &amp;&amp; (data.head == _id || data.tail == _id);</span>
 522 |     | <span class='unexecuted'>        if (!_exist) {</span>
 523 |     | <span class='unexecuted'>            Node memory _node = data.nodes[_id];</span>
 524 |     | <span class='unexecuted'>            _exist = _id != dummyId &amp;&amp; (_node.nextId != dummyId &amp;&amp; _node.prevId != dummyId);</span>
 525 |     | <span class='neutral'>        }</span>
 526 |     | <span class='unexecuted'>        return _exist;</span>
 527 |     | <span class='neutral'>    }</span>
 528 |     | <span class='neutral'></span>
 529 |     | <span class='neutral'>    /// @dev Checks if the list is full</span>
 530 |     | <span class='neutral'>    /// @return true if the list is full, false otherwise</span>
 531 |     | <span class='unexecuted'>    function isFull() public view override returns (bool) {</span>
 532 |     | <span class='unexecuted'>        return size == maxSize;</span>
 533 |     | <span class='neutral'>    }</span>
 534 |     | <span class='neutral'></span>
 535 |     | <span class='neutral'>    /// @dev Checks if the list is empty</span>
 536 |     | <span class='neutral'>    /// @return true if the list is empty, false otherwise</span>
 537 |     | <span class='unexecuted'>    function isEmpty() public view override returns (bool) {</span>
 538 |     | <span class='unexecuted'>        return size == 0;</span>
 539 |     | <span class='neutral'>    }</span>
 540 |     | <span class='neutral'></span>
 541 |     | <span class='neutral'>    /// @dev Returns the current size of the list</span>
 542 |     | <span class='neutral'>    /// @return The current size of the list</span>
 543 |     | <span class='unexecuted'>    function getSize() external view override returns (uint256) {</span>
 544 |     | <span class='unexecuted'>        return size;</span>
 545 |     | <span class='neutral'>    }</span>
 546 |     | <span class='neutral'></span>
 547 |     | <span class='neutral'>    /// @dev Returns the maximum size of the list</span>
 548 |     | <span class='neutral'>    /// @return The maximum size of the list</span>
 549 |     | <span class='unexecuted'>    function getMaxSize() external view override returns (uint256) {</span>
 550 |     | <span class='unexecuted'>        return maxSize;</span>
 551 |     | <span class='neutral'>    }</span>
 552 |     | <span class='neutral'></span>
 553 |     | <span class='neutral'>    /// @dev Returns the first node in the list (node with the largest NICR)</span>
 554 |     | <span class='neutral'>    /// @return The Id of the first node</span>
 555 |     | <span class='unexecuted'>    function getFirst() external view override returns (bytes32) {</span>
 556 |     | <span class='unexecuted'>        return data.head;</span>
 557 |     | <span class='neutral'>    }</span>
 558 |     | <span class='neutral'></span>
 559 |     | <span class='neutral'>    /// @dev Returns the last node in the list (node with the smallest NICR)</span>
 560 |     | <span class='neutral'>    /// @return The Id of the last node</span>
 561 |     | <span class='unexecuted'>    function getLast() external view override returns (bytes32) {</span>
 562 |     | <span class='unexecuted'>        return data.tail;</span>
 563 |     | <span class='neutral'>    }</span>
 564 |     | <span class='neutral'></span>
 565 |     | <span class='neutral'>    /// @dev Returns the next node (with a smaller NICR) in the list for a given node</span>
 566 |     | <span class='neutral'>    /// @param _id The Id of the node</span>
 567 |     | <span class='neutral'>    /// @return The Id of the next node</span>
 568 |     | <span class='unexecuted'>    function getNext(bytes32 _id) external view override returns (bytes32) {</span>
 569 |     | <span class='unexecuted'>        return data.nodes[_id].nextId;</span>
 570 |     | <span class='neutral'>    }</span>
 571 |     | <span class='neutral'></span>
 572 |     | <span class='neutral'>    /// @dev Returns the previous node (with a larger NICR) in the list for a given node</span>
 573 |     | <span class='neutral'>    /// @param _id The Id of the node</span>
 574 |     | <span class='neutral'>    /// @return The Id of the previous node</span>
 575 |     | <span class='unexecuted'>    function getPrev(bytes32 _id) external view override returns (bytes32) {</span>
 576 |     | <span class='unexecuted'>        return data.nodes[_id].prevId;</span>
 577 |     | <span class='neutral'>    }</span>
 578 |     | <span class='neutral'></span>
 579 |     | <span class='neutral'>    /// @dev Check if a pair of nodes is a valid insertion point for a new node with the given NICR</span>
 580 |     | <span class='neutral'>    /// @param _NICR Node&#39;s NICR</span>
 581 |     | <span class='neutral'>    /// @param _prevId Id of previous node for the insert position</span>
 582 |     | <span class='neutral'>    /// @param _nextId Id of next node for the insert position</span>
 583 |     | <span class='neutral'>    /// @return true if the position is valid, false otherwise</span>
 584 |     | <span class='unexecuted'>    function validInsertPosition(</span>
 585 |     | <span class='neutral'>        uint256 _NICR,</span>
 586 |     | <span class='neutral'>        bytes32 _prevId,</span>
 587 |     | <span class='neutral'>        bytes32 _nextId</span>
 588 |     | <span class='unexecuted'>    ) external view override returns (bool) {</span>
 589 |     | <span class='unexecuted'>        return _validInsertPosition(_NICR, _prevId, _nextId);</span>
 590 |     | <span class='neutral'>    }</span>
 591 |     | <span class='neutral'></span>
 592 |     | <span class='unexecuted'>    function _validInsertPosition(</span>
 593 |     | <span class='neutral'>        uint256 _NICR,</span>
 594 |     | <span class='neutral'>        bytes32 _prevId,</span>
 595 |     | <span class='neutral'>        bytes32 _nextId</span>
 596 |     | <span class='unexecuted'>    ) internal view returns (bool) {</span>
 597 |     | <span class='unexecuted'>        if (_prevId == dummyId &amp;&amp; _nextId == dummyId) {</span>
 598 |     | <span class='neutral'>            // `(null, null)` is a valid insert position if the list is empty</span>
 599 |     | <span class='unexecuted'>            return isEmpty();</span>
 600 |     | <span class='unexecuted'>        } else if (_prevId == dummyId) {</span>
 601 |     | <span class='neutral'>            // `(null, _nextId)` is a valid insert position if `_nextId` is the head of the list</span>
 602 |     | <span class='unexecuted'>            return data.head == _nextId &amp;&amp; _NICR &gt;= cdpManager.getCachedNominalICR(_nextId);</span>
 603 |     | <span class='unexecuted'>        } else if (_nextId == dummyId) {</span>
 604 |     | <span class='neutral'>            // `(_prevId, null)` is a valid insert position if `_prevId` is the tail of the list</span>
 605 |     | <span class='unexecuted'>            return data.tail == _prevId &amp;&amp; _NICR &lt;= cdpManager.getCachedNominalICR(_prevId);</span>
 606 |     | <span class='neutral'>        } else {</span>
 607 |     | <span class='neutral'>            // `(_prevId, _nextId)` is a valid insert position if they are adjacent nodes and `_NICR` falls between the two nodes&#39; NICRs</span>
 608 |     | <span class='neutral'>            return</span>
 609 |     | <span class='unexecuted'>                data.nodes[_prevId].nextId == _nextId &amp;&amp;</span>
 610 |     | <span class='unexecuted'>                cdpManager.getCachedNominalICR(_prevId) &gt;= _NICR &amp;&amp;</span>
 611 |     | <span class='unexecuted'>                _NICR &gt;= cdpManager.getCachedNominalICR(_nextId);</span>
 612 |     | <span class='neutral'>        }</span>
 613 |     | <span class='neutral'>    }</span>
 614 |     | <span class='neutral'></span>
 615 |     | <span class='neutral'>    /// @dev Descend the list (larger NICRs to smaller NICRs) to find a valid insert position</span>
 616 |     | <span class='neutral'>    /// @param _NICR Node&#39;s NICR</span>
 617 |     | <span class='neutral'>    /// @param _startId Id of node to start descending the list from</span>
 618 |     | <span class='neutral'>    /// @return The previous node Id for the inserted node</span>
 619 |     | <span class='neutral'>    /// @return The next node Id for the inserted node</span>
 620 |     | <span class='unexecuted'>    function _descendList(uint256 _NICR, bytes32 _startId) internal view returns (bytes32, bytes32) {</span>
 621 |     | <span class='neutral'>        // If `_startId` is the head, check if the insert position is before the head</span>
 622 |     | <span class='unexecuted'>        if (data.head == _startId &amp;&amp; _NICR &gt;= cdpManager.getCachedNominalICR(_startId)) {</span>
 623 |     | <span class='unexecuted'>            return (dummyId, _startId);</span>
 624 |     | <span class='neutral'>        }</span>
 625 |     | <span class='neutral'></span>
 626 |     | <span class='unexecuted'>        bytes32 prevId = _startId;</span>
 627 |     | <span class='unexecuted'>        bytes32 nextId = data.nodes[prevId].nextId;</span>
 628 |     | <span class='neutral'></span>
 629 |     | <span class='neutral'>        // Descend the list until we reach the end or until we find a valid insert position</span>
 630 |     | <span class='unexecuted'>        while (prevId != dummyId &amp;&amp; !_validInsertPosition(_NICR, prevId, nextId)) {</span>
 631 |     | <span class='unexecuted'>            prevId = data.nodes[prevId].nextId;</span>
 632 |     | <span class='unexecuted'>            nextId = data.nodes[prevId].nextId;</span>
 633 |     | <span class='neutral'>        }</span>
 634 |     | <span class='neutral'></span>
 635 |     | <span class='unexecuted'>        return (prevId, nextId);</span>
 636 |     | <span class='neutral'>    }</span>
 637 |     | <span class='neutral'></span>
 638 |     | <span class='neutral'>    /// @dev Ascend the list (smaller NICRs to larger NICRs) to find a valid insert position</span>
 639 |     | <span class='neutral'>    /// @param _NICR Node&#39;s NICR</span>
 640 |     | <span class='neutral'>    /// @param _startId Id of node to start ascending the list from</span>
 641 |     | <span class='neutral'>    /// @return The previous node Id for the inserted node</span>
 642 |     | <span class='neutral'>    /// @return The next node Id for the inserted node</span>
 643 |     | <span class='unexecuted'>    function _ascendList(uint256 _NICR, bytes32 _startId) internal view returns (bytes32, bytes32) {</span>
 644 |     | <span class='neutral'>        // If `_startId` is the tail, check if the insert position is after the tail</span>
 645 |     | <span class='unexecuted'>        if (data.tail == _startId &amp;&amp; _NICR &lt;= cdpManager.getCachedNominalICR(_startId)) {</span>
 646 |     | <span class='unexecuted'>            return (_startId, dummyId);</span>
 647 |     | <span class='neutral'>        }</span>
 648 |     | <span class='neutral'></span>
 649 |     | <span class='unexecuted'>        bytes32 nextId = _startId;</span>
 650 |     | <span class='unexecuted'>        bytes32 prevId = data.nodes[nextId].prevId;</span>
 651 |     | <span class='neutral'></span>
 652 |     | <span class='neutral'>        // Ascend the list until we reach the end or until we find a valid insertion point</span>
 653 |     | <span class='unexecuted'>        while (nextId != dummyId &amp;&amp; !_validInsertPosition(_NICR, prevId, nextId)) {</span>
 654 |     | <span class='unexecuted'>            nextId = data.nodes[nextId].prevId;</span>
 655 |     | <span class='unexecuted'>            prevId = data.nodes[nextId].prevId;</span>
 656 |     | <span class='neutral'>        }</span>
 657 |     | <span class='neutral'></span>
 658 |     | <span class='unexecuted'>        return (prevId, nextId);</span>
 659 |     | <span class='neutral'>    }</span>
 660 |     | <span class='neutral'></span>
 661 |     | <span class='neutral'>    /// @dev Find the insert position for a node with the given NICR</span>
 662 |     | <span class='neutral'>    /// @param _NICR Node&#39;s NICR</span>
 663 |     | <span class='neutral'>    /// @param _prevId Id of previous node for the insert position</span>
 664 |     | <span class='neutral'>    /// @param _nextId Id of next node for the insert position</span>
 665 |     | <span class='neutral'>    /// @return The previous node Id for the inserted node</span>
 666 |     | <span class='neutral'>    /// @return The next node Id for the inserted node</span>
 667 |     | <span class='unexecuted'>    function findInsertPosition(</span>
 668 |     | <span class='neutral'>        uint256 _NICR,</span>
 669 |     | <span class='neutral'>        bytes32 _prevId,</span>
 670 |     | <span class='neutral'>        bytes32 _nextId</span>
 671 |     | <span class='unexecuted'>    ) external view override returns (bytes32, bytes32) {</span>
 672 |     | <span class='unexecuted'>        return _findInsertPosition(_NICR, _prevId, _nextId);</span>
 673 |     | <span class='neutral'>    }</span>
 674 |     | <span class='neutral'></span>
 675 |     | <span class='unexecuted'>    function _findInsertPosition(</span>
 676 |     | <span class='neutral'>        uint256 _NICR,</span>
 677 |     | <span class='neutral'>        bytes32 _prevId,</span>
 678 |     | <span class='neutral'>        bytes32 _nextId</span>
 679 |     | <span class='unexecuted'>    ) internal view returns (bytes32, bytes32) {</span>
 680 |     | <span class='unexecuted'>        bytes32 prevId = _prevId;</span>
 681 |     | <span class='unexecuted'>        bytes32 nextId = _nextId;</span>
 682 |     | <span class='neutral'></span>
 683 |     | <span class='unexecuted'>        if (prevId != dummyId) {</span>
 684 |     | <span class='unexecuted'>            if (!contains(prevId) || _NICR &gt; cdpManager.getCachedNominalICR(prevId)) {</span>
 685 |     | <span class='neutral'>                // `prevId` does not exist anymore or now has a smaller NICR than the given NICR</span>
 686 |     | <span class='neutral'>                prevId = dummyId;</span>
 687 |     | <span class='neutral'>            }</span>
 688 |     | <span class='neutral'>        }</span>
 689 |     | <span class='neutral'></span>
 690 |     | <span class='unexecuted'>        if (nextId != dummyId) {</span>
 691 |     | <span class='unexecuted'>            if (!contains(nextId) || _NICR &lt; cdpManager.getCachedNominalICR(nextId)) {</span>
 692 |     | <span class='neutral'>                // `nextId` does not exist anymore or now has a larger NICR than the given NICR</span>
 693 |     | <span class='neutral'>                nextId = dummyId;</span>
 694 |     | <span class='neutral'>            }</span>
 695 |     | <span class='neutral'>        }</span>
 696 |     | <span class='neutral'></span>
 697 |     | <span class='unexecuted'>        if (prevId == dummyId &amp;&amp; nextId == dummyId) {</span>
 698 |     | <span class='neutral'>            // No hint - descend list starting from head</span>
 699 |     | <span class='unexecuted'>            return _descendList(_NICR, data.head);</span>
 700 |     | <span class='unexecuted'>        } else if (prevId == dummyId) {</span>
 701 |     | <span class='neutral'>            // No `prevId` for hint - ascend list starting from `nextId`</span>
 702 |     | <span class='unexecuted'>            return _ascendList(_NICR, nextId);</span>
 703 |     | <span class='unexecuted'>        } else if (nextId == dummyId) {</span>
 704 |     | <span class='neutral'>            // No `nextId` for hint - descend list starting from `prevId`</span>
 705 |     | <span class='unexecuted'>            return _descendList(_NICR, prevId);</span>
 706 |     | <span class='neutral'>        } else {</span>
 707 |     | <span class='neutral'>            // Descend list starting from `prevId`</span>
 708 |     | <span class='unexecuted'>            return _descendList(_NICR, prevId);</span>
 709 |     | <span class='neutral'>        }</span>
 710 |     | <span class='neutral'>    }</span>
 711 |     | <span class='neutral'></span>
 712 |     | <span class='neutral'>    // === Modifiers ===</span>
 713 |     | <span class='neutral'></span>
 714 |     | <span class='neutral'>    /// @dev Asserts that the caller of the function is the CdpManager</span>
 715 |     | <span class='unexecuted'>    function _requireCallerIsCdpManager() internal view {</span>
 716 |     | <span class='unexecuted'>        require(msg.sender == address(cdpManager), &quot;SortedCdps: Caller is not the CdpManager&quot;);</span>
 717 |     | <span class='neutral'>    }</span>
 718 |     | <span class='neutral'></span>
 719 |     | <span class='neutral'>    /// @dev Asserts that the caller of the function is either the BorrowerOperations contract or the CdpManager</span>
 720 |     | <span class='unexecuted'>    function _requireCallerIsBOorCdpM() internal view {</span>
 721 |     | <span class='unexecuted'>        require(</span>
 722 |     | <span class='unexecuted'>            msg.sender == borrowerOperationsAddress || msg.sender == address(cdpManager),</span>
 723 |     | <span class='neutral'>            &quot;SortedCdps: Caller is neither BO nor CdpM&quot;</span>
 724 |     | <span class='neutral'>        );</span>
 725 |     | <span class='neutral'>    }</span>
 726 |     | <span class='neutral'>}</span>
 727 |     | <span class='neutral'></span>

</code>
<br />

<b>/mnt/c/Users/Lourens/Documents/Recon-Fuzz/collabs/ebtc/packages/contracts/contracts/SyncedLiquidationSequencer.sol</b>
<code>
   1 |     | <span class='neutral'>// SPDX-License-Identifier: MIT</span>
   2 |     | <span class='neutral'></span>
   3 |     | <span class='neutral'>pragma solidity 0.8.17;</span>
   4 |     | <span class='neutral'></span>
   5 |     | <span class='neutral'>import &quot;./Interfaces/IPriceFeed.sol&quot;;</span>
   6 |     | <span class='neutral'>import &quot;./Interfaces/ICdpManager.sol&quot;;</span>
   7 |     | <span class='neutral'>import &quot;./Interfaces/ISortedCdps.sol&quot;;</span>
   8 |     | <span class='neutral'>import &quot;./Interfaces/ICdpManagerData.sol&quot;;</span>
   9 |     | <span class='neutral'>import &quot;./Dependencies/EbtcBase.sol&quot;;</span>
  10 |     | <span class='neutral'></span>
  11 |     | <span class='neutral'>/// @notice Helper to turn a sequence into CDP id array for batch liquidation</span>
  12 |     | <span class='unexecuted'>contract SyncedLiquidationSequencer is EbtcBase {</span>
  13 |     | <span class='unexecuted'>    ICdpManager public immutable cdpManager;</span>
  14 |     | <span class='unexecuted'>    ISortedCdps public immutable sortedCdps;</span>
  15 |     | <span class='neutral'></span>
  16 |     | <span class='neutral'>    /// @param _cdpManagerAddress Address of CdpManager contract</span>
  17 |     | <span class='neutral'>    /// @param _sortedCdpsAddress Address of SortedCdps contract</span>
  18 |     | <span class='neutral'>    /// @param _priceFeedAddress Address of price feed</span>
  19 |     | <span class='neutral'>    /// @param _activePoolAddress Address of ActivePool</span>
  20 |     | <span class='neutral'>    /// @param _collateralAddress Address of collateral contract</span>
  21 |     | <span class='unexecuted'>    constructor(</span>
  22 |     | <span class='neutral'>        address _cdpManagerAddress,</span>
  23 |     | <span class='neutral'>        address _sortedCdpsAddress,</span>
  24 |     | <span class='neutral'>        address _priceFeedAddress,</span>
  25 |     | <span class='neutral'>        address _activePoolAddress,</span>
  26 |     | <span class='neutral'>        address _collateralAddress</span>
  27 |     | <span class='neutral'>    ) EbtcBase(_activePoolAddress, _priceFeedAddress, _collateralAddress) {</span>
  28 |     | <span class='unexecuted'>        cdpManager = ICdpManager(_cdpManagerAddress);</span>
  29 |     | <span class='unexecuted'>        sortedCdps = ISortedCdps(_sortedCdpsAddress);</span>
  30 |     | <span class='neutral'>    }</span>
  31 |     | <span class='neutral'></span>
  32 |     | <span class='neutral'>    /// @notice Get first N batch of liquidatable Cdps at current price, starting at lowest ICR</span>
  33 |     | <span class='neutral'>    /// @dev Non-view function that updates and returns live price at execution time</span>
  34 |     | <span class='neutral'>    /// @param _n Number of Cdps to retrieve</span>
  35 |     | <span class='neutral'>    /// @return _array Array of CDP IDs to batch liquidate</span>
  36 |     | <span class='unexecuted'>    function sequenceLiqToBatchLiq(uint256 _n) external returns (bytes32[] memory _array) {</span>
  37 |     | <span class='unexecuted'>        uint256 _price = priceFeed.fetchPrice();</span>
  38 |     | <span class='unexecuted'>        return sequenceLiqToBatchLiqWithPrice(_n, _price);</span>
  39 |     | <span class='neutral'>    }</span>
  40 |     | <span class='neutral'></span>
  41 |     | <span class='neutral'>    /// @notice Get first N batch of liquidatable Cdps at specified price, starting at lowest ICR</span>
  42 |     | <span class='neutral'>    /// @param _n Number of Cdps to retrieve</span>
  43 |     | <span class='neutral'>    /// @param _price stETH/BTC price</span>
  44 |     | <span class='neutral'>    /// @return _array Array of CDP IDs</span>
  45 |     | <span class='unexecuted'>    function sequenceLiqToBatchLiqWithPrice(</span>
  46 |     | <span class='neutral'>        uint256 _n,</span>
  47 |     | <span class='neutral'>        uint256 _price</span>
  48 |     | <span class='unexecuted'>    ) public view returns (bytes32[] memory _array) {</span>
  49 |     | <span class='unexecuted'>        (uint256 _TCR, , ) = _getTCRWithSystemDebtAndCollShares(_price);</span>
  50 |     | <span class='unexecuted'>        bool _recoveryModeAtStart = _TCR &lt; CCR ? true : false;</span>
  51 |     | <span class='unexecuted'>        return _sequenceLiqToBatchLiq(_n, _recoveryModeAtStart, _price);</span>
  52 |     | <span class='neutral'>    }</span>
  53 |     | <span class='neutral'></span>
  54 |     | <span class='neutral'>    /// @notice Returns array of liquidatable CDP ids</span>
  55 |     | <span class='neutral'>    /// @param _n Number of Cdps to retrieve</span>
  56 |     | <span class='neutral'>    /// @param _recoveryModeAtStart Initial recovery mode state</span>
  57 |     | <span class='neutral'>    /// @param _price stETH/BTC price</span>
  58 |     | <span class='neutral'>    /// @return _array Array of CDP IDs for batch liquidation (in NICR-decreasing order, same as SortedCdps)</span>
  59 |     | <span class='unexecuted'>    function _sequenceLiqToBatchLiq(</span>
  60 |     | <span class='neutral'>        uint256 _n,</span>
  61 |     | <span class='neutral'>        bool _recoveryModeAtStart,</span>
  62 |     | <span class='neutral'>        uint256 _price</span>
  63 |     | <span class='unexecuted'>    ) internal view returns (bytes32[] memory _array) {</span>
  64 |     | <span class='unexecuted'>        if (_n &gt; 0) {</span>
  65 |     | <span class='unexecuted'>            bytes32 _last = sortedCdps.getLast();</span>
  66 |     | <span class='unexecuted'>            bytes32 _first = sortedCdps.getFirst();</span>
  67 |     | <span class='unexecuted'>            bytes32 _cdpId = _last;</span>
  68 |     | <span class='neutral'></span>
  69 |     | <span class='unexecuted'>            uint256 _TCR = cdpManager.getSyncedTCR(_price);</span>
  70 |     | <span class='neutral'></span>
  71 |     | <span class='neutral'>            // get count of liquidatable Cdps</span>
  72 |     | <span class='unexecuted'>            uint256 _cnt;</span>
  73 |     | <span class='unexecuted'>            for (uint256 i = 0; i &lt; _n &amp;&amp; _cdpId != _first; ++i) {</span>
  74 |     | <span class='unexecuted'>                uint256 _icr = cdpManager.getSyncedICR(_cdpId, _price); /// @audit This is view ICR and not real ICR</span>
  75 |     | <span class='unexecuted'>                uint256 _cdpStatus = cdpManager.getCdpStatus(_cdpId);</span>
  76 |     | <span class='unexecuted'>                bool _liquidatable = _canLiquidateInCurrentMode(_recoveryModeAtStart, _icr, _TCR);</span>
  77 |     | <span class='unexecuted'>                if (_liquidatable &amp;&amp; _cdpStatus == 1) {</span>
  78 |     | <span class='unexecuted'>                    _cnt += 1;</span>
  79 |     | <span class='neutral'>                }</span>
  80 |     | <span class='unexecuted'>                _cdpId = sortedCdps.getPrev(_cdpId);</span>
  81 |     | <span class='neutral'>            }</span>
  82 |     | <span class='neutral'></span>
  83 |     | <span class='neutral'>            // retrieve liquidatable Cdps</span>
  84 |     | <span class='unexecuted'>            _array = new bytes32[](_cnt);</span>
  85 |     | <span class='unexecuted'>            _cdpId = _last;</span>
  86 |     | <span class='unexecuted'>            uint256 _j;</span>
  87 |     | <span class='unexecuted'>            for (uint256 i = 0; i &lt; _n &amp;&amp; _cdpId != _first; ++i) {</span>
  88 |     | <span class='unexecuted'>                uint256 _icr = cdpManager.getSyncedICR(_cdpId, _price);</span>
  89 |     | <span class='unexecuted'>                uint256 _cdpStatus = cdpManager.getCdpStatus(_cdpId);</span>
  90 |     | <span class='unexecuted'>                bool _liquidatable = _canLiquidateInCurrentMode(_recoveryModeAtStart, _icr, _TCR);</span>
  91 |     | <span class='unexecuted'>                if (_liquidatable &amp;&amp; _cdpStatus == 1) {</span>
  92 |     | <span class='neutral'>                    // 1 = ICdpManagerData.Status.active</span>
  93 |     | <span class='unexecuted'>                    _array[_cnt - _j - 1] = _cdpId;</span>
  94 |     | <span class='unexecuted'>                    _j += 1;</span>
  95 |     | <span class='neutral'>                }</span>
  96 |     | <span class='unexecuted'>                _cdpId = sortedCdps.getPrev(_cdpId);</span>
  97 |     | <span class='neutral'>            }</span>
  98 |     | <span class='unexecuted'>            require(_j == _cnt, &quot;LiquidationLibrary: wrong sequence conversion!&quot;);</span>
  99 |     | <span class='neutral'>        }</span>
 100 |     | <span class='neutral'>    }</span>
 101 |     | <span class='neutral'></span>
 102 |     | <span class='neutral'>    /// @notice Internal helper function to check if given ICR value can be liquidated in current mode</span>
 103 |     | <span class='neutral'>    /// @dev Assumes correct input values</span>
 104 |     | <span class='neutral'>    /// @param _recovery Current recovery mode state</span>
 105 |     | <span class='neutral'>    /// @param _icr CDP&#39;s current ICR</span>
 106 |     | <span class='neutral'>    /// @param _TCR Current total system collateralization ratio</span>
 107 |     | <span class='neutral'>    /// @return True if liquidatable</span>
 108 |     | <span class='unexecuted'>    function _canLiquidateInCurrentMode(</span>
 109 |     | <span class='neutral'>        bool _recovery,</span>
 110 |     | <span class='neutral'>        uint256 _icr,</span>
 111 |     | <span class='neutral'>        uint256 _TCR</span>
 112 |     | <span class='unexecuted'>    ) internal view returns (bool) {</span>
 113 |     | <span class='unexecuted'>        bool _liquidatable = _recovery ? (_icr &lt; MCR || _icr &lt;= _TCR) : _icr &lt; MCR;</span>
 114 |     | <span class='neutral'></span>
 115 |     | <span class='neutral'>        return _liquidatable;</span>
 116 |     | <span class='neutral'>    }</span>
 117 |     | <span class='neutral'>}</span>
 118 |     | <span class='neutral'></span>

</code>
<br />

<b>/mnt/c/Users/Lourens/Documents/Recon-Fuzz/collabs/ebtc/packages/contracts/contracts/TestContracts/AccruableCdpManager.sol</b>
<code>
  1 |     | <span class='neutral'>// SPDX-License-Identifier: MIT</span>
  2 |     | <span class='neutral'></span>
  3 |     | <span class='neutral'>pragma solidity 0.8.17;</span>
  4 |     | <span class='neutral'></span>
  5 |     | <span class='neutral'>import &quot;../CdpManager.sol&quot;;</span>
  6 |     | <span class='neutral'></span>
  7 |     | <span class='unexecuted'>contract AccruableCdpManager is CdpManager {</span>
  8 |     | <span class='unexecuted'>    constructor(</span>
  9 |     | <span class='neutral'>        address _liquidationLibraryAddress,</span>
 10 |     | <span class='neutral'>        address _authorityAddress,</span>
 11 |     | <span class='neutral'>        address _borrowerOperationsAddress,</span>
 12 |     | <span class='neutral'>        address _collSurplusPoolAddress,</span>
 13 |     | <span class='neutral'>        address _ebtcTokenAddress,</span>
 14 |     | <span class='neutral'>        address _sortedCdpsAddress,</span>
 15 |     | <span class='neutral'>        address _activePoolAddress,</span>
 16 |     | <span class='neutral'>        address _priceFeedAddress,</span>
 17 |     | <span class='neutral'>        address _collTokenAddress</span>
 18 |     | <span class='neutral'>    )</span>
 19 |     | <span class='neutral'>        CdpManager(</span>
 20 |     | <span class='unexecuted'>            _liquidationLibraryAddress,</span>
 21 |     | <span class='unexecuted'>            _authorityAddress,</span>
 22 |     | <span class='unexecuted'>            _borrowerOperationsAddress,</span>
 23 |     | <span class='unexecuted'>            _collSurplusPoolAddress,</span>
 24 |     | <span class='unexecuted'>            _ebtcTokenAddress,</span>
 25 |     | <span class='unexecuted'>            _sortedCdpsAddress,</span>
 26 |     | <span class='unexecuted'>            _activePoolAddress,</span>
 27 |     | <span class='unexecuted'>            _priceFeedAddress,</span>
 28 |     | <span class='unexecuted'>            _collTokenAddress</span>
 29 |     | <span class='neutral'>        )</span>
 30 |     | <span class='neutral'>    {</span>
 31 |     | <span class='neutral'>        /// @audit Based on the idea that Foundry and Echidna will not fork mainnet</span>
 32 |     | <span class='neutral'>        // require(block.chainid != 1, &quot;No prod!!!!&quot;); /// @audit CANNOT SET, PLS HAAAALP</span>
 33 |     | <span class='neutral'>    }</span>
 34 |     | <span class='neutral'></span>
 35 |     | <span class='unexecuted'>    function syncGlobalAccountingInternal() external {</span>
 36 |     | <span class='unexecuted'>        _syncGlobalAccounting();</span>
 37 |     | <span class='neutral'>    }</span>
 38 |     | <span class='neutral'></span>
 39 |     | <span class='unexecuted'>    function syncAccounting(bytes32 _cdpId) external virtual override {</span>
 40 |     | <span class='unexecuted'>        return _syncAccounting(_cdpId);</span>
 41 |     | <span class='neutral'>    }</span>
 42 |     | <span class='neutral'>}</span>
 43 |     | <span class='neutral'></span>

</code>
<br />

<b>/mnt/c/Users/Lourens/Documents/Recon-Fuzz/collabs/ebtc/packages/contracts/contracts/TestContracts/BaseStorageVariables.sol</b>
<code>
  1 |     | <span class='neutral'>// SPDX-License-Identifier: UNLICENSED</span>
  2 |     | <span class='neutral'>pragma solidity 0.8.17;</span>
  3 |     | <span class='neutral'></span>
  4 |     | <span class='neutral'>import {WETH9} from &quot;./WETH9.sol&quot;;</span>
  5 |     | <span class='neutral'>import {BorrowerOperations} from &quot;../BorrowerOperations.sol&quot;;</span>
  6 |     | <span class='neutral'>import {PriceFeedTestnet} from &quot;./testnet/PriceFeedTestnet.sol&quot;;</span>
  7 |     | <span class='neutral'>import {PriceFeedOracleTester} from &quot;./PriceFeedOracleTester.sol&quot;;</span>
  8 |     | <span class='neutral'>import {EbtcFeed} from &quot;../EbtcFeed.sol&quot;;</span>
  9 |     | <span class='neutral'>import {SortedCdps} from &quot;../SortedCdps.sol&quot;;</span>
 10 |     | <span class='neutral'>import {CdpManager} from &quot;../CdpManager.sol&quot;;</span>
 11 |     | <span class='neutral'>import {LiquidationLibrary} from &quot;../LiquidationLibrary.sol&quot;;</span>
 12 |     | <span class='neutral'>import {LiquidationSequencer} from &quot;../LiquidationSequencer.sol&quot;;</span>
 13 |     | <span class='neutral'>import {SyncedLiquidationSequencer} from &quot;../SyncedLiquidationSequencer.sol&quot;;</span>
 14 |     | <span class='neutral'>import {ActivePool} from &quot;../ActivePool.sol&quot;;</span>
 15 |     | <span class='neutral'>import {HintHelpers} from &quot;../HintHelpers.sol&quot;;</span>
 16 |     | <span class='neutral'>import {FeeRecipient} from &quot;../FeeRecipient.sol&quot;;</span>
 17 |     | <span class='neutral'>import {EBTCToken} from &quot;../EBTCToken.sol&quot;;</span>
 18 |     | <span class='neutral'>import {CollSurplusPool} from &quot;../CollSurplusPool.sol&quot;;</span>
 19 |     | <span class='neutral'>import {FunctionCaller} from &quot;./FunctionCaller.sol&quot;;</span>
 20 |     | <span class='neutral'>import {CollateralTokenTester} from &quot;./CollateralTokenTester.sol&quot;;</span>
 21 |     | <span class='neutral'>import {Governor} from &quot;../Governor.sol&quot;;</span>
 22 |     | <span class='neutral'>import {EBTCDeployer} from &quot;../EBTCDeployer.sol&quot;;</span>
 23 |     | <span class='neutral'>import {Actor} from &quot;./invariants/Actor.sol&quot;;</span>
 24 |     | <span class='neutral'>import {CRLens} from &quot;./CRLens.sol&quot;;</span>
 25 |     | <span class='neutral'>import {Simulator} from &quot;./invariants/Simulator.sol&quot;;</span>
 26 |     | <span class='neutral'></span>
 27 |     | <span class='neutral'>abstract contract BaseStorageVariables {</span>
 28 |     | <span class='neutral'>    PriceFeedTestnet internal priceFeedMock;</span>
 29 |     | <span class='neutral'>    EbtcFeed internal ebtcFeed;</span>
 30 |     | <span class='neutral'>    PriceFeedOracleTester internal primaryOracle;</span>
 31 |     | <span class='neutral'>    SortedCdps internal sortedCdps;</span>
 32 |     | <span class='neutral'>    CdpManager internal cdpManager;</span>
 33 |     | <span class='neutral'>    WETH9 internal weth;</span>
 34 |     | <span class='neutral'>    ActivePool internal activePool;</span>
 35 |     | <span class='neutral'>    CollSurplusPool internal collSurplusPool;</span>
 36 |     | <span class='neutral'>    FunctionCaller internal functionCaller;</span>
 37 |     | <span class='neutral'>    BorrowerOperations internal borrowerOperations;</span>
 38 |     | <span class='neutral'>    HintHelpers internal hintHelpers;</span>
 39 |     | <span class='neutral'>    EBTCToken internal eBTCToken;</span>
 40 |     | <span class='neutral'>    CollateralTokenTester internal collateral;</span>
 41 |     | <span class='neutral'>    Governor internal authority;</span>
 42 |     | <span class='neutral'>    LiquidationLibrary internal liqudationLibrary;</span>
 43 |     | <span class='neutral'>    LiquidationSequencer internal liquidationSequencer;</span>
 44 |     | <span class='neutral'>    SyncedLiquidationSequencer internal syncedLiquidationSequencer;</span>
 45 |     | <span class='neutral'>    EBTCDeployer internal ebtcDeployer;</span>
 46 |     | <span class='neutral'>    address internal defaultGovernance;</span>
 47 |     | <span class='neutral'></span>
 48 |     | <span class='neutral'>    // LQTY Stuff</span>
 49 |     | <span class='neutral'>    FeeRecipient internal feeRecipient;</span>
 50 |     | <span class='neutral'></span>
 51 |     | <span class='neutral'>    mapping(address =&gt; Actor) internal actors;</span>
 52 |     | <span class='neutral'>    Actor internal actor;</span>
 53 |     | <span class='neutral'></span>
 54 |     | <span class='neutral'>    CRLens internal crLens;</span>
 55 |     | <span class='neutral'>    Simulator internal simulator;</span>
 56 |     | <span class='neutral'></span>
 57 |     | <span class='unexecuted'>    uint internal constant NUMBER_OF_ACTORS = 3;</span>
 58 |     | <span class='unexecuted'>    uint internal constant INITIAL_ETH_BALANCE = 1e24;</span>
 59 | *   | <span class='executed'>    uint internal constant INITIAL_COLL_BALANCE = 1e21;</span>
 60 |     | <span class='neutral'></span>
 61 |     | <span class='unexecuted'>    uint internal constant diff_tolerance = 0.000000000002e18; //compared to 1e18</span>
 62 | *   | <span class='executed'>    uint internal constant MAX_PRICE_CHANGE_PERCENT = 1.05e18; //compared to 1e18</span>
 63 | *   | <span class='executed'>    uint internal constant MAX_REBASE_PERCENT = 1.1e18; //compared to 1e18</span>
 64 | *   | <span class='executed'>    uint internal constant MAX_FLASHLOAN_ACTIONS = 4;</span>
 65 |     | <span class='neutral'></span>
 66 |     | <span class='neutral'>    uint256 totalCdpDustMaxCap; // The amount of dust we expect if each cdp will lock in at most 1 wei of error</span>
 67 |     | <span class='neutral'>}</span>
 68 |     | <span class='neutral'></span>

</code>
<br />

<b>/mnt/c/Users/Lourens/Documents/Recon-Fuzz/collabs/ebtc/packages/contracts/contracts/TestContracts/CRLens.sol</b>
<code>
   1 |     | <span class='neutral'>// SPDX-License-Identifier: MIT</span>
   2 |     | <span class='neutral'></span>
   3 |     | <span class='neutral'>pragma solidity 0.8.17;</span>
   4 |     | <span class='neutral'></span>
   5 |     | <span class='neutral'>import &quot;@crytic/properties/contracts/util/Hevm.sol&quot;;</span>
   6 |     | <span class='neutral'></span>
   7 |     | <span class='neutral'>import &quot;../Interfaces/IPriceFeed.sol&quot;;</span>
   8 |     | <span class='neutral'>import &quot;../Interfaces/IBorrowerOperations.sol&quot;;</span>
   9 |     | <span class='neutral'>import &quot;../Interfaces/ICdpManager.sol&quot;;</span>
  10 |     | <span class='neutral'></span>
  11 |     | <span class='neutral'>/// @notice The contract allows to check real CR of Cdps</span>
  12 |     | <span class='neutral'>///   Acknowledgement: https://github.com/Uniswap/v3-periphery/blob/main/contracts/lens/Quoter.sol</span>
  13 | *   | <span class='executed'>contract CRLens {</span>
  14 |     | <span class='unexecuted'>    ICdpManager public immutable cdpManager;</span>
  15 |     | <span class='unexecuted'>    IBorrowerOperations public immutable borrowerOperations;</span>
  16 |     | <span class='unexecuted'>    IPriceFeed public immutable priceFeed;</span>
  17 |     | <span class='neutral'></span>
  18 |     | <span class='unexecuted'>    constructor(address _cdpManager, address _borrowerOperations, address _priceFeed) {</span>
  19 |     | <span class='unexecuted'>        cdpManager = ICdpManager(_cdpManager);</span>
  20 |     | <span class='unexecuted'>        borrowerOperations = IBorrowerOperations(_borrowerOperations);</span>
  21 |     | <span class='unexecuted'>        priceFeed = IPriceFeed(_priceFeed);</span>
  22 |     | <span class='neutral'>    }</span>
  23 |     | <span class='neutral'></span>
  24 |     | <span class='neutral'>    // == CORE FUNCTIONS == //</span>
  25 |     | <span class='neutral'></span>
  26 |     | <span class='neutral'>    /// @notice Returns the TCR of the system after the fee split</span>
  27 |     | <span class='neutral'>    /// @dev Call this from offChain with `eth_call` to avoid paying for gas</span>
  28 | *   | <span class='executed'>    function getRealTCR(bool revertValue) external returns (uint256) {</span>
  29 |     | <span class='neutral'>        // Synch State</span>
  30 | *   | <span class='executed'>        cdpManager.syncGlobalAccountingAndGracePeriod();</span>
  31 |     | <span class='neutral'></span>
  32 |     | <span class='neutral'>        // Return latest</span>
  33 | *   | <span class='executed'>        uint price = priceFeed.fetchPrice();</span>
  34 | *   | <span class='executed'>        uint256 tcr = cdpManager.getCachedTCR(price);</span>
  35 |     | <span class='neutral'></span>
  36 | *   | <span class='executed'>        if (revertValue) {</span>
  37 |     | <span class='neutral'>            assembly {</span>
  38 | *   | <span class='executed'>                let ptr := mload(0x40)</span>
  39 | *   | <span class='executed'>                mstore(ptr, tcr)</span>
  40 | *   | <span class='executed'>                revert(ptr, 32)</span>
  41 |     | <span class='neutral'>            }</span>
  42 |     | <span class='neutral'>        }</span>
  43 |     | <span class='neutral'></span>
  44 |     | <span class='neutral'>        return tcr;</span>
  45 |     | <span class='neutral'>    }</span>
  46 |     | <span class='neutral'></span>
  47 |     | <span class='neutral'>    /// @notice Return the ICR of a CDP after the fee split</span>
  48 |     | <span class='neutral'>    /// @dev Call this from offChain with `eth_call` to avoid paying for gas</span>
  49 |     | <span class='unexecuted'>    function getRealICR(bytes32 cdpId, bool revertValue) external returns (uint256) {</span>
  50 |     | <span class='unexecuted'>        hevm.prank(address(borrowerOperations));</span>
  51 |     | <span class='unexecuted'>        cdpManager.syncAccounting(cdpId);</span>
  52 |     | <span class='unexecuted'>        uint price = priceFeed.fetchPrice();</span>
  53 |     | <span class='unexecuted'>        uint256 icr = cdpManager.getCachedICR(cdpId, price);</span>
  54 |     | <span class='neutral'></span>
  55 |     | <span class='neutral'>        if (revertValue) {</span>
  56 |     | <span class='neutral'>            assembly {</span>
  57 |     | <span class='neutral'>                let ptr := mload(0x40)</span>
  58 |     | <span class='neutral'>                mstore(ptr, icr)</span>
  59 |     | <span class='neutral'>                revert(ptr, 32)</span>
  60 |     | <span class='neutral'>            }</span>
  61 |     | <span class='neutral'>        }</span>
  62 |     | <span class='neutral'></span>
  63 |     | <span class='neutral'>        return icr;</span>
  64 |     | <span class='neutral'>    }</span>
  65 |     | <span class='neutral'></span>
  66 |     | <span class='neutral'>    /// @notice Return the ICR of a CDP after the fee split</span>
  67 |     | <span class='neutral'>    /// @dev Call this from offChain with `eth_call` to avoid paying for gas</span>
  68 | *   | <span class='executed'>    function getRealNICR(bytes32 cdpId, bool revertValue) external returns (uint256) {</span>
  69 | *   | <span class='executed'>        hevm.prank(address(borrowerOperations));</span>
  70 | *   | <span class='executed'>        cdpManager.syncAccounting(cdpId);</span>
  71 | *   | <span class='executed'>        uint price = priceFeed.fetchPrice();</span>
  72 | *   | <span class='executed'>        uint256 icr = cdpManager.getCachedNominalICR(cdpId);</span>
  73 |     | <span class='neutral'></span>
  74 | *   | <span class='executed'>        if (revertValue) {</span>
  75 |     | <span class='neutral'>            assembly {</span>
  76 | *   | <span class='executed'>                let ptr := mload(0x40)</span>
  77 | *   | <span class='executed'>                mstore(ptr, icr)</span>
  78 | *   | <span class='executed'>                revert(ptr, 32)</span>
  79 |     | <span class='neutral'>            }</span>
  80 |     | <span class='neutral'>        }</span>
  81 |     | <span class='neutral'></span>
  82 |     | <span class='unexecuted'>        return icr;</span>
  83 |     | <span class='neutral'>    }</span>
  84 |     | <span class='neutral'></span>
  85 | *   | <span class='executed'>    function getRealStake(bytes32 cdpId) external returns (uint256) {</span>
  86 | *   | <span class='executed'>        cdpManager.syncAccounting(cdpId);</span>
  87 |     | <span class='unexecuted'>        uint256 collShares = cdpManager.getCdpCollShares(cdpId);</span>
  88 | *   | <span class='executed'>        return</span>
  89 | *   | <span class='executed'>            cdpManager.totalCollateralSnapshot() == 0</span>
  90 |     | <span class='unexecuted'>                ? collShares</span>
  91 |     | <span class='unexecuted'>                : (collShares * cdpManager.totalStakesSnapshot()) /</span>
  92 |     | <span class='unexecuted'>                    cdpManager.totalCollateralSnapshot();</span>
  93 |     | <span class='neutral'>    }</span>
  94 |     | <span class='neutral'></span>
  95 |     | <span class='neutral'>    /// @dev Returns 1 if we&#39;re in RM</span>
  96 | *   | <span class='executed'>    function getCheckRecoveryMode(bool revertValue) external returns (uint256) {</span>
  97 |     | <span class='neutral'>        // Synch State</span>
  98 | *   | <span class='executed'>        cdpManager.syncGlobalAccountingAndGracePeriod();</span>
  99 |     | <span class='neutral'></span>
 100 |     | <span class='neutral'>        // Return latest</span>
 101 | *   | <span class='executed'>        uint price = priceFeed.fetchPrice();</span>
 102 | *   | <span class='executed'>        uint256 isRm = cdpManager.checkRecoveryMode(price) == true ? 1 : 0;</span>
 103 |     | <span class='neutral'></span>
 104 | *   | <span class='executed'>        if (revertValue) {</span>
 105 |     | <span class='neutral'>            assembly {</span>
 106 | *   | <span class='executed'>                let ptr := mload(0x40)</span>
 107 | *   | <span class='executed'>                mstore(ptr, isRm)</span>
 108 | *   | <span class='executed'>                revert(ptr, 32)</span>
 109 |     | <span class='neutral'>            }</span>
 110 |     | <span class='neutral'>        }</span>
 111 |     | <span class='neutral'></span>
 112 |     | <span class='neutral'>        return isRm;</span>
 113 |     | <span class='neutral'>    }</span>
 114 |     | <span class='neutral'></span>
 115 |     | <span class='neutral'>    // == REVERT LOGIC == //</span>
 116 |     | <span class='neutral'>    // Thanks to: https://github.com/Uniswap/v3-periphery/blob/main/contracts/lens/Quoter.sol</span>
 117 |     | <span class='neutral'>    // NOTE: You should never use these in prod, these are just for testing //</span>
 118 |     | <span class='neutral'></span>
 119 | *   | <span class='executed'>    function parseRevertReason(bytes memory reason) private pure returns (uint256) {</span>
 120 | *   | <span class='executed'>        if (reason.length != 32) {</span>
 121 |     | <span class='unexecuted'>            if (reason.length &lt; 68) revert(&quot;Unexpected error&quot;);</span>
 122 |     | <span class='neutral'>            assembly {</span>
 123 |     | <span class='unexecuted'>                reason := add(reason, 0x04)</span>
 124 |     | <span class='neutral'>            }</span>
 125 |     | <span class='unexecuted'>            revert(abi.decode(reason, (string)));</span>
 126 |     | <span class='neutral'>        }</span>
 127 | *   | <span class='executed'>        return abi.decode(reason, (uint256));</span>
 128 |     | <span class='neutral'>    }</span>
 129 |     | <span class='neutral'></span>
 130 |     | <span class='neutral'>    /// @notice Returns the TCR of the system after the fee split</span>
 131 |     | <span class='neutral'>    /// @dev Call this from offChain with `eth_call` to avoid paying for gas</span>
 132 |     | <span class='neutral'>    ///     These cost more gas, there should never be a reason for you to use them beside integration with Echidna</span>
 133 | *   | <span class='executed'>    function quoteRealTCR() external returns (uint256) {</span>
 134 | *   | <span class='executed'>        try this.getRealTCR(true) {} catch (bytes memory reason) {</span>
 135 |     | <span class='neutral'>            return parseRevertReason(reason);</span>
 136 |     | <span class='neutral'>        }</span>
 137 |     | <span class='neutral'>    }</span>
 138 |     | <span class='neutral'></span>
 139 |     | <span class='neutral'>    /// @notice Returns the ICR of the system after the fee split</span>
 140 |     | <span class='neutral'>    /// @dev Call this from offChain with `eth_call` to avoid paying for gas</span>
 141 |     | <span class='neutral'>    ///     These cost more gas, there should never be a reason for you to use them beside integration with Echidna</span>
 142 |     | <span class='unexecuted'>    function quoteRealICR(bytes32 cdpId) external returns (uint256) {</span>
 143 |     | <span class='unexecuted'>        try this.getRealICR(cdpId, true) {} catch (bytes memory reason) {</span>
 144 |     | <span class='neutral'>            return parseRevertReason(reason);</span>
 145 |     | <span class='neutral'>        }</span>
 146 |     | <span class='neutral'>    }</span>
 147 |     | <span class='neutral'></span>
 148 |     | <span class='neutral'>    /// @notice Returns the NICR of the system after the fee split</span>
 149 |     | <span class='neutral'>    /// @dev Call this from offChain with `eth_call` to avoid paying for gas</span>
 150 |     | <span class='neutral'>    ///     These cost more gas, there should never be a reason for you to use them beside integration with Echidna</span>
 151 | *   | <span class='executed'>    function quoteRealNICR(bytes32 cdpId) external returns (uint256) {</span>
 152 | *   | <span class='executed'>        try this.getRealNICR(cdpId, true) {} catch (bytes memory reason) {</span>
 153 | *   | <span class='executed'>            return parseRevertReason(reason);</span>
 154 |     | <span class='neutral'>        }</span>
 155 |     | <span class='neutral'>    }</span>
 156 |     | <span class='neutral'></span>
 157 |     | <span class='neutral'>    /// @notice Returns whether the system is in RM after taking fee split</span>
 158 |     | <span class='neutral'>    /// @dev Call this from offChain with `eth_call` to avoid paying for gas</span>
 159 |     | <span class='neutral'>    ///     These cost more gas, there should never be a reason for you to use them beside integration with Echidna</span>
 160 | *   | <span class='executed'>    function quoteCheckRecoveryMode() external returns (uint256) {</span>
 161 | *   | <span class='executed'>        try this.getCheckRecoveryMode(true) {} catch (bytes memory reason) {</span>
 162 | *   | <span class='executed'>            return parseRevertReason(reason);</span>
 163 |     | <span class='neutral'>        }</span>
 164 |     | <span class='neutral'>    }</span>
 165 |     | <span class='neutral'></span>
 166 |     | <span class='unexecuted'>    function quoteAnything(function() external anything) external returns (uint256) {</span>
 167 |     | <span class='unexecuted'>        try anything() {} catch (bytes memory reason) {</span>
 168 |     | <span class='unexecuted'>            return parseRevertReason(reason);</span>
 169 |     | <span class='neutral'>        }</span>
 170 |     | <span class='neutral'>    }</span>
 171 |     | <span class='neutral'>}</span>
 172 |     | <span class='neutral'></span>

</code>
<br />

<b>/mnt/c/Users/Lourens/Documents/Recon-Fuzz/collabs/ebtc/packages/contracts/contracts/TestContracts/CollateralTokenTester.sol</b>
<code>
   1 |     | <span class='neutral'>// SPDX-License-Identifier: MIT</span>
   2 |     | <span class='neutral'>pragma solidity 0.8.17;</span>
   3 |     | <span class='neutral'></span>
   4 |     | <span class='neutral'>import &quot;../Dependencies/ICollateralToken.sol&quot;;</span>
   5 |     | <span class='neutral'>import &quot;../Dependencies/ICollateralTokenOracle.sol&quot;;</span>
   6 |     | <span class='neutral'>import &quot;../Dependencies/Ownable.sol&quot;;</span>
   7 |     | <span class='neutral'></span>
   8 |     | <span class='neutral'>interface IEbtcInternalPool {</span>
   9 |     | <span class='neutral'>    function increaseSystemCollShares(uint256 _value) external;</span>
  10 |     | <span class='neutral'>}</span>
  11 |     | <span class='neutral'></span>
  12 |     | <span class='neutral'>// based on WETH9 contract</span>
  13 |     | <span class='unexecuted'>contract CollateralTokenTester is ICollateralToken, ICollateralTokenOracle, Ownable {</span>
  14 |     | <span class='unexecuted'>    string public override name = &quot;Collateral Token Tester in eBTC&quot;;</span>
  15 |     | <span class='unexecuted'>    string public override symbol = &quot;CollTester&quot;;</span>
  16 |     | <span class='unexecuted'>    uint8 public override decimals = 18;</span>
  17 |     | <span class='neutral'></span>
  18 |     | <span class='neutral'>    event TransferShares(address indexed from, address indexed to, uint256 sharesValue);</span>
  19 |     | <span class='neutral'>    event Deposit(address indexed dst, uint256 wad, uint256 _share);</span>
  20 |     | <span class='neutral'>    event Withdrawal(address indexed src, uint256 wad, uint256 _share);</span>
  21 |     | <span class='neutral'>    event UncappedMinterAdded(address indexed account);</span>
  22 |     | <span class='neutral'>    event UncappedMinterRemoved(address indexed account);</span>
  23 |     | <span class='neutral'>    event MintCapSet(uint256 indexed newCap);</span>
  24 |     | <span class='neutral'>    event MintCooldownSet(uint256 indexed newCooldown);</span>
  25 |     | <span class='neutral'></span>
  26 |     | <span class='unexecuted'>    mapping(address =&gt; mapping(address =&gt; uint256)) public override allowance;</span>
  27 |     | <span class='unexecuted'>    mapping(address =&gt; bool) public isUncappedMinter;</span>
  28 |     | <span class='unexecuted'>    mapping(address =&gt; uint256) public lastMintTime;</span>
  29 |     | <span class='neutral'></span>
  30 |     | <span class='neutral'>    // Faucet capped at 10 Collateral tokens per day</span>
  31 |     | <span class='unexecuted'>    uint256 public mintCap = 10e18;</span>
  32 |     | <span class='unexecuted'>    uint256 public mintCooldown = 60 * 60 * 24;</span>
  33 |     | <span class='neutral'></span>
  34 |     | <span class='neutral'>    // NOTE: Seeded a 1e18 to avoid bs</span>
  35 |     | <span class='unexecuted'>    uint256 _getTotalShares = 1e18;</span>
  36 |     | <span class='unexecuted'>    uint256 _getTotalPooledEther = 1e18;</span>
  37 |     | <span class='unexecuted'>    mapping(address =&gt; uint256) public shares;</span>
  38 |     | <span class='neutral'></span>
  39 |     | <span class='unexecuted'>    uint256 private epochsPerFrame = 225;</span>
  40 |     | <span class='unexecuted'>    uint256 private slotsPerEpoch = 32;</span>
  41 |     | <span class='unexecuted'>    uint256 private secondsPerSlot = 12;</span>
  42 |     | <span class='neutral'></span>
  43 |     | <span class='neutral'>    receive() external payable {</span>
  44 |     | <span class='unexecuted'>        deposit();</span>
  45 |     | <span class='neutral'>    }</span>
  46 |     | <span class='neutral'></span>
  47 |     | <span class='unexecuted'>    function deposit() public payable {</span>
  48 |     | <span class='unexecuted'>        uint256 _share = getSharesByPooledEth(msg.value);</span>
  49 |     | <span class='unexecuted'>        shares[msg.sender] += _share;</span>
  50 |     | <span class='unexecuted'>        _getTotalShares += _share;</span>
  51 |     | <span class='unexecuted'>        _getTotalPooledEther += msg.value;</span>
  52 |     | <span class='neutral'></span>
  53 |     | <span class='unexecuted'>        emit Deposit(msg.sender, msg.value, _share);</span>
  54 |     | <span class='neutral'>    }</span>
  55 |     | <span class='neutral'></span>
  56 |     | <span class='neutral'>    /// @dev Deposit collateral without ether for testing purposes</span>
  57 |     | <span class='unexecuted'>    function forceDeposit(uint256 ethToDeposit) external {</span>
  58 |     | <span class='unexecuted'>        if (!isUncappedMinter[msg.sender]) {</span>
  59 |     | <span class='unexecuted'>            require(ethToDeposit &lt;= mintCap, &quot;CollTester: Above mint cap&quot;);</span>
  60 |     | <span class='unexecuted'>            require(</span>
  61 |     | <span class='unexecuted'>                lastMintTime[msg.sender] == 0 ||</span>
  62 |     | <span class='unexecuted'>                    lastMintTime[msg.sender] + mintCooldown &lt; block.timestamp,</span>
  63 |     | <span class='neutral'>                &quot;CollTester: Cooldown period not completed&quot;</span>
  64 |     | <span class='neutral'>            );</span>
  65 |     | <span class='unexecuted'>            lastMintTime[msg.sender] = block.timestamp;</span>
  66 |     | <span class='neutral'>        }</span>
  67 |     | <span class='unexecuted'>        uint256 _share = getSharesByPooledEth(ethToDeposit);</span>
  68 |     | <span class='unexecuted'>        shares[msg.sender] += _share;</span>
  69 |     | <span class='unexecuted'>        _getTotalShares += _share;</span>
  70 |     | <span class='unexecuted'>        _getTotalPooledEther += ethToDeposit;</span>
  71 |     | <span class='neutral'></span>
  72 |     | <span class='unexecuted'>        emit Deposit(msg.sender, ethToDeposit, _share);</span>
  73 |     | <span class='neutral'>    }</span>
  74 |     | <span class='neutral'></span>
  75 |     | <span class='unexecuted'>    function withdraw(uint256 wad) public {</span>
  76 |     | <span class='unexecuted'>        uint256 _share = getSharesByPooledEth(wad);</span>
  77 |     | <span class='unexecuted'>        require(shares[msg.sender] &gt;= _share);</span>
  78 |     | <span class='unexecuted'>        shares[msg.sender] -= _share;</span>
  79 |     | <span class='unexecuted'>        _getTotalShares -= _share;</span>
  80 |     | <span class='unexecuted'>        payable(msg.sender).transfer(wad);</span>
  81 |     | <span class='unexecuted'>        emit Withdrawal(msg.sender, wad, _share);</span>
  82 |     | <span class='neutral'>    }</span>
  83 |     | <span class='neutral'></span>
  84 |     | <span class='unexecuted'>    function totalSupply() public view override returns (uint) {</span>
  85 |     | <span class='unexecuted'>        return _getTotalPooledEther;</span>
  86 |     | <span class='neutral'>    }</span>
  87 |     | <span class='neutral'></span>
  88 |     | <span class='neutral'>    // Permissioned functions</span>
  89 |     | <span class='unexecuted'>    function addUncappedMinter(address account) external onlyOwner {</span>
  90 |     | <span class='unexecuted'>        isUncappedMinter[account] = true;</span>
  91 |     | <span class='unexecuted'>        emit UncappedMinterAdded(account);</span>
  92 |     | <span class='neutral'>    }</span>
  93 |     | <span class='neutral'></span>
  94 |     | <span class='unexecuted'>    function removeUncappedMinter(address account) external onlyOwner {</span>
  95 |     | <span class='unexecuted'>        isUncappedMinter[account] = false;</span>
  96 |     | <span class='unexecuted'>        emit UncappedMinterRemoved(account);</span>
  97 |     | <span class='neutral'>    }</span>
  98 |     | <span class='neutral'></span>
  99 |     | <span class='unexecuted'>    function setMintCap(uint256 newCap) external onlyOwner {</span>
 100 |     | <span class='unexecuted'>        mintCap = newCap;</span>
 101 |     | <span class='unexecuted'>        emit MintCapSet(newCap);</span>
 102 |     | <span class='neutral'>    }</span>
 103 |     | <span class='neutral'></span>
 104 |     | <span class='unexecuted'>    function setMintCooldown(uint256 newCooldown) external onlyOwner {</span>
 105 |     | <span class='unexecuted'>        mintCooldown = newCooldown;</span>
 106 |     | <span class='unexecuted'>        emit MintCooldownSet(newCooldown);</span>
 107 |     | <span class='neutral'>    }</span>
 108 |     | <span class='neutral'></span>
 109 |     | <span class='neutral'>    // helper to set allowance in test</span>
 110 |     | <span class='unexecuted'>    function nonStandardSetApproval(</span>
 111 |     | <span class='neutral'>        address owner,</span>
 112 |     | <span class='neutral'>        address guy,</span>
 113 |     | <span class='neutral'>        uint256 wad</span>
 114 |     | <span class='unexecuted'>    ) external returns (bool) {</span>
 115 |     | <span class='unexecuted'>        allowance[owner][guy] = wad;</span>
 116 |     | <span class='unexecuted'>        emit Approval(owner, guy, wad);</span>
 117 |     | <span class='unexecuted'>        return true;</span>
 118 |     | <span class='neutral'>    }</span>
 119 |     | <span class='neutral'></span>
 120 |     | <span class='unexecuted'>    function approve(address guy, uint256 wad) public override returns (bool) {</span>
 121 |     | <span class='unexecuted'>        allowance[msg.sender][guy] = wad;</span>
 122 |     | <span class='unexecuted'>        emit Approval(msg.sender, guy, wad);</span>
 123 |     | <span class='unexecuted'>        return true;</span>
 124 |     | <span class='neutral'>    }</span>
 125 |     | <span class='neutral'></span>
 126 |     | <span class='unexecuted'>    function transfer(address dst, uint256 wad) public override returns (bool) {</span>
 127 |     | <span class='unexecuted'>        return transferFrom(msg.sender, dst, wad);</span>
 128 |     | <span class='neutral'>    }</span>
 129 |     | <span class='neutral'></span>
 130 |     | <span class='unexecuted'>    function transferFrom(address src, address dst, uint256 wad) public override returns (bool) {</span>
 131 |     | <span class='unexecuted'>        uint256 _share = getSharesByPooledEth(wad);</span>
 132 |     | <span class='unexecuted'>        require(shares[src] &gt;= _share, &quot;ERC20: transfer amount exceeds balance&quot;);</span>
 133 |     | <span class='neutral'></span>
 134 |     | <span class='unexecuted'>        if (src != msg.sender &amp;&amp; allowance[src][msg.sender] != type(uint256).max) {</span>
 135 |     | <span class='unexecuted'>            require(allowance[src][msg.sender] &gt;= wad);</span>
 136 |     | <span class='unexecuted'>            allowance[src][msg.sender] -= wad;</span>
 137 |     | <span class='neutral'>        }</span>
 138 |     | <span class='neutral'></span>
 139 |     | <span class='unexecuted'>        shares[src] -= _share;</span>
 140 |     | <span class='unexecuted'>        shares[dst] += _share;</span>
 141 |     | <span class='neutral'></span>
 142 |     | <span class='unexecuted'>        _emitTransferEvents(src, dst, wad, _share);</span>
 143 |     | <span class='neutral'></span>
 144 |     | <span class='unexecuted'>        return true;</span>
 145 |     | <span class='neutral'>    }</span>
 146 |     | <span class='neutral'></span>
 147 |     | <span class='neutral'>    // tests should adjust the ratio by this function</span>
 148 |     | <span class='unexecuted'>    function setEthPerShare(uint256 _ePerS) external {</span>
 149 |     | <span class='neutral'>        // We change this</span>
 150 |     | <span class='unexecuted'>        _getTotalPooledEther = _div(_mul(_getTotalShares, _ePerS), 1e18);</span>
 151 |     | <span class='neutral'>    }</span>
 152 |     | <span class='neutral'></span>
 153 |     | <span class='unexecuted'>    function getEthPerShare() external view returns (uint256) {</span>
 154 |     | <span class='unexecuted'>        return _div(_mul(1e18, _getTotalPooledEther), _getTotalShares);</span>
 155 |     | <span class='neutral'>    }</span>
 156 |     | <span class='neutral'></span>
 157 |     | <span class='neutral'>    /***</span>
 158 |     | <span class='neutral'>        function getSharesByPooledEth(uint256 _ethAmount) public view returns (uint256) {</span>
 159 |     | <span class='neutral'>            return _ethAmount</span>
 160 |     | <span class='neutral'>                .mul(_getTotalShares())</span>
 161 |     | <span class='neutral'>                .div(_getTotalPooledEther());</span>
 162 |     | <span class='neutral'>        }</span>
 163 |     | <span class='neutral'>     */</span>
 164 |     | <span class='neutral'></span>
 165 |     | <span class='unexecuted'>    function getSharesByPooledEth(uint256 _ethAmount) public view override returns (uint256) {</span>
 166 |     | <span class='unexecuted'>        return _div(_mul(_ethAmount, _getTotalShares), _getTotalPooledEther);</span>
 167 |     | <span class='neutral'>    }</span>
 168 |     | <span class='neutral'></span>
 169 |     | <span class='neutral'>    /**</span>
 170 |     | <span class='neutral'>            function getPooledEthByShares(uint256 _sharesAmount) public view returns (uint256) {</span>
 171 |     | <span class='neutral'>            return _sharesAmount</span>
 172 |     | <span class='neutral'>                .mul(_getTotalPooledEther())</span>
 173 |     | <span class='neutral'>                .div(_getTotalShares());</span>
 174 |     | <span class='neutral'>        }</span>
 175 |     | <span class='neutral'>     */</span>
 176 |     | <span class='neutral'></span>
 177 |     | <span class='unexecuted'>    function getPooledEthByShares(uint256 _sharesAmount) public view override returns (uint256) {</span>
 178 |     | <span class='unexecuted'>        return _div(_mul(_sharesAmount, _getTotalPooledEther), _getTotalShares);</span>
 179 |     | <span class='neutral'>    }</span>
 180 |     | <span class='neutral'></span>
 181 |     | <span class='unexecuted'>    function transferShares(</span>
 182 |     | <span class='neutral'>        address _recipient,</span>
 183 |     | <span class='neutral'>        uint256 _sharesAmount</span>
 184 |     | <span class='unexecuted'>    ) public override returns (uint256) {</span>
 185 |     | <span class='unexecuted'>        uint256 _tknAmt = getPooledEthByShares(_sharesAmount);</span>
 186 |     | <span class='neutral'></span>
 187 |     | <span class='neutral'>        // NOTE: Changed here to transfer underlying shares without rounding</span>
 188 |     | <span class='unexecuted'>        shares[msg.sender] -= _sharesAmount;</span>
 189 |     | <span class='unexecuted'>        shares[_recipient] += _sharesAmount;</span>
 190 |     | <span class='neutral'></span>
 191 |     | <span class='unexecuted'>        _emitTransferEvents(msg.sender, _recipient, _tknAmt, _sharesAmount);</span>
 192 |     | <span class='neutral'></span>
 193 |     | <span class='unexecuted'>        return _tknAmt;</span>
 194 |     | <span class='neutral'>    }</span>
 195 |     | <span class='neutral'></span>
 196 |     | <span class='unexecuted'>    function sharesOf(address _account) public view override returns (uint256) {</span>
 197 |     | <span class='unexecuted'>        return shares[_account];</span>
 198 |     | <span class='neutral'>    }</span>
 199 |     | <span class='neutral'></span>
 200 |     | <span class='unexecuted'>    function getOracle() external view override returns (address) {</span>
 201 |     | <span class='unexecuted'>        return address(this);</span>
 202 |     | <span class='neutral'>    }</span>
 203 |     | <span class='neutral'></span>
 204 |     | <span class='unexecuted'>    function getBeaconSpec() public view override returns (uint64, uint64, uint64, uint64) {</span>
 205 |     | <span class='neutral'>        return (</span>
 206 |     | <span class='unexecuted'>            uint64(epochsPerFrame),</span>
 207 |     | <span class='unexecuted'>            uint64(slotsPerEpoch),</span>
 208 |     | <span class='unexecuted'>            uint64(secondsPerSlot),</span>
 209 |     | <span class='unexecuted'>            uint64(block.timestamp)</span>
 210 |     | <span class='neutral'>        );</span>
 211 |     | <span class='neutral'>    }</span>
 212 |     | <span class='neutral'></span>
 213 |     | <span class='unexecuted'>    function setBeaconSpec(</span>
 214 |     | <span class='neutral'>        uint64 _epochsPerFrame,</span>
 215 |     | <span class='neutral'>        uint64 _slotsPerEpoch,</span>
 216 |     | <span class='neutral'>        uint64 _secondsPerSlot</span>
 217 |     | <span class='neutral'>    ) external {</span>
 218 |     | <span class='unexecuted'>        epochsPerFrame = _epochsPerFrame;</span>
 219 |     | <span class='unexecuted'>        slotsPerEpoch = _slotsPerEpoch;</span>
 220 |     | <span class='unexecuted'>        secondsPerSlot = _secondsPerSlot;</span>
 221 |     | <span class='neutral'>    }</span>
 222 |     | <span class='neutral'></span>
 223 |     | <span class='unexecuted'>    function decreaseAllowance(</span>
 224 |     | <span class='neutral'>        address spender,</span>
 225 |     | <span class='neutral'>        uint256 subtractedValue</span>
 226 |     | <span class='unexecuted'>    ) external override returns (bool) {</span>
 227 |     | <span class='unexecuted'>        approve(spender, allowance[msg.sender][spender] - subtractedValue);</span>
 228 |     | <span class='neutral'>        return true;</span>
 229 |     | <span class='neutral'>    }</span>
 230 |     | <span class='neutral'></span>
 231 |     | <span class='unexecuted'>    function balanceOf(address _usr) external view override returns (uint256) {</span>
 232 |     | <span class='unexecuted'>        return getPooledEthByShares(shares[_usr]);</span>
 233 |     | <span class='neutral'>    }</span>
 234 |     | <span class='neutral'></span>
 235 |     | <span class='unexecuted'>    function increaseAllowance(</span>
 236 |     | <span class='neutral'>        address spender,</span>
 237 |     | <span class='neutral'>        uint256 addedValue</span>
 238 |     | <span class='unexecuted'>    ) external override returns (bool) {</span>
 239 |     | <span class='unexecuted'>        approve(spender, allowance[msg.sender][spender] + addedValue);</span>
 240 |     | <span class='unexecuted'>        return true;</span>
 241 |     | <span class='neutral'>    }</span>
 242 |     | <span class='neutral'></span>
 243 |     | <span class='neutral'>    // internal helper functions</span>
 244 |     | <span class='unexecuted'>    function _mul(uint256 a, uint256 b) internal pure returns (uint256) {</span>
 245 |     | <span class='unexecuted'>        if (a == 0) {</span>
 246 |     | <span class='unexecuted'>            return 0;</span>
 247 |     | <span class='neutral'>        }</span>
 248 |     | <span class='unexecuted'>        uint256 c = a * b;</span>
 249 |     | <span class='unexecuted'>        require(c / a == b, &quot;SafeMath: multiplication overflow&quot;);</span>
 250 |     | <span class='neutral'>        return c;</span>
 251 |     | <span class='neutral'>    }</span>
 252 |     | <span class='neutral'></span>
 253 |     | <span class='unexecuted'>    function _div(uint256 a, uint256 b) internal pure returns (uint256) {</span>
 254 |     | <span class='unexecuted'>        require(b &gt; 0, &quot;SafeMath: zero denominator&quot;);</span>
 255 |     | <span class='unexecuted'>        uint256 c = a / b;</span>
 256 |     | <span class='neutral'>        return c;</span>
 257 |     | <span class='neutral'>    }</span>
 258 |     | <span class='neutral'></span>
 259 |     | <span class='neutral'>    // dummy test purpose</span>
 260 |     | <span class='neutral'>    function feeRecipientAddress() external view returns (address) {</span>
 261 |     | <span class='neutral'>        return address(this);</span>
 262 |     | <span class='neutral'>    }</span>
 263 |     | <span class='neutral'></span>
 264 |     | <span class='neutral'>    function authority() external view returns (address) {</span>
 265 |     | <span class='neutral'>        return address(this);</span>
 266 |     | <span class='neutral'>    }</span>
 267 |     | <span class='neutral'></span>
 268 |     | <span class='neutral'>    /**</span>
 269 |     | <span class='neutral'>     * @dev Emits {Transfer} and {TransferShares} events</span>
 270 |     | <span class='neutral'>     */</span>
 271 |     | <span class='unexecuted'>    function _emitTransferEvents(</span>
 272 |     | <span class='neutral'>        address _from,</span>
 273 |     | <span class='neutral'>        address _to,</span>
 274 |     | <span class='neutral'>        uint _tokenAmount,</span>
 275 |     | <span class='neutral'>        uint256 _sharesAmount</span>
 276 |     | <span class='neutral'>    ) internal {</span>
 277 |     | <span class='unexecuted'>        emit Transfer(_from, _to, _tokenAmount);</span>
 278 |     | <span class='unexecuted'>        emit TransferShares(_from, _to, _sharesAmount);</span>
 279 |     | <span class='neutral'>    }</span>
 280 |     | <span class='neutral'>}</span>
 281 |     | <span class='neutral'></span>

</code>
<br />

<b>/mnt/c/Users/Lourens/Documents/Recon-Fuzz/collabs/ebtc/packages/contracts/contracts/TestContracts/EBTCTokenTester.sol</b>
<code>
  1 |     | <span class='neutral'>// SPDX-License-Identifier: MIT</span>
  2 |     | <span class='neutral'></span>
  3 |     | <span class='neutral'>pragma solidity 0.8.17;</span>
  4 |     | <span class='neutral'></span>
  5 |     | <span class='neutral'>import &quot;../EBTCToken.sol&quot;;</span>
  6 |     | <span class='neutral'></span>
  7 |     | <span class='unexecuted'>contract EBTCTokenTester is EBTCToken {</span>
  8 |     | <span class='unexecuted'>    bytes32 private immutable _PERMIT_TYPEHASH =</span>
  9 |     | <span class='unexecuted'>        0x6e71edae12b1b97f4d1f60370fef10105fa2faae0126114a169c64845d6126c9;</span>
 10 |     | <span class='neutral'></span>
 11 |     | <span class='unexecuted'>    constructor(</span>
 12 |     | <span class='neutral'>        address _cdpManagerAddress,</span>
 13 |     | <span class='neutral'>        address _borrowerOperationsAddress,</span>
 14 |     | <span class='neutral'>        address _authorityAddress</span>
 15 |     | <span class='unexecuted'>    ) EBTCToken(_cdpManagerAddress, _borrowerOperationsAddress, _authorityAddress) {}</span>
 16 |     | <span class='neutral'></span>
 17 |     | <span class='unexecuted'>    function unprotectedMint(address _account, uint256 _amount) external {</span>
 18 |     | <span class='neutral'>        // No check on caller here</span>
 19 |     | <span class='neutral'></span>
 20 |     | <span class='neutral'>        _mint(_account, _amount);</span>
 21 |     | <span class='neutral'>    }</span>
 22 |     | <span class='neutral'></span>
 23 |     | <span class='unexecuted'>    function unprotectedBurn(address _account, uint256 _amount) external {</span>
 24 |     | <span class='neutral'>        // No check on caller here</span>
 25 |     | <span class='neutral'></span>
 26 |     | <span class='unexecuted'>        _burn(_account, _amount);</span>
 27 |     | <span class='neutral'>    }</span>
 28 |     | <span class='neutral'></span>
 29 |     | <span class='unexecuted'>    function unprotectedSendToPool(address _sender, address _poolAddress, uint256 _amount) external {</span>
 30 |     | <span class='neutral'>        // No check on caller here</span>
 31 |     | <span class='neutral'></span>
 32 |     | <span class='unexecuted'>        _transfer(_sender, _poolAddress, _amount);</span>
 33 |     | <span class='neutral'>    }</span>
 34 |     | <span class='neutral'></span>
 35 |     | <span class='neutral'>    function unprotectedReturnFromPool(</span>
 36 |     | <span class='neutral'>        address _poolAddress,</span>
 37 |     | <span class='neutral'>        address _receiver,</span>
 38 |     | <span class='neutral'>        uint256 _amount</span>
 39 |     | <span class='neutral'>    ) external {</span>
 40 |     | <span class='neutral'>        // No check on caller here</span>
 41 |     | <span class='neutral'></span>
 42 |     | <span class='neutral'>        _transfer(_poolAddress, _receiver, _amount);</span>
 43 |     | <span class='neutral'>    }</span>
 44 |     | <span class='neutral'></span>
 45 |     | <span class='unexecuted'>    function callInternalApprove(address owner, address spender, uint256 amount) external {</span>
 46 |     | <span class='unexecuted'>        _approve(owner, spender, amount);</span>
 47 |     | <span class='neutral'>    }</span>
 48 |     | <span class='neutral'></span>
 49 |     | <span class='unexecuted'>    function getChainId() external view returns (uint256 chainID) {</span>
 50 |     | <span class='neutral'>        //return _chainID(); // it’s private</span>
 51 |     | <span class='neutral'>        assembly {</span>
 52 |     | <span class='unexecuted'>            chainID := chainid()</span>
 53 |     | <span class='neutral'>        }</span>
 54 |     | <span class='neutral'>    }</span>
 55 |     | <span class='neutral'></span>
 56 |     | <span class='unexecuted'>    function getDigest(</span>
 57 |     | <span class='neutral'>        address owner,</span>
 58 |     | <span class='neutral'>        address spender,</span>
 59 |     | <span class='neutral'>        uint256 amount,</span>
 60 |     | <span class='neutral'>        uint256 nonce,</span>
 61 |     | <span class='neutral'>        uint256 deadline</span>
 62 |     | <span class='unexecuted'>    ) external view returns (bytes32) {</span>
 63 |     | <span class='unexecuted'>        return</span>
 64 |     | <span class='unexecuted'>            keccak256(</span>
 65 |     | <span class='unexecuted'>                abi.encodePacked(</span>
 66 |     | <span class='unexecuted'>                    uint16(0x1901),</span>
 67 |     | <span class='unexecuted'>                    domainSeparator(),</span>
 68 |     | <span class='unexecuted'>                    keccak256(abi.encode(_PERMIT_TYPEHASH, owner, spender, amount, nonce, deadline))</span>
 69 |     | <span class='neutral'>                )</span>
 70 |     | <span class='neutral'>            );</span>
 71 |     | <span class='neutral'>    }</span>
 72 |     | <span class='neutral'></span>
 73 |     | <span class='unexecuted'>    function recoverAddress(</span>
 74 |     | <span class='neutral'>        bytes32 digest,</span>
 75 |     | <span class='neutral'>        uint8 v,</span>
 76 |     | <span class='neutral'>        bytes32 r,</span>
 77 |     | <span class='neutral'>        bytes32 s</span>
 78 |     | <span class='unexecuted'>    ) external pure returns (address) {</span>
 79 |     | <span class='unexecuted'>        return ecrecover(digest, v, r, s);</span>
 80 |     | <span class='neutral'>    }</span>
 81 |     | <span class='neutral'>}</span>
 82 |     | <span class='neutral'></span>

</code>
<br />

<b>/mnt/c/Users/Lourens/Documents/Recon-Fuzz/collabs/ebtc/packages/contracts/contracts/TestContracts/FunctionCaller.sol</b>
<code>
  1 |     | <span class='neutral'>// SPDX-License-Identifier: MIT</span>
  2 |     | <span class='neutral'></span>
  3 |     | <span class='neutral'>pragma solidity 0.8.17;</span>
  4 |     | <span class='neutral'></span>
  5 |     | <span class='neutral'>import &quot;../Interfaces/ICdpManager.sol&quot;;</span>
  6 |     | <span class='neutral'>import &quot;../Interfaces/ISortedCdps.sol&quot;;</span>
  7 |     | <span class='neutral'>import &quot;../Interfaces/IPriceFeed.sol&quot;;</span>
  8 |     | <span class='neutral'>import &quot;../Dependencies/EbtcMath.sol&quot;;</span>
  9 |     | <span class='neutral'></span>
 10 |     | <span class='neutral'>/* Wrapper contract - used for calculating gas of read-only and internal functions. </span>
 11 |     | <span class='neutral'>Not part of the Liquity application. */</span>
 12 |     | <span class='unexecuted'>contract FunctionCaller {</span>
 13 |     | <span class='neutral'>    ICdpManager cdpManager;</span>
 14 |     | <span class='unexecuted'>    address public cdpManagerAddress;</span>
 15 |     | <span class='neutral'></span>
 16 |     | <span class='neutral'>    ISortedCdps sortedCdps;</span>
 17 |     | <span class='unexecuted'>    address public sortedCdpsAddress;</span>
 18 |     | <span class='neutral'></span>
 19 |     | <span class='neutral'>    IPriceFeed priceFeed;</span>
 20 |     | <span class='unexecuted'>    address public priceFeedAddress;</span>
 21 |     | <span class='neutral'></span>
 22 |     | <span class='neutral'>    // --- Dependency setters ---</span>
 23 |     | <span class='neutral'></span>
 24 |     | <span class='unexecuted'>    function setCdpManagerAddress(address _cdpManagerAddress) external {</span>
 25 |     | <span class='unexecuted'>        cdpManagerAddress = _cdpManagerAddress;</span>
 26 |     | <span class='unexecuted'>        cdpManager = ICdpManager(_cdpManagerAddress);</span>
 27 |     | <span class='neutral'>    }</span>
 28 |     | <span class='neutral'></span>
 29 |     | <span class='unexecuted'>    function setSortedCdpsAddress(address _sortedCdpsAddress) external {</span>
 30 |     | <span class='unexecuted'>        cdpManagerAddress = _sortedCdpsAddress;</span>
 31 |     | <span class='unexecuted'>        sortedCdps = ISortedCdps(_sortedCdpsAddress);</span>
 32 |     | <span class='neutral'>    }</span>
 33 |     | <span class='neutral'></span>
 34 |     | <span class='unexecuted'>    function setPriceFeedAddress(address _priceFeedAddress) external {</span>
 35 |     | <span class='unexecuted'>        priceFeedAddress = _priceFeedAddress;</span>
 36 |     | <span class='unexecuted'>        priceFeed = IPriceFeed(_priceFeedAddress);</span>
 37 |     | <span class='neutral'>    }</span>
 38 |     | <span class='neutral'></span>
 39 |     | <span class='neutral'>    // --- Non-view wrapper functions used for calculating gas ---</span>
 40 |     | <span class='neutral'></span>
 41 |     | <span class='unexecuted'>    function cdpManager_getCachedICR(</span>
 42 |     | <span class='neutral'>        bytes32 _cdpId,</span>
 43 |     | <span class='neutral'>        uint256 _price</span>
 44 |     | <span class='unexecuted'>    ) external view returns (uint256) {</span>
 45 |     | <span class='unexecuted'>        return cdpManager.getCachedICR(_cdpId, _price);</span>
 46 |     | <span class='neutral'>    }</span>
 47 |     | <span class='neutral'></span>
 48 |     | <span class='unexecuted'>    function sortedCdps_findInsertPosition(</span>
 49 |     | <span class='neutral'>        uint256 _NICR,</span>
 50 |     | <span class='neutral'>        bytes32 _prevId,</span>
 51 |     | <span class='neutral'>        bytes32 _nextId</span>
 52 |     | <span class='unexecuted'>    ) external view returns (bytes32, bytes32) {</span>
 53 |     | <span class='unexecuted'>        return sortedCdps.findInsertPosition(_NICR, _prevId, _nextId);</span>
 54 |     | <span class='neutral'>    }</span>
 55 |     | <span class='neutral'>}</span>
 56 |     | <span class='neutral'></span>

</code>
<br />

<b>/mnt/c/Users/Lourens/Documents/Recon-Fuzz/collabs/ebtc/packages/contracts/contracts/TestContracts/Pretty.sol</b>
<code>
   1 |     | <span class='neutral'>// https://github.com/one-hundred-proof/kyberswap-exploit/blob/main/lib/helpers/Pretty.sol</span>
   2 |     | <span class='neutral'></span>
   3 |     | <span class='neutral'>pragma solidity 0.8.17;</span>
   4 |     | <span class='neutral'></span>
   5 |     | <span class='unexecuted'>library Strings {</span>
   6 |     | <span class='unexecuted'>    function concat(</span>
   7 |     | <span class='neutral'>        string memory _base,</span>
   8 |     | <span class='neutral'>        string memory _value</span>
   9 |     | <span class='unexecuted'>    ) internal pure returns (string memory) {</span>
  10 |     | <span class='unexecuted'>        bytes memory _baseBytes = bytes(_base);</span>
  11 |     | <span class='unexecuted'>        bytes memory _valueBytes = bytes(_value);</span>
  12 |     | <span class='neutral'></span>
  13 |     | <span class='unexecuted'>        string memory _tmpValue = new string(_baseBytes.length + _valueBytes.length);</span>
  14 |     | <span class='unexecuted'>        bytes memory _newValue = bytes(_tmpValue);</span>
  15 |     | <span class='neutral'></span>
  16 |     | <span class='neutral'>        uint i;</span>
  17 |     | <span class='neutral'>        uint j;</span>
  18 |     | <span class='neutral'></span>
  19 |     | <span class='unexecuted'>        for (i = 0; i &lt; _baseBytes.length; i++) {</span>
  20 |     | <span class='unexecuted'>            _newValue[j++] = _baseBytes[i];</span>
  21 |     | <span class='neutral'>        }</span>
  22 |     | <span class='neutral'></span>
  23 |     | <span class='unexecuted'>        for (i = 0; i &lt; _valueBytes.length; i++) {</span>
  24 |     | <span class='unexecuted'>            _newValue[j++] = _valueBytes[i];</span>
  25 |     | <span class='neutral'>        }</span>
  26 |     | <span class='neutral'></span>
  27 |     | <span class='unexecuted'>        return string(_newValue);</span>
  28 |     | <span class='neutral'>    }</span>
  29 |     | <span class='neutral'>}</span>
  30 |     | <span class='neutral'></span>
  31 |     | <span class='unexecuted'>library Pretty {</span>
  32 |     | <span class='unexecuted'>    uint8 constant DEFAULT_DECIMALS = 18;</span>
  33 |     | <span class='neutral'></span>
  34 |     | <span class='unexecuted'>    function toBitString(uint256 n) external pure returns (string memory) {</span>
  35 |     | <span class='unexecuted'>        return uintToBitString(n, 256);</span>
  36 |     | <span class='neutral'>    }</span>
  37 |     | <span class='neutral'></span>
  38 |     | <span class='unexecuted'>    function toBitString(uint256 n, uint8 decimals) external pure returns (string memory) {</span>
  39 |     | <span class='unexecuted'>        return uintToBitString(n, decimals);</span>
  40 |     | <span class='neutral'>    }</span>
  41 |     | <span class='neutral'></span>
  42 |     | <span class='unexecuted'>    function pretty(uint256 n) external pure returns (string memory) {</span>
  43 |     | <span class='neutral'>        return</span>
  44 |     | <span class='unexecuted'>            n == type(uint256).max ? &quot;type(uint256).max&quot; : n == type(uint128).max</span>
  45 |     | <span class='neutral'>                ? &quot;type(uint128).max&quot;</span>
  46 |     | <span class='unexecuted'>                : _pretty(n, DEFAULT_DECIMALS);</span>
  47 |     | <span class='neutral'>    }</span>
  48 |     | <span class='neutral'></span>
  49 |     | <span class='unexecuted'>    function pretty(bool value) external pure returns (string memory) {</span>
  50 |     | <span class='unexecuted'>        return value ? &quot;true&quot; : &quot;false&quot;;</span>
  51 |     | <span class='neutral'>    }</span>
  52 |     | <span class='neutral'></span>
  53 |     | <span class='unexecuted'>    function pretty(uint256 n, uint8 decimals) external pure returns (string memory) {</span>
  54 |     | <span class='unexecuted'>        return _pretty(n, decimals);</span>
  55 |     | <span class='neutral'>    }</span>
  56 |     | <span class='neutral'></span>
  57 |     | <span class='unexecuted'>    function pretty(uint128 n) external pure returns (string memory) {</span>
  58 |     | <span class='unexecuted'>        return _pretty(uint128(n), DEFAULT_DECIMALS);</span>
  59 |     | <span class='neutral'>    }</span>
  60 |     | <span class='neutral'></span>
  61 |     | <span class='unexecuted'>    function pretty(uint128 n, uint8 decimals) external pure returns (string memory) {</span>
  62 |     | <span class='unexecuted'>        return _pretty(uint128(n), decimals);</span>
  63 |     | <span class='neutral'>    }</span>
  64 |     | <span class='neutral'></span>
  65 |     | <span class='unexecuted'>    function pretty(uint64 n) external pure returns (string memory) {</span>
  66 |     | <span class='unexecuted'>        return _pretty(uint64(n), DEFAULT_DECIMALS);</span>
  67 |     | <span class='neutral'>    }</span>
  68 |     | <span class='neutral'></span>
  69 |     | <span class='unexecuted'>    function pretty(uint64 n, uint8 decimals) external pure returns (string memory) {</span>
  70 |     | <span class='unexecuted'>        return _pretty(uint64(n), decimals);</span>
  71 |     | <span class='neutral'>    }</span>
  72 |     | <span class='neutral'></span>
  73 |     | <span class='unexecuted'>    function pretty(int256 n) external pure returns (string memory) {</span>
  74 |     | <span class='unexecuted'>        return _prettyInt(n, DEFAULT_DECIMALS);</span>
  75 |     | <span class='neutral'>    }</span>
  76 |     | <span class='neutral'></span>
  77 |     | <span class='unexecuted'>    function pretty(int256 n, uint8 decimals) external pure returns (string memory) {</span>
  78 |     | <span class='unexecuted'>        return _prettyInt(n, decimals);</span>
  79 |     | <span class='neutral'>    }</span>
  80 |     | <span class='neutral'></span>
  81 |     | <span class='unexecuted'>    function _pretty(uint256 n, uint8 decimals) internal pure returns (string memory) {</span>
  82 |     | <span class='unexecuted'>        bool pastDecimals = decimals == 0;</span>
  83 |     | <span class='neutral'>        uint256 place = 0;</span>
  84 |     | <span class='neutral'>        uint256 r; // remainder</span>
  85 |     | <span class='unexecuted'>        string memory s = &quot;&quot;;</span>
  86 |     | <span class='neutral'></span>
  87 |     | <span class='unexecuted'>        while (n != 0) {</span>
  88 |     | <span class='unexecuted'>            r = n % 10;</span>
  89 |     | <span class='unexecuted'>            n /= 10;</span>
  90 |     | <span class='unexecuted'>            place++;</span>
  91 |     | <span class='unexecuted'>            s = Strings.concat(toDigit(r), s);</span>
  92 |     | <span class='unexecuted'>            if (pastDecimals &amp;&amp; place % 3 == 0 &amp;&amp; n != 0) {</span>
  93 |     | <span class='unexecuted'>                s = Strings.concat(&quot;_&quot;, s);</span>
  94 |     | <span class='neutral'>            }</span>
  95 |     | <span class='unexecuted'>            if (!pastDecimals &amp;&amp; place == decimals) {</span>
  96 |     | <span class='unexecuted'>                pastDecimals = true;</span>
  97 |     | <span class='unexecuted'>                place = 0;</span>
  98 |     | <span class='unexecuted'>                s = Strings.concat(&quot;_&quot;, s);</span>
  99 |     | <span class='neutral'>            }</span>
 100 |     | <span class='neutral'>        }</span>
 101 |     | <span class='unexecuted'>        if (pastDecimals &amp;&amp; place == 0) {</span>
 102 |     | <span class='unexecuted'>            s = Strings.concat(&quot;0&quot;, s);</span>
 103 |     | <span class='neutral'>        }</span>
 104 |     | <span class='unexecuted'>        if (!pastDecimals) {</span>
 105 |     | <span class='unexecuted'>            uint256 i;</span>
 106 |     | <span class='unexecuted'>            uint256 upper = (decimals &gt;= place ? decimals - place : 0);</span>
 107 |     | <span class='unexecuted'>            for (i = 0; i &lt; upper; ++i) {</span>
 108 |     | <span class='unexecuted'>                s = Strings.concat(&quot;0&quot;, s);</span>
 109 |     | <span class='neutral'>            }</span>
 110 |     | <span class='unexecuted'>            s = Strings.concat(&quot;0_&quot;, s);</span>
 111 |     | <span class='neutral'>        }</span>
 112 |     | <span class='unexecuted'>        return s;</span>
 113 |     | <span class='neutral'>    }</span>
 114 |     | <span class='neutral'></span>
 115 |     | <span class='unexecuted'>    function _prettyInt(int256 n, uint8 decimals) internal pure returns (string memory) {</span>
 116 |     | <span class='unexecuted'>        bool isNegative = n &lt; 0;</span>
 117 |     | <span class='unexecuted'>        string memory s = &quot;&quot;;</span>
 118 |     | <span class='unexecuted'>        if (isNegative) {</span>
 119 |     | <span class='unexecuted'>            s = &quot;-&quot;;</span>
 120 |     | <span class='neutral'>        }</span>
 121 |     | <span class='unexecuted'>        return Strings.concat(s, _pretty(uint256(isNegative ? -n : n), decimals));</span>
 122 |     | <span class='neutral'>    }</span>
 123 |     | <span class='neutral'></span>
 124 |     | <span class='unexecuted'>    function toDigit(uint256 n) internal pure returns (string memory) {</span>
 125 |     | <span class='unexecuted'>        if (n == 0) {</span>
 126 |     | <span class='unexecuted'>            return &quot;0&quot;;</span>
 127 |     | <span class='unexecuted'>        } else if (n == 1) {</span>
 128 |     | <span class='unexecuted'>            return &quot;1&quot;;</span>
 129 |     | <span class='unexecuted'>        } else if (n == 2) {</span>
 130 |     | <span class='unexecuted'>            return &quot;2&quot;;</span>
 131 |     | <span class='unexecuted'>        } else if (n == 3) {</span>
 132 |     | <span class='unexecuted'>            return &quot;3&quot;;</span>
 133 |     | <span class='unexecuted'>        } else if (n == 4) {</span>
 134 |     | <span class='unexecuted'>            return &quot;4&quot;;</span>
 135 |     | <span class='unexecuted'>        } else if (n == 5) {</span>
 136 |     | <span class='unexecuted'>            return &quot;5&quot;;</span>
 137 |     | <span class='unexecuted'>        } else if (n == 6) {</span>
 138 |     | <span class='unexecuted'>            return &quot;6&quot;;</span>
 139 |     | <span class='unexecuted'>        } else if (n == 7) {</span>
 140 |     | <span class='unexecuted'>            return &quot;7&quot;;</span>
 141 |     | <span class='unexecuted'>        } else if (n == 8) {</span>
 142 |     | <span class='unexecuted'>            return &quot;8&quot;;</span>
 143 |     | <span class='unexecuted'>        } else if (n == 9) {</span>
 144 |     | <span class='unexecuted'>            return &quot;9&quot;;</span>
 145 |     | <span class='neutral'>        } else {</span>
 146 |     | <span class='unexecuted'>            revert(&quot;Not in range 0 to 10&quot;);</span>
 147 |     | <span class='neutral'>        }</span>
 148 |     | <span class='neutral'>    }</span>
 149 |     | <span class='neutral'></span>
 150 |     | <span class='unexecuted'>    function uintToBitString(uint256 n, uint16 bits) internal pure returns (string memory) {</span>
 151 |     | <span class='unexecuted'>        string memory s = &quot;&quot;;</span>
 152 |     | <span class='unexecuted'>        for (uint256 i; i &lt; bits; i++) {</span>
 153 |     | <span class='unexecuted'>            if (n % 2 == 0) {</span>
 154 |     | <span class='unexecuted'>                s = Strings.concat(&quot;0&quot;, s);</span>
 155 |     | <span class='neutral'>            } else {</span>
 156 |     | <span class='unexecuted'>                s = Strings.concat(&quot;1&quot;, s);</span>
 157 |     | <span class='neutral'>            }</span>
 158 |     | <span class='unexecuted'>            n = n / 2;</span>
 159 |     | <span class='neutral'>        }</span>
 160 |     | <span class='unexecuted'>        return s;</span>
 161 |     | <span class='neutral'>    }</span>
 162 |     | <span class='neutral'>}</span>
 163 |     | <span class='neutral'></span>

</code>
<br />

<b>/mnt/c/Users/Lourens/Documents/Recon-Fuzz/collabs/ebtc/packages/contracts/contracts/TestContracts/PriceFeedOracleTester.sol</b>
<code>
  1 |     | <span class='neutral'>// SPDX-License-Identifier: MIT</span>
  2 |     | <span class='neutral'>pragma solidity 0.8.17;</span>
  3 |     | <span class='neutral'></span>
  4 |     | <span class='neutral'>import {PriceFeed} from &quot;../PriceFeed.sol&quot;;</span>
  5 |     | <span class='neutral'>import {IPriceFetcher} from &quot;../Interfaces/IOracleCaller.sol&quot;;</span>
  6 |     | <span class='neutral'></span>
  7 |     | <span class='unexecuted'>contract PriceFeedOracleTester {</span>
  8 |     | <span class='neutral'>    enum ErrorState {</span>
  9 |     | <span class='neutral'>        NONE,</span>
 10 |     | <span class='neutral'>        REVERT_BOMB,</span>
 11 |     | <span class='neutral'>        RETURN_BOMB,</span>
 12 |     | <span class='neutral'>        RETURN_BYTES,</span>
 13 |     | <span class='neutral'>        REVERT_CUSTOM_ERROR,</span>
 14 |     | <span class='neutral'>        REVERT_CUSTOM_ERROR_PARAMS,</span>
 15 |     | <span class='neutral'>        BURN_ALL_GAS,</span>
 16 |     | <span class='neutral'>        SELF_DESTRUCT,</span>
 17 |     | <span class='neutral'>        COUNT // Number of elements</span>
 18 |     | <span class='neutral'>    }</span>
 19 |     | <span class='neutral'></span>
 20 |     | <span class='unexecuted'>    IPriceFetcher public priceFeed;</span>
 21 |     | <span class='unexecuted'>    ErrorState public errorState;</span>
 22 |     | <span class='neutral'></span>
 23 |     | <span class='neutral'>    error InvalidAddress();</span>
 24 |     | <span class='neutral'>    error InvalidNumber(uint224);</span>
 25 |     | <span class='neutral'></span>
 26 |     | <span class='unexecuted'>    constructor(address _priceFeed) {</span>
 27 |     | <span class='unexecuted'>        priceFeed = IPriceFetcher(_priceFeed);</span>
 28 |     | <span class='unexecuted'>        errorState = ErrorState.NONE;</span>
 29 |     | <span class='neutral'>    }</span>
 30 |     | <span class='neutral'></span>
 31 |     | <span class='unexecuted'>    function fetchPrice() external returns (uint256) {</span>
 32 |     | <span class='unexecuted'>        if (errorState == ErrorState.NONE) {</span>
 33 |     | <span class='unexecuted'>            return priceFeed.fetchPrice();</span>
 34 |     | <span class='unexecuted'>        } else if (errorState == ErrorState.REVERT_BOMB) {</span>
 35 |     | <span class='unexecuted'>            revBytes(2_000_000);</span>
 36 |     | <span class='unexecuted'>        } else if (errorState == ErrorState.RETURN_BOMB) {</span>
 37 |     | <span class='unexecuted'>            retBytes(2_000_000);</span>
 38 |     | <span class='unexecuted'>        } else if (errorState == ErrorState.RETURN_BYTES) {</span>
 39 |     | <span class='unexecuted'>            retByteArray();</span>
 40 |     | <span class='unexecuted'>        } else if (errorState == ErrorState.REVERT_CUSTOM_ERROR) {</span>
 41 |     | <span class='unexecuted'>            revert InvalidAddress();</span>
 42 |     | <span class='unexecuted'>        } else if (errorState == ErrorState.REVERT_CUSTOM_ERROR_PARAMS) {</span>
 43 |     | <span class='unexecuted'>            revert InvalidNumber(12346);</span>
 44 |     | <span class='unexecuted'>        } else if (errorState == ErrorState.BURN_ALL_GAS) {</span>
 45 |     | <span class='unexecuted'>            uint256 counter;</span>
 46 |     | <span class='unexecuted'>            while (true) {</span>
 47 |     | <span class='unexecuted'>                counter += 1;</span>
 48 |     | <span class='neutral'>            }</span>
 49 |     | <span class='unexecuted'>        } else if (errorState == ErrorState.SELF_DESTRUCT) {</span>
 50 |     | <span class='unexecuted'>            selfdestruct(payable(msg.sender));</span>
 51 |     | <span class='neutral'>        }</span>
 52 |     | <span class='neutral'>    }</span>
 53 |     | <span class='neutral'></span>
 54 |     | <span class='neutral'>    function revBytes(uint256 _bytes) internal pure {</span>
 55 |     | <span class='neutral'>        assembly {</span>
 56 |     | <span class='unexecuted'>            revert(0, _bytes)</span>
 57 |     | <span class='neutral'>        }</span>
 58 |     | <span class='neutral'>    }</span>
 59 |     | <span class='neutral'></span>
 60 |     | <span class='unexecuted'>    function retBytes(uint256 _bytes) public pure {</span>
 61 |     | <span class='neutral'>        assembly {</span>
 62 |     | <span class='unexecuted'>            return(0, _bytes)</span>
 63 |     | <span class='neutral'>        }</span>
 64 |     | <span class='neutral'>    }</span>
 65 |     | <span class='neutral'></span>
 66 |     | <span class='unexecuted'>    function retByteArray() public pure {</span>
 67 |     | <span class='unexecuted'>        uint256[] memory entries = new uint256[](250);</span>
 68 |     | <span class='unexecuted'>        bytes memory retData = abi.encode(entries);</span>
 69 |     | <span class='unexecuted'>        uint256 retLen = retData.length;</span>
 70 |     | <span class='neutral'>        assembly {</span>
 71 |     | <span class='unexecuted'>            return(add(retData, 0x20), retLen)</span>
 72 |     | <span class='neutral'>        }</span>
 73 |     | <span class='neutral'>    }</span>
 74 |     | <span class='neutral'></span>
 75 |     | <span class='unexecuted'>    function setErrorState(ErrorState _errorState) external {</span>
 76 |     | <span class='unexecuted'>        errorState = _errorState;</span>
 77 |     | <span class='neutral'>    }</span>
 78 |     | <span class='neutral'>}</span>
 79 |     | <span class='neutral'></span>

</code>
<br />

<b>/mnt/c/Users/Lourens/Documents/Recon-Fuzz/collabs/ebtc/packages/contracts/contracts/TestContracts/WETH9.sol</b>
<code>
   1 |     | <span class='neutral'>/**</span>
   2 |     | <span class='neutral'> *Submitted for verification at Etherscan.io on 2017-12-12</span>
   3 |     | <span class='neutral'> */</span>
   4 |     | <span class='neutral'></span>
   5 |     | <span class='neutral'>// Copyright (C) 2015, 2016, 2017 Dapphub</span>
   6 |     | <span class='neutral'></span>
   7 |     | <span class='neutral'>// This program is free software: you can redistribute it and/or modify</span>
   8 |     | <span class='neutral'>// it under the terms of the GNU General Public License as published by</span>
   9 |     | <span class='neutral'>// the Free Software Foundation, either version 3 of the License, or</span>
  10 |     | <span class='neutral'>// (at your option) any later version.</span>
  11 |     | <span class='neutral'></span>
  12 |     | <span class='neutral'>// This program is distributed in the hope that it will be useful,</span>
  13 |     | <span class='neutral'>// but WITHOUT ANY WARRANTY; without even the implied warranty of</span>
  14 |     | <span class='neutral'>// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the</span>
  15 |     | <span class='neutral'>// GNU General Public License for more details.</span>
  16 |     | <span class='neutral'></span>
  17 |     | <span class='neutral'>// You should have received a copy of the GNU General Public License</span>
  18 |     | <span class='neutral'>// along with this program.  If not, see &lt;http://www.gnu.org/licenses/&gt;.</span>
  19 |     | <span class='neutral'></span>
  20 |     | <span class='neutral'>pragma solidity 0.8.17;</span>
  21 |     | <span class='neutral'></span>
  22 |     | <span class='unexecuted'>contract WETH9 {</span>
  23 |     | <span class='unexecuted'>    string public name = &quot;Wrapped Ether&quot;;</span>
  24 |     | <span class='unexecuted'>    string public symbol = &quot;WETH&quot;;</span>
  25 |     | <span class='unexecuted'>    uint8 public decimals = 18;</span>
  26 |     | <span class='neutral'></span>
  27 |     | <span class='neutral'>    event Approval(address indexed src, address indexed guy, uint256 wad);</span>
  28 |     | <span class='neutral'>    event Transfer(address indexed src, address indexed dst, uint256 wad);</span>
  29 |     | <span class='neutral'>    event Deposit(address indexed dst, uint256 wad);</span>
  30 |     | <span class='neutral'>    event Withdrawal(address indexed src, uint256 wad);</span>
  31 |     | <span class='neutral'></span>
  32 |     | <span class='unexecuted'>    mapping(address =&gt; uint256) public balanceOf;</span>
  33 |     | <span class='unexecuted'>    mapping(address =&gt; mapping(address =&gt; uint256)) public allowance;</span>
  34 |     | <span class='neutral'></span>
  35 |     | <span class='unexecuted'>    function receive() public payable {</span>
  36 |     | <span class='unexecuted'>        deposit();</span>
  37 |     | <span class='neutral'>    }</span>
  38 |     | <span class='neutral'></span>
  39 |     | <span class='unexecuted'>    function deposit() public payable {</span>
  40 |     | <span class='unexecuted'>        balanceOf[msg.sender] += msg.value;</span>
  41 |     | <span class='unexecuted'>        emit Deposit(msg.sender, msg.value);</span>
  42 |     | <span class='neutral'>    }</span>
  43 |     | <span class='neutral'></span>
  44 |     | <span class='unexecuted'>    function withdraw(uint256 wad) public {</span>
  45 |     | <span class='unexecuted'>        require(balanceOf[msg.sender] &gt;= wad);</span>
  46 |     | <span class='unexecuted'>        balanceOf[msg.sender] -= wad;</span>
  47 |     | <span class='unexecuted'>        payable(msg.sender).transfer(wad);</span>
  48 |     | <span class='unexecuted'>        emit Withdrawal(msg.sender, wad);</span>
  49 |     | <span class='neutral'>    }</span>
  50 |     | <span class='neutral'></span>
  51 |     | <span class='unexecuted'>    function totalSupply() public view returns (uint256) {</span>
  52 |     | <span class='unexecuted'>        return address(this).balance;</span>
  53 |     | <span class='neutral'>    }</span>
  54 |     | <span class='neutral'></span>
  55 |     | <span class='unexecuted'>    function approve(address guy, uint256 wad) public returns (bool) {</span>
  56 |     | <span class='unexecuted'>        allowance[msg.sender][guy] = wad;</span>
  57 |     | <span class='unexecuted'>        emit Approval(msg.sender, guy, wad);</span>
  58 |     | <span class='unexecuted'>        return true;</span>
  59 |     | <span class='neutral'>    }</span>
  60 |     | <span class='neutral'></span>
  61 |     | <span class='unexecuted'>    function transfer(address dst, uint256 wad) public virtual returns (bool) {</span>
  62 |     | <span class='unexecuted'>        return transferFrom(msg.sender, dst, wad);</span>
  63 |     | <span class='neutral'>    }</span>
  64 |     | <span class='neutral'></span>
  65 |     | <span class='unexecuted'>    function transferFrom(address src, address dst, uint256 wad) public returns (bool) {</span>
  66 |     | <span class='unexecuted'>        require(balanceOf[src] &gt;= wad);</span>
  67 |     | <span class='neutral'></span>
  68 |     | <span class='unexecuted'>        if (src != msg.sender &amp;&amp; allowance[src][msg.sender] != type(uint256).max) {</span>
  69 |     | <span class='unexecuted'>            require(allowance[src][msg.sender] &gt;= wad);</span>
  70 |     | <span class='unexecuted'>            allowance[src][msg.sender] -= wad;</span>
  71 |     | <span class='neutral'>        }</span>
  72 |     | <span class='neutral'></span>
  73 |     | <span class='unexecuted'>        balanceOf[src] -= wad;</span>
  74 |     | <span class='unexecuted'>        balanceOf[dst] += wad;</span>
  75 |     | <span class='neutral'></span>
  76 |     | <span class='unexecuted'>        emit Transfer(src, dst, wad);</span>
  77 |     | <span class='neutral'></span>
  78 |     | <span class='unexecuted'>        return true;</span>
  79 |     | <span class='neutral'>    }</span>
  80 |     | <span class='neutral'>}</span>
  81 |     | <span class='neutral'></span>
  82 |     | <span class='neutral'>/*</span>
  83 |     | <span class='neutral'>                    GNU GENERAL PUBLIC LICENSE</span>
  84 |     | <span class='neutral'>                       Version 3, 29 June 2007</span>
  85 |     | <span class='neutral'></span>
  86 |     | <span class='neutral'> Copyright (C) 2007 Free Software Foundation, Inc. &lt;http://fsf.org/&gt;</span>
  87 |     | <span class='neutral'> Everyone is permitted to copy and distribute verbatim copies</span>
  88 |     | <span class='neutral'> of this license document, but changing it is not allowed.</span>
  89 |     | <span class='neutral'></span>
  90 |     | <span class='neutral'>                            Preamble</span>
  91 |     | <span class='neutral'></span>
  92 |     | <span class='neutral'>  The GNU General Public License is a free, copyleft license for</span>
  93 |     | <span class='neutral'>software and other kinds of works.</span>
  94 |     | <span class='neutral'></span>
  95 |     | <span class='neutral'>  The licenses for most software and other practical works are designed</span>
  96 |     | <span class='neutral'>to take away your freedom to share and change the works.  By contrast,</span>
  97 |     | <span class='neutral'>the GNU General Public License is intended to guarantee your freedom to</span>
  98 |     | <span class='neutral'>share and change all versions of a program--to make sure it remains free</span>
  99 |     | <span class='neutral'>software for all its users.  We, the Free Software Foundation, use the</span>
 100 |     | <span class='neutral'>GNU General Public License for most of our software; it applies also to</span>
 101 |     | <span class='neutral'>any other work released this way by its authors.  You can apply it to</span>
 102 |     | <span class='neutral'>your programs, too.</span>
 103 |     | <span class='neutral'></span>
 104 |     | <span class='neutral'>  When we speak of free software, we are referring to freedom, not</span>
 105 |     | <span class='neutral'>price.  Our General Public Licenses are designed to make sure that you</span>
 106 |     | <span class='neutral'>have the freedom to distribute copies of free software (and charge for</span>
 107 |     | <span class='neutral'>them if you wish), that you receive source code or can get it if you</span>
 108 |     | <span class='neutral'>want it, that you can change the software or use pieces of it in new</span>
 109 |     | <span class='neutral'>free programs, and that you know you can do these things.</span>
 110 |     | <span class='neutral'></span>
 111 |     | <span class='neutral'>  To protect your rights, we need to prevent others from denying you</span>
 112 |     | <span class='neutral'>these rights or asking you to surrender the rights.  Therefore, you have</span>
 113 |     | <span class='neutral'>certain responsibilities if you distribute copies of the software, or if</span>
 114 |     | <span class='neutral'>you modify it: responsibilities to respect the freedom of others.</span>
 115 |     | <span class='neutral'></span>
 116 |     | <span class='neutral'>  For example, if you distribute copies of such a program, whether</span>
 117 |     | <span class='neutral'>gratis or for a fee, you must pass on to the recipients the same</span>
 118 |     | <span class='neutral'>freedoms that you received.  You must make sure that they, too, receive</span>
 119 |     | <span class='neutral'>or can get the source code.  And you must show them these terms so they</span>
 120 |     | <span class='neutral'>know their rights.</span>
 121 |     | <span class='neutral'></span>
 122 |     | <span class='neutral'>  Developers that use the GNU GPL protect your rights with two steps:</span>
 123 |     | <span class='neutral'>(1) assert copyright on the software, and (2) offer you this License</span>
 124 |     | <span class='neutral'>giving you legal permission to copy, distribute and/or modify it.</span>
 125 |     | <span class='neutral'></span>
 126 |     | <span class='neutral'>  For the developers&#39; and authors&#39; protection, the GPL clearly explains</span>
 127 |     | <span class='neutral'>that there is no warranty for this free software.  For both users&#39; and</span>
 128 |     | <span class='neutral'>authors&#39; sake, the GPL requires that modified versions be marked as</span>
 129 |     | <span class='neutral'>changed, so that their problems will not be attributed erroneously to</span>
 130 |     | <span class='neutral'>authors of previous versions.</span>
 131 |     | <span class='neutral'></span>
 132 |     | <span class='neutral'>  Some devices are designed to deny users access to install or run</span>
 133 |     | <span class='neutral'>modified versions of the software inside them, although the manufacturer</span>
 134 |     | <span class='neutral'>can do so.  This is fundamentally incompatible with the aim of</span>
 135 |     | <span class='neutral'>protecting users&#39; freedom to change the software.  The systematic</span>
 136 |     | <span class='neutral'>pattern of such abuse occurs in the area of products for individuals to</span>
 137 |     | <span class='neutral'>use, which is precisely where it is most unacceptable.  Therefore, we</span>
 138 |     | <span class='neutral'>have designed this version of the GPL to prohibit the practice for those</span>
 139 |     | <span class='neutral'>products.  If such problems arise substantially in other domains, we</span>
 140 |     | <span class='neutral'>stand ready to extend this provision to those domains in future versions</span>
 141 |     | <span class='neutral'>of the GPL, as needed to protect the freedom of users.</span>
 142 |     | <span class='neutral'></span>
 143 |     | <span class='neutral'>  Finally, every program is threatened constantly by software patents.</span>
 144 |     | <span class='neutral'>States should not allow patents to restrict development and use of</span>
 145 |     | <span class='neutral'>software on general-purpose computers, but in those that do, we wish to</span>
 146 |     | <span class='neutral'>avoid the special danger that patents applied to a free program could</span>
 147 |     | <span class='neutral'>make it effectively proprietary.  To prevent this, the GPL assures that</span>
 148 |     | <span class='neutral'>patents cannot be used to render the program non-free.</span>
 149 |     | <span class='neutral'></span>
 150 |     | <span class='neutral'>  The precise terms and conditions for copying, distribution and</span>
 151 |     | <span class='neutral'>modification follow.</span>
 152 |     | <span class='neutral'></span>
 153 |     | <span class='neutral'>                       TERMS AND CONDITIONS</span>
 154 |     | <span class='neutral'></span>
 155 |     | <span class='neutral'>  0. Definitions.</span>
 156 |     | <span class='neutral'></span>
 157 |     | <span class='neutral'>  &quot;This License&quot; refers to version 3 of the GNU General Public License.</span>
 158 |     | <span class='neutral'></span>
 159 |     | <span class='neutral'>  &quot;Copyright&quot; also means copyright-like laws that apply to other kinds of</span>
 160 |     | <span class='neutral'>works, such as semiconductor masks.</span>
 161 |     | <span class='neutral'></span>
 162 |     | <span class='neutral'>  &quot;The Program&quot; refers to any copyrightable work licensed under this</span>
 163 |     | <span class='neutral'>License.  Each licensee is addressed as &quot;you&quot;.  &quot;Licensees&quot; and</span>
 164 |     | <span class='neutral'>&quot;recipients&quot; may be individuals or organizations.</span>
 165 |     | <span class='neutral'></span>
 166 |     | <span class='neutral'>  To &quot;modify&quot; a work means to copy from or adapt all or part of the work</span>
 167 |     | <span class='neutral'>in a fashion requiring copyright permission, other than the making of an</span>
 168 |     | <span class='neutral'>exact copy.  The resulting work is called a &quot;modified version&quot; of the</span>
 169 |     | <span class='neutral'>earlier work or a work &quot;based on&quot; the earlier work.</span>
 170 |     | <span class='neutral'></span>
 171 |     | <span class='neutral'>  A &quot;covered work&quot; means either the unmodified Program or a work based</span>
 172 |     | <span class='neutral'>on the Program.</span>
 173 |     | <span class='neutral'></span>
 174 |     | <span class='neutral'>  To &quot;propagate&quot; a work means to do anything with it that, without</span>
 175 |     | <span class='neutral'>permission, would make you directly or secondarily liable for</span>
 176 |     | <span class='neutral'>infringement under applicable copyright law, except executing it on a</span>
 177 |     | <span class='neutral'>computer or modifying a private copy.  Propagation includes copying,</span>
 178 |     | <span class='neutral'>distribution (with or without modification), making available to the</span>
 179 |     | <span class='neutral'>public, and in some countries other activities as well.</span>
 180 |     | <span class='neutral'></span>
 181 |     | <span class='neutral'>  To &quot;convey&quot; a work means any kind of propagation that enables other</span>
 182 |     | <span class='neutral'>parties to make or receive copies.  Mere interaction with a user through</span>
 183 |     | <span class='neutral'>a computer network, with no transfer of a copy, is not conveying.</span>
 184 |     | <span class='neutral'></span>
 185 |     | <span class='neutral'>  An interactive user interface displays &quot;Appropriate Legal Notices&quot;</span>
 186 |     | <span class='neutral'>to the extent that it includes a convenient and prominently visible</span>
 187 |     | <span class='neutral'>feature that (1) displays an appropriate copyright notice, and (2)</span>
 188 |     | <span class='neutral'>tells the user that there is no warranty for the work (except to the</span>
 189 |     | <span class='neutral'>extent that warranties are provided), that licensees may convey the</span>
 190 |     | <span class='neutral'>work under this License, and how to view a copy of this License.  If</span>
 191 |     | <span class='neutral'>the interface presents a list of user commands or options, such as a</span>
 192 |     | <span class='neutral'>menu, a prominent item in the list meets this criterion.</span>
 193 |     | <span class='neutral'></span>
 194 |     | <span class='neutral'>  1. Source Code.</span>
 195 |     | <span class='neutral'></span>
 196 |     | <span class='neutral'>  The &quot;source code&quot; for a work means the preferred form of the work</span>
 197 |     | <span class='neutral'>for making modifications to it.  &quot;Object code&quot; means any non-source</span>
 198 |     | <span class='neutral'>form of a work.</span>
 199 |     | <span class='neutral'></span>
 200 |     | <span class='neutral'>  A &quot;Standard Interface&quot; means an interface that either is an official</span>
 201 |     | <span class='neutral'>standard defined by a recognized standards body, or, in the case of</span>
 202 |     | <span class='neutral'>interfaces specified for a particular programming language, one that</span>
 203 |     | <span class='neutral'>is widely used among developers working in that language.</span>
 204 |     | <span class='neutral'></span>
 205 |     | <span class='neutral'>  The &quot;System Libraries&quot; of an executable work include anything, other</span>
 206 |     | <span class='neutral'>than the work as a whole, that (a) is included in the normal form of</span>
 207 |     | <span class='neutral'>packaging a Major Component, but which is not part of that Major</span>
 208 |     | <span class='neutral'>Component, and (b) serves only to enable use of the work with that</span>
 209 |     | <span class='neutral'>Major Component, or to implement a Standard Interface for which an</span>
 210 |     | <span class='neutral'>implementation is available to the public in source code form.  A</span>
 211 |     | <span class='neutral'>&quot;Major Component&quot;, in this context, means a major essential component</span>
 212 |     | <span class='neutral'>(kernel, window system, and so on) of the specific operating system</span>
 213 |     | <span class='neutral'>(if any) on which the executable work runs, or a compiler used to</span>
 214 |     | <span class='neutral'>produce the work, or an object code interpreter used to run it.</span>
 215 |     | <span class='neutral'></span>
 216 |     | <span class='neutral'>  The &quot;Corresponding Source&quot; for a work in object code form means all</span>
 217 |     | <span class='neutral'>the source code needed to generate, install, and (for an executable</span>
 218 |     | <span class='neutral'>work) run the object code and to modify the work, including scripts to</span>
 219 |     | <span class='neutral'>control those activities.  However, it does not include the work&#39;s</span>
 220 |     | <span class='neutral'>System Libraries, or general-purpose tools or generally available free</span>
 221 |     | <span class='neutral'>programs which are used unmodified in performing those activities but</span>
 222 |     | <span class='neutral'>which are not part of the work.  For example, Corresponding Source</span>
 223 |     | <span class='neutral'>includes interface definition files associated with source files for</span>
 224 |     | <span class='neutral'>the work, and the source code for shared libraries and dynamically</span>
 225 |     | <span class='neutral'>linked subprograms that the work is specifically designed to require,</span>
 226 |     | <span class='neutral'>such as by intimate data communication or control flow between those</span>
 227 |     | <span class='neutral'>subprograms and other parts of the work.</span>
 228 |     | <span class='neutral'></span>
 229 |     | <span class='neutral'>  The Corresponding Source need not include anything that users</span>
 230 |     | <span class='neutral'>can regenerate automatically from other parts of the Corresponding</span>
 231 |     | <span class='neutral'>Source.</span>
 232 |     | <span class='neutral'></span>
 233 |     | <span class='neutral'>  The Corresponding Source for a work in source code form is that</span>
 234 |     | <span class='neutral'>same work.</span>
 235 |     | <span class='neutral'></span>
 236 |     | <span class='neutral'>  2. Basic Permissions.</span>
 237 |     | <span class='neutral'></span>
 238 |     | <span class='neutral'>  All rights granted under this License are granted for the term of</span>
 239 |     | <span class='neutral'>copyright on the Program, and are irrevocable provided the stated</span>
 240 |     | <span class='neutral'>conditions are met.  This License explicitly affirms your unlimited</span>
 241 |     | <span class='neutral'>permission to run the unmodified Program.  The output from running a</span>
 242 |     | <span class='neutral'>covered work is covered by this License only if the output, given its</span>
 243 |     | <span class='neutral'>content, constitutes a covered work.  This License acknowledges your</span>
 244 |     | <span class='neutral'>rights of fair use or other equivalent, as provided by copyright law.</span>
 245 |     | <span class='neutral'></span>
 246 |     | <span class='neutral'>  You may make, run and propagate covered works that you do not</span>
 247 |     | <span class='neutral'>convey, without conditions so long as your license otherwise remains</span>
 248 |     | <span class='neutral'>in force.  You may convey covered works to others for the sole purpose</span>
 249 |     | <span class='neutral'>of having them make modifications exclusively for you, or provide you</span>
 250 |     | <span class='neutral'>with facilities for running those works, provided that you comply with</span>
 251 |     | <span class='neutral'>the terms of this License in conveying all material for which you do</span>
 252 |     | <span class='neutral'>not control copyright.  Those thus making or running the covered works</span>
 253 |     | <span class='neutral'>for you must do so exclusively on your behalf, under your direction</span>
 254 |     | <span class='neutral'>and control, on terms that prohibit them from making any copies of</span>
 255 |     | <span class='neutral'>your copyrighted material outside their relationship with you.</span>
 256 |     | <span class='neutral'></span>
 257 |     | <span class='neutral'>  Conveying under any other circumstances is permitted solely under</span>
 258 |     | <span class='neutral'>the conditions stated below.  Sublicensing is not allowed; section 10</span>
 259 |     | <span class='neutral'>makes it unnecessary.</span>
 260 |     | <span class='neutral'></span>
 261 |     | <span class='neutral'>  3. Protecting Users&#39; Legal Rights From Anti-Circumvention Law.</span>
 262 |     | <span class='neutral'></span>
 263 |     | <span class='neutral'>  No covered work shall be deemed part of an effective technological</span>
 264 |     | <span class='neutral'>measure under any applicable law fulfilling obligations under article</span>
 265 |     | <span class='neutral'>11 of the WIPO copyright treaty adopted on 20 December 1996, or</span>
 266 |     | <span class='neutral'>similar laws prohibiting or restricting circumvention of such</span>
 267 |     | <span class='neutral'>measures.</span>
 268 |     | <span class='neutral'></span>
 269 |     | <span class='neutral'>  When you convey a covered work, you waive any legal power to forbid</span>
 270 |     | <span class='neutral'>circumvention of technological measures to the extent such circumvention</span>
 271 |     | <span class='neutral'>is effected by exercising rights under this License with respect to</span>
 272 |     | <span class='neutral'>the covered work, and you disclaim any intention to limit operation or</span>
 273 |     | <span class='neutral'>modification of the work as a means of enforcing, against the work&#39;s</span>
 274 |     | <span class='neutral'>users, your or third parties&#39; legal rights to forbid circumvention of</span>
 275 |     | <span class='neutral'>technological measures.</span>
 276 |     | <span class='neutral'></span>
 277 |     | <span class='neutral'>  4. Conveying Verbatim Copies.</span>
 278 |     | <span class='neutral'></span>
 279 |     | <span class='neutral'>  You may convey verbatim copies of the Program&#39;s source code as you</span>
 280 |     | <span class='neutral'>receive it, in any medium, provided that you conspicuously and</span>
 281 |     | <span class='neutral'>appropriately publish on each copy an appropriate copyright notice;</span>
 282 |     | <span class='neutral'>keep intact all notices stating that this License and any</span>
 283 |     | <span class='neutral'>non-permissive terms added in accord with section 7 apply to the code;</span>
 284 |     | <span class='neutral'>keep intact all notices of the absence of any warranty; and give all</span>
 285 |     | <span class='neutral'>recipients a copy of this License along with the Program.</span>
 286 |     | <span class='neutral'></span>
 287 |     | <span class='neutral'>  You may charge any price or no price for each copy that you convey,</span>
 288 |     | <span class='neutral'>and you may offer support or warranty protection for a fee.</span>
 289 |     | <span class='neutral'></span>
 290 |     | <span class='neutral'>  5. Conveying Modified Source Versions.</span>
 291 |     | <span class='neutral'></span>
 292 |     | <span class='neutral'>  You may convey a work based on the Program, or the modifications to</span>
 293 |     | <span class='neutral'>produce it from the Program, in the form of source code under the</span>
 294 |     | <span class='neutral'>terms of section 4, provided that you also meet all of these conditions:</span>
 295 |     | <span class='neutral'></span>
 296 |     | <span class='neutral'>    a) The work must carry prominent notices stating that you modified</span>
 297 |     | <span class='neutral'>    it, and giving a relevant date.</span>
 298 |     | <span class='neutral'></span>
 299 |     | <span class='neutral'>    b) The work must carry prominent notices stating that it is</span>
 300 |     | <span class='neutral'>    released under this License and any conditions added under section</span>
 301 |     | <span class='neutral'>    7.  This requirement modifies the requirement in section 4 to</span>
 302 |     | <span class='neutral'>    &quot;keep intact all notices&quot;.</span>
 303 |     | <span class='neutral'></span>
 304 |     | <span class='neutral'>    c) You must license the entire work, as a whole, under this</span>
 305 |     | <span class='neutral'>    License to anyone who comes into possession of a copy.  This</span>
 306 |     | <span class='neutral'>    License will therefore apply, along with any applicable section 7</span>
 307 |     | <span class='neutral'>    additional terms, to the whole of the work, and all its parts,</span>
 308 |     | <span class='neutral'>    regardless of how they are packaged.  This License gives no</span>
 309 |     | <span class='neutral'>    permission to license the work in any other way, but it does not</span>
 310 |     | <span class='neutral'>    invalidate such permission if you have separately received it.</span>
 311 |     | <span class='neutral'></span>
 312 |     | <span class='neutral'>    d) If the work has interactive user interfaces, each must display</span>
 313 |     | <span class='neutral'>    Appropriate Legal Notices; however, if the Program has interactive</span>
 314 |     | <span class='neutral'>    interfaces that do not display Appropriate Legal Notices, your</span>
 315 |     | <span class='neutral'>    work need not make them do so.</span>
 316 |     | <span class='neutral'></span>
 317 |     | <span class='neutral'>  A compilation of a covered work with other separate and independent</span>
 318 |     | <span class='neutral'>works, which are not by their nature extensions of the covered work,</span>
 319 |     | <span class='neutral'>and which are not combined with it such as to form a larger program,</span>
 320 |     | <span class='neutral'>in or on a volume of a storage or distribution medium, is called an</span>
 321 |     | <span class='neutral'>&quot;aggregate&quot; if the compilation and its resulting copyright are not</span>
 322 |     | <span class='neutral'>used to limit the access or legal rights of the compilation&#39;s users</span>
 323 |     | <span class='neutral'>beyond what the individual works permit.  Inclusion of a covered work</span>
 324 |     | <span class='neutral'>in an aggregate does not cause this License to apply to the other</span>
 325 |     | <span class='neutral'>parts of the aggregate.</span>
 326 |     | <span class='neutral'></span>
 327 |     | <span class='neutral'>  6. Conveying Non-Source Forms.</span>
 328 |     | <span class='neutral'></span>
 329 |     | <span class='neutral'>  You may convey a covered work in object code form under the terms</span>
 330 |     | <span class='neutral'>of sections 4 and 5, provided that you also convey the</span>
 331 |     | <span class='neutral'>machine-readable Corresponding Source under the terms of this License,</span>
 332 |     | <span class='neutral'>in one of these ways:</span>
 333 |     | <span class='neutral'></span>
 334 |     | <span class='neutral'>    a) Convey the object code in, or embodied in, a physical product</span>
 335 |     | <span class='neutral'>    (including a physical distribution medium), accompanied by the</span>
 336 |     | <span class='neutral'>    Corresponding Source fixed on a durable physical medium</span>
 337 |     | <span class='neutral'>    customarily used for software interchange.</span>
 338 |     | <span class='neutral'></span>
 339 |     | <span class='neutral'>    b) Convey the object code in, or embodied in, a physical product</span>
 340 |     | <span class='neutral'>    (including a physical distribution medium), accompanied by a</span>
 341 |     | <span class='neutral'>    written offer, valid for at least three years and valid for as</span>
 342 |     | <span class='neutral'>    long as you offer spare parts or customer support for that product</span>
 343 |     | <span class='neutral'>    model, to give anyone who possesses the object code either (1) a</span>
 344 |     | <span class='neutral'>    copy of the Corresponding Source for all the software in the</span>
 345 |     | <span class='neutral'>    product that is covered by this License, on a durable physical</span>
 346 |     | <span class='neutral'>    medium customarily used for software interchange, for a price no</span>
 347 |     | <span class='neutral'>    more than your reasonable cost of physically performing this</span>
 348 |     | <span class='neutral'>    conveying of source, or (2) access to copy the</span>
 349 |     | <span class='neutral'>    Corresponding Source from a network server at no charge.</span>
 350 |     | <span class='neutral'></span>
 351 |     | <span class='neutral'>    c) Convey individual copies of the object code with a copy of the</span>
 352 |     | <span class='neutral'>    written offer to provide the Corresponding Source.  This</span>
 353 |     | <span class='neutral'>    alternative is allowed only occasionally and noncommercially, and</span>
 354 |     | <span class='neutral'>    only if you received the object code with such an offer, in accord</span>
 355 |     | <span class='neutral'>    with subsection 6b.</span>
 356 |     | <span class='neutral'></span>
 357 |     | <span class='neutral'>    d) Convey the object code by offering access from a designated</span>
 358 |     | <span class='neutral'>    place (gratis or for a charge), and offer equivalent access to the</span>
 359 |     | <span class='neutral'>    Corresponding Source in the same way through the same place at no</span>
 360 |     | <span class='neutral'>    further charge.  You need not require recipients to copy the</span>
 361 |     | <span class='neutral'>    Corresponding Source along with the object code.  If the place to</span>
 362 |     | <span class='neutral'>    copy the object code is a network server, the Corresponding Source</span>
 363 |     | <span class='neutral'>    may be on a different server (operated by you or a third party)</span>
 364 |     | <span class='neutral'>    that supports equivalent copying facilities, provided you maintain</span>
 365 |     | <span class='neutral'>    clear directions next to the object code saying where to find the</span>
 366 |     | <span class='neutral'>    Corresponding Source.  Regardless of what server hosts the</span>
 367 |     | <span class='neutral'>    Corresponding Source, you remain obligated to ensure that it is</span>
 368 |     | <span class='neutral'>    available for as long as needed to satisfy these requirements.</span>
 369 |     | <span class='neutral'></span>
 370 |     | <span class='neutral'>    e) Convey the object code using peer-to-peer transmission, provided</span>
 371 |     | <span class='neutral'>    you inform other peers where the object code and Corresponding</span>
 372 |     | <span class='neutral'>    Source of the work are being offered to the general public at no</span>
 373 |     | <span class='neutral'>    charge under subsection 6d.</span>
 374 |     | <span class='neutral'></span>
 375 |     | <span class='neutral'>  A separable portion of the object code, whose source code is excluded</span>
 376 |     | <span class='neutral'>from the Corresponding Source as a System Library, need not be</span>
 377 |     | <span class='neutral'>included in conveying the object code work.</span>
 378 |     | <span class='neutral'></span>
 379 |     | <span class='neutral'>  A &quot;User Product&quot; is either (1) a &quot;consumer product&quot;, which means any</span>
 380 |     | <span class='neutral'>tangible personal property which is normally used for personal, family,</span>
 381 |     | <span class='neutral'>or household purposes, or (2) anything designed or sold for incorporation</span>
 382 |     | <span class='neutral'>into a dwelling.  In determining whether a product is a consumer product,</span>
 383 |     | <span class='neutral'>doubtful cases shall be resolved in favor of coverage.  For a particular</span>
 384 |     | <span class='neutral'>product received by a particular user, &quot;normally used&quot; refers to a</span>
 385 |     | <span class='neutral'>typical or common use of that class of product, regardless of the status</span>
 386 |     | <span class='neutral'>of the particular user or of the way in which the particular user</span>
 387 |     | <span class='neutral'>actually uses, or expects or is expected to use, the product.  A product</span>
 388 |     | <span class='neutral'>is a consumer product regardless of whether the product has substantial</span>
 389 |     | <span class='neutral'>commercial, industrial or non-consumer uses, unless such uses represent</span>
 390 |     | <span class='neutral'>the only significant mode of use of the product.</span>
 391 |     | <span class='neutral'></span>
 392 |     | <span class='neutral'>  &quot;Installation Information&quot; for a User Product means any methods,</span>
 393 |     | <span class='neutral'>procedures, authorization keys, or other information required to install</span>
 394 |     | <span class='neutral'>and execute modified versions of a covered work in that User Product from</span>
 395 |     | <span class='neutral'>a modified version of its Corresponding Source.  The information must</span>
 396 |     | <span class='neutral'>suffice to ensure that the continued functioning of the modified object</span>
 397 |     | <span class='neutral'>code is in no case prevented or interfered with solely because</span>
 398 |     | <span class='neutral'>modification has been made.</span>
 399 |     | <span class='neutral'></span>
 400 |     | <span class='neutral'>  If you convey an object code work under this section in, or with, or</span>
 401 |     | <span class='neutral'>specifically for use in, a User Product, and the conveying occurs as</span>
 402 |     | <span class='neutral'>part of a transaction in which the right of possession and use of the</span>
 403 |     | <span class='neutral'>User Product is transferred to the recipient in perpetuity or for a</span>
 404 |     | <span class='neutral'>fixed term (regardless of how the transaction is characterized), the</span>
 405 |     | <span class='neutral'>Corresponding Source conveyed under this section must be accompanied</span>
 406 |     | <span class='neutral'>by the Installation Information.  But this requirement does not apply</span>
 407 |     | <span class='neutral'>if neither you nor any third party retains the ability to install</span>
 408 |     | <span class='neutral'>modified object code on the User Product (for example, the work has</span>
 409 |     | <span class='neutral'>been installed in ROM).</span>
 410 |     | <span class='neutral'></span>
 411 |     | <span class='neutral'>  The requirement to provide Installation Information does not include a</span>
 412 |     | <span class='neutral'>requirement to continue to provide support service, warranty, or updates</span>
 413 |     | <span class='neutral'>for a work that has been modified or installed by the recipient, or for</span>
 414 |     | <span class='neutral'>the User Product in which it has been modified or installed.  Access to a</span>
 415 |     | <span class='neutral'>network may be denied when the modification itself materially and</span>
 416 |     | <span class='neutral'>adversely affects the operation of the network or violates the rules and</span>
 417 |     | <span class='neutral'>protocols for communication across the network.</span>
 418 |     | <span class='neutral'></span>
 419 |     | <span class='neutral'>  Corresponding Source conveyed, and Installation Information provided,</span>
 420 |     | <span class='neutral'>in accord with this section must be in a format that is publicly</span>
 421 |     | <span class='neutral'>documented (and with an implementation available to the public in</span>
 422 |     | <span class='neutral'>source code form), and must require no special password or key for</span>
 423 |     | <span class='neutral'>unpacking, reading or copying.</span>
 424 |     | <span class='neutral'></span>
 425 |     | <span class='neutral'>  7. Additional Terms.</span>
 426 |     | <span class='neutral'></span>
 427 |     | <span class='neutral'>  &quot;Additional permissions&quot; are terms that supplement the terms of this</span>
 428 |     | <span class='neutral'>License by making exceptions from one or more of its conditions.</span>
 429 |     | <span class='neutral'>Additional permissions that are applicable to the entire Program shall</span>
 430 |     | <span class='neutral'>be treated as though they were included in this License, to the extent</span>
 431 |     | <span class='neutral'>that they are valid under applicable law.  If additional permissions</span>
 432 |     | <span class='neutral'>apply only to part of the Program, that part may be used separately</span>
 433 |     | <span class='neutral'>under those permissions, but the entire Program remains governed by</span>
 434 |     | <span class='neutral'>this License without regard to the additional permissions.</span>
 435 |     | <span class='neutral'></span>
 436 |     | <span class='neutral'>  When you convey a copy of a covered work, you may at your option</span>
 437 |     | <span class='neutral'>remove any additional permissions from that copy, or from any part of</span>
 438 |     | <span class='neutral'>it.  (Additional permissions may be written to require their own</span>
 439 |     | <span class='neutral'>removal in certain cases when you modify the work.)  You may place</span>
 440 |     | <span class='neutral'>additional permissions on material, added by you to a covered work,</span>
 441 |     | <span class='neutral'>for which you have or can give appropriate copyright permission.</span>
 442 |     | <span class='neutral'></span>
 443 |     | <span class='neutral'>  Notwithstanding any other provision of this License, for material you</span>
 444 |     | <span class='neutral'>add to a covered work, you may (if authorized by the copyright holders of</span>
 445 |     | <span class='neutral'>that material) supplement the terms of this License with terms:</span>
 446 |     | <span class='neutral'></span>
 447 |     | <span class='neutral'>    a) Disclaiming warranty or limiting liability differently from the</span>
 448 |     | <span class='neutral'>    terms of sections 15 and 16 of this License; or</span>
 449 |     | <span class='neutral'></span>
 450 |     | <span class='neutral'>    b) Requiring preservation of specified reasonable legal notices or</span>
 451 |     | <span class='neutral'>    author attributions in that material or in the Appropriate Legal</span>
 452 |     | <span class='neutral'>    Notices displayed by works containing it; or</span>
 453 |     | <span class='neutral'></span>
 454 |     | <span class='neutral'>    c) Prohibiting misrepresentation of the origin of that material, or</span>
 455 |     | <span class='neutral'>    requiring that modified versions of such material be marked in</span>
 456 |     | <span class='neutral'>    reasonable ways as different from the original version; or</span>
 457 |     | <span class='neutral'></span>
 458 |     | <span class='neutral'>    d) Limiting the use for publicity purposes of names of licensors or</span>
 459 |     | <span class='neutral'>    authors of the material; or</span>
 460 |     | <span class='neutral'></span>
 461 |     | <span class='neutral'>    e) Declining to grant rights under trademark law for use of some</span>
 462 |     | <span class='neutral'>    trade names, trademarks, or service marks; or</span>
 463 |     | <span class='neutral'></span>
 464 |     | <span class='neutral'>    f) Requiring indemnification of licensors and authors of that</span>
 465 |     | <span class='neutral'>    material by anyone who conveys the material (or modified versions of</span>
 466 |     | <span class='neutral'>    it) with contractual assumptions of liability to the recipient, for</span>
 467 |     | <span class='neutral'>    any liability that these contractual assumptions directly impose on</span>
 468 |     | <span class='neutral'>    those licensors and authors.</span>
 469 |     | <span class='neutral'></span>
 470 |     | <span class='neutral'>  All other non-permissive additional terms are considered &quot;further</span>
 471 |     | <span class='neutral'>restrictions&quot; within the meaning of section 10.  If the Program as you</span>
 472 |     | <span class='neutral'>received it, or any part of it, contains a notice stating that it is</span>
 473 |     | <span class='neutral'>governed by this License along with a term that is a further</span>
 474 |     | <span class='neutral'>restriction, you may remove that term.  If a license document contains</span>
 475 |     | <span class='neutral'>a further restriction but permits relicensing or conveying under this</span>
 476 |     | <span class='neutral'>License, you may add to a covered work material governed by the terms</span>
 477 |     | <span class='neutral'>of that license document, provided that the further restriction does</span>
 478 |     | <span class='neutral'>not survive such relicensing or conveying.</span>
 479 |     | <span class='neutral'></span>
 480 |     | <span class='neutral'>  If you add terms to a covered work in accord with this section, you</span>
 481 |     | <span class='neutral'>must place, in the relevant source files, a statement of the</span>
 482 |     | <span class='neutral'>additional terms that apply to those files, or a notice indicating</span>
 483 |     | <span class='neutral'>where to find the applicable terms.</span>
 484 |     | <span class='neutral'></span>
 485 |     | <span class='neutral'>  Additional terms, permissive or non-permissive, may be stated in the</span>
 486 |     | <span class='neutral'>form of a separately written license, or stated as exceptions;</span>
 487 |     | <span class='neutral'>the above requirements apply either way.</span>
 488 |     | <span class='neutral'></span>
 489 |     | <span class='neutral'>  8. Termination.</span>
 490 |     | <span class='neutral'></span>
 491 |     | <span class='neutral'>  You may not propagate or modify a covered work except as expressly</span>
 492 |     | <span class='neutral'>provided under this License.  Any attempt otherwise to propagate or</span>
 493 |     | <span class='neutral'>modify it is void, and will automatically terminate your rights under</span>
 494 |     | <span class='neutral'>this License (including any patent licenses granted under the third</span>
 495 |     | <span class='neutral'>paragraph of section 11).</span>
 496 |     | <span class='neutral'></span>
 497 |     | <span class='neutral'>  However, if you cease all violation of this License, then your</span>
 498 |     | <span class='neutral'>license from a particular copyright holder is reinstated (a)</span>
 499 |     | <span class='neutral'>provisionally, unless and until the copyright holder explicitly and</span>
 500 |     | <span class='neutral'>finally terminates your license, and (b) permanently, if the copyright</span>
 501 |     | <span class='neutral'>holder fails to notify you of the violation by some reasonable means</span>
 502 |     | <span class='neutral'>prior to 60 days after the cessation.</span>
 503 |     | <span class='neutral'></span>
 504 |     | <span class='neutral'>  Moreover, your license from a particular copyright holder is</span>
 505 |     | <span class='neutral'>reinstated permanently if the copyright holder notifies you of the</span>
 506 |     | <span class='neutral'>violation by some reasonable means, this is the first time you have</span>
 507 |     | <span class='neutral'>received notice of violation of this License (for any work) from that</span>
 508 |     | <span class='neutral'>copyright holder, and you cure the violation prior to 30 days after</span>
 509 |     | <span class='neutral'>your receipt of the notice.</span>
 510 |     | <span class='neutral'></span>
 511 |     | <span class='neutral'>  Termination of your rights under this section does not terminate the</span>
 512 |     | <span class='neutral'>licenses of parties who have received copies or rights from you under</span>
 513 |     | <span class='neutral'>this License.  If your rights have been terminated and not permanently</span>
 514 |     | <span class='neutral'>reinstated, you do not qualify to receive new licenses for the same</span>
 515 |     | <span class='neutral'>material under section 10.</span>
 516 |     | <span class='neutral'></span>
 517 |     | <span class='neutral'>  9. Acceptance Not Required for Having Copies.</span>
 518 |     | <span class='neutral'></span>
 519 |     | <span class='neutral'>  You are not required to accept this License in order to receive or</span>
 520 |     | <span class='neutral'>run a copy of the Program.  Ancillary propagation of a covered work</span>
 521 |     | <span class='neutral'>occurring solely as a consequence of using peer-to-peer transmission</span>
 522 |     | <span class='neutral'>to receive a copy likewise does not require acceptance.  However,</span>
 523 |     | <span class='neutral'>nothing other than this License grants you permission to propagate or</span>
 524 |     | <span class='neutral'>modify any covered work.  These actions infringe copyright if you do</span>
 525 |     | <span class='neutral'>not accept this License.  Therefore, by modifying or propagating a</span>
 526 |     | <span class='neutral'>covered work, you indicate your acceptance of this License to do so.</span>
 527 |     | <span class='neutral'></span>
 528 |     | <span class='neutral'>  10. Automatic Licensing of Downstream Recipients.</span>
 529 |     | <span class='neutral'></span>
 530 |     | <span class='neutral'>  Each time you convey a covered work, the recipient automatically</span>
 531 |     | <span class='neutral'>receives a license from the original licensors, to run, modify and</span>
 532 |     | <span class='neutral'>propagate that work, subject to this License.  You are not responsible</span>
 533 |     | <span class='neutral'>for enforcing compliance by third parties with this License.</span>
 534 |     | <span class='neutral'></span>
 535 |     | <span class='neutral'>  An &quot;entity transaction&quot; is a transaction transferring control of an</span>
 536 |     | <span class='neutral'>organization, or substantially all assets of one, or subdividing an</span>
 537 |     | <span class='neutral'>organization, or merging organizations.  If propagation of a covered</span>
 538 |     | <span class='neutral'>work results from an entity transaction, each party to that</span>
 539 |     | <span class='neutral'>transaction who receives a copy of the work also receives whatever</span>
 540 |     | <span class='neutral'>licenses to the work the party&#39;s predecessor in interest had or could</span>
 541 |     | <span class='neutral'>give under the previous paragraph, plus a right to possession of the</span>
 542 |     | <span class='neutral'>Corresponding Source of the work from the predecessor in interest, if</span>
 543 |     | <span class='neutral'>the predecessor has it or can get it with reasonable efforts.</span>
 544 |     | <span class='neutral'></span>
 545 |     | <span class='neutral'>  You may not impose any further restrictions on the exercise of the</span>
 546 |     | <span class='neutral'>rights granted or affirmed under this License.  For example, you may</span>
 547 |     | <span class='neutral'>not impose a license fee, royalty, or other charge for exercise of</span>
 548 |     | <span class='neutral'>rights granted under this License, and you may not initiate litigation</span>
 549 |     | <span class='neutral'>(including a cross-claim or counterclaim in a lawsuit) alleging that</span>
 550 |     | <span class='neutral'>any patent claim is infringed by making, using, selling, offering for</span>
 551 |     | <span class='neutral'>sale, or importing the Program or any portion of it.</span>
 552 |     | <span class='neutral'></span>
 553 |     | <span class='neutral'>  11. Patents.</span>
 554 |     | <span class='neutral'></span>
 555 |     | <span class='neutral'>  A &quot;contributor&quot; is a copyright holder who authorizes use under this</span>
 556 |     | <span class='neutral'>License of the Program or a work on which the Program is based.  The</span>
 557 |     | <span class='neutral'>work thus licensed is called the contributor&#39;s &quot;contributor version&quot;.</span>
 558 |     | <span class='neutral'></span>
 559 |     | <span class='neutral'>  A contributor&#39;s &quot;essential patent claims&quot; are all patent claims</span>
 560 |     | <span class='neutral'>owned or controlled by the contributor, whether already acquired or</span>
 561 |     | <span class='neutral'>hereafter acquired, that would be infringed by some manner, permitted</span>
 562 |     | <span class='neutral'>by this License, of making, using, or selling its contributor version,</span>
 563 |     | <span class='neutral'>but do not include claims that would be infringed only as a</span>
 564 |     | <span class='neutral'>consequence of further modification of the contributor version.  For</span>
 565 |     | <span class='neutral'>purposes of this definition, &quot;control&quot; includes the right to grant</span>
 566 |     | <span class='neutral'>patent sublicenses in a manner consistent with the requirements of</span>
 567 |     | <span class='neutral'>this License.</span>
 568 |     | <span class='neutral'></span>
 569 |     | <span class='neutral'>  Each contributor grants you a non-exclusive, worldwide, royalty-free</span>
 570 |     | <span class='neutral'>patent license under the contributor&#39;s essential patent claims, to</span>
 571 |     | <span class='neutral'>make, use, sell, offer for sale, import and otherwise run, modify and</span>
 572 |     | <span class='neutral'>propagate the contents of its contributor version.</span>
 573 |     | <span class='neutral'></span>
 574 |     | <span class='neutral'>  In the following three paragraphs, a &quot;patent license&quot; is any express</span>
 575 |     | <span class='neutral'>agreement or commitment, however denominated, not to enforce a patent</span>
 576 |     | <span class='neutral'>(such as an express permission to practice a patent or covenant not to</span>
 577 |     | <span class='neutral'>sue for patent infringement).  To &quot;grant&quot; such a patent license to a</span>
 578 |     | <span class='neutral'>party means to make such an agreement or commitment not to enforce a</span>
 579 |     | <span class='neutral'>patent against the party.</span>
 580 |     | <span class='neutral'></span>
 581 |     | <span class='neutral'>  If you convey a covered work, knowingly relying on a patent license,</span>
 582 |     | <span class='neutral'>and the Corresponding Source of the work is not available for anyone</span>
 583 |     | <span class='neutral'>to copy, free of charge and under the terms of this License, through a</span>
 584 |     | <span class='neutral'>publicly available network server or other readily accessible means,</span>
 585 |     | <span class='neutral'>then you must either (1) cause the Corresponding Source to be so</span>
 586 |     | <span class='neutral'>available, or (2) arrange to deprive yourself of the benefit of the</span>
 587 |     | <span class='neutral'>patent license for this particular work, or (3) arrange, in a manner</span>
 588 |     | <span class='neutral'>consistent with the requirements of this License, to extend the patent</span>
 589 |     | <span class='neutral'>license to downstream recipients.  &quot;Knowingly relying&quot; means you have</span>
 590 |     | <span class='neutral'>actual knowledge that, but for the patent license, your conveying the</span>
 591 |     | <span class='neutral'>covered work in a country, or your recipient&#39;s use of the covered work</span>
 592 |     | <span class='neutral'>in a country, would infringe one or more identifiable patents in that</span>
 593 |     | <span class='neutral'>country that you have reason to believe are valid.</span>
 594 |     | <span class='neutral'></span>
 595 |     | <span class='neutral'>  If, pursuant to or in connection with a single transaction or</span>
 596 |     | <span class='neutral'>arrangement, you convey, or propagate by procuring conveyance of, a</span>
 597 |     | <span class='neutral'>covered work, and grant a patent license to some of the parties</span>
 598 |     | <span class='neutral'>receiving the covered work authorizing them to use, propagate, modify</span>
 599 |     | <span class='neutral'>or convey a specific copy of the covered work, then the patent license</span>
 600 |     | <span class='neutral'>you grant is automatically extended to all recipients of the covered</span>
 601 |     | <span class='neutral'>work and works based on it.</span>
 602 |     | <span class='neutral'></span>
 603 |     | <span class='neutral'>  A patent license is &quot;discriminatory&quot; if it does not include within</span>
 604 |     | <span class='neutral'>the scope of its coverage, prohibits the exercise of, or is</span>
 605 |     | <span class='neutral'>conditioned on the non-exercise of one or more of the rights that are</span>
 606 |     | <span class='neutral'>specifically granted under this License.  You may not convey a covered</span>
 607 |     | <span class='neutral'>work if you are a party to an arrangement with a third party that is</span>
 608 |     | <span class='neutral'>in the business of distributing software, under which you make payment</span>
 609 |     | <span class='neutral'>to the third party based on the extent of your activity of conveying</span>
 610 |     | <span class='neutral'>the work, and under which the third party grants, to any of the</span>
 611 |     | <span class='neutral'>parties who would receive the covered work from you, a discriminatory</span>
 612 |     | <span class='neutral'>patent license (a) in connection with copies of the covered work</span>
 613 |     | <span class='neutral'>conveyed by you (or copies made from those copies), or (b) primarily</span>
 614 |     | <span class='neutral'>for and in connection with specific products or compilations that</span>
 615 |     | <span class='neutral'>contain the covered work, unless you entered into that arrangement,</span>
 616 |     | <span class='neutral'>or that patent license was granted, prior to 28 March 2007.</span>
 617 |     | <span class='neutral'></span>
 618 |     | <span class='neutral'>  Nothing in this License shall be construed as excluding or limiting</span>
 619 |     | <span class='neutral'>any implied license or other defenses to infringement that may</span>
 620 |     | <span class='neutral'>otherwise be available to you under applicable patent law.</span>
 621 |     | <span class='neutral'></span>
 622 |     | <span class='neutral'>  12. No Surrender of Others&#39; Freedom.</span>
 623 |     | <span class='neutral'></span>
 624 |     | <span class='neutral'>  If conditions are imposed on you (whether by court order, agreement or</span>
 625 |     | <span class='neutral'>otherwise) that contradict the conditions of this License, they do not</span>
 626 |     | <span class='neutral'>excuse you from the conditions of this License.  If you cannot convey a</span>
 627 |     | <span class='neutral'>covered work so as to satisfy simultaneously your obligations under this</span>
 628 |     | <span class='neutral'>License and any other pertinent obligations, then as a consequence you may</span>
 629 |     | <span class='neutral'>not convey it at all.  For example, if you agree to terms that obligate you</span>
 630 |     | <span class='neutral'>to collect a royalty for further conveying from those to whom you convey</span>
 631 |     | <span class='neutral'>the Program, the only way you could satisfy both those terms and this</span>
 632 |     | <span class='neutral'>License would be to refrain entirely from conveying the Program.</span>
 633 |     | <span class='neutral'></span>
 634 |     | <span class='neutral'>  13. Use with the GNU Affero General Public License.</span>
 635 |     | <span class='neutral'></span>
 636 |     | <span class='neutral'>  Notwithstanding any other provision of this License, you have</span>
 637 |     | <span class='neutral'>permission to link or combine any covered work with a work licensed</span>
 638 |     | <span class='neutral'>under version 3 of the GNU Affero General Public License into a single</span>
 639 |     | <span class='neutral'>combined work, and to convey the resulting work.  The terms of this</span>
 640 |     | <span class='neutral'>License will continue to apply to the part which is the covered work,</span>
 641 |     | <span class='neutral'>but the special requirements of the GNU Affero General Public License,</span>
 642 |     | <span class='neutral'>section 13, concerning interaction through a network will apply to the</span>
 643 |     | <span class='neutral'>combination as such.</span>
 644 |     | <span class='neutral'></span>
 645 |     | <span class='neutral'>  14. Revised Versions of this License.</span>
 646 |     | <span class='neutral'></span>
 647 |     | <span class='neutral'>  The Free Software Foundation may publish revised and/or new versions of</span>
 648 |     | <span class='neutral'>the GNU General Public License from time to time.  Such new versions will</span>
 649 |     | <span class='neutral'>be similar in spirit to the present version, but may differ in detail to</span>
 650 |     | <span class='neutral'>address new problems or concerns.</span>
 651 |     | <span class='neutral'></span>
 652 |     | <span class='neutral'>  Each version is given a distinguishing version number.  If the</span>
 653 |     | <span class='neutral'>Program specifies that a certain numbered version of the GNU General</span>
 654 |     | <span class='neutral'>Public License &quot;or any later version&quot; applies to it, you have the</span>
 655 |     | <span class='neutral'>option of following the terms and conditions either of that numbered</span>
 656 |     | <span class='neutral'>version or of any later version published by the Free Software</span>
 657 |     | <span class='neutral'>Foundation.  If the Program does not specify a version number of the</span>
 658 |     | <span class='neutral'>GNU General Public License, you may choose any version ever published</span>
 659 |     | <span class='neutral'>by the Free Software Foundation.</span>
 660 |     | <span class='neutral'></span>
 661 |     | <span class='neutral'>  If the Program specifies that a proxy can decide which future</span>
 662 |     | <span class='neutral'>versions of the GNU General Public License can be used, that proxy&#39;s</span>
 663 |     | <span class='neutral'>public statement of acceptance of a version permanently authorizes you</span>
 664 |     | <span class='neutral'>to choose that version for the Program.</span>
 665 |     | <span class='neutral'></span>
 666 |     | <span class='neutral'>  Later license versions may give you additional or different</span>
 667 |     | <span class='neutral'>permissions.  However, no additional obligations are imposed on any</span>
 668 |     | <span class='neutral'>author or copyright holder as a result of your choosing to follow a</span>
 669 |     | <span class='neutral'>later version.</span>
 670 |     | <span class='neutral'></span>
 671 |     | <span class='neutral'>  15. Disclaimer of Warranty.</span>
 672 |     | <span class='neutral'></span>
 673 |     | <span class='neutral'>  THERE IS NO WARRANTY FOR THE PROGRAM, TO THE EXTENT PERMITTED BY</span>
 674 |     | <span class='neutral'>APPLICABLE LAW.  EXCEPT WHEN OTHERWISE STATED IN WRITING THE COPYRIGHT</span>
 675 |     | <span class='neutral'>HOLDERS AND/OR OTHER PARTIES PROVIDE THE PROGRAM &quot;AS IS&quot; WITHOUT WARRANTY</span>
 676 |     | <span class='neutral'>OF ANY KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING, BUT NOT LIMITED TO,</span>
 677 |     | <span class='neutral'>THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR</span>
 678 |     | <span class='neutral'>PURPOSE.  THE ENTIRE RISK AS TO THE QUALITY AND PERFORMANCE OF THE PROGRAM</span>
 679 |     | <span class='neutral'>IS WITH YOU.  SHOULD THE PROGRAM PROVE DEFECTIVE, YOU ASSUME THE COST OF</span>
 680 |     | <span class='neutral'>ALL NECESSARY SERVICING, REPAIR OR CORRECTION.</span>
 681 |     | <span class='neutral'></span>
 682 |     | <span class='neutral'>  16. Limitation of Liability.</span>
 683 |     | <span class='neutral'></span>
 684 |     | <span class='neutral'>  IN NO EVENT UNLESS REQUIRED BY APPLICABLE LAW OR AGREED TO IN WRITING</span>
 685 |     | <span class='neutral'>WILL ANY COPYRIGHT HOLDER, OR ANY OTHER PARTY WHO MODIFIES AND/OR CONVEYS</span>
 686 |     | <span class='neutral'>THE PROGRAM AS PERMITTED ABOVE, BE LIABLE TO YOU FOR DAMAGES, INCLUDING ANY</span>
 687 |     | <span class='neutral'>GENERAL, SPECIAL, INCIDENTAL OR CONSEQUENTIAL DAMAGES ARISING OUT OF THE</span>
 688 |     | <span class='neutral'>USE OR INABILITY TO USE THE PROGRAM (INCLUDING BUT NOT LIMITED TO LOSS OF</span>
 689 |     | <span class='neutral'>DATA OR DATA BEING RENDERED INACCURATE OR LOSSES SUSTAINED BY YOU OR THIRD</span>
 690 |     | <span class='neutral'>PARTIES OR A FAILURE OF THE PROGRAM TO OPERATE WITH ANY OTHER PROGRAMS),</span>
 691 |     | <span class='neutral'>EVEN IF SUCH HOLDER OR OTHER PARTY HAS BEEN ADVISED OF THE POSSIBILITY OF</span>
 692 |     | <span class='neutral'>SUCH DAMAGES.</span>
 693 |     | <span class='neutral'></span>
 694 |     | <span class='neutral'>  17. Interpretation of Sections 15 and 16.</span>
 695 |     | <span class='neutral'></span>
 696 |     | <span class='neutral'>  If the disclaimer of warranty and limitation of liability provided</span>
 697 |     | <span class='neutral'>above cannot be given local legal effect according to their terms,</span>
 698 |     | <span class='neutral'>reviewing courts shall apply local law that most closely approximates</span>
 699 |     | <span class='neutral'>an absolute waiver of all civil liability in connection with the</span>
 700 |     | <span class='neutral'>Program, unless a warranty or assumption of liability accompanies a</span>
 701 |     | <span class='neutral'>copy of the Program in return for a fee.</span>
 702 |     | <span class='neutral'></span>
 703 |     | <span class='neutral'>                     END OF TERMS AND CONDITIONS</span>
 704 |     | <span class='neutral'></span>
 705 |     | <span class='neutral'>            How to Apply These Terms to Your New Programs</span>
 706 |     | <span class='neutral'></span>
 707 |     | <span class='neutral'>  If you develop a new program, and you want it to be of the greatest</span>
 708 |     | <span class='neutral'>possible use to the public, the best way to achieve this is to make it</span>
 709 |     | <span class='neutral'>free software which everyone can redistribute and change under these terms.</span>
 710 |     | <span class='neutral'></span>
 711 |     | <span class='neutral'>  To do so, attach the following notices to the program.  It is safest</span>
 712 |     | <span class='neutral'>to attach them to the start of each source file to most effectively</span>
 713 |     | <span class='neutral'>state the exclusion of warranty; and each file should have at least</span>
 714 |     | <span class='neutral'>the &quot;copyright&quot; line and a pointer to where the full notice is found.</span>
 715 |     | <span class='neutral'></span>
 716 |     | <span class='neutral'>    &lt;one line to give the program&#39;s name and a brief idea of what it does.&gt;</span>
 717 |     | <span class='neutral'>    Copyright (C) &lt;year&gt;  &lt;name of author&gt;</span>
 718 |     | <span class='neutral'></span>
 719 |     | <span class='neutral'>    This program is free software: you can redistribute it and/or modify</span>
 720 |     | <span class='neutral'>    it under the terms of the GNU General Public License as published by</span>
 721 |     | <span class='neutral'>    the Free Software Foundation, either version 3 of the License, or</span>
 722 |     | <span class='neutral'>    (at your option) any later version.</span>
 723 |     | <span class='neutral'></span>
 724 |     | <span class='neutral'>    This program is distributed in the hope that it will be useful,</span>
 725 |     | <span class='neutral'>    but WITHOUT ANY WARRANTY; without even the implied warranty of</span>
 726 |     | <span class='neutral'>    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the</span>
 727 |     | <span class='neutral'>    GNU General Public License for more details.</span>
 728 |     | <span class='neutral'></span>
 729 |     | <span class='neutral'>    You should have received a copy of the GNU General Public License</span>
 730 |     | <span class='neutral'>    along with this program.  If not, see &lt;http://www.gnu.org/licenses/&gt;.</span>
 731 |     | <span class='neutral'></span>
 732 |     | <span class='neutral'>Also add information on how to contact you by electronic and paper mail.</span>
 733 |     | <span class='neutral'></span>
 734 |     | <span class='neutral'>  If the program does terminal interaction, make it output a short</span>
 735 |     | <span class='neutral'>notice like this when it starts in an interactive mode:</span>
 736 |     | <span class='neutral'></span>
 737 |     | <span class='neutral'>    &lt;program&gt;  Copyright (C) &lt;year&gt;  &lt;name of author&gt;</span>
 738 |     | <span class='neutral'>    This program comes with ABSOLUTELY NO WARRANTY; for details type `show w&#39;.</span>
 739 |     | <span class='neutral'>    This is free software, and you are welcome to redistribute it</span>
 740 |     | <span class='neutral'>    under certain conditions; type `show c&#39; for details.</span>
 741 |     | <span class='neutral'></span>
 742 |     | <span class='neutral'>The hypothetical commands `show w&#39; and `show c&#39; should show the appropriate</span>
 743 |     | <span class='neutral'>parts of the General Public License.  Of course, your program&#39;s commands</span>
 744 |     | <span class='neutral'>might be different; for a GUI interface, you would use an &quot;about box&quot;.</span>
 745 |     | <span class='neutral'></span>
 746 |     | <span class='neutral'>  You should also get your employer (if you work as a programmer) or school,</span>
 747 |     | <span class='neutral'>if any, to sign a &quot;copyright disclaimer&quot; for the program, if necessary.</span>
 748 |     | <span class='neutral'>For more information on this, and how to apply and follow the GNU GPL, see</span>
 749 |     | <span class='neutral'>&lt;http://www.gnu.org/licenses/&gt;.</span>
 750 |     | <span class='neutral'></span>
 751 |     | <span class='neutral'>  The GNU General Public License does not permit incorporating your program</span>
 752 |     | <span class='neutral'>into proprietary programs.  If your program is a subroutine library, you</span>
 753 |     | <span class='neutral'>may consider it more useful to permit linking proprietary applications with</span>
 754 |     | <span class='neutral'>the library.  If this is what you want to do, use the GNU Lesser General</span>
 755 |     | <span class='neutral'>Public License instead of this License.  But first, please read</span>
 756 |     | <span class='neutral'>&lt;http://www.gnu.org/philosophy/why-not-lgpl.html&gt;.</span>
 757 |     | <span class='neutral'></span>
 758 |     | <span class='neutral'>*/</span>
 759 |     | <span class='neutral'></span>

</code>
<br />

<b>/mnt/c/Users/Lourens/Documents/Recon-Fuzz/collabs/ebtc/packages/contracts/contracts/TestContracts/invariants/Actor.sol</b>
<code>
  1 |     | <span class='neutral'>pragma solidity 0.8.17;</span>
  2 |     | <span class='neutral'></span>
  3 |     | <span class='neutral'>import {IERC3156FlashBorrower} from &quot;../../Interfaces/IERC3156FlashBorrower.sol&quot;;</span>
  4 |     | <span class='neutral'>import {IERC20} from &quot;../../Dependencies/IERC20.sol&quot;;</span>
  5 |     | <span class='neutral'></span>
  6 | *   | <span class='executed'>contract Actor is IERC3156FlashBorrower {</span>
  7 |     | <span class='neutral'>    address[] internal tokens;</span>
  8 |     | <span class='neutral'>    address[] internal callers;</span>
  9 |     | <span class='neutral'></span>
 10 |     | <span class='unexecuted'>    constructor(address[] memory _tokens, address[] memory _callers) payable {</span>
 11 |     | <span class='unexecuted'>        tokens = _tokens;</span>
 12 |     | <span class='unexecuted'>        callers = _callers;</span>
 13 |     | <span class='unexecuted'>        for (uint256 i = 0; i &lt; tokens.length; i++) {</span>
 14 |     | <span class='unexecuted'>            IERC20(tokens[i]).approve(callers[i], type(uint256).max);</span>
 15 |     | <span class='neutral'>        }</span>
 16 |     | <span class='neutral'>    }</span>
 17 |     | <span class='neutral'></span>
 18 | *   | <span class='executed'>    function proxy(</span>
 19 |     | <span class='neutral'>        address _target,</span>
 20 |     | <span class='neutral'>        bytes memory _calldata</span>
 21 | *   | <span class='executed'>    ) public returns (bool success, bytes memory returnData) {</span>
 22 | *   | <span class='executed'>        (success, returnData) = address(_target).call(_calldata);</span>
 23 |     | <span class='neutral'>    }</span>
 24 |     | <span class='neutral'></span>
 25 |     | <span class='unexecuted'>    function proxy(</span>
 26 |     | <span class='neutral'>        address _target,</span>
 27 |     | <span class='neutral'>        bytes memory _calldata,</span>
 28 |     | <span class='neutral'>        uint256 value</span>
 29 |     | <span class='unexecuted'>    ) public returns (bool success, bytes memory returnData) {</span>
 30 |     | <span class='unexecuted'>        (success, returnData) = address(_target).call{value: value}(_calldata);</span>
 31 |     | <span class='neutral'>    }</span>
 32 |     | <span class='neutral'></span>
 33 |     | <span class='neutral'>    receive() external payable {}</span>
 34 |     | <span class='neutral'></span>
 35 |     | <span class='neutral'>    // callback for flashloan</span>
 36 | *   | <span class='executed'>    function onFlashLoan(</span>
 37 |     | <span class='neutral'>        address,</span>
 38 |     | <span class='neutral'>        address token,</span>
 39 |     | <span class='neutral'>        uint256 amount,</span>
 40 |     | <span class='neutral'>        uint256 fee,</span>
 41 |     | <span class='neutral'>        bytes calldata data</span>
 42 | *   | <span class='executed'>    ) external override returns (bytes32) {</span>
 43 |     | <span class='neutral'>        bool isValidCaller = false;</span>
 44 | *   | <span class='executed'>        for (uint256 i = 0; i &lt; tokens.length; i++) {</span>
 45 | *   | <span class='executed'>            if (token == tokens[i]) {</span>
 46 | *   | <span class='executed'>                isValidCaller = msg.sender == callers[i];</span>
 47 | *   | <span class='executed'>                break;</span>
 48 |     | <span class='neutral'>            }</span>
 49 |     | <span class='neutral'>        }</span>
 50 | *   | <span class='executed'>        require(isValidCaller, &quot;Invalid caller&quot;);</span>
 51 |     | <span class='neutral'></span>
 52 | *   | <span class='executed'>        if (data.length != 0) {</span>
 53 | *   | <span class='executed'>            (address[] memory _targets, bytes[] memory _calldatas) = abi.decode(</span>
 54 | *   | <span class='executed'>                data,</span>
 55 |     | <span class='neutral'>                (address[], bytes[])</span>
 56 |     | <span class='neutral'>            );</span>
 57 | *   | <span class='executed'>            for (uint256 i = 0; i &lt; _targets.length; ++i) {</span>
 58 | *   | <span class='executed'>                (bool success, ) = address(_targets[i]).call(_calldatas[i]);</span>
 59 | *   | <span class='executed'>                require(success);</span>
 60 |     | <span class='neutral'>            }</span>
 61 |     | <span class='neutral'>        }</span>
 62 |     | <span class='neutral'></span>
 63 | *   | <span class='executed'>        IERC20(token).approve(msg.sender, amount + fee);</span>
 64 |     | <span class='neutral'></span>
 65 | *   | <span class='executed'>        return keccak256(&quot;ERC3156FlashBorrower.onFlashLoan&quot;);</span>
 66 |     | <span class='neutral'>    }</span>
 67 |     | <span class='neutral'>}</span>
 68 |     | <span class='neutral'></span>

</code>
<br />

<b>/mnt/c/Users/Lourens/Documents/Recon-Fuzz/collabs/ebtc/packages/contracts/contracts/TestContracts/invariants/Asserts.sol</b>
<code>
   1 |     | <span class='neutral'>pragma solidity 0.8.17;</span>
   2 |     | <span class='neutral'></span>
   3 |     | <span class='neutral'>abstract contract Asserts {</span>
   4 |     | <span class='neutral'>    event L1(uint256);</span>
   5 |     | <span class='neutral'>    event L2(uint256, uint256);</span>
   6 |     | <span class='neutral'>    event L3(uint256, uint256, uint256);</span>
   7 |     | <span class='neutral'>    event L4(uint256, uint256, uint256, uint256);</span>
   8 |     | <span class='neutral'></span>
   9 |     | <span class='neutral'>    function gt(uint256 a, uint256 b, string memory reason) internal virtual;</span>
  10 |     | <span class='neutral'></span>
  11 |     | <span class='neutral'>    function gte(uint256 a, uint256 b, string memory reason) internal virtual;</span>
  12 |     | <span class='neutral'></span>
  13 |     | <span class='neutral'>    function lt(uint256 a, uint256 b, string memory reason) internal virtual;</span>
  14 |     | <span class='neutral'></span>
  15 |     | <span class='neutral'>    function lte(uint256 a, uint256 b, string memory reason) internal virtual;</span>
  16 |     | <span class='neutral'></span>
  17 |     | <span class='neutral'>    function eq(uint256 a, uint256 b, string memory reason) internal virtual;</span>
  18 |     | <span class='neutral'></span>
  19 |     | <span class='neutral'>    function t(bool b, string memory reason) internal virtual;</span>
  20 |     | <span class='neutral'></span>
  21 |     | <span class='neutral'>    function between(uint256 value, uint256 low, uint256 high) internal virtual returns (uint256);</span>
  22 |     | <span class='neutral'></span>
  23 |     | <span class='unexecuted'>    function isApproximateEq(</span>
  24 |     | <span class='neutral'>        uint256 _num1,</span>
  25 |     | <span class='neutral'>        uint256 _num2,</span>
  26 |     | <span class='neutral'>        uint256 _tolerance</span>
  27 |     | <span class='unexecuted'>    ) internal pure returns (bool) {</span>
  28 |     | <span class='unexecuted'>        return diffPercent(_num1, _num2) &lt;= _tolerance;</span>
  29 |     | <span class='neutral'>    }</span>
  30 |     | <span class='neutral'></span>
  31 |     | <span class='unexecuted'>    function diffPercent(uint256 _num1, uint256 _num2) internal pure returns (uint256) {</span>
  32 |     | <span class='unexecuted'>        if (_num1 == _num2) return 0;</span>
  33 |     | <span class='unexecuted'>        else if (_num1 &gt; _num2) {</span>
  34 |     | <span class='unexecuted'>            return ((_num1 - _num2) * 1e18) / ((_num1 + _num2) / 2);</span>
  35 |     | <span class='neutral'>        } else {</span>
  36 |     | <span class='unexecuted'>            return ((_num2 - _num1) * 1e18) / ((_num1 + _num2) / 2);</span>
  37 |     | <span class='neutral'>        }</span>
  38 |     | <span class='neutral'>    }</span>
  39 |     | <span class='neutral'></span>
  40 |     | <span class='neutral'>    /// @dev compare absoulte value</span>
  41 |     | <span class='unexecuted'>    function _assertApproximateEq(</span>
  42 |     | <span class='neutral'>        uint256 _num1,</span>
  43 |     | <span class='neutral'>        uint256 _num2,</span>
  44 |     | <span class='neutral'>        uint256 _tolerance</span>
  45 |     | <span class='unexecuted'>    ) internal pure returns (bool) {</span>
  46 |     | <span class='unexecuted'>        if (_num1 &gt; _num2) {</span>
  47 |     | <span class='unexecuted'>            return _tolerance &gt;= (_num1 - _num2);</span>
  48 |     | <span class='neutral'>        } else {</span>
  49 |     | <span class='unexecuted'>            return _tolerance &gt;= (_num2 - _num1);</span>
  50 |     | <span class='neutral'>        }</span>
  51 |     | <span class='neutral'>    }</span>
  52 |     | <span class='neutral'></span>
  53 |     | <span class='neutral'>    // https://ethereum.stackexchange.com/a/83577</span>
  54 | *   | <span class='executed'>    function _getRevertMsg(bytes memory returnData) internal pure returns (string memory) {</span>
  55 |     | <span class='neutral'>        // Check that the data has the right size: 4 bytes for signature + 32 bytes for panic code</span>
  56 | *   | <span class='executed'>        if (returnData.length == 4 + 32) {</span>
  57 |     | <span class='neutral'>            // Check that the data starts with the Panic signature</span>
  58 |     | <span class='unexecuted'>            bytes4 panicSignature = bytes4(keccak256(bytes(&quot;Panic(uint256)&quot;)));</span>
  59 |     | <span class='unexecuted'>            for (uint i = 0; i &lt; 4; i++) {</span>
  60 |     | <span class='unexecuted'>                if (returnData[i] != panicSignature[i]) return &quot;Undefined signature&quot;;</span>
  61 |     | <span class='neutral'>            }</span>
  62 |     | <span class='neutral'></span>
  63 |     | <span class='unexecuted'>            uint256 panicCode;</span>
  64 |     | <span class='unexecuted'>            for (uint i = 4; i &lt; 36; i++) {</span>
  65 |     | <span class='unexecuted'>                panicCode = panicCode &lt;&lt; 8;</span>
  66 |     | <span class='unexecuted'>                panicCode |= uint8(returnData[i]);</span>
  67 |     | <span class='neutral'>            }</span>
  68 |     | <span class='neutral'></span>
  69 |     | <span class='neutral'>            // Now convert the panic code into its string representation</span>
  70 |     | <span class='unexecuted'>            if (panicCode == 17) {</span>
  71 |     | <span class='unexecuted'>                return &quot;Panic(17)&quot;;</span>
  72 |     | <span class='neutral'>            }</span>
  73 |     | <span class='neutral'></span>
  74 |     | <span class='neutral'>            // Add other panic codes as needed or return a generic &quot;Unknown panic&quot;</span>
  75 |     | <span class='unexecuted'>            return &quot;Undefined panic code&quot;;</span>
  76 |     | <span class='neutral'>        }</span>
  77 |     | <span class='neutral'></span>
  78 |     | <span class='neutral'>        // If the returnData length is less than 68, then the transaction failed silently (without a revert message)</span>
  79 | *   | <span class='executed'>        if (returnData.length &lt; 68) return &quot;Transaction reverted silently&quot;;</span>
  80 |     | <span class='neutral'></span>
  81 |     | <span class='neutral'>        assembly {</span>
  82 |     | <span class='neutral'>            // Slice the sighash.</span>
  83 | *   | <span class='executed'>            returnData := add(returnData, 0x04)</span>
  84 |     | <span class='neutral'>        }</span>
  85 | *   | <span class='executed'>        return abi.decode(returnData, (string)); // All that remains is the revert string</span>
  86 |     | <span class='neutral'>    }</span>
  87 |     | <span class='neutral'></span>
  88 | *   | <span class='executed'>    function _isRevertReasonEqual(</span>
  89 |     | <span class='neutral'>        bytes memory returnData,</span>
  90 |     | <span class='neutral'>        string memory reason</span>
  91 | *   | <span class='executed'>    ) internal pure returns (bool) {</span>
  92 | *   | <span class='executed'>        return (keccak256(abi.encodePacked(_getRevertMsg(returnData))) ==</span>
  93 | *   | <span class='executed'>            keccak256(abi.encodePacked(reason)));</span>
  94 |     | <span class='neutral'>    }</span>
  95 |     | <span class='neutral'></span>
  96 | *   | <span class='executed'>    function max(uint256 a, uint256 b) internal pure returns (uint256) {</span>
  97 | *   | <span class='executed'>        return a &gt;= b ? a : b;</span>
  98 |     | <span class='neutral'>    }</span>
  99 |     | <span class='neutral'></span>
 100 | *   | <span class='executed'>    function min(uint256 a, uint256 b) internal pure returns (uint256) {</span>
 101 | *   | <span class='executed'>        return a &lt; b ? a : b;</span>
 102 |     | <span class='neutral'>    }</span>
 103 |     | <span class='neutral'></span>
 104 | *   | <span class='executed'>    function assertRevertReasonNotEqual(bytes memory returnData, string memory reason) internal {</span>
 105 | *   | <span class='executed'>        bool isEqual = _isRevertReasonEqual(returnData, reason);</span>
 106 | *   | <span class='executed'>        t(!isEqual, reason);</span>
 107 |     | <span class='neutral'>    }</span>
 108 |     | <span class='neutral'></span>
 109 |     | <span class='neutral'>    function assertRevertReasonEqual(bytes memory returnData, string memory reason) internal {</span>
 110 |     | <span class='neutral'>        bool isEqual = _isRevertReasonEqual(returnData, reason);</span>
 111 |     | <span class='neutral'>        t(isEqual, reason);</span>
 112 |     | <span class='neutral'>    }</span>
 113 |     | <span class='neutral'></span>
 114 |     | <span class='neutral'>    function assertRevertReasonEqual(</span>
 115 |     | <span class='neutral'>        bytes memory returnData,</span>
 116 |     | <span class='neutral'>        string memory reason1,</span>
 117 |     | <span class='neutral'>        string memory reason2</span>
 118 |     | <span class='neutral'>    ) internal {</span>
 119 |     | <span class='neutral'>        bool isEqual = _isRevertReasonEqual(returnData, reason1) ||</span>
 120 |     | <span class='neutral'>            _isRevertReasonEqual(returnData, reason2);</span>
 121 |     | <span class='neutral'>        t(isEqual, string.concat(reason1, &quot; OR &quot;, reason2));</span>
 122 |     | <span class='neutral'>    }</span>
 123 |     | <span class='neutral'></span>
 124 |     | <span class='neutral'>    function assertRevertReasonEqual(</span>
 125 |     | <span class='neutral'>        bytes memory returnData,</span>
 126 |     | <span class='neutral'>        string memory reason1,</span>
 127 |     | <span class='neutral'>        string memory reason2,</span>
 128 |     | <span class='neutral'>        string memory reason3</span>
 129 |     | <span class='neutral'>    ) internal {</span>
 130 |     | <span class='neutral'>        bool isEqual = _isRevertReasonEqual(returnData, reason1) ||</span>
 131 |     | <span class='neutral'>            _isRevertReasonEqual(returnData, reason2) ||</span>
 132 |     | <span class='neutral'>            _isRevertReasonEqual(returnData, reason3);</span>
 133 |     | <span class='neutral'>        t(isEqual, string.concat(reason1, &quot; OR &quot;, reason2, &quot; OR &quot;, reason3));</span>
 134 |     | <span class='neutral'>    }</span>
 135 |     | <span class='neutral'></span>
 136 |     | <span class='neutral'>    function assertRevertReasonEqual(</span>
 137 |     | <span class='neutral'>        bytes memory returnData,</span>
 138 |     | <span class='neutral'>        string memory reason1,</span>
 139 |     | <span class='neutral'>        string memory reason2,</span>
 140 |     | <span class='neutral'>        string memory reason3,</span>
 141 |     | <span class='neutral'>        string memory reason4</span>
 142 |     | <span class='neutral'>    ) internal {</span>
 143 |     | <span class='neutral'>        bool isEqual = _isRevertReasonEqual(returnData, reason1) ||</span>
 144 |     | <span class='neutral'>            _isRevertReasonEqual(returnData, reason2) ||</span>
 145 |     | <span class='neutral'>            _isRevertReasonEqual(returnData, reason3) ||</span>
 146 |     | <span class='neutral'>            _isRevertReasonEqual(returnData, reason4);</span>
 147 |     | <span class='neutral'>        t(isEqual, string.concat(reason1, &quot; OR &quot;, reason2, &quot; OR &quot;, reason3, &quot; OR &quot;, reason4));</span>
 148 |     | <span class='neutral'>    }</span>
 149 |     | <span class='neutral'>}</span>
 150 |     | <span class='neutral'></span>

</code>
<br />

<b>/mnt/c/Users/Lourens/Documents/Recon-Fuzz/collabs/ebtc/packages/contracts/contracts/TestContracts/invariants/BeforeAfter.sol</b>
<code>
   1 |     | <span class='neutral'>pragma solidity 0.8.17;</span>
   2 |     | <span class='neutral'></span>
   3 |     | <span class='neutral'>import {Pretty, Strings} from &quot;../Pretty.sol&quot;;</span>
   4 |     | <span class='neutral'>import {BaseStorageVariables} from &quot;../BaseStorageVariables.sol&quot;;</span>
   5 |     | <span class='neutral'></span>
   6 |     | <span class='neutral'>abstract contract BeforeAfter is BaseStorageVariables {</span>
   7 |     | <span class='neutral'>    using Strings for string;</span>
   8 |     | <span class='neutral'>    using Pretty for uint256;</span>
   9 |     | <span class='neutral'>    using Pretty for int256;</span>
  10 |     | <span class='neutral'>    using Pretty for bool;</span>
  11 |     | <span class='neutral'></span>
  12 |     | <span class='neutral'>    struct Vars {</span>
  13 |     | <span class='neutral'>        uint256 userSurplusBefore;</span>
  14 |     | <span class='neutral'>        uint256 userSurplusAfter;</span>
  15 |     | <span class='neutral'>        uint256 valueInSystemBefore;</span>
  16 |     | <span class='neutral'>        uint256 valueInSystemAfter;</span>
  17 |     | <span class='neutral'>        uint256 nicrBefore;</span>
  18 |     | <span class='neutral'>        uint256 nicrAfter;</span>
  19 |     | <span class='neutral'>        uint256 icrBefore;</span>
  20 |     | <span class='neutral'>        uint256 icrAfter;</span>
  21 |     | <span class='neutral'>        uint256 newIcrBefore;</span>
  22 |     | <span class='neutral'>        uint256 newIcrAfter;</span>
  23 |     | <span class='neutral'>        uint256 feeSplitBefore;</span>
  24 |     | <span class='neutral'>        uint256 feeSplitAfter;</span>
  25 |     | <span class='neutral'>        uint256 feeRecipientTotalCollBefore;</span>
  26 |     | <span class='neutral'>        uint256 feeRecipientTotalCollAfter;</span>
  27 |     | <span class='neutral'>        uint256 feeRecipientCollSharesBefore;</span>
  28 |     | <span class='neutral'>        uint256 feeRecipientCollSharesAfter;</span>
  29 |     | <span class='neutral'>        uint256 actorCollBefore;</span>
  30 |     | <span class='neutral'>        uint256 actorCollAfter;</span>
  31 |     | <span class='neutral'>        uint256 actorEbtcBefore;</span>
  32 |     | <span class='neutral'>        uint256 actorEbtcAfter;</span>
  33 |     | <span class='neutral'>        uint256 actorCdpCountBefore;</span>
  34 |     | <span class='neutral'>        uint256 actorCdpCountAfter;</span>
  35 |     | <span class='neutral'>        uint256 cdpCollBefore;</span>
  36 |     | <span class='neutral'>        uint256 cdpCollAfter;</span>
  37 |     | <span class='neutral'>        uint256 cdpDebtBefore;</span>
  38 |     | <span class='neutral'>        uint256 cdpDebtAfter;</span>
  39 |     | <span class='neutral'>        uint256 cdpStakeBefore;</span>
  40 |     | <span class='neutral'>        uint256 cdpStakeAfter;</span>
  41 |     | <span class='neutral'>        uint256 liquidatorRewardSharesBefore;</span>
  42 |     | <span class='neutral'>        uint256 liquidatorRewardSharesAfter;</span>
  43 |     | <span class='neutral'>        uint256 sortedCdpsSizeBefore;</span>
  44 |     | <span class='neutral'>        uint256 sortedCdpsSizeAfter;</span>
  45 |     | <span class='neutral'>        uint256 cdpStatusBefore;</span>
  46 |     | <span class='neutral'>        uint256 cdpStatusAfter;</span>
  47 |     | <span class='neutral'>        uint256 tcrBefore;</span>
  48 |     | <span class='neutral'>        uint256 tcrAfter;</span>
  49 |     | <span class='neutral'>        uint256 newTcrBefore;</span>
  50 |     | <span class='neutral'>        uint256 newTcrAfter;</span>
  51 |     | <span class='neutral'>        uint256 ebtcTotalSupplyBefore;</span>
  52 |     | <span class='neutral'>        uint256 ebtcTotalSupplyAfter;</span>
  53 |     | <span class='neutral'>        uint256 ethPerShareBefore;</span>
  54 |     | <span class='neutral'>        uint256 ethPerShareAfter;</span>
  55 |     | <span class='neutral'>        uint256 activePoolCollBefore;</span>
  56 |     | <span class='neutral'>        uint256 activePoolCollAfter;</span>
  57 |     | <span class='neutral'>        uint256 activePoolDebtBefore;</span>
  58 |     | <span class='neutral'>        uint256 activePoolDebtAfter;</span>
  59 |     | <span class='neutral'>        uint256 collSurplusPoolBefore;</span>
  60 |     | <span class='neutral'>        uint256 collSurplusPoolAfter;</span>
  61 |     | <span class='neutral'>        uint256 priceBefore;</span>
  62 |     | <span class='neutral'>        uint256 priceAfter;</span>
  63 |     | <span class='neutral'>        bool isRecoveryModeBefore;</span>
  64 |     | <span class='neutral'>        bool isRecoveryModeAfter;</span>
  65 |     | <span class='neutral'>        uint256 lastGracePeriodStartTimestampBefore;</span>
  66 |     | <span class='neutral'>        uint256 lastGracePeriodStartTimestampAfter;</span>
  67 |     | <span class='neutral'>        bool lastGracePeriodStartTimestampIsSetBefore;</span>
  68 |     | <span class='neutral'>        bool lastGracePeriodStartTimestampIsSetAfter;</span>
  69 |     | <span class='neutral'>        bool hasGracePeriodPassedBefore;</span>
  70 |     | <span class='neutral'>        bool hasGracePeriodPassedAfter;</span>
  71 |     | <span class='neutral'>        uint256 systemDebtRedistributionIndexBefore;</span>
  72 |     | <span class='neutral'>        uint256 systemDebtRedistributionIndexAfter;</span>
  73 |     | <span class='neutral'>        uint256 feeRecipientCollSharesBalBefore;</span>
  74 |     | <span class='neutral'>        uint256 feeRecipientCollSharesBalAfter;</span>
  75 |     | <span class='neutral'>        uint256 cumulativeCdpsAtTimeOfRebase;</span>
  76 |     | <span class='neutral'>        uint256 prevStEthFeeIndex;</span>
  77 |     | <span class='neutral'>        uint256 afterStEthFeeIndex;</span>
  78 |     | <span class='neutral'>        uint256 totalStakesBefore;</span>
  79 |     | <span class='neutral'>        uint256 totalStakesAfter;</span>
  80 |     | <span class='neutral'>        uint256 totalStakesSnapshotBefore;</span>
  81 |     | <span class='neutral'>        uint256 totalStakesSnapshotAfter;</span>
  82 |     | <span class='neutral'>        uint256 totalCollateralSnapshotBefore;</span>
  83 |     | <span class='neutral'>        uint256 totalCollateralSnapshotAfter;</span>
  84 |     | <span class='neutral'>    }</span>
  85 |     | <span class='neutral'></span>
  86 |     | <span class='neutral'>    Vars vars;</span>
  87 |     | <span class='neutral'>    struct Cdp {</span>
  88 |     | <span class='neutral'>        bytes32 id;</span>
  89 |     | <span class='neutral'>        uint256 icr;</span>
  90 |     | <span class='neutral'>    }</span>
  91 |     | <span class='neutral'></span>
  92 | *   | <span class='executed'>    function _before(bytes32 _cdpId) internal {</span>
  93 | *   | <span class='executed'>        vars.priceBefore = priceFeedMock.fetchPrice();</span>
  94 |     | <span class='neutral'></span>
  95 | *   | <span class='executed'>        address ownerToCheck = sortedCdps.getOwnerAddress(_cdpId);</span>
  96 | *   | <span class='executed'>        vars.userSurplusBefore = collSurplusPool.getSurplusCollShares(ownerToCheck);</span>
  97 |     | <span class='neutral'></span>
  98 | *   | <span class='executed'>        (uint256 debtBefore, uint256 collBefore) = cdpManager.getSyncedDebtAndCollShares(_cdpId);</span>
  99 |     | <span class='neutral'></span>
 100 | *   | <span class='executed'>        vars.nicrBefore = _cdpId != bytes32(0) ? crLens.quoteRealNICR(_cdpId) : 0;</span>
 101 | *   | <span class='executed'>        vars.icrBefore = _cdpId != bytes32(0)</span>
 102 | *   | <span class='executed'>            ? cdpManager.getCachedICR(_cdpId, vars.priceBefore)</span>
 103 | *   | <span class='executed'>            : 0;</span>
 104 | *   | <span class='executed'>        vars.cdpCollBefore = _cdpId != bytes32(0) ? collBefore : 0;</span>
 105 | *   | <span class='executed'>        vars.cdpDebtBefore = _cdpId != bytes32(0) ? debtBefore : 0;</span>
 106 | *r  | <span class='executed'>        vars.cdpStakeBefore = _cdpId != bytes32(0) ? crLens.getRealStake(_cdpId) : 0;</span>
 107 | *   | <span class='executed'>        vars.liquidatorRewardSharesBefore = _cdpId != bytes32(0)</span>
 108 | *   | <span class='executed'>            ? cdpManager.getCdpLiquidatorRewardShares(_cdpId)</span>
 109 | *   | <span class='executed'>            : 0;</span>
 110 | *   | <span class='executed'>        vars.cdpStatusBefore = _cdpId != bytes32(0) ? cdpManager.getCdpStatus(_cdpId) : 0;</span>
 111 |     | <span class='neutral'></span>
 112 | *   | <span class='executed'>        vars.isRecoveryModeBefore = crLens.quoteCheckRecoveryMode() == 1; /// @audit crLens</span>
 113 | *   | <span class='executed'>        (vars.feeSplitBefore, , ) = collateral.getPooledEthByShares(cdpManager.DECIMAL_PRECISION()) &gt;</span>
 114 | *   | <span class='executed'>            cdpManager.stEthIndex()</span>
 115 | *   | <span class='executed'>            ? cdpManager.calcFeeUponStakingReward(</span>
 116 |     | <span class='unexecuted'>                collateral.getPooledEthByShares(cdpManager.DECIMAL_PRECISION()),</span>
 117 |     | <span class='unexecuted'>                cdpManager.stEthIndex()</span>
 118 |     | <span class='neutral'>            )</span>
 119 | *   | <span class='executed'>            : (0, 0, 0);</span>
 120 | *   | <span class='executed'>        vars.feeRecipientTotalCollBefore = collateral.balanceOf(activePool.feeRecipientAddress());</span>
 121 | *   | <span class='executed'>        vars.feeRecipientCollSharesBefore = activePool.getFeeRecipientClaimableCollShares();</span>
 122 | *   | <span class='executed'>        vars.feeRecipientCollSharesBalBefore = collateral.sharesOf(activePool.feeRecipientAddress());</span>
 123 | *   | <span class='executed'>        vars.actorCollBefore = collateral.balanceOf(address(actor));</span>
 124 | *   | <span class='executed'>        vars.actorEbtcBefore = eBTCToken.balanceOf(address(actor));</span>
 125 | *   | <span class='executed'>        vars.actorCdpCountBefore = sortedCdps.cdpCountOf(address(actor));</span>
 126 | *   | <span class='executed'>        vars.sortedCdpsSizeBefore = sortedCdps.getSize();</span>
 127 | *   | <span class='executed'>        vars.tcrBefore = cdpManager.getCachedTCR(vars.priceBefore);</span>
 128 | *   | <span class='executed'>        vars.ebtcTotalSupplyBefore = eBTCToken.totalSupply();</span>
 129 | *   | <span class='executed'>        vars.ethPerShareBefore = collateral.getPooledEthByShares(1e18);</span>
 130 | *   | <span class='executed'>        vars.activePoolDebtBefore = activePool.getSystemDebt();</span>
 131 | *   | <span class='executed'>        vars.activePoolCollBefore = activePool.getSystemCollShares();</span>
 132 | *   | <span class='executed'>        vars.collSurplusPoolBefore = collSurplusPool.getTotalSurplusCollShares();</span>
 133 | *   | <span class='executed'>        vars.lastGracePeriodStartTimestampBefore = cdpManager.lastGracePeriodStartTimestamp();</span>
 134 | *   | <span class='executed'>        vars.lastGracePeriodStartTimestampIsSetBefore =</span>
 135 | *   | <span class='executed'>            cdpManager.lastGracePeriodStartTimestamp() != cdpManager.UNSET_TIMESTAMP();</span>
 136 | *   | <span class='executed'>        vars.hasGracePeriodPassedBefore =</span>
 137 | *   | <span class='executed'>            cdpManager.lastGracePeriodStartTimestamp() != cdpManager.UNSET_TIMESTAMP() &amp;&amp;</span>
 138 | *   | <span class='executed'>            block.timestamp &gt;</span>
 139 | *   | <span class='executed'>            cdpManager.lastGracePeriodStartTimestamp() +</span>
 140 | *   | <span class='executed'>                cdpManager.recoveryModeGracePeriodDuration();</span>
 141 | *   | <span class='executed'>        vars.systemDebtRedistributionIndexBefore = cdpManager.systemDebtRedistributionIndex();</span>
 142 | *   | <span class='executed'>        vars.newTcrBefore = crLens.quoteRealTCR();</span>
 143 | *   | <span class='executed'>        vars.newIcrBefore = _cdpId != bytes32(0) ? crLens.quoteRealICR(_cdpId) : 0;</span>
 144 |     | <span class='neutral'></span>
 145 |     | <span class='neutral'>        vars.valueInSystemBefore ==</span>
 146 | *   | <span class='executed'>            (collateral.getPooledEthByShares(</span>
 147 | *   | <span class='executed'>                vars.activePoolCollBefore +</span>
 148 | *   | <span class='executed'>                    vars.collSurplusPoolBefore +</span>
 149 | *   | <span class='executed'>                    vars.feeRecipientTotalCollBefore</span>
 150 | *   | <span class='executed'>            ) * vars.priceBefore) /</span>
 151 | *   | <span class='executed'>                1e18 -</span>
 152 | *   | <span class='executed'>                vars.activePoolDebtBefore;</span>
 153 | *   | <span class='executed'>        vars.prevStEthFeeIndex = cdpManager.systemStEthFeePerUnitIndex();</span>
 154 |     | <span class='neutral'></span>
 155 | *   | <span class='executed'>        vars.totalStakesBefore = cdpManager.totalStakes();</span>
 156 | *   | <span class='executed'>        vars.totalStakesSnapshotBefore = cdpManager.totalStakesSnapshot();</span>
 157 | *   | <span class='executed'>        vars.totalCollateralSnapshotBefore = cdpManager.totalCollateralSnapshot();</span>
 158 |     | <span class='neutral'>    }</span>
 159 |     | <span class='neutral'></span>
 160 | *   | <span class='executed'>    function _after(bytes32 _cdpId) internal {</span>
 161 | *   | <span class='executed'>        address ownerToCheck = sortedCdps.getOwnerAddress(_cdpId);</span>
 162 | *   | <span class='executed'>        vars.userSurplusAfter = collSurplusPool.getSurplusCollShares(ownerToCheck);</span>
 163 |     | <span class='neutral'></span>
 164 | *   | <span class='executed'>        vars.priceAfter = priceFeedMock.fetchPrice();</span>
 165 |     | <span class='neutral'></span>
 166 | *   | <span class='executed'>        (, uint256 collAfter) = cdpManager.getSyncedDebtAndCollShares(_cdpId);</span>
 167 |     | <span class='neutral'></span>
 168 | *   | <span class='executed'>        vars.nicrAfter = _cdpId != bytes32(0) ? crLens.quoteRealNICR(_cdpId) : 0;</span>
 169 | *   | <span class='executed'>        vars.icrAfter = _cdpId != bytes32(0) ? cdpManager.getCachedICR(_cdpId, vars.priceAfter) : 0;</span>
 170 | *   | <span class='executed'>        vars.cdpCollAfter = _cdpId != bytes32(0) ? collAfter : 0;</span>
 171 | *   | <span class='executed'>        vars.cdpDebtAfter = _cdpId != bytes32(0) ? cdpManager.getCdpDebt(_cdpId) : 0;</span>
 172 | *r  | <span class='executed'>        vars.cdpStakeAfter = _cdpId != bytes32(0) ? crLens.getRealStake(_cdpId) : 0;</span>
 173 | *   | <span class='executed'>        vars.liquidatorRewardSharesAfter = _cdpId != bytes32(0)</span>
 174 | *   | <span class='executed'>            ? cdpManager.getCdpLiquidatorRewardShares(_cdpId)</span>
 175 | *   | <span class='executed'>            : 0;</span>
 176 | *   | <span class='executed'>        vars.cdpStatusAfter = _cdpId != bytes32(0) ? cdpManager.getCdpStatus(_cdpId) : 0;</span>
 177 |     | <span class='neutral'></span>
 178 | *   | <span class='executed'>        vars.isRecoveryModeAfter = cdpManager.checkRecoveryMode(vars.priceAfter); /// @audit This is fine as is because after the system is synched</span>
 179 | *   | <span class='executed'>        (vars.feeSplitAfter, , ) = collateral.getPooledEthByShares(cdpManager.DECIMAL_PRECISION()) &gt;</span>
 180 | *   | <span class='executed'>            cdpManager.stEthIndex()</span>
 181 | *   | <span class='executed'>            ? cdpManager.calcFeeUponStakingReward(</span>
 182 |     | <span class='unexecuted'>                collateral.getPooledEthByShares(cdpManager.DECIMAL_PRECISION()),</span>
 183 |     | <span class='unexecuted'>                cdpManager.stEthIndex()</span>
 184 |     | <span class='neutral'>            )</span>
 185 | *   | <span class='executed'>            : (0, 0, 0);</span>
 186 |     | <span class='neutral'></span>
 187 | *   | <span class='executed'>        vars.feeRecipientTotalCollAfter = collateral.balanceOf(activePool.feeRecipientAddress());</span>
 188 | *   | <span class='executed'>        vars.feeRecipientCollSharesAfter = activePool.getFeeRecipientClaimableCollShares();</span>
 189 | *   | <span class='executed'>        vars.feeRecipientCollSharesBalAfter = collateral.sharesOf(activePool.feeRecipientAddress());</span>
 190 | *   | <span class='executed'>        vars.actorCollAfter = collateral.balanceOf(address(actor));</span>
 191 | *   | <span class='executed'>        vars.actorEbtcAfter = eBTCToken.balanceOf(address(actor));</span>
 192 | *   | <span class='executed'>        vars.actorCdpCountAfter = sortedCdps.cdpCountOf(address(actor));</span>
 193 | *   | <span class='executed'>        vars.sortedCdpsSizeAfter = sortedCdps.getSize();</span>
 194 | *   | <span class='executed'>        vars.tcrAfter = cdpManager.getCachedTCR(vars.priceAfter);</span>
 195 | *   | <span class='executed'>        vars.ebtcTotalSupplyAfter = eBTCToken.totalSupply();</span>
 196 | *   | <span class='executed'>        vars.ethPerShareAfter = collateral.getPooledEthByShares(1e18);</span>
 197 | *   | <span class='executed'>        vars.activePoolDebtAfter = activePool.getSystemDebt();</span>
 198 | *   | <span class='executed'>        vars.activePoolCollAfter = activePool.getSystemCollShares();</span>
 199 | *   | <span class='executed'>        vars.collSurplusPoolAfter = collSurplusPool.getTotalSurplusCollShares();</span>
 200 | *   | <span class='executed'>        vars.lastGracePeriodStartTimestampAfter = cdpManager.lastGracePeriodStartTimestamp();</span>
 201 | *   | <span class='executed'>        vars.lastGracePeriodStartTimestampIsSetAfter =</span>
 202 | *   | <span class='executed'>            cdpManager.lastGracePeriodStartTimestamp() != cdpManager.UNSET_TIMESTAMP();</span>
 203 | *   | <span class='executed'>        vars.hasGracePeriodPassedAfter =</span>
 204 | *   | <span class='executed'>            cdpManager.lastGracePeriodStartTimestamp() != cdpManager.UNSET_TIMESTAMP() &amp;&amp;</span>
 205 | *   | <span class='executed'>            block.timestamp &gt;</span>
 206 | *   | <span class='executed'>            cdpManager.lastGracePeriodStartTimestamp() +</span>
 207 | *   | <span class='executed'>                cdpManager.recoveryModeGracePeriodDuration();</span>
 208 | *   | <span class='executed'>        vars.systemDebtRedistributionIndexAfter = cdpManager.systemDebtRedistributionIndex();</span>
 209 |     | <span class='neutral'></span>
 210 | *   | <span class='executed'>        vars.newTcrAfter = crLens.quoteRealTCR();</span>
 211 | *   | <span class='executed'>        vars.newIcrAfter = _cdpId != bytes32(0) ? crLens.quoteRealICR(_cdpId) : 0;</span>
 212 |     | <span class='neutral'></span>
 213 |     | <span class='neutral'>        // Value in system after</span>
 214 | *   | <span class='executed'>        vars.valueInSystemAfter =</span>
 215 | *   | <span class='executed'>            (collateral.getPooledEthByShares(</span>
 216 | *   | <span class='executed'>                vars.activePoolCollAfter +</span>
 217 | *   | <span class='executed'>                    vars.collSurplusPoolAfter +</span>
 218 | *   | <span class='executed'>                    vars.feeRecipientTotalCollAfter</span>
 219 | *   | <span class='executed'>            ) * vars.priceAfter) /</span>
 220 | *   | <span class='executed'>            1e18 -</span>
 221 | *   | <span class='executed'>            vars.activePoolDebtAfter;</span>
 222 | *   | <span class='executed'>        vars.afterStEthFeeIndex = cdpManager.systemStEthFeePerUnitIndex();</span>
 223 |     | <span class='neutral'></span>
 224 | *   | <span class='executed'>        if (vars.afterStEthFeeIndex &gt; vars.prevStEthFeeIndex) {</span>
 225 | *   | <span class='executed'>            vars.cumulativeCdpsAtTimeOfRebase += cdpManager.getActiveCdpsCount();</span>
 226 |     | <span class='neutral'>        }</span>
 227 |     | <span class='neutral'></span>
 228 | *   | <span class='executed'>        vars.totalStakesAfter = cdpManager.totalStakes();</span>
 229 | *   | <span class='executed'>        vars.totalStakesSnapshotAfter = cdpManager.totalStakesSnapshot();</span>
 230 | *   | <span class='executed'>        vars.totalCollateralSnapshotAfter = cdpManager.totalCollateralSnapshot();</span>
 231 |     | <span class='neutral'>    }</span>
 232 |     | <span class='neutral'></span>
 233 |     | <span class='neutral'>    function _diff() internal view returns (string memory log) {</span>
 234 |     | <span class='neutral'>        log = string(&quot;\n\t\t\t\tBefore\t\t\tAfter\n&quot;);</span>
 235 |     | <span class='neutral'>        if (vars.activePoolCollBefore != vars.activePoolCollAfter) {</span>
 236 |     | <span class='neutral'>            log = log</span>
 237 |     | <span class='neutral'>                .concat(&quot;activePoolColl\t\t\t&quot;)</span>
 238 |     | <span class='neutral'>                .concat(vars.activePoolCollBefore.pretty())</span>
 239 |     | <span class='neutral'>                .concat(&quot;\t&quot;)</span>
 240 |     | <span class='neutral'>                .concat(vars.activePoolCollAfter.pretty())</span>
 241 |     | <span class='neutral'>                .concat(&quot;\n&quot;);</span>
 242 |     | <span class='neutral'>        }</span>
 243 |     | <span class='neutral'>        if (vars.collSurplusPoolBefore != vars.collSurplusPoolAfter) {</span>
 244 |     | <span class='neutral'>            log = log</span>
 245 |     | <span class='neutral'>                .concat(&quot;collSurplusPool\t\t\t&quot;)</span>
 246 |     | <span class='neutral'>                .concat(vars.collSurplusPoolBefore.pretty())</span>
 247 |     | <span class='neutral'>                .concat(&quot;\t&quot;)</span>
 248 |     | <span class='neutral'>                .concat(vars.collSurplusPoolAfter.pretty())</span>
 249 |     | <span class='neutral'>                .concat(&quot;\n&quot;);</span>
 250 |     | <span class='neutral'>        }</span>
 251 |     | <span class='neutral'>        if (vars.nicrBefore != vars.nicrAfter) {</span>
 252 |     | <span class='neutral'>            log = log</span>
 253 |     | <span class='neutral'>                .concat(&quot;nicr\t\t\t\t&quot;)</span>
 254 |     | <span class='neutral'>                .concat(vars.nicrBefore.pretty())</span>
 255 |     | <span class='neutral'>                .concat(&quot;\t&quot;)</span>
 256 |     | <span class='neutral'>                .concat(vars.nicrAfter.pretty())</span>
 257 |     | <span class='neutral'>                .concat(&quot;\n&quot;);</span>
 258 |     | <span class='neutral'>        }</span>
 259 |     | <span class='neutral'>        if (vars.icrBefore != vars.icrAfter) {</span>
 260 |     | <span class='neutral'>            log = log</span>
 261 |     | <span class='neutral'>                .concat(&quot;icr\t\t\t\t&quot;)</span>
 262 |     | <span class='neutral'>                .concat(vars.icrBefore.pretty())</span>
 263 |     | <span class='neutral'>                .concat(&quot;\t&quot;)</span>
 264 |     | <span class='neutral'>                .concat(vars.icrAfter.pretty())</span>
 265 |     | <span class='neutral'>                .concat(&quot;\n&quot;);</span>
 266 |     | <span class='neutral'>        }</span>
 267 |     | <span class='neutral'>        if (vars.newIcrBefore != vars.newIcrAfter) {</span>
 268 |     | <span class='neutral'>            log = log</span>
 269 |     | <span class='neutral'>                .concat(&quot;newIcr\t\t\t\t&quot;)</span>
 270 |     | <span class='neutral'>                .concat(vars.newIcrBefore.pretty())</span>
 271 |     | <span class='neutral'>                .concat(&quot;\t&quot;)</span>
 272 |     | <span class='neutral'>                .concat(vars.newIcrAfter.pretty())</span>
 273 |     | <span class='neutral'>                .concat(&quot;\n&quot;);</span>
 274 |     | <span class='neutral'>        }</span>
 275 |     | <span class='neutral'>        if (vars.feeSplitBefore != vars.feeSplitAfter) {</span>
 276 |     | <span class='neutral'>            log = log</span>
 277 |     | <span class='neutral'>                .concat(&quot;feeSplit\t\t\t\t&quot;)</span>
 278 |     | <span class='neutral'>                .concat(vars.feeSplitBefore.pretty())</span>
 279 |     | <span class='neutral'>                .concat(&quot;\t&quot;)</span>
 280 |     | <span class='neutral'>                .concat(vars.feeSplitAfter.pretty())</span>
 281 |     | <span class='neutral'>                .concat(&quot;\n&quot;);</span>
 282 |     | <span class='neutral'>        }</span>
 283 |     | <span class='neutral'>        if (vars.feeRecipientTotalCollBefore != vars.feeRecipientTotalCollAfter) {</span>
 284 |     | <span class='neutral'>            log = log</span>
 285 |     | <span class='neutral'>                .concat(&quot;feeRecipientTotalColl\t&quot;)</span>
 286 |     | <span class='neutral'>                .concat(vars.feeRecipientTotalCollBefore.pretty())</span>
 287 |     | <span class='neutral'>                .concat(&quot;\t&quot;)</span>
 288 |     | <span class='neutral'>                .concat(vars.feeRecipientTotalCollAfter.pretty())</span>
 289 |     | <span class='neutral'>                .concat(&quot;\n&quot;);</span>
 290 |     | <span class='neutral'>        }</span>
 291 |     | <span class='neutral'>        if (vars.actorCollBefore != vars.actorCollAfter) {</span>
 292 |     | <span class='neutral'>            log = log</span>
 293 |     | <span class='neutral'>                .concat(&quot;actorColl\t\t\t\t&quot;)</span>
 294 |     | <span class='neutral'>                .concat(vars.actorCollBefore.pretty())</span>
 295 |     | <span class='neutral'>                .concat(&quot;\t&quot;)</span>
 296 |     | <span class='neutral'>                .concat(vars.actorCollAfter.pretty())</span>
 297 |     | <span class='neutral'>                .concat(&quot;\n&quot;);</span>
 298 |     | <span class='neutral'>        }</span>
 299 |     | <span class='neutral'>        if (vars.actorEbtcBefore != vars.actorEbtcAfter) {</span>
 300 |     | <span class='neutral'>            log = log</span>
 301 |     | <span class='neutral'>                .concat(&quot;actorEbtc\t\t\t\t&quot;)</span>
 302 |     | <span class='neutral'>                .concat(vars.actorEbtcBefore.pretty())</span>
 303 |     | <span class='neutral'>                .concat(&quot;\t&quot;)</span>
 304 |     | <span class='neutral'>                .concat(vars.actorEbtcAfter.pretty())</span>
 305 |     | <span class='neutral'>                .concat(&quot;\n&quot;);</span>
 306 |     | <span class='neutral'>        }</span>
 307 |     | <span class='neutral'>        if (vars.actorCdpCountBefore != vars.actorCdpCountAfter) {</span>
 308 |     | <span class='neutral'>            log = log</span>
 309 |     | <span class='neutral'>                .concat(&quot;actorCdpCount\t\t\t&quot;)</span>
 310 |     | <span class='neutral'>                .concat(vars.actorCdpCountBefore.pretty())</span>
 311 |     | <span class='neutral'>                .concat(&quot;\t&quot;)</span>
 312 |     | <span class='neutral'>                .concat(vars.actorCdpCountAfter.pretty())</span>
 313 |     | <span class='neutral'>                .concat(&quot;\n&quot;);</span>
 314 |     | <span class='neutral'>        }</span>
 315 |     | <span class='neutral'>        if (vars.cdpCollBefore != vars.cdpCollAfter) {</span>
 316 |     | <span class='neutral'>            log = log</span>
 317 |     | <span class='neutral'>                .concat(&quot;cdpColl\t\t\t\t&quot;)</span>
 318 |     | <span class='neutral'>                .concat(vars.cdpCollBefore.pretty())</span>
 319 |     | <span class='neutral'>                .concat(&quot;\t&quot;)</span>
 320 |     | <span class='neutral'>                .concat(vars.cdpCollAfter.pretty())</span>
 321 |     | <span class='neutral'>                .concat(&quot;\n&quot;);</span>
 322 |     | <span class='neutral'>        }</span>
 323 |     | <span class='neutral'>        if (vars.cdpDebtBefore != vars.cdpDebtAfter) {</span>
 324 |     | <span class='neutral'>            log = log</span>
 325 |     | <span class='neutral'>                .concat(&quot;cdpDebt\t\t\t\t&quot;)</span>
 326 |     | <span class='neutral'>                .concat(vars.cdpDebtBefore.pretty())</span>
 327 |     | <span class='neutral'>                .concat(&quot;\t&quot;)</span>
 328 |     | <span class='neutral'>                .concat(vars.cdpDebtAfter.pretty())</span>
 329 |     | <span class='neutral'>                .concat(&quot;\n&quot;);</span>
 330 |     | <span class='neutral'>        }</span>
 331 |     | <span class='neutral'>        if (vars.liquidatorRewardSharesBefore != vars.liquidatorRewardSharesAfter) {</span>
 332 |     | <span class='neutral'>            log = log</span>
 333 |     | <span class='neutral'>                .concat(&quot;liquidatorRewardShares\t\t&quot;)</span>
 334 |     | <span class='neutral'>                .concat(vars.liquidatorRewardSharesBefore.pretty())</span>
 335 |     | <span class='neutral'>                .concat(&quot;\t&quot;)</span>
 336 |     | <span class='neutral'>                .concat(vars.liquidatorRewardSharesAfter.pretty())</span>
 337 |     | <span class='neutral'>                .concat(&quot;\n&quot;);</span>
 338 |     | <span class='neutral'>        }</span>
 339 |     | <span class='neutral'>        if (vars.sortedCdpsSizeBefore != vars.sortedCdpsSizeAfter) {</span>
 340 |     | <span class='neutral'>            log = log</span>
 341 |     | <span class='neutral'>                .concat(&quot;sortedCdpsSize\t\t\t&quot;)</span>
 342 |     | <span class='neutral'>                .concat(vars.sortedCdpsSizeBefore.pretty(0))</span>
 343 |     | <span class='neutral'>                .concat(&quot;\t\t\t&quot;)</span>
 344 |     | <span class='neutral'>                .concat(vars.sortedCdpsSizeAfter.pretty(0))</span>
 345 |     | <span class='neutral'>                .concat(&quot;\n&quot;);</span>
 346 |     | <span class='neutral'>        }</span>
 347 |     | <span class='neutral'>        if (vars.cdpStatusBefore != vars.cdpStatusAfter) {</span>
 348 |     | <span class='neutral'>            log = log</span>
 349 |     | <span class='neutral'>                .concat(&quot;cdpStatus\t\t\t&quot;)</span>
 350 |     | <span class='neutral'>                .concat(vars.cdpStatusBefore.pretty(0))</span>
 351 |     | <span class='neutral'>                .concat(&quot;\t\t\t&quot;)</span>
 352 |     | <span class='neutral'>                .concat(vars.cdpStatusAfter.pretty(0))</span>
 353 |     | <span class='neutral'>                .concat(&quot;\n&quot;);</span>
 354 |     | <span class='neutral'>        }</span>
 355 |     | <span class='neutral'>        if (vars.tcrBefore != vars.tcrAfter) {</span>
 356 |     | <span class='neutral'>            log = log</span>
 357 |     | <span class='neutral'>                .concat(&quot;tcr\t\t\t\t&quot;)</span>
 358 |     | <span class='neutral'>                .concat(vars.tcrBefore.pretty())</span>
 359 |     | <span class='neutral'>                .concat(&quot;\t&quot;)</span>
 360 |     | <span class='neutral'>                .concat(vars.tcrAfter.pretty())</span>
 361 |     | <span class='neutral'>                .concat(&quot;\n&quot;);</span>
 362 |     | <span class='neutral'>        }</span>
 363 |     | <span class='neutral'>        if (vars.newTcrBefore != vars.newTcrAfter) {</span>
 364 |     | <span class='neutral'>            log = log</span>
 365 |     | <span class='neutral'>                .concat(&quot;newTcr\t\t\t\t&quot;)</span>
 366 |     | <span class='neutral'>                .concat(vars.newTcrBefore.pretty())</span>
 367 |     | <span class='neutral'>                .concat(&quot;\t&quot;)</span>
 368 |     | <span class='neutral'>                .concat(vars.newTcrAfter.pretty())</span>
 369 |     | <span class='neutral'>                .concat(&quot;\n&quot;);</span>
 370 |     | <span class='neutral'>        }</span>
 371 |     | <span class='neutral'>        if (vars.ebtcTotalSupplyBefore != vars.ebtcTotalSupplyAfter) {</span>
 372 |     | <span class='neutral'>            log = log</span>
 373 |     | <span class='neutral'>                .concat(&quot;ebtcTotalSupply\t\t\t&quot;)</span>
 374 |     | <span class='neutral'>                .concat(vars.ebtcTotalSupplyBefore.pretty())</span>
 375 |     | <span class='neutral'>                .concat(&quot;\t&quot;)</span>
 376 |     | <span class='neutral'>                .concat(vars.ebtcTotalSupplyAfter.pretty())</span>
 377 |     | <span class='neutral'>                .concat(&quot;\n&quot;);</span>
 378 |     | <span class='neutral'>        }</span>
 379 |     | <span class='neutral'>        if (vars.ethPerShareBefore != vars.ethPerShareAfter) {</span>
 380 |     | <span class='neutral'>            log = log</span>
 381 |     | <span class='neutral'>                .concat(&quot;ethPerShare\t\t\t&quot;)</span>
 382 |     | <span class='neutral'>                .concat(vars.ethPerShareBefore.pretty())</span>
 383 |     | <span class='neutral'>                .concat(&quot;\t&quot;)</span>
 384 |     | <span class='neutral'>                .concat(vars.ethPerShareAfter.pretty())</span>
 385 |     | <span class='neutral'>                .concat(&quot;\n&quot;);</span>
 386 |     | <span class='neutral'>        }</span>
 387 |     | <span class='neutral'>        if (vars.isRecoveryModeBefore != vars.isRecoveryModeAfter) {</span>
 388 |     | <span class='neutral'>            log = log</span>
 389 |     | <span class='neutral'>                .concat(&quot;isRecoveryMode\t\t\t&quot;)</span>
 390 |     | <span class='neutral'>                .concat(vars.isRecoveryModeBefore.pretty())</span>
 391 |     | <span class='neutral'>                .concat(&quot;\t&quot;)</span>
 392 |     | <span class='neutral'>                .concat(vars.isRecoveryModeAfter.pretty())</span>
 393 |     | <span class='neutral'>                .concat(&quot;\n&quot;);</span>
 394 |     | <span class='neutral'>        }</span>
 395 |     | <span class='neutral'>        if (vars.lastGracePeriodStartTimestampBefore != vars.lastGracePeriodStartTimestampAfter) {</span>
 396 |     | <span class='neutral'>            log = log</span>
 397 |     | <span class='neutral'>                .concat(&quot;lastGracePeriodStartTimestamp\t&quot;)</span>
 398 |     | <span class='neutral'>                .concat(vars.lastGracePeriodStartTimestampBefore.pretty())</span>
 399 |     | <span class='neutral'>                .concat(&quot;\t&quot;)</span>
 400 |     | <span class='neutral'>                .concat(vars.lastGracePeriodStartTimestampAfter.pretty())</span>
 401 |     | <span class='neutral'>                .concat(&quot;\n&quot;);</span>
 402 |     | <span class='neutral'>        }</span>
 403 |     | <span class='neutral'>        if (</span>
 404 |     | <span class='neutral'>            vars.lastGracePeriodStartTimestampIsSetBefore !=</span>
 405 |     | <span class='neutral'>            vars.lastGracePeriodStartTimestampIsSetAfter</span>
 406 |     | <span class='neutral'>        ) {</span>
 407 |     | <span class='neutral'>            log = log</span>
 408 |     | <span class='neutral'>                .concat(&quot;lastGracePeriodStartTimestampIsSet\t&quot;)</span>
 409 |     | <span class='neutral'>                .concat(vars.lastGracePeriodStartTimestampIsSetBefore.pretty())</span>
 410 |     | <span class='neutral'>                .concat(&quot;\t&quot;)</span>
 411 |     | <span class='neutral'>                .concat(vars.lastGracePeriodStartTimestampIsSetAfter.pretty())</span>
 412 |     | <span class='neutral'>                .concat(&quot;\n&quot;);</span>
 413 |     | <span class='neutral'>        }</span>
 414 |     | <span class='neutral'>        if (vars.hasGracePeriodPassedBefore != vars.hasGracePeriodPassedAfter) {</span>
 415 |     | <span class='neutral'>            log = log</span>
 416 |     | <span class='neutral'>                .concat(&quot;hasGracePeriodPassed\t\t&quot;)</span>
 417 |     | <span class='neutral'>                .concat(vars.hasGracePeriodPassedBefore.pretty())</span>
 418 |     | <span class='neutral'>                .concat(&quot;\t\t\t&quot;)</span>
 419 |     | <span class='neutral'>                .concat(vars.hasGracePeriodPassedAfter.pretty())</span>
 420 |     | <span class='neutral'>                .concat(&quot;\n&quot;);</span>
 421 |     | <span class='neutral'>        }</span>
 422 |     | <span class='neutral'>        if (vars.systemDebtRedistributionIndexBefore != vars.systemDebtRedistributionIndexAfter) {</span>
 423 |     | <span class='neutral'>            log = log</span>
 424 |     | <span class='neutral'>                .concat(&quot;systemDebtRedistributionIndex\t\t&quot;)</span>
 425 |     | <span class='neutral'>                .concat(vars.systemDebtRedistributionIndexBefore.pretty())</span>
 426 |     | <span class='neutral'>                .concat(&quot;\t&quot;)</span>
 427 |     | <span class='neutral'>                .concat(vars.systemDebtRedistributionIndexAfter.pretty())</span>
 428 |     | <span class='neutral'>                .concat(&quot;\n&quot;);</span>
 429 |     | <span class='neutral'>        }</span>
 430 |     | <span class='neutral'>    }</span>
 431 |     | <span class='neutral'>}</span>
 432 |     | <span class='neutral'></span>

</code>
<br />

<b>/mnt/c/Users/Lourens/Documents/Recon-Fuzz/collabs/ebtc/packages/contracts/contracts/TestContracts/invariants/Properties.sol</b>
<code>
   1 |     | <span class='neutral'>pragma solidity 0.8.17;</span>
   2 |     | <span class='neutral'></span>
   3 |     | <span class='neutral'>import &quot;@crytic/properties/contracts/util/PropertiesConstants.sol&quot;;</span>
   4 |     | <span class='neutral'></span>
   5 |     | <span class='neutral'>import {ICollateralToken} from &quot;../../Dependencies/ICollateralToken.sol&quot;;</span>
   6 |     | <span class='neutral'>import {EbtcMath} from &quot;../../Dependencies/EbtcMath.sol&quot;;</span>
   7 |     | <span class='neutral'>import {ActivePool} from &quot;../../ActivePool.sol&quot;;</span>
   8 |     | <span class='neutral'>import {EBTCToken} from &quot;../../EBTCToken.sol&quot;;</span>
   9 |     | <span class='neutral'>import {BorrowerOperations} from &quot;../../BorrowerOperations.sol&quot;;</span>
  10 |     | <span class='neutral'>import {CdpManager} from &quot;../../CdpManager.sol&quot;;</span>
  11 |     | <span class='neutral'>import {SortedCdps} from &quot;../../SortedCdps.sol&quot;;</span>
  12 |     | <span class='neutral'>import {Asserts} from &quot;./Asserts.sol&quot;;</span>
  13 |     | <span class='neutral'>import {CollSurplusPool} from &quot;../../CollSurplusPool.sol&quot;;</span>
  14 |     | <span class='neutral'>import {PriceFeedTestnet} from &quot;../testnet/PriceFeedTestnet.sol&quot;;</span>
  15 |     | <span class='neutral'>import {ICdpManagerData} from &quot;../../Interfaces/ICdpManagerData.sol&quot;;</span>
  16 |     | <span class='neutral'>import {BeforeAfter} from &quot;./BeforeAfter.sol&quot;;</span>
  17 |     | <span class='neutral'>import {PropertiesDescriptions} from &quot;./PropertiesDescriptions.sol&quot;;</span>
  18 |     | <span class='neutral'>import {CRLens} from &quot;../CRLens.sol&quot;;</span>
  19 |     | <span class='neutral'>import {LiquidationSequencer} from &quot;../../LiquidationSequencer.sol&quot;;</span>
  20 |     | <span class='neutral'>import {SyncedLiquidationSequencer} from &quot;../../SyncedLiquidationSequencer.sol&quot;;</span>
  21 |     | <span class='neutral'></span>
  22 |     | <span class='neutral'>abstract contract Properties is BeforeAfter, PropertiesDescriptions, Asserts, PropertiesConstants {</span>
  23 |     | <span class='unexecuted'>    function invariant_AP_01(</span>
  24 |     | <span class='neutral'>        ICollateralToken collateral,</span>
  25 |     | <span class='neutral'>        ActivePool activePool</span>
  26 |     | <span class='unexecuted'>    ) internal view returns (bool) {</span>
  27 |     | <span class='unexecuted'>        return (collateral.sharesOf(address(activePool)) &gt;= activePool.getSystemCollShares());</span>
  28 |     | <span class='neutral'>    }</span>
  29 |     | <span class='neutral'></span>
  30 |     | <span class='unexecuted'>    function invariant_AP_02(</span>
  31 |     | <span class='neutral'>        CdpManager cdpManager,</span>
  32 |     | <span class='neutral'>        ActivePool activePool</span>
  33 |     | <span class='unexecuted'>    ) internal view returns (bool) {</span>
  34 |     | <span class='unexecuted'>        return cdpManager.getActiveCdpsCount() &gt; 0 ? activePool.getSystemCollShares() &gt; 0 : true;</span>
  35 |     | <span class='neutral'>    }</span>
  36 |     | <span class='neutral'></span>
  37 |     | <span class='unexecuted'>    function invariant_AP_03(</span>
  38 |     | <span class='neutral'>        EBTCToken eBTCToken,</span>
  39 |     | <span class='neutral'>        ActivePool activePool</span>
  40 |     | <span class='unexecuted'>    ) internal view returns (bool) {</span>
  41 |     | <span class='unexecuted'>        return (eBTCToken.totalSupply() == activePool.getSystemDebt());</span>
  42 |     | <span class='neutral'>    }</span>
  43 |     | <span class='neutral'></span>
  44 |     | <span class='unexecuted'>    function invariant_AP_04(</span>
  45 |     | <span class='neutral'>        CdpManager cdpManager,</span>
  46 |     | <span class='neutral'>        ActivePool activePool,</span>
  47 |     | <span class='neutral'>        uint256 diff_tolerance</span>
  48 |     | <span class='unexecuted'>    ) internal view returns (bool) {</span>
  49 |     | <span class='unexecuted'>        uint256 _cdpCount = cdpManager.getActiveCdpsCount();</span>
  50 |     | <span class='unexecuted'>        bytes32[] memory cdpIds = hintHelpers.sortedCdpsToArray();</span>
  51 |     | <span class='unexecuted'>        uint256 _sum;</span>
  52 |     | <span class='neutral'></span>
  53 |     | <span class='unexecuted'>        for (uint256 i = 0; i &lt; _cdpCount; ++i) {</span>
  54 |     | <span class='unexecuted'>            (, uint256 _coll) = cdpManager.getSyncedDebtAndCollShares(cdpIds[i]);</span>
  55 |     | <span class='unexecuted'>            _sum += _coll;</span>
  56 |     | <span class='neutral'>        }</span>
  57 |     | <span class='unexecuted'>        uint256 _activeColl = activePool.getSystemCollShares();</span>
  58 |     | <span class='unexecuted'>        uint256 _diff = _sum &gt; _activeColl ? (_sum - _activeColl) : (_activeColl - _sum);</span>
  59 |     | <span class='unexecuted'>        return (_diff * 1e18 &lt;= diff_tolerance * _activeColl);</span>
  60 |     | <span class='neutral'>    }</span>
  61 |     | <span class='neutral'></span>
  62 | *   | <span class='executed'>    function invariant_AP_05(</span>
  63 |     | <span class='neutral'>        CdpManager cdpManager,</span>
  64 |     | <span class='neutral'>        uint256 diff_tolerance</span>
  65 |     | <span class='unexecuted'>    ) internal view returns (bool) {</span>
  66 |     | <span class='unexecuted'>        uint256 _cdpCount = cdpManager.getActiveCdpsCount();</span>
  67 |     | <span class='unexecuted'>        bytes32[] memory cdpIds = hintHelpers.sortedCdpsToArray();</span>
  68 |     | <span class='unexecuted'>        uint256 _sum;</span>
  69 |     | <span class='neutral'></span>
  70 |     | <span class='unexecuted'>        for (uint256 i = 0; i &lt; _cdpCount; ++i) {</span>
  71 |     | <span class='unexecuted'>            (uint256 _debt, ) = cdpManager.getSyncedDebtAndCollShares(cdpIds[i]);</span>
  72 |     | <span class='unexecuted'>            _sum += _debt;</span>
  73 |     | <span class='neutral'>        }</span>
  74 |     | <span class='neutral'></span>
  75 |     | <span class='unexecuted'>        bool oldCheck = isApproximateEq(_sum, cdpManager.getSystemDebt(), diff_tolerance);</span>
  76 |     | <span class='neutral'>        // New check ensures this is above 1000 wei</span>
  77 |     | <span class='unexecuted'>        bool newCheck = cdpManager.getSystemDebt() - _sum &gt; 1_000;</span>
  78 |     | <span class='neutral'>        // @audit We have an instance of getting above 1e18 in rounding error, see `testBrokenInvariantFive`</span>
  79 | *   | <span class='executed'>        return oldCheck || !newCheck;</span>
  80 |     | <span class='neutral'>    }</span>
  81 |     | <span class='neutral'></span>
  82 |     | <span class='unexecuted'>    function invariant_CDPM_01(</span>
  83 |     | <span class='neutral'>        CdpManager cdpManager,</span>
  84 |     | <span class='neutral'>        SortedCdps sortedCdps</span>
  85 |     | <span class='unexecuted'>    ) internal view returns (bool) {</span>
  86 |     | <span class='unexecuted'>        return (cdpManager.getActiveCdpsCount() == sortedCdps.getSize());</span>
  87 |     | <span class='neutral'>    }</span>
  88 |     | <span class='neutral'></span>
  89 |     | <span class='unexecuted'>    function invariant_CDPM_02(CdpManager cdpManager) internal view returns (bool) {</span>
  90 |     | <span class='unexecuted'>        uint256 _cdpCount = cdpManager.getActiveCdpsCount();</span>
  91 |     | <span class='unexecuted'>        bytes32[] memory cdpIds = hintHelpers.sortedCdpsToArray();</span>
  92 |     | <span class='neutral'></span>
  93 |     | <span class='unexecuted'>        uint256 _sum;</span>
  94 |     | <span class='neutral'></span>
  95 |     | <span class='unexecuted'>        for (uint256 i = 0; i &lt; _cdpCount; ++i) {</span>
  96 |     | <span class='unexecuted'>            _sum += cdpManager.getCdpStake(cdpIds[i]);</span>
  97 |     | <span class='neutral'>        }</span>
  98 |     | <span class='unexecuted'>        return (_sum == cdpManager.totalStakes());</span>
  99 |     | <span class='neutral'>    }</span>
 100 |     | <span class='neutral'></span>
 101 |     | <span class='unexecuted'>    function invariant_CDPM_03(CdpManager cdpManager) internal view returns (bool) {</span>
 102 |     | <span class='unexecuted'>        uint256 _cdpCount = cdpManager.getActiveCdpsCount();</span>
 103 |     | <span class='unexecuted'>        bytes32[] memory cdpIds = hintHelpers.sortedCdpsToArray();</span>
 104 |     | <span class='unexecuted'>        uint256 systemStEthFeePerUnitIndex = cdpManager.systemStEthFeePerUnitIndex();</span>
 105 |     | <span class='unexecuted'>        for (uint256 i = 0; i &lt; _cdpCount; ++i) {</span>
 106 |     | <span class='unexecuted'>            if (systemStEthFeePerUnitIndex &lt; cdpManager.cdpStEthFeePerUnitIndex(cdpIds[i])) {</span>
 107 |     | <span class='unexecuted'>                return false;</span>
 108 |     | <span class='neutral'>            }</span>
 109 |     | <span class='neutral'>        }</span>
 110 |     | <span class='unexecuted'>        return true;</span>
 111 |     | <span class='neutral'>    }</span>
 112 |     | <span class='neutral'></span>
 113 |     | <span class='neutral'>    /** TODO: See EchidnaToFoundry._getValue */</span>
 114 |     | <span class='unexecuted'>    function invariant_CDPM_04(Vars memory vars) internal view returns (bool) {</span>
 115 |     | <span class='neutral'>        return</span>
 116 |     | <span class='unexecuted'>            vars.valueInSystemAfter &gt;= vars.valueInSystemBefore ||</span>
 117 |     | <span class='unexecuted'>            isApproximateEq(vars.valueInSystemAfter, vars.valueInSystemBefore, 0.01e18);</span>
 118 |     | <span class='neutral'>    }</span>
 119 |     | <span class='neutral'></span>
 120 |     | <span class='unexecuted'>    function invariant_CDPM_10(CdpManager cdpManager) internal view returns (bool) {</span>
 121 |     | <span class='unexecuted'>        if (vars.afterStEthFeeIndex &gt; vars.prevStEthFeeIndex) {</span>
 122 |     | <span class='unexecuted'>            return cdpManager.totalStakesSnapshot() == cdpManager.totalStakes();</span>
 123 |     | <span class='neutral'>        }</span>
 124 |     | <span class='unexecuted'>        return true;</span>
 125 |     | <span class='neutral'>    }</span>
 126 |     | <span class='neutral'></span>
 127 |     | <span class='unexecuted'>    function invariant_CDPM_11(CdpManager cdpManager) internal view returns (bool) {</span>
 128 |     | <span class='unexecuted'>        if (vars.afterStEthFeeIndex &gt; vars.prevStEthFeeIndex) {</span>
 129 |     | <span class='unexecuted'>            return cdpManager.totalCollateralSnapshot() == cdpManager.getSystemCollShares();</span>
 130 |     | <span class='neutral'>        }</span>
 131 |     | <span class='neutral'>        return true;</span>
 132 |     | <span class='neutral'>    }</span>
 133 |     | <span class='neutral'></span>
 134 |     | <span class='unexecuted'>    function invariant_CDPM_12(</span>
 135 |     | <span class='neutral'>        SortedCdps sortedCdps,</span>
 136 |     | <span class='neutral'>        Vars memory vars</span>
 137 |     | <span class='unexecuted'>    ) internal view returns (bool) {</span>
 138 |     | <span class='unexecuted'>        bytes32 currentCdp = sortedCdps.getFirst();</span>
 139 |     | <span class='neutral'></span>
 140 |     | <span class='unexecuted'>        uint256 sumStakes;</span>
 141 |     | <span class='unexecuted'>        while (currentCdp != bytes32(0)) {</span>
 142 |     | <span class='unexecuted'>            sumStakes += cdpManager.getCdpStake(currentCdp);</span>
 143 |     | <span class='unexecuted'>            currentCdp = sortedCdps.getNext(currentCdp);</span>
 144 |     | <span class='neutral'>        }</span>
 145 |     | <span class='neutral'></span>
 146 |     | <span class='unexecuted'>        return sumStakes == cdpManager.totalStakes();</span>
 147 |     | <span class='neutral'>    }</span>
 148 |     | <span class='neutral'></span>
 149 |     | <span class='unexecuted'>    function invariant_CSP_01(</span>
 150 |     | <span class='neutral'>        ICollateralToken collateral,</span>
 151 |     | <span class='neutral'>        CollSurplusPool collSurplusPool</span>
 152 |     | <span class='unexecuted'>    ) internal view returns (bool) {</span>
 153 |     | <span class='neutral'>        return</span>
 154 |     | <span class='neutral'>            collateral.sharesOf(address(collSurplusPool)) &gt;=</span>
 155 |     | <span class='unexecuted'>            collSurplusPool.getTotalSurplusCollShares();</span>
 156 |     | <span class='neutral'>    }</span>
 157 |     | <span class='neutral'></span>
 158 |     | <span class='unexecuted'>    function invariant_CSP_02(CollSurplusPool collSurplusPool) internal view returns (bool) {</span>
 159 |     | <span class='neutral'>        uint256 sum;</span>
 160 |     | <span class='neutral'></span>
 161 |     | <span class='neutral'>        // NOTE: See PropertiesConstants</span>
 162 |     | <span class='neutral'>        // We only have 3 actors so just set these up</span>
 163 |     | <span class='unexecuted'>        sum += collSurplusPool.getSurplusCollShares(address(actors[USER1]));</span>
 164 |     | <span class='unexecuted'>        sum += collSurplusPool.getSurplusCollShares(address(actors[USER2]));</span>
 165 |     | <span class='unexecuted'>        sum += collSurplusPool.getSurplusCollShares(address(actors[USER3]));</span>
 166 |     | <span class='neutral'></span>
 167 |     | <span class='unexecuted'>        return sum == collSurplusPool.getTotalSurplusCollShares();</span>
 168 |     | <span class='neutral'>    }</span>
 169 |     | <span class='neutral'></span>
 170 |     | <span class='unexecuted'>    function invariant_SL_01(CdpManager cdpManager, SortedCdps sortedCdps) internal returns (bool) {</span>
 171 |     | <span class='unexecuted'>        bytes32 currentCdp = sortedCdps.getFirst();</span>
 172 |     | <span class='unexecuted'>        bytes32 nextCdp = sortedCdps.getNext(currentCdp);</span>
 173 |     | <span class='neutral'></span>
 174 |     | <span class='unexecuted'>        while (currentCdp != bytes32(0) &amp;&amp; nextCdp != bytes32(0) &amp;&amp; currentCdp != nextCdp) {</span>
 175 |     | <span class='neutral'>            // TODO remove tolerance once proper fix has been applied</span>
 176 |     | <span class='unexecuted'>            uint256 nicrNext = cdpManager.getCachedNominalICR(nextCdp);</span>
 177 |     | <span class='unexecuted'>            uint256 nicrCurrent = cdpManager.getCachedNominalICR(currentCdp);</span>
 178 |     | <span class='unexecuted'>            emit L2(nicrNext, nicrCurrent);</span>
 179 |     | <span class='unexecuted'>            if (nicrNext &gt; nicrCurrent &amp;&amp; diffPercent(nicrNext, nicrCurrent) &gt; 0.01e18) {</span>
 180 |     | <span class='unexecuted'>                return false;</span>
 181 |     | <span class='neutral'>            }</span>
 182 |     | <span class='neutral'></span>
 183 |     | <span class='unexecuted'>            currentCdp = nextCdp;</span>
 184 |     | <span class='unexecuted'>            nextCdp = sortedCdps.getNext(currentCdp);</span>
 185 |     | <span class='neutral'>        }</span>
 186 |     | <span class='neutral'></span>
 187 |     | <span class='neutral'>        return true;</span>
 188 |     | <span class='neutral'>    }</span>
 189 |     | <span class='neutral'></span>
 190 |     | <span class='unexecuted'>    function invariant_SL_02(</span>
 191 |     | <span class='neutral'>        CdpManager cdpManager,</span>
 192 |     | <span class='neutral'>        SortedCdps sortedCdps,</span>
 193 |     | <span class='neutral'>        PriceFeedTestnet priceFeedMock</span>
 194 |     | <span class='unexecuted'>    ) internal returns (bool) {</span>
 195 |     | <span class='unexecuted'>        bytes32 _first = sortedCdps.getFirst();</span>
 196 |     | <span class='unexecuted'>        uint256 _price = priceFeedMock.fetchPrice();</span>
 197 |     | <span class='unexecuted'>        uint256 _firstICR = cdpManager.getCachedICR(_first, _price);</span>
 198 |     | <span class='unexecuted'>        uint256 _TCR = cdpManager.getCachedTCR(_price);</span>
 199 |     | <span class='neutral'></span>
 200 |     | <span class='unexecuted'>        if (</span>
 201 |     | <span class='unexecuted'>            _first != sortedCdps.dummyId() &amp;&amp;</span>
 202 |     | <span class='unexecuted'>            _firstICR &lt; _TCR &amp;&amp;</span>
 203 |     | <span class='unexecuted'>            diffPercent(_firstICR, _TCR) &gt; 0.01e18</span>
 204 |     | <span class='neutral'>        ) {</span>
 205 |     | <span class='unexecuted'>            return false;</span>
 206 |     | <span class='neutral'>        }</span>
 207 |     | <span class='unexecuted'>        return true;</span>
 208 |     | <span class='neutral'>    }</span>
 209 |     | <span class='neutral'></span>
 210 |     | <span class='unexecuted'>    function invariant_SL_03(</span>
 211 |     | <span class='neutral'>        CdpManager cdpManager,</span>
 212 |     | <span class='neutral'>        PriceFeedTestnet priceFeedMock,</span>
 213 |     | <span class='neutral'>        SortedCdps sortedCdps</span>
 214 |     | <span class='unexecuted'>    ) internal returns (bool) {</span>
 215 |     | <span class='unexecuted'>        bytes32 currentCdp = sortedCdps.getFirst();</span>
 216 |     | <span class='neutral'></span>
 217 |     | <span class='unexecuted'>        uint256 _price = priceFeedMock.fetchPrice();</span>
 218 |     | <span class='unexecuted'>        if (_price == 0) return true;</span>
 219 |     | <span class='neutral'></span>
 220 |     | <span class='unexecuted'>        while (currentCdp != bytes32(0)) {</span>
 221 |     | <span class='neutral'>            // Status</span>
 222 |     | <span class='unexecuted'>            if (</span>
 223 |     | <span class='unexecuted'>                ICdpManagerData.Status(cdpManager.getCdpStatus(currentCdp)) !=</span>
 224 |     | <span class='unexecuted'>                ICdpManagerData.Status.active</span>
 225 |     | <span class='neutral'>            ) {</span>
 226 |     | <span class='unexecuted'>                return false;</span>
 227 |     | <span class='neutral'>            }</span>
 228 |     | <span class='neutral'></span>
 229 |     | <span class='neutral'>            // Stake &gt; 0</span>
 230 |     | <span class='unexecuted'>            if (cdpManager.getCdpStake(currentCdp) == 0) {</span>
 231 |     | <span class='unexecuted'>                return false;</span>
 232 |     | <span class='neutral'>            }</span>
 233 |     | <span class='neutral'></span>
 234 |     | <span class='unexecuted'>            currentCdp = sortedCdps.getNext(currentCdp);</span>
 235 |     | <span class='neutral'>        }</span>
 236 |     | <span class='neutral'>        return true;</span>
 237 |     | <span class='neutral'>    }</span>
 238 |     | <span class='neutral'></span>
 239 |     | <span class='unexecuted'>    uint256 NICR_ERROR_THRESHOLD = 1e18; // NOTE: 1e20 is basically 1/1 so it&#39;s completely safe as a threshold</span>
 240 |     | <span class='neutral'></span>
 241 |     | <span class='unexecuted'>    function invariant_SL_05(CRLens crLens, SortedCdps sortedCdps) internal returns (bool) {</span>
 242 |     | <span class='unexecuted'>        bytes32 currentCdp = sortedCdps.getFirst();</span>
 243 |     | <span class='neutral'></span>
 244 |     | <span class='neutral'>        uint256 newIcrPrevious = type(uint256).max;</span>
 245 |     | <span class='neutral'></span>
 246 |     | <span class='unexecuted'>        while (currentCdp != bytes32(0)) {</span>
 247 |     | <span class='unexecuted'>            uint256 newIcr = crLens.quoteRealICR(currentCdp);</span>
 248 |     | <span class='unexecuted'>            if (newIcr &gt; newIcrPrevious) {</span>
 249 |     | <span class='neutral'>                /// @audit Precision Threshold to flag very scary scenarios</span>
 250 |     | <span class='neutral'>                /// Innoquous scenario illustrated here: https://github.com/Badger-Finance/ebtc-fuzz-review/issues/15</span>
 251 |     | <span class='unexecuted'>                if (newIcr - newIcrPrevious &gt; NICR_ERROR_THRESHOLD) {</span>
 252 |     | <span class='unexecuted'>                    return false;</span>
 253 |     | <span class='neutral'>                }</span>
 254 |     | <span class='neutral'>            }</span>
 255 |     | <span class='unexecuted'>            newIcrPrevious = newIcr;</span>
 256 |     | <span class='neutral'></span>
 257 |     | <span class='unexecuted'>            currentCdp = sortedCdps.getNext(currentCdp);</span>
 258 |     | <span class='neutral'>        }</span>
 259 |     | <span class='unexecuted'>        return true;</span>
 260 |     | <span class='neutral'>    }</span>
 261 |     | <span class='neutral'></span>
 262 |     | <span class='unexecuted'>    function invariant_GENERAL_01(Vars memory vars) internal view returns (bool) {</span>
 263 |     | <span class='unexecuted'>        return !vars.isRecoveryModeBefore ? !vars.isRecoveryModeAfter : true;</span>
 264 |     | <span class='neutral'>    }</span>
 265 |     | <span class='neutral'></span>
 266 |     | <span class='unexecuted'>    function invariant_GENERAL_02(</span>
 267 |     | <span class='neutral'>        CdpManager cdpManager,</span>
 268 |     | <span class='neutral'>        PriceFeedTestnet priceFeedMock,</span>
 269 |     | <span class='neutral'>        EBTCToken eBTCToken,</span>
 270 |     | <span class='neutral'>        ICollateralToken collateral</span>
 271 |     | <span class='unexecuted'>    ) internal returns (bool) {</span>
 272 |     | <span class='neutral'>        // TODO how to calculate &quot;the dollar value of eBTC&quot;?</span>
 273 |     | <span class='neutral'>        // TODO how do we take into account underlying/shares into this calculation?</span>
 274 |     | <span class='unexecuted'>        return</span>
 275 |     | <span class='unexecuted'>            cdpManager.getCachedTCR(priceFeedMock.fetchPrice()) &gt; 1e18</span>
 276 |     | <span class='unexecuted'>                ? (collateral.getPooledEthByShares(cdpManager.getSystemCollShares()) *</span>
 277 |     | <span class='unexecuted'>                    priceFeedMock.fetchPrice()) /</span>
 278 |     | <span class='unexecuted'>                    1e18 &gt;=</span>
 279 |     | <span class='unexecuted'>                    eBTCToken.totalSupply()</span>
 280 |     | <span class='unexecuted'>                : (collateral.getPooledEthByShares(cdpManager.getSystemCollShares()) *</span>
 281 |     | <span class='unexecuted'>                    priceFeedMock.fetchPrice()) /</span>
 282 |     | <span class='unexecuted'>                    1e18 &lt;</span>
 283 |     | <span class='unexecuted'>                    eBTCToken.totalSupply();</span>
 284 |     | <span class='neutral'>    }</span>
 285 |     | <span class='neutral'></span>
 286 |     | <span class='unexecuted'>    function invariant_GENERAL_03(</span>
 287 |     | <span class='neutral'>        CdpManager cdpManager,</span>
 288 |     | <span class='neutral'>        BorrowerOperations borrowerOperations,</span>
 289 |     | <span class='neutral'>        EBTCToken eBTCToken,</span>
 290 |     | <span class='neutral'>        ICollateralToken collateral</span>
 291 |     | <span class='unexecuted'>    ) internal view returns (bool) {</span>
 292 |     | <span class='neutral'>        return</span>
 293 |     | <span class='unexecuted'>            collateral.balanceOf(address(cdpManager)) == 0 &amp;&amp;</span>
 294 |     | <span class='unexecuted'>            eBTCToken.balanceOf(address(cdpManager)) == 0 &amp;&amp;</span>
 295 |     | <span class='unexecuted'>            collateral.balanceOf(address(borrowerOperations)) == 0 &amp;&amp;</span>
 296 |     | <span class='unexecuted'>            eBTCToken.balanceOf(address(borrowerOperations)) == 0;</span>
 297 |     | <span class='neutral'>    }</span>
 298 |     | <span class='neutral'></span>
 299 |     | <span class='unexecuted'>    function invariant_GENERAL_05(</span>
 300 |     | <span class='neutral'>        ActivePool activePool,</span>
 301 |     | <span class='neutral'>        CdpManager cdpManager,</span>
 302 |     | <span class='neutral'>        ICollateralToken collateral</span>
 303 |     | <span class='unexecuted'>    ) internal view returns (bool) {</span>
 304 |     | <span class='unexecuted'>        uint256 totalStipendShares;</span>
 305 |     | <span class='neutral'></span>
 306 |     | <span class='neutral'>        // Iterate over CDPs add the stipendShares</span>
 307 |     | <span class='unexecuted'>        bytes32 currentCdp = sortedCdps.getFirst();</span>
 308 |     | <span class='unexecuted'>        while (currentCdp != bytes32(0)) {</span>
 309 |     | <span class='unexecuted'>            totalStipendShares += cdpManager.getCdpLiquidatorRewardShares(currentCdp);</span>
 310 |     | <span class='neutral'></span>
 311 |     | <span class='unexecuted'>            currentCdp = sortedCdps.getNext(currentCdp);</span>
 312 |     | <span class='neutral'>        }</span>
 313 |     | <span class='neutral'></span>
 314 |     | <span class='neutral'>        return</span>
 315 |     | <span class='unexecuted'>            collateral.sharesOf(address(activePool)) &gt;=</span>
 316 |     | <span class='unexecuted'>            (activePool.getSystemCollShares() +</span>
 317 |     | <span class='unexecuted'>                activePool.getFeeRecipientClaimableCollShares() +</span>
 318 |     | <span class='unexecuted'>                totalStipendShares);</span>
 319 |     | <span class='neutral'>    }</span>
 320 |     | <span class='neutral'></span>
 321 |     | <span class='unexecuted'>    function invariant_GENERAL_05_B(</span>
 322 |     | <span class='neutral'>        CollSurplusPool surplusPool,</span>
 323 |     | <span class='neutral'>        ICollateralToken collateral</span>
 324 |     | <span class='unexecuted'>    ) internal view returns (bool) {</span>
 325 |     | <span class='neutral'>        return</span>
 326 |     | <span class='unexecuted'>            collateral.sharesOf(address(surplusPool)) &gt;= (surplusPool.getTotalSurplusCollShares());</span>
 327 |     | <span class='neutral'>    }</span>
 328 |     | <span class='neutral'></span>
 329 |     | <span class='unexecuted'>    function invariant_GENERAL_06(</span>
 330 |     | <span class='neutral'>        EBTCToken eBTCToken,</span>
 331 |     | <span class='neutral'>        CdpManager cdpManager,</span>
 332 |     | <span class='neutral'>        SortedCdps sortedCdps</span>
 333 |     | <span class='unexecuted'>    ) internal view returns (bool) {</span>
 334 |     | <span class='unexecuted'>        uint256 totalSupply = eBTCToken.totalSupply();</span>
 335 |     | <span class='neutral'></span>
 336 |     | <span class='unexecuted'>        bytes32 currentCdp = sortedCdps.getFirst();</span>
 337 |     | <span class='unexecuted'>        uint256 cdpsBalance;</span>
 338 |     | <span class='unexecuted'>        while (currentCdp != bytes32(0)) {</span>
 339 |     | <span class='unexecuted'>            (uint256 entireDebt, uint256 entireColl) = cdpManager.getSyncedDebtAndCollShares(</span>
 340 |     | <span class='neutral'>                currentCdp</span>
 341 |     | <span class='neutral'>            );</span>
 342 |     | <span class='unexecuted'>            cdpsBalance += entireDebt;</span>
 343 |     | <span class='unexecuted'>            currentCdp = sortedCdps.getNext(currentCdp);</span>
 344 |     | <span class='neutral'>        }</span>
 345 |     | <span class='neutral'></span>
 346 |     | <span class='unexecuted'>        return totalSupply &gt;= cdpsBalance;</span>
 347 |     | <span class='neutral'>    }</span>
 348 |     | <span class='neutral'></span>
 349 |     | <span class='unexecuted'>    function invariant_GENERAL_17(</span>
 350 |     | <span class='neutral'>        CdpManager cdpManager,</span>
 351 |     | <span class='neutral'>        SortedCdps sortedCdps,</span>
 352 |     | <span class='neutral'>        PriceFeedTestnet priceFeedTestnet,</span>
 353 |     | <span class='neutral'>        ICollateralToken collateral</span>
 354 |     | <span class='unexecuted'>    ) internal view returns (bool) {</span>
 355 |     | <span class='unexecuted'>        bytes32 currentCdp = sortedCdps.getFirst();</span>
 356 |     | <span class='neutral'></span>
 357 |     | <span class='unexecuted'>        uint256 sumOfDebt;</span>
 358 |     | <span class='unexecuted'>        while (currentCdp != bytes32(0)) {</span>
 359 |     | <span class='unexecuted'>            uint256 entireDebt = cdpManager.getSyncedCdpDebt(currentCdp);</span>
 360 |     | <span class='unexecuted'>            sumOfDebt += entireDebt;</span>
 361 |     | <span class='unexecuted'>            currentCdp = sortedCdps.getNext(currentCdp);</span>
 362 |     | <span class='neutral'>        }</span>
 363 |     | <span class='unexecuted'>        sumOfDebt += cdpManager.lastEBTCDebtErrorRedistribution() / 1e18; // TODO: We need to add 1 wei for all CDPs at their time of redistribution</span>
 364 |     | <span class='unexecuted'>        uint256 _systemDebt = activePool.getSystemDebt();</span>
 365 |     | <span class='neutral'></span>
 366 |     | <span class='unexecuted'>        if (cdpManager.lastEBTCDebtErrorRedistribution() % 1e18 &gt; 0) sumOfDebt += 1; // Round up debt</span>
 367 |     | <span class='neutral'></span>
 368 |     | <span class='neutral'>        // SumOfDebt can have rounding error</span>
 369 |     | <span class='neutral'>        // And rounding error is capped by:</span>
 370 |     | <span class='neutral'>        // 1 wei of rounding error in lastEBTCDebtErrorRedistribution</span>
 371 |     | <span class='neutral'>        // 1 wei for each cdp at each redistribution (as their index may round down causing them to lose 1 wei of debt)</span>
 372 |     | <span class='unexecuted'>        return sumOfDebt &lt;= _systemDebt &amp;&amp; sumOfDebt + totalCdpDustMaxCap &gt;= _systemDebt;</span>
 373 |     | <span class='neutral'>    }</span>
 374 |     | <span class='neutral'></span>
 375 |     | <span class='neutral'>    function invariant_GENERAL_18(</span>
 376 |     | <span class='neutral'>        CdpManager cdpManager,</span>
 377 |     | <span class='neutral'>        SortedCdps sortedCdps,</span>
 378 |     | <span class='neutral'>        PriceFeedTestnet priceFeedTestnet,</span>
 379 |     | <span class='neutral'>        ICollateralToken collateral</span>
 380 |     | <span class='neutral'>    ) internal view returns (bool) {</span>
 381 |     | <span class='neutral'>        bytes32 currentCdp = sortedCdps.getFirst();</span>
 382 |     | <span class='neutral'></span>
 383 |     | <span class='neutral'>        uint256 sumOfColl;</span>
 384 |     | <span class='neutral'>        while (currentCdp != bytes32(0)) {</span>
 385 |     | <span class='neutral'>            uint256 entireColl = cdpManager.getSyncedCdpCollShares(currentCdp);</span>
 386 |     | <span class='neutral'>            sumOfColl += entireColl;</span>
 387 |     | <span class='neutral'>            currentCdp = sortedCdps.getNext(currentCdp);</span>
 388 |     | <span class='neutral'>        }</span>
 389 |     | <span class='neutral'></span>
 390 |     | <span class='neutral'>        if (sumOfColl == 0) {</span>
 391 |     | <span class='neutral'>            return sumOfColl == cdpManager.getSyncedSystemCollShares();</span>
 392 |     | <span class='neutral'>        }</span>
 393 |     | <span class='neutral'></span>
 394 |     | <span class='neutral'>        sumOfColl -= cdpManager.systemStEthFeePerUnitIndexError() / 1e18;</span>
 395 |     | <span class='neutral'>        uint256 _systemCollShares = cdpManager.getSyncedSystemCollShares();</span>
 396 |     | <span class='neutral'></span>
 397 |     | <span class='neutral'>        if (cdpManager.systemStEthFeePerUnitIndexError() % 1e18 &gt; 0) sumOfColl -= 1; // Round down coll</span>
 398 |     | <span class='neutral'>        // sumOfColl can have rounding error</span>
 399 |     | <span class='neutral'>        // And rounding error is capped by:</span>
 400 |     | <span class='neutral'>        // 1 wei of rounding error in systemStEthFeePerUnitIndexError</span>
 401 |     | <span class='neutral'>        // 1 wei for each cdp at each index change (as their index may round down causing them to lose 1 wei of fee split)</span>
 402 |     | <span class='neutral'>        return</span>
 403 |     | <span class='neutral'>            sumOfColl &lt;= _systemCollShares &amp;&amp;</span>
 404 |     | <span class='neutral'>            sumOfColl + vars.cumulativeCdpsAtTimeOfRebase &gt;= _systemCollShares;</span>
 405 |     | <span class='neutral'>    }</span>
 406 |     | <span class='neutral'></span>
 407 |     | <span class='unexecuted'>    function invariant_GENERAL_19(ActivePool activePool) internal view returns (bool) {</span>
 408 |     | <span class='unexecuted'>        return !activePool.twapDisabled();</span>
 409 |     | <span class='neutral'>    }</span>
 410 |     | <span class='neutral'></span>
 411 |     | <span class='unexecuted'>    function invariant_GENERAL_08(</span>
 412 |     | <span class='neutral'>        CdpManager cdpManager,</span>
 413 |     | <span class='neutral'>        SortedCdps sortedCdps,</span>
 414 |     | <span class='neutral'>        PriceFeedTestnet priceFeedTestnet,</span>
 415 |     | <span class='neutral'>        ICollateralToken collateral</span>
 416 |     | <span class='unexecuted'>    ) internal returns (bool) {</span>
 417 |     | <span class='unexecuted'>        uint256 curentPrice = priceFeedTestnet.fetchPrice();</span>
 418 |     | <span class='neutral'></span>
 419 |     | <span class='unexecuted'>        bytes32 currentCdp = sortedCdps.getFirst();</span>
 420 |     | <span class='neutral'></span>
 421 |     | <span class='unexecuted'>        uint256 sumOfColl;</span>
 422 |     | <span class='unexecuted'>        uint256 sumOfDebt;</span>
 423 |     | <span class='unexecuted'>        while (currentCdp != bytes32(0)) {</span>
 424 |     | <span class='unexecuted'>            uint256 entireColl = cdpManager.getSyncedCdpCollShares(currentCdp);</span>
 425 |     | <span class='unexecuted'>            uint256 entireDebt = cdpManager.getSyncedCdpDebt(currentCdp);</span>
 426 |     | <span class='unexecuted'>            sumOfColl += entireColl;</span>
 427 |     | <span class='unexecuted'>            sumOfDebt += entireDebt;</span>
 428 |     | <span class='unexecuted'>            currentCdp = sortedCdps.getNext(currentCdp);</span>
 429 |     | <span class='neutral'>        }</span>
 430 |     | <span class='neutral'></span>
 431 |     | <span class='unexecuted'>        uint256 _systemCollShares = cdpManager.getSyncedSystemCollShares();</span>
 432 |     | <span class='unexecuted'>        uint256 _systemDebt = activePool.getSystemDebt();</span>
 433 |     | <span class='unexecuted'>        uint256 tcrFromSystem = cdpManager.getSyncedTCR(curentPrice);</span>
 434 |     | <span class='neutral'></span>
 435 |     | <span class='unexecuted'>        uint256 tcrFromSums = EbtcMath._computeCR(</span>
 436 |     | <span class='unexecuted'>            collateral.getPooledEthByShares(sumOfColl),</span>
 437 |     | <span class='unexecuted'>            sumOfDebt,</span>
 438 |     | <span class='unexecuted'>            curentPrice</span>
 439 |     | <span class='neutral'>        );</span>
 440 |     | <span class='neutral'></span>
 441 |     | <span class='unexecuted'>        bool _acceptedTcrDiff = _assertApproximateEq(tcrFromSystem, tcrFromSums, 1e8);</span>
 442 |     | <span class='neutral'></span>
 443 |     | <span class='neutral'>        // add generic diff function (original, second, diff) - all at once</span>
 444 |     | <span class='neutral'></span>
 445 |     | <span class='neutral'>        /// @audit 1e8 precision in absoulte value (not the percent)</span>
 446 |     | <span class='neutral'>        //return  isApproximateEq(tcrFromSystem, tcrFromSums, 1e8); // Up to 1e8 precision is accepted</span>
 447 |     | <span class='unexecuted'>        bool _acceptedCollDiff = _assertApproximateEq(_systemCollShares, sumOfColl, 1e8);</span>
 448 |     | <span class='unexecuted'>        bool _acceptedDebtDiff = _assertApproximateEq(_systemDebt, sumOfDebt, 1e8);</span>
 449 |     | <span class='unexecuted'>        return (_acceptedCollDiff &amp;&amp; _acceptedDebtDiff);</span>
 450 |     | <span class='neutral'>    }</span>
 451 |     | <span class='neutral'></span>
 452 | *   | <span class='executed'>    function invariant_GENERAL_09(</span>
 453 |     | <span class='neutral'>        CdpManager cdpManager,</span>
 454 |     | <span class='neutral'>        Vars memory vars</span>
 455 |     | <span class='unexecuted'>    ) internal view returns (bool) {</span>
 456 | *   | <span class='executed'>        if (vars.isRecoveryModeBefore) {</span>
 457 |     | <span class='unexecuted'>            if (vars.cdpDebtAfter &gt; vars.cdpDebtBefore) return (vars.icrAfter &gt; cdpManager.MCR());</span>
 458 |     | <span class='unexecuted'>            else return true;</span>
 459 |     | <span class='neutral'>        } else {</span>
 460 |     | <span class='unexecuted'>            return (vars.icrAfter &gt; cdpManager.MCR());</span>
 461 |     | <span class='neutral'>        }</span>
 462 |     | <span class='neutral'>    }</span>
 463 |     | <span class='neutral'></span>
 464 |     | <span class='unexecuted'>    function invariant_GENERAL_12(</span>
 465 |     | <span class='neutral'>        CdpManager cdpManager,</span>
 466 |     | <span class='neutral'>        PriceFeedTestnet priceFeedMock,</span>
 467 |     | <span class='neutral'>        CRLens crLens</span>
 468 |     | <span class='unexecuted'>    ) internal returns (bool) {</span>
 469 |     | <span class='unexecuted'>        uint256 curentPrice = priceFeedMock.fetchPrice();</span>
 470 |     | <span class='unexecuted'>        return crLens.quoteRealTCR() == cdpManager.getSyncedTCR(curentPrice);</span>
 471 |     | <span class='neutral'>    }</span>
 472 |     | <span class='neutral'></span>
 473 |     | <span class='unexecuted'>    function invariant_GENERAL_13(</span>
 474 |     | <span class='neutral'>        CRLens crLens,</span>
 475 |     | <span class='neutral'>        CdpManager cdpManager,</span>
 476 |     | <span class='neutral'>        PriceFeedTestnet priceFeedMock,</span>
 477 |     | <span class='neutral'>        SortedCdps sortedCdps</span>
 478 |     | <span class='unexecuted'>    ) internal returns (bool) {</span>
 479 |     | <span class='unexecuted'>        bytes32 currentCdp = sortedCdps.getFirst();</span>
 480 |     | <span class='neutral'></span>
 481 |     | <span class='unexecuted'>        uint256 _price = priceFeedMock.fetchPrice();</span>
 482 |     | <span class='neutral'></span>
 483 |     | <span class='neutral'>        // Compare synched with quote for all Cdps</span>
 484 |     | <span class='unexecuted'>        while (currentCdp != bytes32(0)) {</span>
 485 |     | <span class='unexecuted'>            uint256 newIcr = crLens.quoteRealICR(currentCdp);</span>
 486 |     | <span class='unexecuted'>            uint256 synchedICR = cdpManager.getSyncedICR(currentCdp, _price);</span>
 487 |     | <span class='neutral'></span>
 488 |     | <span class='unexecuted'>            if (newIcr != synchedICR) {</span>
 489 |     | <span class='unexecuted'>                return false;</span>
 490 |     | <span class='neutral'>            }</span>
 491 |     | <span class='neutral'></span>
 492 |     | <span class='unexecuted'>            currentCdp = sortedCdps.getNext(currentCdp);</span>
 493 |     | <span class='neutral'>        }</span>
 494 |     | <span class='unexecuted'>        return true;</span>
 495 |     | <span class='neutral'>    }</span>
 496 |     | <span class='neutral'></span>
 497 |     | <span class='unexecuted'>    function invariant_GENERAL_14(</span>
 498 |     | <span class='neutral'>        CRLens crLens,</span>
 499 |     | <span class='neutral'>        CdpManager cdpManager,</span>
 500 |     | <span class='neutral'>        SortedCdps sortedCdps</span>
 501 |     | <span class='unexecuted'>    ) internal returns (bool) {</span>
 502 |     | <span class='unexecuted'>        bytes32 currentCdp = sortedCdps.getFirst();</span>
 503 |     | <span class='neutral'></span>
 504 |     | <span class='neutral'>        uint256 newIcrPrevious = type(uint256).max;</span>
 505 |     | <span class='neutral'></span>
 506 |     | <span class='neutral'>        // Compare synched with quote for all Cdps</span>
 507 |     | <span class='unexecuted'>        while (currentCdp != bytes32(0)) {</span>
 508 |     | <span class='unexecuted'>            uint256 newNICR = crLens.quoteRealNICR(currentCdp);</span>
 509 |     | <span class='unexecuted'>            uint256 synchedNICR = cdpManager.getSyncedNominalICR(currentCdp); // Uses cached stETH index -&gt; It&#39;s not the &quot;real NICR&quot;</span>
 510 |     | <span class='neutral'></span>
 511 |     | <span class='unexecuted'>            if (newNICR != synchedNICR) {</span>
 512 |     | <span class='unexecuted'>                return false;</span>
 513 |     | <span class='neutral'>            }</span>
 514 |     | <span class='neutral'></span>
 515 |     | <span class='unexecuted'>            currentCdp = sortedCdps.getNext(currentCdp);</span>
 516 |     | <span class='neutral'>        }</span>
 517 |     | <span class='neutral'>        return true;</span>
 518 |     | <span class='neutral'>    }</span>
 519 |     | <span class='neutral'></span>
 520 |     | <span class='neutral'>    function invariant_GENERAL_15() internal returns (bool) {</span>
 521 |     | <span class='neutral'>        return</span>
 522 |     | <span class='neutral'>            crLens.quoteAnything(simulator.simulateRepayEverythingAndCloseCdps) == simulator.TRUE();</span>
 523 |     | <span class='neutral'>    }</span>
 524 |     | <span class='neutral'></span>
 525 | *   | <span class='executed'>    function invariant_LS_01(</span>
 526 |     | <span class='neutral'>        CdpManager cdpManager,</span>
 527 |     | <span class='neutral'>        LiquidationSequencer ls,</span>
 528 |     | <span class='neutral'>        SyncedLiquidationSequencer syncedLs,</span>
 529 |     | <span class='neutral'>        PriceFeedTestnet priceFeedTestnet</span>
 530 |     | <span class='unexecuted'>    ) internal returns (bool) {</span>
 531 |     | <span class='neutral'>        // Or just compare max lenght since that&#39;s the one with all of them</span>
 532 |     | <span class='unexecuted'>        uint256 n = cdpManager.getActiveCdpsCount();</span>
 533 |     | <span class='neutral'></span>
 534 |     | <span class='neutral'>        // Get</span>
 535 |     | <span class='unexecuted'>        uint256 price = priceFeedTestnet.fetchPrice();</span>
 536 |     | <span class='neutral'></span>
 537 |     | <span class='neutral'>        // Get lists</span>
 538 |     | <span class='unexecuted'>        bytes32[] memory cdpsFromCurrent = ls.sequenceLiqToBatchLiqWithPrice(n, price);</span>
 539 |     | <span class='unexecuted'>        bytes32[] memory cdpsSynced = syncedLs.sequenceLiqToBatchLiqWithPrice(n, price);</span>
 540 |     | <span class='neutral'></span>
 541 |     | <span class='unexecuted'>        uint256 length = cdpsFromCurrent.length;</span>
 542 |     | <span class='unexecuted'>        if (length != cdpsSynced.length) {</span>
 543 |     | <span class='unexecuted'>            return false;</span>
 544 |     | <span class='neutral'>        }</span>
 545 |     | <span class='neutral'></span>
 546 |     | <span class='neutral'>        // Compare Lists</span>
 547 |     | <span class='unexecuted'>        for (uint256 i; i &lt; length; i++) {</span>
 548 |     | <span class='neutral'>            // Find difference = broken</span>
 549 |     | <span class='unexecuted'>            if (cdpsFromCurrent[i] != cdpsSynced[i]) {</span>
 550 |     | <span class='unexecuted'>                return false;</span>
 551 |     | <span class='neutral'>            }</span>
 552 |     | <span class='neutral'>        }</span>
 553 |     | <span class='neutral'></span>
 554 |     | <span class='neutral'>        // Implies we&#39;re good</span>
 555 |     | <span class='unexecuted'>        return true;</span>
 556 |     | <span class='neutral'>    }</span>
 557 |     | <span class='neutral'></span>
 558 |     | <span class='unexecuted'>    function invariant_DUMMY_01(PriceFeedTestnet priceFeedTestnet) internal returns (bool) {</span>
 559 |     | <span class='unexecuted'>        return priceFeedTestnet.fetchPrice() &gt; 0;</span>
 560 |     | <span class='neutral'>    }</span>
 561 |     | <span class='neutral'></span>
 562 |     | <span class='unexecuted'>    function invariant_BO_09(</span>
 563 |     | <span class='neutral'>        CdpManager cdpManager,</span>
 564 |     | <span class='neutral'>        uint256 price,</span>
 565 |     | <span class='neutral'>        bytes32 cdpId</span>
 566 |     | <span class='unexecuted'>    ) internal view returns (bool) {</span>
 567 |     | <span class='unexecuted'>        uint256 _icr = cdpManager.getSyncedICR(cdpId, price);</span>
 568 |     | <span class='unexecuted'>        if (cdpManager.checkRecoveryMode(price)) {</span>
 569 |     | <span class='unexecuted'>            return _icr &gt;= cdpManager.CCR();</span>
 570 |     | <span class='neutral'>        } else {</span>
 571 |     | <span class='unexecuted'>            return _icr &gt;= cdpManager.MCR();</span>
 572 |     | <span class='neutral'>        }</span>
 573 |     | <span class='neutral'>    }</span>
 574 |     | <span class='neutral'>}</span>
 575 |     | <span class='neutral'></span>

</code>
<br />

<b>/mnt/c/Users/Lourens/Documents/Recon-Fuzz/collabs/ebtc/packages/contracts/contracts/TestContracts/invariants/PropertiesDescriptions.sol</b>
<code>
   1 |     | <span class='neutral'>pragma solidity 0.8.17;</span>
   2 |     | <span class='neutral'></span>
   3 |     | <span class='neutral'>abstract contract PropertiesDescriptions {</span>
   4 |     | <span class='neutral'>    ///////////////////////////////////////////////////////</span>
   5 |     | <span class='neutral'>    // Active Pool</span>
   6 |     | <span class='neutral'>    ///////////////////////////////////////////////////////</span>
   7 |     | <span class='neutral'></span>
   8 |     | <span class='neutral'>    string constant AP_01 =</span>
   9 |     | <span class='neutral'>        &quot;AP-01: The collateral balance in the active pool is greater than or equal to its accounting number&quot;;</span>
  10 |     | <span class='neutral'>    string constant AP_02 =</span>
  11 |     | <span class='neutral'>        &quot;AP-02: The collateral balance of the ActivePool is positive if there is at least one CDP open&quot;;</span>
  12 |     | <span class='neutral'>    string constant AP_03 =</span>
  13 |     | <span class='neutral'>        &quot;AP-03: The eBTC debt accounting number in active pool is greater than or equal to its accounting number&quot;;</span>
  14 |     | <span class='neutral'>    string constant AP_04 =</span>
  15 |     | <span class='neutral'>        &quot;AP-04: The total collateral in active pool should be equal to the sum of all individual CDP collateral&quot;;</span>
  16 |     | <span class='neutral'>    string constant AP_05 =</span>
  17 |     | <span class='neutral'>        &quot;AP-05: The sum of debt accounting in active pool should be equal to sum of debt accounting of individual CDPs&quot;;</span>
  18 |     | <span class='neutral'></span>
  19 |     | <span class='neutral'>    ///////////////////////////////////////////////////////</span>
  20 |     | <span class='neutral'>    // Cdp Manager</span>
  21 |     | <span class='neutral'>    ///////////////////////////////////////////////////////</span>
  22 |     | <span class='neutral'></span>
  23 |     | <span class='neutral'>    string constant CDPM_01 =</span>
  24 |     | <span class='neutral'>        &quot;CDPM-01: The count of active CDPs is equal to the SortedCdp list length&quot;;</span>
  25 |     | <span class='neutral'>    string constant CDPM_02 = &quot;CDPM-02: The sum of active CDPs stake is equal to totalStakes&quot;;</span>
  26 |     | <span class='neutral'>    string constant CDPM_03 =</span>
  27 |     | <span class='neutral'>        &quot;CDPM-03: The stFeePerUnit tracker for individual CDP is equal to or less than the global variable&quot;;</span>
  28 |     | <span class='neutral'>    string constant CDPM_04 = &quot;CDPM-04: The total system value does not decrease during redemptions&quot;;</span>
  29 |     | <span class='neutral'>    string constant CDPM_05 = &quot;CDPM-05: Redemptions do not increase the total system debt&quot;;</span>
  30 |     | <span class='neutral'>    string constant CDPM_06 = &quot;CDPM-06: Redemptions do not increase the total system debt&quot;;</span>
  31 |     | <span class='neutral'>    string constant CDPM_07 = &quot;CDPM-07: Stake decreases when collShares decreases for a CDP&quot;;</span>
  32 |     | <span class='neutral'>    string constant CDPM_08 = &quot;CDPM-08: Stake increases when collShares increases for a CDP&quot;;</span>
  33 |     | <span class='neutral'>    string constant CDPM_09 =</span>
  34 |     | <span class='neutral'>        &quot;CDPM-09: expectedStake = coll * totalStakesSnapshot / totalCollateralSnapshot after every operation involving a CDP&quot;;</span>
  35 |     | <span class='neutral'>    string constant CDPM_10 =</span>
  36 |     | <span class='neutral'>        &quot;CDPM-10: totalStakesSnapshot matches totalStakes after an operation, if rebase index changed during the OP&quot;;</span>
  37 |     | <span class='neutral'>    string constant CDPM_11 =</span>
  38 |     | <span class='neutral'>        &quot;CDPM-11: totalCollateralSnapshot matches activePool.systemCollShares after an operation, if rebase index changed during the OP&quot;;</span>
  39 |     | <span class='neutral'>    string constant CDPM_12 =</span>
  40 |     | <span class='neutral'>        &quot;CDPM-12: Sum of all individual CDP stakes should equal to totalStakes&quot;;</span>
  41 |     | <span class='neutral'></span>
  42 |     | <span class='neutral'>    ///////////////////////////////////////////////////////</span>
  43 |     | <span class='neutral'>    // Collateral Surplus Pool</span>
  44 |     | <span class='neutral'>    ///////////////////////////////////////////////////////</span>
  45 |     | <span class='neutral'></span>
  46 |     | <span class='neutral'>    string constant CSP_01 =</span>
  47 |     | <span class='neutral'>        &quot;CSP-01: The collateral balance in the collSurplus pool is greater than or equal to its accounting number&quot;;</span>
  48 |     | <span class='neutral'>    string constant CSP_02 =</span>
  49 |     | <span class='neutral'>        &quot;CSP-02: The sum of all surpluses is equal to the value of getTotalSurplusCollShares&quot;;</span>
  50 |     | <span class='neutral'></span>
  51 |     | <span class='neutral'>    ///////////////////////////////////////////////////////</span>
  52 |     | <span class='neutral'>    // Sorted List</span>
  53 |     | <span class='neutral'>    ///////////////////////////////////////////////////////</span>
  54 |     | <span class='neutral'></span>
  55 |     | <span class='neutral'>    string constant SL_01 =</span>
  56 |     | <span class='neutral'>        &quot;SL-01: The NICR ranking in the sorted list should follow descending order&quot;;</span>
  57 |     | <span class='neutral'>    string constant SL_02 =</span>
  58 |     | <span class='neutral'>        &quot;SL-02: The the first(highest) ICR in the sorted list should be greater or equal to TCR (with tolerance due to rounding errors)&quot;;</span>
  59 |     | <span class='neutral'>    string constant SL_03 = &quot;SL-03: All CDPs have status active and stake greater than zero&quot;;</span>
  60 |     | <span class='neutral'>    string constant SL_05 =</span>
  61 |     | <span class='neutral'>        &quot;SL-05: The CDPs should be sorted in descending order of new ICR (accrued)&quot;;</span>
  62 |     | <span class='neutral'></span>
  63 |     | <span class='neutral'>    ///////////////////////////////////////////////////////</span>
  64 |     | <span class='neutral'>    // Borrower Operations</span>
  65 |     | <span class='neutral'>    ///////////////////////////////////////////////////////</span>
  66 |     | <span class='neutral'></span>
  67 |     | <span class='neutral'>    string constant BO_01 = &quot;BO-01: Users can only open CDPs with healthy ICR&quot;;</span>
  68 |     | <span class='neutral'>    string constant BO_02 = &quot;BO-02: Users must repay all debt to close a CDP&quot;;</span>
  69 |     | <span class='neutral'>    string constant BO_03 = &quot;BO-03: Adding collateral doesn&#39;t reduce Nominal ICR&quot;;</span>
  70 |     | <span class='neutral'>    string constant BO_04 = &quot;BO-04: Removing collateral does not increase the Nominal ICR&quot;;</span>
  71 |     | <span class='neutral'>    string constant BO_05 =</span>
  72 |     | <span class='neutral'>        &quot;BO-05: When a borrower closes their active CDP, the gas compensation is refunded to the user&quot;;</span>
  73 |     | <span class='neutral'>    string constant BO_07 = &quot;BO-07: eBTC tokens are burned upon repayment of a CDP&#39;s debt&quot;;</span>
  74 |     | <span class='neutral'>    string constant BO_08 = &quot;BO-08: TCR must increase after a repayment&quot;;</span>
  75 |     | <span class='neutral'>    string constant BO_09 = &quot;BO-09: Borrower can not open a CDP that is immediately liquidatable&quot;;</span>
  76 |     | <span class='neutral'></span>
  77 |     | <span class='neutral'>    ///////////////////////////////////////////////////////</span>
  78 |     | <span class='neutral'>    // General</span>
  79 |     | <span class='neutral'>    ///////////////////////////////////////////////////////</span>
  80 |     | <span class='neutral'>    string constant GENERAL_01 =</span>
  81 |     | <span class='neutral'>        &quot;GENERAL-01: After any operation, the system should not enter in Recovery Mode&quot;;</span>
  82 |     | <span class='neutral'>    string constant GENERAL_02 =</span>
  83 |     | <span class='neutral'>        &quot;GENERAL-02: The dollar value of the locked stETH exceeds the dollar value of the issued eBTC if TCR is greater than 100%&quot;;</span>
  84 |     | <span class='neutral'>    string constant GENERAL_03 =</span>
  85 |     | <span class='neutral'>        &quot;GENERAL-03: CdpManager and BorrowerOperations do not hold value terms of stETH and eBTC unless there are donations&quot;;</span>
  86 |     | <span class='neutral'>    string constant GENERAL_05 =</span>
  87 |     | <span class='neutral'>        &quot;GENERAL-05: At all times, the total stETH shares of the system exceeds the deposits if there is no negative rebasing events&quot;; /// NOTE this holds even with rebases</span>
  88 |     | <span class='neutral'>    string constant GENERAL_06 =</span>
  89 |     | <span class='neutral'>        &quot;GENERAL-06: At all times, the total debt is greater than the sum of all debts from all CDPs&quot;;</span>
  90 |     | <span class='neutral'>    string constant GENERAL_08 =</span>
  91 |     | <span class='neutral'>        &quot;GENERAL-08: At all times TCR = SUM(COLL)  * price / SUM(DEBT) of all CDPs&quot;;</span>
  92 |     | <span class='neutral'>    string constant GENERAL_09 =</span>
  93 |     | <span class='neutral'>        &quot;GENERAL-09: After any operation, the ICR of a CDP must be above the MCR in Normal Mode, and after debt increase in Recovery Mode the ICR must be above the CCR&quot;;</span>
  94 |     | <span class='neutral'>    string constant GENERAL_10 = &quot;GENERAL-10: All CDPs should maintain a minimum collateral size&quot;;</span>
  95 |     | <span class='neutral'>    string constant GENERAL_11 =</span>
  96 |     | <span class='neutral'>        &quot;GENERAL-11: The TCR pre-computed (TCRNotified) is the same as the one after all calls&quot;;</span>
  97 |     | <span class='neutral'>    string constant GENERAL_12 =</span>
  98 |     | <span class='neutral'>        &quot;GENERAL-12: The synchedTCR matches the TCR after accrual (as returned by CrLens)&quot;;</span>
  99 |     | <span class='neutral'>    string constant GENERAL_13 =</span>
 100 |     | <span class='neutral'>        &quot;GENERAL-13: The SynchedICR of every CDP in the Linked List Matches the ICR the CDPs will have the call (as returned by CrLens)&quot;;</span>
 101 |     | <span class='neutral'>    string constant GENERAL_14 =</span>
 102 |     | <span class='neutral'>        &quot;GENERAL-14: The NominalICR from `getNominalICR` matches `quoteRealNICR` (as returned by CrLens)&quot;;</span>
 103 |     | <span class='neutral'>    string constant GENERAL_15 =</span>
 104 |     | <span class='neutral'>        &quot;GENERAL-15: CDP debt should always be greater than MIN_CHANGE (1000 Wei)&quot;;</span>
 105 |     | <span class='neutral'>    string constant GENERAL_16 =</span>
 106 |     | <span class='neutral'>        &quot;GENERAL-16: Collateral and debt change amounts should always be greater than MIN_CHANGE (1000 Wei)&quot;;</span>
 107 |     | <span class='neutral'>    string constant GENERAL_17 =</span>
 108 |     | <span class='neutral'>        &quot;GENERAL-17: Sum of synced debt values of all Cdps + the stored debt redistribution error accumulator should never be more than the total system debt + 1&quot;;</span>
 109 |     | <span class='neutral'>    string constant GENERAL_18 =</span>
 110 |     | <span class='neutral'>        &quot;GENERAL-18: Sum of synced coll shares of all Cdps - cumulative errors should never be more than _systemCollShares&quot;;</span>
 111 |     | <span class='neutral'>    string constant GENERAL_19 = &quot;GENERAL-19: TWAP should never be disabled&quot;;</span>
 112 |     | <span class='neutral'></span>
 113 |     | <span class='neutral'>    ///////////////////////////////////////////////////////</span>
 114 |     | <span class='neutral'>    // Redemptions</span>
 115 |     | <span class='neutral'>    ///////////////////////////////////////////////////////</span>
 116 |     | <span class='neutral'></span>
 117 |     | <span class='neutral'>    string constant R_07 = &quot;R-07: TCR should not decrease after redemptions&quot;;</span>
 118 |     | <span class='neutral'>    string constant R_08 = &quot;R-08: The user eBTC balance should be used to pay the system debt&quot;;</span>
 119 |     | <span class='neutral'></span>
 120 |     | <span class='neutral'>    ///////////////////////////////////////////////////////</span>
 121 |     | <span class='neutral'>    // Liquidations</span>
 122 |     | <span class='neutral'>    ///////////////////////////////////////////////////////</span>
 123 |     | <span class='neutral'></span>
 124 |     | <span class='neutral'>    string constant L_01 =</span>
 125 |     | <span class='neutral'>        &quot;L-01: Liquidation only succeeds if ICR &lt; 110% in Normal Mode, or if ICR &lt; 125% in Recovery Mode&quot;;</span>
 126 |     | <span class='neutral'>    string constant L_09 =</span>
 127 |     | <span class='neutral'>        &quot;L-09: Undercollateralized liquidations are also incentivized with the Gas Stipend&quot;;</span>
 128 |     | <span class='neutral'>    string constant L_12 =</span>
 129 |     | <span class='neutral'>        &quot;L-12: TCR must increase after liquidation with no redistributions if the liquidated CDP&#39;s ICR is less than TCR before liquidation&quot;;</span>
 130 |     | <span class='neutral'>    string constant L_14 =</span>
 131 |     | <span class='neutral'>        &quot;If the RM grace period is set and we&#39;re in recovery mode, new actions that keep the system in recovery mode should not change the cooldown timestamp&quot;;</span>
 132 |     | <span class='neutral'>    string constant L_15 =</span>
 133 |     | <span class='neutral'>        &quot;L-15: The RM grace period should set if a BO/liquidation/redistribution makes the TCR below CCR&quot;;</span>
 134 |     | <span class='neutral'>    string constant L_16 =</span>
 135 |     | <span class='neutral'>        &quot;L-16: The RM grace period should reset if a BO/liquidation/redistribution makes the TCR above CCR&quot;;</span>
 136 |     | <span class='neutral'>    string constant L_17 =</span>
 137 |     | <span class='neutral'>        &quot;L-17: Debt Redistribution Error Accumulator should be less than Total Stakes immediately after a bad debt redistribution&quot;;</span>
 138 |     | <span class='neutral'></span>
 139 |     | <span class='neutral'>    ///////////////////////////////////////////////////////</span>
 140 |     | <span class='neutral'>    // eBTC</span>
 141 |     | <span class='neutral'>    ///////////////////////////////////////////////////////</span>
 142 |     | <span class='neutral'></span>
 143 |     | <span class='neutral'>    string constant EBTC_02 =</span>
 144 |     | <span class='neutral'>        &quot;EBTC-02: Any eBTC holder (whether or not they have an active CDP) may redeem their eBTC unless TCR is below MCR&quot;;</span>
 145 |     | <span class='neutral'></span>
 146 |     | <span class='neutral'>    ///////////////////////////////////////////////////////</span>
 147 |     | <span class='neutral'>    // Fee Recipient</span>
 148 |     | <span class='neutral'>    ///////////////////////////////////////////////////////</span>
 149 |     | <span class='neutral'></span>
 150 |     | <span class='neutral'>    string constant F_01 = &quot;F-01: `claimFeeRecipientCollShares` allows to claim at any time&quot;;</span>
 151 |     | <span class='neutral'>    string constant F_02 = &quot;F-02: Fees From Redemptions are added to `claimFeeRecipientCollShares`&quot;;</span>
 152 |     | <span class='neutral'>    string constant F_03 = &quot;F-03: Fees From FlashLoans are sent to the fee Recipient&quot;;</span>
 153 |     | <span class='neutral'>    string constant F_04 =</span>
 154 |     | <span class='neutral'>        &quot;F-04: `claimFeeRecipientCollShares` claiming increases the balance of the fee recipient&quot;;</span>
 155 |     | <span class='neutral'></span>
 156 |     | <span class='neutral'>    ///////////////////////////////////////////////////////</span>
 157 |     | <span class='neutral'>    // Price Feed</span>
 158 |     | <span class='neutral'>    ///////////////////////////////////////////////////////</span>
 159 |     | <span class='neutral'></span>
 160 |     | <span class='neutral'>    string constant PF_01 = &quot;PF-01: The price feed must never revert&quot;;</span>
 161 |     | <span class='neutral'>    string constant PF_02 = &quot;PF-02: The price feed must follow valid status transitions&quot;;</span>
 162 |     | <span class='neutral'>    string constant PF_03 = &quot;PF-03: The price feed must never deadlock&quot;;</span>
 163 |     | <span class='neutral'>    string constant PF_04 =</span>
 164 |     | <span class='neutral'>        &quot;PF-04: The price feed should never report an outdated price if chainlink is Working&quot;;</span>
 165 |     | <span class='neutral'>    string constant PF_05 =</span>
 166 |     | <span class='neutral'>        &quot;PF-05: The price feed should never use the fallback if chainlink is Working&quot;;</span>
 167 |     | <span class='neutral'>    string constant PF_06 = &quot;PF-06: The system never tries to use the fallback if it is not set&quot;;</span>
 168 |     | <span class='neutral'>    string constant PF_07 =</span>
 169 |     | <span class='neutral'>        &quot;PF-07: The price feed should return the primary oracle price if it is working&quot;;</span>
 170 |     | <span class='neutral'>    string constant PF_08 =</span>
 171 |     | <span class='neutral'>        &quot;PF-08: The price feed should return the secondary oracle price if the primary oracle is not working&quot;;</span>
 172 |     | <span class='neutral'>    string constant PF_09 =</span>
 173 |     | <span class='neutral'>        &quot;PF-09: The price feed should return the last good price if both oracles are not working&quot;;</span>
 174 |     | <span class='neutral'>    string constant PF_10 =</span>
 175 |     | <span class='neutral'>        &quot;PF-10: The price feed should never return different prices when called multiple times in a single tx&quot;;</span>
 176 |     | <span class='neutral'>}</span>
 177 |     | <span class='neutral'></span>

</code>
<br />

<b>/mnt/c/Users/Lourens/Documents/Recon-Fuzz/collabs/ebtc/packages/contracts/contracts/TestContracts/invariants/Simulator.sol</b>
<code>
  1 |     | <span class='neutral'>pragma solidity 0.8.17;</span>
  2 |     | <span class='neutral'></span>
  3 |     | <span class='neutral'>import {BorrowerOperations} from &quot;../../BorrowerOperations.sol&quot;;</span>
  4 |     | <span class='neutral'>import {CdpManager} from &quot;../../CdpManager.sol&quot;;</span>
  5 |     | <span class='neutral'>import {SortedCdps} from &quot;../../SortedCdps.sol&quot;;</span>
  6 |     | <span class='neutral'>import {Actor} from &quot;./Actor.sol&quot;;</span>
  7 |     | <span class='neutral'></span>
  8 |     | <span class='unexecuted'>contract Simulator {</span>
  9 |     | <span class='unexecuted'>    uint256 public constant TRUE = uint256(keccak256(abi.encodePacked(&quot;TRUE&quot;)));</span>
 10 |     | <span class='neutral'>    event Log(string);</span>
 11 |     | <span class='neutral'></span>
 12 |     | <span class='neutral'>    Actor[] private actors;</span>
 13 |     | <span class='neutral'>    CdpManager private cdpManager;</span>
 14 |     | <span class='neutral'>    SortedCdps private sortedCdps;</span>
 15 |     | <span class='neutral'>    BorrowerOperations private borrowerOperations;</span>
 16 |     | <span class='neutral'></span>
 17 |     | <span class='unexecuted'>    constructor(</span>
 18 |     | <span class='neutral'>        Actor[] memory _actors,</span>
 19 |     | <span class='neutral'>        CdpManager _cdpManager,</span>
 20 |     | <span class='neutral'>        SortedCdps _sortedCdps,</span>
 21 |     | <span class='neutral'>        BorrowerOperations _borrowerOperations</span>
 22 |     | <span class='neutral'>    ) {</span>
 23 |     | <span class='unexecuted'>        actors = _actors;</span>
 24 |     | <span class='unexecuted'>        cdpManager = _cdpManager;</span>
 25 |     | <span class='unexecuted'>        sortedCdps = _sortedCdps;</span>
 26 |     | <span class='unexecuted'>        borrowerOperations = _borrowerOperations;</span>
 27 |     | <span class='neutral'>    }</span>
 28 |     | <span class='neutral'></span>
 29 |     | <span class='unexecuted'>    function simulateRepayEverythingAndCloseCdps() external {</span>
 30 |     | <span class='unexecuted'>        bool success;</span>
 31 |     | <span class='neutral'></span>
 32 |     | <span class='unexecuted'>        bytes32 currentCdp = sortedCdps.getFirst();</span>
 33 |     | <span class='unexecuted'>        while (currentCdp != bytes32(0) &amp;&amp; sortedCdps.getSize() &gt; 1) {</span>
 34 |     | <span class='unexecuted'>            Actor actor = Actor(payable(sortedCdps.getOwnerAddress(currentCdp)));</span>
 35 |     | <span class='unexecuted'>            (uint256 entireDebt, ) = cdpManager.getSyncedDebtAndCollShares(currentCdp);</span>
 36 |     | <span class='neutral'></span>
 37 |     | <span class='unexecuted'>            (success, ) = actor.proxy(</span>
 38 |     | <span class='unexecuted'>                address(borrowerOperations),</span>
 39 |     | <span class='unexecuted'>                abi.encodeWithSelector(BorrowerOperations.closeCdp.selector, currentCdp)</span>
 40 |     | <span class='neutral'>            );</span>
 41 |     | <span class='unexecuted'>            require(success);</span>
 42 |     | <span class='neutral'></span>
 43 |     | <span class='unexecuted'>            currentCdp = sortedCdps.getNext(currentCdp);</span>
 44 |     | <span class='neutral'>        }</span>
 45 |     | <span class='neutral'></span>
 46 |     | <span class='unexecuted'>        _success();</span>
 47 |     | <span class='neutral'>    }</span>
 48 |     | <span class='neutral'></span>
 49 |     | <span class='unexecuted'>    function _success() private {</span>
 50 |     | <span class='unexecuted'>        uint256 ans = TRUE;</span>
 51 |     | <span class='neutral'>        assembly {</span>
 52 |     | <span class='neutral'>            let ptr := mload(0x40)</span>
 53 |     | <span class='unexecuted'>            mstore(ptr, ans)</span>
 54 |     | <span class='unexecuted'>            revert(ptr, 32)</span>
 55 |     | <span class='neutral'>        }</span>
 56 |     | <span class='neutral'>    }</span>
 57 |     | <span class='neutral'>}</span>
 58 |     | <span class='neutral'></span>

</code>
<br />

<b>/mnt/c/Users/Lourens/Documents/Recon-Fuzz/collabs/ebtc/packages/contracts/contracts/TestContracts/invariants/TargetContractSetup.sol</b>
<code>
   1 |     | <span class='neutral'>pragma solidity 0.8.17;</span>
   2 |     | <span class='neutral'></span>
   3 |     | <span class='neutral'>import &quot;@crytic/properties/contracts/util/PropertiesConstants.sol&quot;;</span>
   4 |     | <span class='neutral'>import &quot;@crytic/properties/contracts/util/Hevm.sol&quot;;</span>
   5 |     | <span class='neutral'></span>
   6 |     | <span class='neutral'>import &quot;../../Dependencies/SafeMath.sol&quot;;</span>
   7 |     | <span class='neutral'>import &quot;../../CdpManager.sol&quot;;</span>
   8 |     | <span class='neutral'>import &quot;../AccruableCdpManager.sol&quot;;</span>
   9 |     | <span class='neutral'>import &quot;../../LiquidationLibrary.sol&quot;;</span>
  10 |     | <span class='neutral'>import &quot;../../BorrowerOperations.sol&quot;;</span>
  11 |     | <span class='neutral'>import &quot;../../ActivePool.sol&quot;;</span>
  12 |     | <span class='neutral'>import &quot;../../CollSurplusPool.sol&quot;;</span>
  13 |     | <span class='neutral'>import &quot;../../SortedCdps.sol&quot;;</span>
  14 |     | <span class='neutral'>import &quot;../../HintHelpers.sol&quot;;</span>
  15 |     | <span class='neutral'>import &quot;../../FeeRecipient.sol&quot;;</span>
  16 |     | <span class='neutral'>import &quot;../../EbtcFeed.sol&quot;;</span>
  17 |     | <span class='neutral'>import &quot;../testnet/PriceFeedTestnet.sol&quot;;</span>
  18 |     | <span class='neutral'>import &quot;../CollateralTokenTester.sol&quot;;</span>
  19 |     | <span class='neutral'>import &quot;../EBTCTokenTester.sol&quot;;</span>
  20 |     | <span class='neutral'>import &quot;../../Governor.sol&quot;;</span>
  21 |     | <span class='neutral'>import &quot;../../EBTCDeployer.sol&quot;;</span>
  22 |     | <span class='neutral'></span>
  23 |     | <span class='neutral'>import &quot;./Properties.sol&quot;;</span>
  24 |     | <span class='neutral'>import &quot;./Actor.sol&quot;;</span>
  25 |     | <span class='neutral'>import &quot;../BaseStorageVariables.sol&quot;;</span>
  26 |     | <span class='neutral'></span>
  27 |     | <span class='neutral'>abstract contract TargetContractSetup is BaseStorageVariables, PropertiesConstants {</span>
  28 |     | <span class='neutral'>    using SafeMath for uint;</span>
  29 |     | <span class='neutral'></span>
  30 |     | <span class='neutral'>    bytes4 internal constant BURN_SIG = bytes4(keccak256(bytes(&quot;burn(address,uint256)&quot;)));</span>
  31 |     | <span class='neutral'></span>
  32 |     | <span class='neutral'>    uint internal numberOfCdps;</span>
  33 |     | <span class='neutral'></span>
  34 |     | <span class='neutral'>    struct CDPChange {</span>
  35 |     | <span class='neutral'>        uint collAddition;</span>
  36 |     | <span class='neutral'>        uint collReduction;</span>
  37 |     | <span class='neutral'>        uint debtAddition;</span>
  38 |     | <span class='neutral'>        uint debtReduction;</span>
  39 |     | <span class='neutral'>    }</span>
  40 |     | <span class='neutral'></span>
  41 |     | <span class='neutral'>    function _setUp() internal {</span>
  42 |     | <span class='neutral'>        defaultGovernance = address(this);</span>
  43 |     | <span class='neutral'>        ebtcDeployer = new EBTCDeployer();</span>
  44 |     | <span class='neutral'></span>
  45 |     | <span class='neutral'>        // Default governance is deployer</span>
  46 |     | <span class='neutral'>        // vm.prank(defaultGovernance);</span>
  47 |     | <span class='neutral'>        collateral = new CollateralTokenTester();</span>
  48 |     | <span class='neutral'></span>
  49 |     | <span class='neutral'>        EBTCDeployer.EbtcAddresses memory addr = ebtcDeployer.getFutureEbtcAddresses();</span>
  50 |     | <span class='neutral'></span>
  51 |     | <span class='neutral'>        {</span>
  52 |     | <span class='neutral'>            bytes memory creationCode;</span>
  53 |     | <span class='neutral'>            bytes memory args;</span>
  54 |     | <span class='neutral'></span>
  55 |     | <span class='neutral'>            // Use EBTCDeployer to deploy all contracts at determistic addresses</span>
  56 |     | <span class='neutral'></span>
  57 |     | <span class='neutral'>            // Authority</span>
  58 |     | <span class='neutral'>            creationCode = type(Governor).creationCode;</span>
  59 |     | <span class='neutral'>            args = abi.encode(address(this));</span>
  60 |     | <span class='neutral'></span>
  61 |     | <span class='neutral'>            authority = Governor(</span>
  62 |     | <span class='neutral'>                ebtcDeployer.deploy(ebtcDeployer.AUTHORITY(), abi.encodePacked(creationCode, args))</span>
  63 |     | <span class='neutral'>            );</span>
  64 |     | <span class='neutral'></span>
  65 |     | <span class='neutral'>            // Liquidation Library</span>
  66 |     | <span class='neutral'>            creationCode = type(LiquidationLibrary).creationCode;</span>
  67 |     | <span class='neutral'>            args = abi.encode(</span>
  68 |     | <span class='neutral'>                addr.borrowerOperationsAddress,</span>
  69 |     | <span class='neutral'>                addr.collSurplusPoolAddress,</span>
  70 |     | <span class='neutral'>                addr.ebtcTokenAddress,</span>
  71 |     | <span class='neutral'>                addr.sortedCdpsAddress,</span>
  72 |     | <span class='neutral'>                addr.activePoolAddress,</span>
  73 |     | <span class='neutral'>                addr.priceFeedAddress,</span>
  74 |     | <span class='neutral'>                address(collateral)</span>
  75 |     | <span class='neutral'>            );</span>
  76 |     | <span class='neutral'></span>
  77 |     | <span class='neutral'>            liqudationLibrary = LiquidationLibrary(</span>
  78 |     | <span class='neutral'>                ebtcDeployer.deploy(</span>
  79 |     | <span class='neutral'>                    ebtcDeployer.LIQUIDATION_LIBRARY(),</span>
  80 |     | <span class='neutral'>                    abi.encodePacked(creationCode, args)</span>
  81 |     | <span class='neutral'>                )</span>
  82 |     | <span class='neutral'>            );</span>
  83 |     | <span class='neutral'></span>
  84 |     | <span class='neutral'>            // CDP Manager</span>
  85 |     | <span class='neutral'>            /// @audit NOTE: This is the TEST contract!!!</span>
  86 |     | <span class='neutral'>            creationCode = type(AccruableCdpManager).creationCode;</span>
  87 |     | <span class='neutral'>            args = abi.encode(</span>
  88 |     | <span class='neutral'>                addr.liquidationLibraryAddress,</span>
  89 |     | <span class='neutral'>                addr.authorityAddress,</span>
  90 |     | <span class='neutral'>                addr.borrowerOperationsAddress,</span>
  91 |     | <span class='neutral'>                addr.collSurplusPoolAddress,</span>
  92 |     | <span class='neutral'>                addr.ebtcTokenAddress,</span>
  93 |     | <span class='neutral'>                addr.sortedCdpsAddress,</span>
  94 |     | <span class='neutral'>                addr.activePoolAddress,</span>
  95 |     | <span class='neutral'>                addr.priceFeedAddress,</span>
  96 |     | <span class='neutral'>                address(collateral)</span>
  97 |     | <span class='neutral'>            );</span>
  98 |     | <span class='neutral'></span>
  99 |     | <span class='neutral'>            cdpManager = CdpManager(</span>
 100 |     | <span class='neutral'>                ebtcDeployer.deploy(ebtcDeployer.CDP_MANAGER(), abi.encodePacked(creationCode, args))</span>
 101 |     | <span class='neutral'>            );</span>
 102 |     | <span class='neutral'></span>
 103 |     | <span class='neutral'>            // Borrower Operations</span>
 104 |     | <span class='neutral'>            creationCode = type(BorrowerOperations).creationCode;</span>
 105 |     | <span class='neutral'>            args = abi.encode(</span>
 106 |     | <span class='neutral'>                addr.cdpManagerAddress,</span>
 107 |     | <span class='neutral'>                addr.activePoolAddress,</span>
 108 |     | <span class='neutral'>                addr.collSurplusPoolAddress,</span>
 109 |     | <span class='neutral'>                addr.priceFeedAddress,</span>
 110 |     | <span class='neutral'>                addr.sortedCdpsAddress,</span>
 111 |     | <span class='neutral'>                addr.ebtcTokenAddress,</span>
 112 |     | <span class='neutral'>                addr.feeRecipientAddress,</span>
 113 |     | <span class='neutral'>                address(collateral)</span>
 114 |     | <span class='neutral'>            );</span>
 115 |     | <span class='neutral'></span>
 116 |     | <span class='neutral'>            borrowerOperations = BorrowerOperations(</span>
 117 |     | <span class='neutral'>                ebtcDeployer.deploy(</span>
 118 |     | <span class='neutral'>                    ebtcDeployer.BORROWER_OPERATIONS(),</span>
 119 |     | <span class='neutral'>                    abi.encodePacked(creationCode, args)</span>
 120 |     | <span class='neutral'>                )</span>
 121 |     | <span class='neutral'>            );</span>
 122 |     | <span class='neutral'></span>
 123 |     | <span class='neutral'>            priceFeedMock = new PriceFeedTestnet(addr.authorityAddress);</span>
 124 |     | <span class='neutral'></span>
 125 |     | <span class='neutral'>            // Price Feed Mock</span>
 126 |     | <span class='neutral'>            creationCode = type(EbtcFeed).creationCode;</span>
 127 |     | <span class='neutral'>            args = abi.encode(addr.authorityAddress, address(priceFeedMock), address(0));</span>
 128 |     | <span class='neutral'></span>
 129 |     | <span class='neutral'>            ebtcFeed = EbtcFeed(</span>
 130 |     | <span class='neutral'>                ebtcDeployer.deploy(ebtcDeployer.PRICE_FEED(), abi.encodePacked(creationCode, args))</span>
 131 |     | <span class='neutral'>            );</span>
 132 |     | <span class='neutral'></span>
 133 |     | <span class='neutral'>            // Sorted CDPS</span>
 134 |     | <span class='neutral'>            creationCode = type(SortedCdps).creationCode;</span>
 135 |     | <span class='neutral'>            args = abi.encode(</span>
 136 |     | <span class='neutral'>                type(uint256).max,</span>
 137 |     | <span class='neutral'>                addr.cdpManagerAddress,</span>
 138 |     | <span class='neutral'>                addr.borrowerOperationsAddress</span>
 139 |     | <span class='neutral'>            );</span>
 140 |     | <span class='neutral'></span>
 141 |     | <span class='neutral'>            sortedCdps = SortedCdps(</span>
 142 |     | <span class='neutral'>                ebtcDeployer.deploy(ebtcDeployer.SORTED_CDPS(), abi.encodePacked(creationCode, args))</span>
 143 |     | <span class='neutral'>            );</span>
 144 |     | <span class='neutral'></span>
 145 |     | <span class='neutral'>            // Active Pool</span>
 146 |     | <span class='neutral'>            creationCode = type(ActivePool).creationCode;</span>
 147 |     | <span class='neutral'>            args = abi.encode(</span>
 148 |     | <span class='neutral'>                addr.borrowerOperationsAddress,</span>
 149 |     | <span class='neutral'>                addr.cdpManagerAddress,</span>
 150 |     | <span class='neutral'>                address(collateral),</span>
 151 |     | <span class='neutral'>                addr.collSurplusPoolAddress,</span>
 152 |     | <span class='neutral'>                addr.feeRecipientAddress</span>
 153 |     | <span class='neutral'>            );</span>
 154 |     | <span class='neutral'></span>
 155 |     | <span class='neutral'>            activePool = ActivePool(</span>
 156 |     | <span class='neutral'>                ebtcDeployer.deploy(ebtcDeployer.ACTIVE_POOL(), abi.encodePacked(creationCode, args))</span>
 157 |     | <span class='neutral'>            );</span>
 158 |     | <span class='neutral'></span>
 159 |     | <span class='neutral'>            // Coll Surplus Pool</span>
 160 |     | <span class='neutral'>            creationCode = type(CollSurplusPool).creationCode;</span>
 161 |     | <span class='neutral'>            args = abi.encode(</span>
 162 |     | <span class='neutral'>                addr.borrowerOperationsAddress,</span>
 163 |     | <span class='neutral'>                addr.cdpManagerAddress,</span>
 164 |     | <span class='neutral'>                addr.activePoolAddress,</span>
 165 |     | <span class='neutral'>                address(collateral)</span>
 166 |     | <span class='neutral'>            );</span>
 167 |     | <span class='neutral'></span>
 168 |     | <span class='neutral'>            collSurplusPool = CollSurplusPool(</span>
 169 |     | <span class='neutral'>                ebtcDeployer.deploy(</span>
 170 |     | <span class='neutral'>                    ebtcDeployer.COLL_SURPLUS_POOL(),</span>
 171 |     | <span class='neutral'>                    abi.encodePacked(creationCode, args)</span>
 172 |     | <span class='neutral'>                )</span>
 173 |     | <span class='neutral'>            );</span>
 174 |     | <span class='neutral'></span>
 175 |     | <span class='neutral'>            // Hint Helpers</span>
 176 |     | <span class='neutral'>            creationCode = type(HintHelpers).creationCode;</span>
 177 |     | <span class='neutral'>            args = abi.encode(</span>
 178 |     | <span class='neutral'>                addr.sortedCdpsAddress,</span>
 179 |     | <span class='neutral'>                addr.cdpManagerAddress,</span>
 180 |     | <span class='neutral'>                address(collateral),</span>
 181 |     | <span class='neutral'>                addr.activePoolAddress,</span>
 182 |     | <span class='neutral'>                addr.priceFeedAddress</span>
 183 |     | <span class='neutral'>            );</span>
 184 |     | <span class='neutral'></span>
 185 |     | <span class='neutral'>            hintHelpers = HintHelpers(</span>
 186 |     | <span class='neutral'>                ebtcDeployer.deploy(</span>
 187 |     | <span class='neutral'>                    ebtcDeployer.HINT_HELPERS(),</span>
 188 |     | <span class='neutral'>                    abi.encodePacked(creationCode, args)</span>
 189 |     | <span class='neutral'>                )</span>
 190 |     | <span class='neutral'>            );</span>
 191 |     | <span class='neutral'></span>
 192 |     | <span class='neutral'>            // eBTC Token</span>
 193 |     | <span class='neutral'>            creationCode = type(EBTCTokenTester).creationCode;</span>
 194 |     | <span class='neutral'>            args = abi.encode(</span>
 195 |     | <span class='neutral'>                addr.cdpManagerAddress,</span>
 196 |     | <span class='neutral'>                addr.borrowerOperationsAddress,</span>
 197 |     | <span class='neutral'>                addr.authorityAddress</span>
 198 |     | <span class='neutral'>            );</span>
 199 |     | <span class='neutral'></span>
 200 |     | <span class='neutral'>            eBTCToken = EBTCTokenTester(</span>
 201 |     | <span class='neutral'>                ebtcDeployer.deploy(ebtcDeployer.EBTC_TOKEN(), abi.encodePacked(creationCode, args))</span>
 202 |     | <span class='neutral'>            );</span>
 203 |     | <span class='neutral'></span>
 204 |     | <span class='neutral'>            // Fee Recipieint</span>
 205 |     | <span class='neutral'>            creationCode = type(FeeRecipient).creationCode;</span>
 206 |     | <span class='neutral'>            args = abi.encode(</span>
 207 |     | <span class='neutral'>                addr.ebtcTokenAddress,</span>
 208 |     | <span class='neutral'>                addr.cdpManagerAddress,</span>
 209 |     | <span class='neutral'>                addr.borrowerOperationsAddress,</span>
 210 |     | <span class='neutral'>                addr.activePoolAddress,</span>
 211 |     | <span class='neutral'>                address(collateral)</span>
 212 |     | <span class='neutral'>            );</span>
 213 |     | <span class='neutral'></span>
 214 |     | <span class='neutral'>            feeRecipient = FeeRecipient(</span>
 215 |     | <span class='neutral'>                ebtcDeployer.deploy(</span>
 216 |     | <span class='neutral'>                    ebtcDeployer.FEE_RECIPIENT(),</span>
 217 |     | <span class='neutral'>                    abi.encodePacked(creationCode, args)</span>
 218 |     | <span class='neutral'>                )</span>
 219 |     | <span class='neutral'>            );</span>
 220 |     | <span class='neutral'></span>
 221 |     | <span class='neutral'>            // Configure authority</span>
 222 |     | <span class='neutral'>            authority.setRoleName(0, &quot;Admin&quot;);</span>
 223 |     | <span class='neutral'>            authority.setRoleName(1, &quot;eBTCToken: mint&quot;);</span>
 224 |     | <span class='neutral'>            authority.setRoleName(2, &quot;eBTCToken: burn&quot;);</span>
 225 |     | <span class='neutral'>            authority.setRoleName(3, &quot;CDPManager: all&quot;);</span>
 226 |     | <span class='neutral'>            authority.setRoleName(4, &quot;PriceFeed: setTellorCaller&quot;);</span>
 227 |     | <span class='neutral'>            authority.setRoleName(5, &quot;BorrowerOperations: all&quot;);</span>
 228 |     | <span class='neutral'></span>
 229 |     | <span class='neutral'>            authority.setRoleCapability(1, address(eBTCToken), eBTCToken.mint.selector, true);</span>
 230 |     | <span class='neutral'></span>
 231 |     | <span class='neutral'>            authority.setRoleCapability(2, address(eBTCToken), BURN_SIG, true);</span>
 232 |     | <span class='neutral'></span>
 233 |     | <span class='neutral'>            authority.setRoleCapability(</span>
 234 |     | <span class='neutral'>                3,</span>
 235 |     | <span class='neutral'>                address(cdpManager),</span>
 236 |     | <span class='neutral'>                cdpManager.setStakingRewardSplit.selector,</span>
 237 |     | <span class='neutral'>                true</span>
 238 |     | <span class='neutral'>            );</span>
 239 |     | <span class='neutral'>            authority.setRoleCapability(</span>
 240 |     | <span class='neutral'>                3,</span>
 241 |     | <span class='neutral'>                address(cdpManager),</span>
 242 |     | <span class='neutral'>                cdpManager.setRedemptionFeeFloor.selector,</span>
 243 |     | <span class='neutral'>                true</span>
 244 |     | <span class='neutral'>            );</span>
 245 |     | <span class='neutral'>            authority.setRoleCapability(</span>
 246 |     | <span class='neutral'>                3,</span>
 247 |     | <span class='neutral'>                address(cdpManager),</span>
 248 |     | <span class='neutral'>                cdpManager.setMinuteDecayFactor.selector,</span>
 249 |     | <span class='neutral'>                true</span>
 250 |     | <span class='neutral'>            );</span>
 251 |     | <span class='neutral'>            authority.setRoleCapability(3, address(cdpManager), cdpManager.setBeta.selector, true);</span>
 252 |     | <span class='neutral'>            authority.setRoleCapability(</span>
 253 |     | <span class='neutral'>                3,</span>
 254 |     | <span class='neutral'>                address(cdpManager),</span>
 255 |     | <span class='neutral'>                cdpManager.setGracePeriod.selector,</span>
 256 |     | <span class='neutral'>                true</span>
 257 |     | <span class='neutral'>            );</span>
 258 |     | <span class='neutral'>            authority.setRoleCapability(</span>
 259 |     | <span class='neutral'>                3,</span>
 260 |     | <span class='neutral'>                address(cdpManager),</span>
 261 |     | <span class='neutral'>                cdpManager.setRedemptionsPaused.selector,</span>
 262 |     | <span class='neutral'>                true</span>
 263 |     | <span class='neutral'>            );</span>
 264 |     | <span class='neutral'></span>
 265 |     | <span class='neutral'>            authority.setRoleCapability(</span>
 266 |     | <span class='neutral'>                4,</span>
 267 |     | <span class='neutral'>                address(priceFeedMock),</span>
 268 |     | <span class='neutral'>                priceFeedMock.setFallbackCaller.selector,</span>
 269 |     | <span class='neutral'>                true</span>
 270 |     | <span class='neutral'>            );</span>
 271 |     | <span class='neutral'>            authority.setRoleCapability(</span>
 272 |     | <span class='neutral'>                4,</span>
 273 |     | <span class='neutral'>                address(ebtcFeed),</span>
 274 |     | <span class='neutral'>                ebtcFeed.setPrimaryOracle.selector,</span>
 275 |     | <span class='neutral'>                true</span>
 276 |     | <span class='neutral'>            );</span>
 277 |     | <span class='neutral'>            authority.setRoleCapability(</span>
 278 |     | <span class='neutral'>                4,</span>
 279 |     | <span class='neutral'>                address(ebtcFeed),</span>
 280 |     | <span class='neutral'>                ebtcFeed.setSecondaryOracle.selector,</span>
 281 |     | <span class='neutral'>                true</span>
 282 |     | <span class='neutral'>            );</span>
 283 |     | <span class='neutral'></span>
 284 |     | <span class='neutral'>            authority.setRoleCapability(</span>
 285 |     | <span class='neutral'>                5,</span>
 286 |     | <span class='neutral'>                address(borrowerOperations),</span>
 287 |     | <span class='neutral'>                borrowerOperations.setFeeBps.selector,</span>
 288 |     | <span class='neutral'>                true</span>
 289 |     | <span class='neutral'>            );</span>
 290 |     | <span class='neutral'>            authority.setRoleCapability(</span>
 291 |     | <span class='neutral'>                5,</span>
 292 |     | <span class='neutral'>                address(borrowerOperations),</span>
 293 |     | <span class='neutral'>                borrowerOperations.setFlashLoansPaused.selector,</span>
 294 |     | <span class='neutral'>                true</span>
 295 |     | <span class='neutral'>            );</span>
 296 |     | <span class='neutral'></span>
 297 |     | <span class='neutral'>            authority.setRoleCapability(5, address(activePool), activePool.setFeeBps.selector, true);</span>
 298 |     | <span class='neutral'>            authority.setRoleCapability(</span>
 299 |     | <span class='neutral'>                5,</span>
 300 |     | <span class='neutral'>                address(activePool),</span>
 301 |     | <span class='neutral'>                activePool.setFlashLoansPaused.selector,</span>
 302 |     | <span class='neutral'>                true</span>
 303 |     | <span class='neutral'>            );</span>
 304 |     | <span class='neutral'>            authority.setRoleCapability(</span>
 305 |     | <span class='neutral'>                5,</span>
 306 |     | <span class='neutral'>                address(activePool),</span>
 307 |     | <span class='neutral'>                activePool.claimFeeRecipientCollShares.selector,</span>
 308 |     | <span class='neutral'>                true</span>
 309 |     | <span class='neutral'>            );</span>
 310 |     | <span class='neutral'></span>
 311 |     | <span class='neutral'>            authority.setUserRole(defaultGovernance, 0, true);</span>
 312 |     | <span class='neutral'>            authority.setUserRole(defaultGovernance, 1, true);</span>
 313 |     | <span class='neutral'>            authority.setUserRole(defaultGovernance, 2, true);</span>
 314 |     | <span class='neutral'>            authority.setUserRole(defaultGovernance, 3, true);</span>
 315 |     | <span class='neutral'>            authority.setUserRole(defaultGovernance, 4, true);</span>
 316 |     | <span class='neutral'>            authority.setUserRole(defaultGovernance, 5, true);</span>
 317 |     | <span class='neutral'></span>
 318 |     | <span class='neutral'>            crLens = new CRLens(</span>
 319 |     | <span class='neutral'>                address(cdpManager),</span>
 320 |     | <span class='neutral'>                address(borrowerOperations),</span>
 321 |     | <span class='neutral'>                address(priceFeedMock)</span>
 322 |     | <span class='neutral'>            );</span>
 323 |     | <span class='neutral'></span>
 324 |     | <span class='neutral'>            liquidationSequencer = new LiquidationSequencer(</span>
 325 |     | <span class='neutral'>                address(cdpManager),</span>
 326 |     | <span class='neutral'>                address(cdpManager.sortedCdps()),</span>
 327 |     | <span class='neutral'>                address(priceFeedMock),</span>
 328 |     | <span class='neutral'>                address(activePool),</span>
 329 |     | <span class='neutral'>                address(collateral)</span>
 330 |     | <span class='neutral'>            );</span>
 331 |     | <span class='neutral'>            syncedLiquidationSequencer = new SyncedLiquidationSequencer(</span>
 332 |     | <span class='neutral'>                address(cdpManager),</span>
 333 |     | <span class='neutral'>                address(cdpManager.sortedCdps()),</span>
 334 |     | <span class='neutral'>                address(priceFeedMock),</span>
 335 |     | <span class='neutral'>                address(activePool),</span>
 336 |     | <span class='neutral'>                address(collateral)</span>
 337 |     | <span class='neutral'>            );</span>
 338 |     | <span class='neutral'>        }</span>
 339 |     | <span class='neutral'>    }</span>
 340 |     | <span class='neutral'></span>
 341 |     | <span class='neutral'>    event Log(string);</span>
 342 |     | <span class='neutral'></span>
 343 |     | <span class='unexecuted'>    function _setUpFork() internal {</span>
 344 |     | <span class='neutral'>        // NOTE: Addresses from: https://gist.github.com/GalloDaSballo/75d77f8d0837821156fe061d0d8687e1</span>
 345 |     | <span class='unexecuted'>        defaultGovernance = address(0xaDDeE229Bd103bb5B10C3CdB595A01c425dd3264);</span>
 346 |     | <span class='unexecuted'>        ebtcDeployer = EBTCDeployer(0x5c42faC7eEa7e724986bB5e4F3B12912F046120a);</span>
 347 |     | <span class='unexecuted'>        collateral = CollateralTokenTester(payable(0xae7ab96520DE3A18E5e111B5EaAb095312D7fE84)); // stETH</span>
 348 |     | <span class='neutral'>        {</span>
 349 |     | <span class='unexecuted'>            authority = Governor(0x2A095d44831C26cFB6aCb806A6531AE3CA32DBc1);</span>
 350 |     | <span class='unexecuted'>            liqudationLibrary = LiquidationLibrary(0x4Ae990C3b2F7C3961c51483eFba20760946a7681);</span>
 351 |     | <span class='unexecuted'>            cdpManager = CdpManager(0xc4cbaE499bb4Ca41E78f52F07f5d98c375711774);</span>
 352 |     | <span class='unexecuted'>            borrowerOperations = BorrowerOperations(0xd366e016Ae0677CdCE93472e603b75051E022AD0);</span>
 353 |     | <span class='unexecuted'>            eBTCToken = EBTCTokenTester(0x661c70333AA1850CcDBAe82776Bb436A0fCfeEfB);</span>
 354 |     | <span class='unexecuted'>            priceFeedMock = PriceFeedTestnet(address(0xa9a65B1B1dDa8376527E89985b221B6bfCA1Dc9a)); // eBTC Price Feed</span>
 355 |     | <span class='unexecuted'>            activePool = ActivePool(0x6dBDB6D420c110290431E863A1A978AE53F69ebC);</span>
 356 |     | <span class='unexecuted'>            collSurplusPool = CollSurplusPool(0x335982DaE827049d35f09D5ec927De2bc38df3De);</span>
 357 |     | <span class='unexecuted'>            sortedCdps = SortedCdps(0x591AcB5AE192c147948c12651a0a5f24f0529BE3);</span>
 358 |     | <span class='unexecuted'>            hintHelpers = HintHelpers(0x2591554c5EE0b62B8E2725556Cc27744D8C2E7eB);</span>
 359 |     | <span class='unexecuted'>            feeRecipient = FeeRecipient(0xD4D1e77C69E7AA63D0E66a06df89A2AA5d3b1d9E);</span>
 360 |     | <span class='neutral'>            // multiCdpGetter</span>
 361 |     | <span class='neutral'></span>
 362 |     | <span class='unexecuted'>            crLens = new CRLens(</span>
 363 |     | <span class='neutral'>                address(cdpManager),</span>
 364 |     | <span class='neutral'>                address(borrowerOperations),</span>
 365 |     | <span class='neutral'>                address(priceFeedMock)</span>
 366 |     | <span class='neutral'>            );</span>
 367 |     | <span class='neutral'></span>
 368 |     | <span class='neutral'>            // TODO: Contracts ar enot working on forked state</span>
 369 |     | <span class='neutral'>            // Liq should now be working correctly in forked state</span>
 370 |     | <span class='unexecuted'>            liquidationSequencer = new LiquidationSequencer(</span>
 371 |     | <span class='unexecuted'>                address(cdpManager),</span>
 372 |     | <span class='unexecuted'>                address(cdpManager.sortedCdps()),</span>
 373 |     | <span class='unexecuted'>                address(priceFeedMock),</span>
 374 |     | <span class='unexecuted'>                address(activePool),</span>
 375 |     | <span class='unexecuted'>                address(collateral)</span>
 376 |     | <span class='neutral'>            );</span>
 377 |     | <span class='neutral'></span>
 378 |     | <span class='unexecuted'>            syncedLiquidationSequencer = new SyncedLiquidationSequencer(</span>
 379 |     | <span class='unexecuted'>                address(cdpManager),</span>
 380 |     | <span class='unexecuted'>                address(cdpManager.sortedCdps()),</span>
 381 |     | <span class='unexecuted'>                address(priceFeedMock),</span>
 382 |     | <span class='unexecuted'>                address(activePool),</span>
 383 |     | <span class='unexecuted'>                address(collateral)</span>
 384 |     | <span class='neutral'>            );</span>
 385 |     | <span class='neutral'>        }</span>
 386 |     | <span class='neutral'>    }</span>
 387 |     | <span class='neutral'></span>
 388 |     | <span class='neutral'>    function _setUpActors() internal {</span>
 389 |     | <span class='neutral'>        bool success;</span>
 390 |     | <span class='neutral'>        address[] memory tokens = new address[](2);</span>
 391 |     | <span class='neutral'>        tokens[0] = address(eBTCToken);</span>
 392 |     | <span class='neutral'>        tokens[1] = address(collateral);</span>
 393 |     | <span class='neutral'>        address[] memory callers = new address[](2);</span>
 394 |     | <span class='neutral'>        callers[0] = address(borrowerOperations);</span>
 395 |     | <span class='neutral'>        callers[1] = address(activePool);</span>
 396 |     | <span class='neutral'>        address[] memory addresses = new address[](3);</span>
 397 |     | <span class='neutral'>        addresses[0] = USER1;</span>
 398 |     | <span class='neutral'>        addresses[1] = USER2;</span>
 399 |     | <span class='neutral'>        addresses[2] = USER3;</span>
 400 |     | <span class='neutral'>        Actor[] memory actorsArray = new Actor[](NUMBER_OF_ACTORS);</span>
 401 |     | <span class='neutral'>        for (uint i = 0; i &lt; NUMBER_OF_ACTORS; i++) {</span>
 402 |     | <span class='neutral'>            actors[addresses[i]] = new Actor(tokens, callers);</span>
 403 |     | <span class='neutral'>            (success, ) = address(actors[addresses[i]]).call{value: INITIAL_ETH_BALANCE}(&quot;&quot;);</span>
 404 |     | <span class='neutral'>            assert(success);</span>
 405 |     | <span class='neutral'>            (success, ) = actors[addresses[i]].proxy(</span>
 406 |     | <span class='neutral'>                address(collateral),</span>
 407 |     | <span class='neutral'>                abi.encodeWithSelector(CollateralTokenTester.deposit.selector, &quot;&quot;),</span>
 408 |     | <span class='neutral'>                INITIAL_COLL_BALANCE</span>
 409 |     | <span class='neutral'>            );</span>
 410 |     | <span class='neutral'>            assert(success);</span>
 411 |     | <span class='neutral'>            assert(collateral.balanceOf(address(actors[addresses[i]])) &gt; 0);</span>
 412 |     | <span class='neutral'>            actorsArray[i] = actors[addresses[i]];</span>
 413 |     | <span class='neutral'>        }</span>
 414 |     | <span class='neutral'>        simulator = new Simulator(actorsArray, cdpManager, sortedCdps, borrowerOperations);</span>
 415 |     | <span class='neutral'>    }</span>
 416 |     | <span class='neutral'></span>
 417 |     | <span class='unexecuted'>    function _setUpActorsFork() internal {</span>
 418 |     | <span class='unexecuted'>        bool success;</span>
 419 |     | <span class='unexecuted'>        address[] memory tokens = new address[](2);</span>
 420 |     | <span class='unexecuted'>        tokens[0] = address(eBTCToken);</span>
 421 |     | <span class='unexecuted'>        tokens[1] = address(collateral);</span>
 422 |     | <span class='unexecuted'>        address[] memory callers = new address[](2);</span>
 423 |     | <span class='unexecuted'>        callers[0] = address(borrowerOperations);</span>
 424 |     | <span class='unexecuted'>        callers[1] = address(activePool);</span>
 425 |     | <span class='unexecuted'>        address[] memory addresses = new address[](3);</span>
 426 |     | <span class='unexecuted'>        addresses[0] = USER1;</span>
 427 |     | <span class='unexecuted'>        addresses[1] = USER2;</span>
 428 |     | <span class='unexecuted'>        addresses[2] = USER3;</span>
 429 |     | <span class='unexecuted'>        Actor[] memory actorsArray = new Actor[](NUMBER_OF_ACTORS);</span>
 430 |     | <span class='unexecuted'>        for (uint i = 0; i &lt; NUMBER_OF_ACTORS; i++) {</span>
 431 |     | <span class='unexecuted'>            actors[addresses[i]] = new Actor(tokens, callers);</span>
 432 |     | <span class='unexecuted'>            (success, ) = address(actors[addresses[i]]).call{value: INITIAL_ETH_BALANCE}(&quot;&quot;);</span>
 433 |     | <span class='unexecuted'>            assert(success);</span>
 434 |     | <span class='unexecuted'>            (success, ) = actors[addresses[i]].proxy(</span>
 435 |     | <span class='unexecuted'>                address(collateral),</span>
 436 |     | <span class='unexecuted'>                abi.encodeWithSignature(&quot;submit(address)&quot;, address(0)),</span>
 437 |     | <span class='neutral'>                INITIAL_COLL_BALANCE</span>
 438 |     | <span class='neutral'>            );</span>
 439 |     | <span class='unexecuted'>            assert(success);</span>
 440 |     | <span class='unexecuted'>            assert(collateral.balanceOf(address(actors[addresses[i]])) &gt; 0);</span>
 441 |     | <span class='unexecuted'>            actorsArray[i] = actors[addresses[i]];</span>
 442 |     | <span class='neutral'>        }</span>
 443 |     | <span class='unexecuted'>        simulator = new Simulator(actorsArray, cdpManager, sortedCdps, borrowerOperations);</span>
 444 |     | <span class='neutral'></span>
 445 |     | <span class='neutral'>        // Make sure there is always an actor for any actor related calls in setup to be successful</span>
 446 |     | <span class='unexecuted'>        actor = actors[addresses[0]];</span>
 447 |     | <span class='neutral'>    }</span>
 448 |     | <span class='neutral'></span>
 449 |     | <span class='neutral'>    // Simple canaries for fork health</span>
 450 |     | <span class='neutral'>    function _setUpCanaries() internal {</span>
 451 |     | <span class='neutral'>        try cdpManager.totalStakes() {} catch {</span>
 452 |     | <span class='neutral'>            assert(false);</span>
 453 |     | <span class='neutral'>        }</span>
 454 |     | <span class='neutral'></span>
 455 |     | <span class='neutral'>        assert(cdpManager.getSystemDebt() &gt; 0);</span>
 456 |     | <span class='neutral'>    }</span>
 457 |     | <span class='neutral'></span>
 458 |     | <span class='neutral'>    function _syncSystemDebtTwapToSpotValue() internal {</span>
 459 |     | <span class='neutral'>        hevm.warp(block.timestamp + activePool.PERIOD());</span>
 460 |     | <span class='neutral'>        activePool.update();</span>
 461 |     | <span class='neutral'>    }</span>
 462 |     | <span class='neutral'></span>
 463 |     | <span class='neutral'>    function _openWhaleCdpAndTransferEBTC() internal {</span>
 464 |     | <span class='neutral'>        bool success;</span>
 465 |     | <span class='neutral'>        Actor actor = actors[USER3]; // USER3 is the whale CDP holder</span>
 466 |     | <span class='neutral'>        uint256 _col = INITIAL_COLL_BALANCE / 2; // 50% of their initial collateral balance</span>
 467 |     | <span class='neutral'></span>
 468 |     | <span class='neutral'>        uint256 price = priceFeedMock.getPrice();</span>
 469 |     | <span class='neutral'>        uint256 _EBTCAmount = (_col * price) / cdpManager.CCR();</span>
 470 |     | <span class='neutral'></span>
 471 |     | <span class='neutral'>        (success, ) = actor.proxy(</span>
 472 |     | <span class='neutral'>            address(collateral),</span>
 473 |     | <span class='neutral'>            abi.encodeWithSelector(</span>
 474 |     | <span class='neutral'>                CollateralTokenTester.approve.selector,</span>
 475 |     | <span class='neutral'>                address(borrowerOperations),</span>
 476 |     | <span class='neutral'>                _col</span>
 477 |     | <span class='neutral'>            )</span>
 478 |     | <span class='neutral'>        );</span>
 479 |     | <span class='neutral'>        assert(success);</span>
 480 |     | <span class='neutral'>        (success, ) = actor.proxy(</span>
 481 |     | <span class='neutral'>            address(borrowerOperations),</span>
 482 |     | <span class='neutral'>            abi.encodeWithSelector(</span>
 483 |     | <span class='neutral'>                BorrowerOperations.openCdp.selector,</span>
 484 |     | <span class='neutral'>                _EBTCAmount,</span>
 485 |     | <span class='neutral'>                bytes32(0),</span>
 486 |     | <span class='neutral'>                bytes32(0),</span>
 487 |     | <span class='neutral'>                _col</span>
 488 |     | <span class='neutral'>            )</span>
 489 |     | <span class='neutral'>        );</span>
 490 |     | <span class='neutral'>        assert(success);</span>
 491 |     | <span class='neutral'>        address[] memory addresses = new address[](2);</span>
 492 |     | <span class='neutral'>        addresses[0] = USER1;</span>
 493 |     | <span class='neutral'>        addresses[1] = USER2;</span>
 494 |     | <span class='neutral'>        for (uint i = 0; i &lt; addresses.length; i++) {</span>
 495 |     | <span class='neutral'>            (success, ) = actor.proxy(</span>
 496 |     | <span class='neutral'>                address(eBTCToken),</span>
 497 |     | <span class='neutral'>                abi.encodeWithSelector(</span>
 498 |     | <span class='neutral'>                    eBTCToken.transfer.selector,</span>
 499 |     | <span class='neutral'>                    actors[addresses[i]],</span>
 500 |     | <span class='neutral'>                    _EBTCAmount / 3</span>
 501 |     | <span class='neutral'>                )</span>
 502 |     | <span class='neutral'>            );</span>
 503 |     | <span class='neutral'>            assert(success);</span>
 504 |     | <span class='neutral'>        }</span>
 505 |     | <span class='neutral'>    }</span>
 506 |     | <span class='neutral'>}</span>
 507 |     | <span class='neutral'></span>

</code>
<br />

<b>/mnt/c/Users/Lourens/Documents/Recon-Fuzz/collabs/ebtc/packages/contracts/contracts/TestContracts/invariants/TargetFunctions.sol</b>
<code>
    1 |     | <span class='neutral'>// SPDX-License-Identifier: MIT</span>
    2 |     | <span class='neutral'></span>
    3 |     | <span class='neutral'>pragma solidity 0.8.17;</span>
    4 |     | <span class='neutral'></span>
    5 |     | <span class='neutral'>import &quot;@crytic/properties/contracts/util/Hevm.sol&quot;;</span>
    6 |     | <span class='neutral'></span>
    7 |     | <span class='neutral'>import &quot;../../Interfaces/ICdpManagerData.sol&quot;;</span>
    8 |     | <span class='neutral'>import &quot;../../Dependencies/SafeMath.sol&quot;;</span>
    9 |     | <span class='neutral'>import &quot;../../CdpManager.sol&quot;;</span>
   10 |     | <span class='neutral'>import &quot;../../LiquidationLibrary.sol&quot;;</span>
   11 |     | <span class='neutral'>import &quot;../../BorrowerOperations.sol&quot;;</span>
   12 |     | <span class='neutral'>import &quot;../../ActivePool.sol&quot;;</span>
   13 |     | <span class='neutral'>import &quot;../../CollSurplusPool.sol&quot;;</span>
   14 |     | <span class='neutral'>import &quot;../../SortedCdps.sol&quot;;</span>
   15 |     | <span class='neutral'>import &quot;../../HintHelpers.sol&quot;;</span>
   16 |     | <span class='neutral'>import &quot;../../FeeRecipient.sol&quot;;</span>
   17 |     | <span class='neutral'>import &quot;../testnet/PriceFeedTestnet.sol&quot;;</span>
   18 |     | <span class='neutral'>import &quot;../CollateralTokenTester.sol&quot;;</span>
   19 |     | <span class='neutral'>import &quot;../EBTCTokenTester.sol&quot;;</span>
   20 |     | <span class='neutral'>import &quot;../../Governor.sol&quot;;</span>
   21 |     | <span class='neutral'>import &quot;../../EBTCDeployer.sol&quot;;</span>
   22 |     | <span class='neutral'></span>
   23 |     | <span class='neutral'>import &quot;./Properties.sol&quot;;</span>
   24 |     | <span class='neutral'>import &quot;./Actor.sol&quot;;</span>
   25 |     | <span class='neutral'>import &quot;./BeforeAfter.sol&quot;;</span>
   26 |     | <span class='neutral'>import &quot;./TargetContractSetup.sol&quot;;</span>
   27 |     | <span class='neutral'>import &quot;./Asserts.sol&quot;;</span>
   28 |     | <span class='neutral'>import &quot;../BaseStorageVariables.sol&quot;;</span>
   29 |     | <span class='neutral'></span>
   30 |     | <span class='neutral'>abstract contract TargetFunctions is Properties {</span>
   31 |     | <span class='neutral'>    modifier setup() virtual {</span>
   32 | *   | <span class='executed'>        actor = actors[msg.sender];</span>
   33 |     | <span class='neutral'>        _;</span>
   34 |     | <span class='neutral'>    }</span>
   35 |     | <span class='neutral'></span>
   36 |     | <span class='neutral'>    ///////////////////////////////////////////////////////</span>
   37 |     | <span class='neutral'>    // Helper functions</span>
   38 |     | <span class='neutral'>    ///////////////////////////////////////////////////////</span>
   39 |     | <span class='neutral'></span>
   40 |     | <span class='neutral'>    function _totalCdpsBelowMcr() internal returns (uint256) {</span>
   41 |     | <span class='neutral'>        uint256 ans;</span>
   42 |     | <span class='neutral'>        bytes32 currentCdp = sortedCdps.getFirst();</span>
   43 |     | <span class='neutral'></span>
   44 |     | <span class='neutral'>        uint256 _price = priceFeedMock.fetchPrice();</span>
   45 |     | <span class='neutral'></span>
   46 |     | <span class='neutral'>        while (currentCdp != bytes32(0)) {</span>
   47 |     | <span class='neutral'>            if (cdpManager.getCachedICR(currentCdp, _price) &lt; cdpManager.MCR()) {</span>
   48 |     | <span class='neutral'>                ++ans;</span>
   49 |     | <span class='neutral'>            }</span>
   50 |     | <span class='neutral'></span>
   51 |     | <span class='neutral'>            currentCdp = sortedCdps.getNext(currentCdp);</span>
   52 |     | <span class='neutral'>        }</span>
   53 |     | <span class='neutral'></span>
   54 |     | <span class='neutral'>        return ans;</span>
   55 |     | <span class='neutral'>    }</span>
   56 |     | <span class='neutral'></span>
   57 | *   | <span class='executed'>    function _getCdpIdsAndICRs() internal returns (Cdp[] memory ans) {</span>
   58 | *   | <span class='executed'>        ans = new Cdp[](sortedCdps.getSize());</span>
   59 | *   | <span class='executed'>        uint256 i = 0;</span>
   60 | *   | <span class='executed'>        bytes32 currentCdp = sortedCdps.getFirst();</span>
   61 |     | <span class='neutral'></span>
   62 | *   | <span class='executed'>        uint256 _price = priceFeedMock.fetchPrice();</span>
   63 |     | <span class='neutral'></span>
   64 | *   | <span class='executed'>        while (currentCdp != bytes32(0)) {</span>
   65 | *   | <span class='executed'>            uint256 _currentCdpDebt = cdpManager.getSyncedCdpDebt(currentCdp);</span>
   66 | *   | <span class='executed'>            ans[i++] = Cdp({id: currentCdp, icr: cdpManager.getSyncedICR(currentCdp, _price)}); /// @audit NOTE: Synced to ensure it&#39;s realistic</span>
   67 |     | <span class='neutral'></span>
   68 | *   | <span class='executed'>            currentCdp = sortedCdps.getNext(currentCdp);</span>
   69 |     | <span class='neutral'>        }</span>
   70 |     | <span class='neutral'>    }</span>
   71 |     | <span class='neutral'></span>
   72 | *   | <span class='executed'>    function _cdpIdsAndICRsDiff(</span>
   73 |     | <span class='neutral'>        Cdp[] memory superset,</span>
   74 |     | <span class='neutral'>        Cdp[] memory subset</span>
   75 | *   | <span class='executed'>    ) internal returns (Cdp[] memory ans) {</span>
   76 | *   | <span class='executed'>        ans = new Cdp[](superset.length - subset.length);</span>
   77 | *   | <span class='executed'>        uint256 index = 0;</span>
   78 | *   | <span class='executed'>        for (uint256 i = 0; i &lt; superset.length; i++) {</span>
   79 | *   | <span class='executed'>            bool duplicate = false;</span>
   80 | *   | <span class='executed'>            for (uint256 j = 0; j &lt; subset.length; j++) {</span>
   81 | *   | <span class='executed'>                if (superset[i].id == subset[j].id) {</span>
   82 | *   | <span class='executed'>                    duplicate = true;</span>
   83 |     | <span class='neutral'>                }</span>
   84 |     | <span class='neutral'>            }</span>
   85 | *   | <span class='executed'>            if (!duplicate) {</span>
   86 | *   | <span class='executed'>                ans[index++] = superset[i];</span>
   87 |     | <span class='neutral'>            }</span>
   88 |     | <span class='neutral'>        }</span>
   89 |     | <span class='neutral'>    }</span>
   90 |     | <span class='neutral'></span>
   91 | *   | <span class='executed'>    function _getRandomCdp(uint _i) internal view returns (bytes32) {</span>
   92 | *   | <span class='executed'>        uint _cdpIdx = _i % cdpManager.getActiveCdpsCount();</span>
   93 | *   | <span class='executed'>        bytes32[] memory cdpIds = hintHelpers.sortedCdpsToArray();</span>
   94 | *   | <span class='executed'>        return cdpIds[_cdpIdx];</span>
   95 |     | <span class='neutral'>    }</span>
   96 |     | <span class='neutral'></span>
   97 |     | <span class='neutral'>    event FlashLoanAction(uint, uint);</span>
   98 |     | <span class='neutral'></span>
   99 | *   | <span class='executed'>    function _getFlashLoanActions(uint256 value) internal returns (bytes memory) {</span>
  100 | *   | <span class='executed'>        uint256 _actions = between(value, 1, MAX_FLASHLOAN_ACTIONS);</span>
  101 | *   | <span class='executed'>        uint256 _EBTCAmount = between(value, 1, eBTCToken.totalSupply() / 2);</span>
  102 | *   | <span class='executed'>        uint256 _col = between(value, 1, cdpManager.getSystemCollShares() / 2);</span>
  103 | *   | <span class='executed'>        uint256 _n = between(value, 1, cdpManager.getActiveCdpsCount());</span>
  104 |     | <span class='neutral'></span>
  105 | *   | <span class='executed'>        uint256 numberOfCdps = sortedCdps.cdpCountOf(address(actor));</span>
  106 | *   | <span class='executed'>        require(numberOfCdps &gt; 0, &quot;Actor must have at least one CDP open&quot;);</span>
  107 | *   | <span class='executed'>        uint256 _i = between(value, 0, numberOfCdps - 1);</span>
  108 | *   | <span class='executed'>        bytes32 _cdpId = sortedCdps.cdpOfOwnerByIndex(address(actor), _i);</span>
  109 | *   | <span class='executed'>        t(_cdpId != bytes32(0), &quot;CDP ID must not be null if the index is valid&quot;);</span>
  110 |     | <span class='neutral'></span>
  111 | *   | <span class='executed'>        address[] memory _targets = new address[](_actions);</span>
  112 | *   | <span class='executed'>        bytes[] memory _calldatas = new bytes[](_actions);</span>
  113 |     | <span class='neutral'></span>
  114 | *   | <span class='executed'>        address[] memory _allTargets = new address[](6);</span>
  115 | *   | <span class='executed'>        bytes[] memory _allCalldatas = new bytes[](6);</span>
  116 |     | <span class='neutral'></span>
  117 | *   | <span class='executed'>        _allTargets[0] = address(borrowerOperations);</span>
  118 | *   | <span class='executed'>        _allCalldatas[0] = abi.encodeWithSelector(</span>
  119 |     | <span class='neutral'>            BorrowerOperations.openCdp.selector,</span>
  120 |     | <span class='neutral'>            _EBTCAmount,</span>
  121 | *   | <span class='executed'>            bytes32(0),</span>
  122 |     | <span class='neutral'>            bytes32(0),</span>
  123 |     | <span class='neutral'>            _col</span>
  124 |     | <span class='neutral'>        );</span>
  125 |     | <span class='neutral'></span>
  126 | *   | <span class='executed'>        _allTargets[1] = address(borrowerOperations);</span>
  127 | *   | <span class='executed'>        _allCalldatas[1] = abi.encodeWithSelector(BorrowerOperations.closeCdp.selector, _cdpId);</span>
  128 |     | <span class='neutral'></span>
  129 | *   | <span class='executed'>        _allTargets[2] = address(borrowerOperations);</span>
  130 | *   | <span class='executed'>        _allCalldatas[2] = abi.encodeWithSelector(</span>
  131 |     | <span class='neutral'>            BorrowerOperations.addColl.selector,</span>
  132 |     | <span class='neutral'>            _cdpId,</span>
  133 |     | <span class='neutral'>            _cdpId,</span>
  134 |     | <span class='neutral'>            _cdpId,</span>
  135 |     | <span class='neutral'>            _col</span>
  136 |     | <span class='neutral'>        );</span>
  137 |     | <span class='neutral'></span>
  138 | *   | <span class='executed'>        _allTargets[3] = address(borrowerOperations);</span>
  139 | *   | <span class='executed'>        _allCalldatas[3] = abi.encodeWithSelector(</span>
  140 |     | <span class='neutral'>            BorrowerOperations.withdrawColl.selector,</span>
  141 |     | <span class='neutral'>            _cdpId,</span>
  142 |     | <span class='neutral'>            _col,</span>
  143 |     | <span class='neutral'>            _cdpId,</span>
  144 |     | <span class='neutral'>            _cdpId</span>
  145 |     | <span class='neutral'>        );</span>
  146 |     | <span class='neutral'></span>
  147 | *   | <span class='executed'>        _allTargets[4] = address(borrowerOperations);</span>
  148 | *   | <span class='executed'>        _allCalldatas[4] = abi.encodeWithSelector(</span>
  149 |     | <span class='neutral'>            BorrowerOperations.withdrawDebt.selector,</span>
  150 |     | <span class='neutral'>            _cdpId,</span>
  151 |     | <span class='neutral'>            _EBTCAmount,</span>
  152 |     | <span class='neutral'>            _cdpId,</span>
  153 |     | <span class='neutral'>            _cdpId</span>
  154 |     | <span class='neutral'>        );</span>
  155 |     | <span class='neutral'></span>
  156 | *   | <span class='executed'>        _allTargets[5] = address(borrowerOperations);</span>
  157 | *   | <span class='executed'>        _allCalldatas[5] = abi.encodeWithSelector(</span>
  158 |     | <span class='neutral'>            BorrowerOperations.repayDebt.selector,</span>
  159 |     | <span class='neutral'>            _cdpId,</span>
  160 |     | <span class='neutral'>            _EBTCAmount,</span>
  161 |     | <span class='neutral'>            _cdpId,</span>
  162 |     | <span class='neutral'>            _cdpId</span>
  163 |     | <span class='neutral'>        );</span>
  164 |     | <span class='neutral'></span>
  165 | *   | <span class='executed'>        for (uint256 _j = 0; _j &lt; _actions; ++_j) {</span>
  166 | *   | <span class='executed'>            _i = uint256(keccak256(abi.encodePacked(value, _j, _i))) % _allTargets.length;</span>
  167 | *   | <span class='executed'>            emit FlashLoanAction(_j, _i);</span>
  168 |     | <span class='neutral'></span>
  169 | *   | <span class='executed'>            _targets[_j] = _allTargets[_i];</span>
  170 | *   | <span class='executed'>            _calldatas[_j] = _allCalldatas[_i];</span>
  171 |     | <span class='neutral'>        }</span>
  172 |     | <span class='neutral'></span>
  173 | *   | <span class='executed'>        return abi.encode(_targets, _calldatas);</span>
  174 |     | <span class='neutral'>    }</span>
  175 |     | <span class='neutral'></span>
  176 | *   | <span class='executed'>    function _getFirstCdpWithIcrGteMcr() internal returns (bytes32) {</span>
  177 | *   | <span class='executed'>        bytes32 _cId = sortedCdps.getLast();</span>
  178 | *   | <span class='executed'>        address currentBorrower = sortedCdps.getOwnerAddress(_cId);</span>
  179 |     | <span class='neutral'>        // Find the first cdp with ICR &gt;= MCR</span>
  180 | *   | <span class='executed'>        while (</span>
  181 | *   | <span class='executed'>            currentBorrower != address(0) &amp;&amp;</span>
  182 | *   | <span class='executed'>            cdpManager.getCachedICR(_cId, priceFeedMock.fetchPrice()) &lt; cdpManager.MCR()</span>
  183 |     | <span class='neutral'>        ) {</span>
  184 | *   | <span class='executed'>            _cId = sortedCdps.getPrev(_cId);</span>
  185 | *   | <span class='executed'>            currentBorrower = sortedCdps.getOwnerAddress(_cId);</span>
  186 |     | <span class='neutral'>        }</span>
  187 | *   | <span class='executed'>        return _cId;</span>
  188 |     | <span class='neutral'>    }</span>
  189 |     | <span class='neutral'></span>
  190 | *   | <span class='executed'>    function _atLeastOneCdpIsLiquidatable(</span>
  191 |     | <span class='neutral'>        Cdp[] memory cdps,</span>
  192 |     | <span class='neutral'>        bool isRecoveryModeBefore</span>
  193 | *   | <span class='executed'>    ) internal view returns (bool atLeastOneCdpIsLiquidatable) {</span>
  194 | *   | <span class='executed'>        for (uint256 i = 0; i &lt; cdps.length; ++i) {</span>
  195 | *   | <span class='executed'>            if (</span>
  196 | *   | <span class='executed'>                cdps[i].icr &lt; cdpManager.MCR() ||</span>
  197 | *   | <span class='executed'>                (cdps[i].icr &lt; cdpManager.CCR() &amp;&amp; isRecoveryModeBefore)</span>
  198 |     | <span class='neutral'>            ) {</span>
  199 | *   | <span class='executed'>                atLeastOneCdpIsLiquidatable = true;</span>
  200 | *   | <span class='executed'>                break;</span>
  201 |     | <span class='neutral'>            }</span>
  202 |     | <span class='neutral'>        }</span>
  203 |     | <span class='neutral'>    }</span>
  204 |     | <span class='neutral'></span>
  205 |     | <span class='neutral'>    ///////////////////////////////////////////////////////</span>
  206 |     | <span class='neutral'>    // CdpManager</span>
  207 |     | <span class='neutral'>    ///////////////////////////////////////////////////////</span>
  208 |     | <span class='neutral'></span>
  209 | *   | <span class='executed'>    function _checkL_15IfRecoveryMode() internal {</span>
  210 | *   | <span class='executed'>        if (vars.isRecoveryModeAfter) {</span>
  211 | *   | <span class='executed'>            t(vars.lastGracePeriodStartTimestampIsSetAfter, L_15);</span>
  212 |     | <span class='neutral'>        }</span>
  213 |     | <span class='neutral'>    }</span>
  214 |     | <span class='neutral'></span>
  215 | *   | <span class='executed'>    function liquidate(uint _i) public setup {</span>
  216 |     | <span class='neutral'>        bool success;</span>
  217 | *   | <span class='executed'>        bytes memory returnData;</span>
  218 |     | <span class='neutral'></span>
  219 | *   | <span class='executed'>        require(cdpManager.getActiveCdpsCount() &gt; 1, &quot;Cannot liquidate last CDP&quot;);</span>
  220 |     | <span class='neutral'></span>
  221 | *   | <span class='executed'>        bytes32 _cdpId = _getRandomCdp(_i);</span>
  222 |     | <span class='neutral'></span>
  223 | *   | <span class='executed'>        (uint256 entireDebt, ) = cdpManager.getSyncedDebtAndCollShares(_cdpId);</span>
  224 | *   | <span class='executed'>        require(entireDebt &gt; 0, &quot;CDP must have debt&quot;);</span>
  225 |     | <span class='neutral'></span>
  226 | *   | <span class='executed'>        _before(_cdpId);</span>
  227 |     | <span class='neutral'></span>
  228 |     | <span class='unexecuted'>        uint256 _icrToLiq = cdpManager.getSyncedICR(_cdpId, priceFeedMock.getPrice());</span>
  229 |     | <span class='neutral'></span>
  230 |     | <span class='unexecuted'>        (success, returnData) = actor.proxy(</span>
  231 |     | <span class='unexecuted'>            address(cdpManager),</span>
  232 |     | <span class='unexecuted'>            abi.encodeWithSelector(CdpManager.liquidate.selector, _cdpId)</span>
  233 |     | <span class='neutral'>        );</span>
  234 |     | <span class='neutral'></span>
  235 |     | <span class='unexecuted'>        _after(_cdpId);</span>
  236 |     | <span class='neutral'></span>
  237 |     | <span class='unexecuted'>        if (success) {</span>
  238 |     | <span class='neutral'>            // SURPLUS-CHECK-1 | The surplus is capped at 4 wei | NOTE: Proxy of growth, storage var would further refine</span>
  239 |     | <span class='unexecuted'>            if (_icrToLiq &lt;= cdpManager.MCR()) {</span>
  240 | *   | <span class='executed'>                gte(</span>
  241 | *   | <span class='executed'>                    vars.collSurplusPoolBefore + 12,</span>
  242 | *   | <span class='executed'>                    vars.collSurplusPoolAfter,</span>
  243 |     | <span class='neutral'>                    &quot;SURPLUS-CHECK-1_12&quot;</span>
  244 |     | <span class='neutral'>                );</span>
  245 |     | <span class='unexecuted'>                gte(vars.userSurplusBefore + 12, vars.userSurplusAfter, &quot;SURPLUS-CHECK-2_12&quot;);</span>
  246 |     | <span class='neutral'></span>
  247 | *   | <span class='executed'>                gte(vars.collSurplusPoolBefore + 8, vars.collSurplusPoolAfter, &quot;SURPLUS-CHECK-1_8&quot;);</span>
  248 |     | <span class='unexecuted'>                gte(vars.userSurplusBefore + 8, vars.userSurplusAfter, &quot;SURPLUS-CHECK-2_8&quot;);</span>
  249 |     | <span class='neutral'></span>
  250 | *   | <span class='executed'>                gte(vars.collSurplusPoolBefore + 4, vars.collSurplusPoolAfter, &quot;SURPLUS-CHECK-1_4&quot;);</span>
  251 |     | <span class='unexecuted'>                gte(vars.userSurplusBefore + 4, vars.userSurplusAfter, &quot;SURPLUS-CHECK-2_4&quot;);</span>
  252 |     | <span class='neutral'>            }</span>
  253 |     | <span class='neutral'></span>
  254 |     | <span class='neutral'>            // if ICR &gt;= TCR then we ignore</span>
  255 |     | <span class='neutral'>            // We could check that Liquidated is not above TCR</span>
  256 |     | <span class='unexecuted'>            if (</span>
  257 |     | <span class='unexecuted'>                vars.newIcrBefore &gt;= cdpManager.LICR() // 103% else liquidating locks in bad debt</span>
  258 |     | <span class='neutral'>            ) {</span>
  259 |     | <span class='neutral'>                // https://github.com/Badger-Finance/ebtc-fuzz-review/issues/5</span>
  260 |     | <span class='unexecuted'>                if (vars.newIcrBefore &lt;= vars.newTcrBefore) {</span>
  261 |     | <span class='unexecuted'>                    gte(vars.newTcrAfter, vars.newTcrBefore, L_12);</span>
  262 |     | <span class='neutral'>                }</span>
  263 |     | <span class='neutral'>            }</span>
  264 |     | <span class='neutral'>            // https://github.com/Badger-Finance/ebtc-fuzz-review/issues/12</span>
  265 |     | <span class='unexecuted'>            t(</span>
  266 |     | <span class='unexecuted'>                vars.newIcrBefore &lt; cdpManager.MCR() ||</span>
  267 |     | <span class='unexecuted'>                    (vars.newIcrBefore &lt; cdpManager.CCR() &amp;&amp; vars.isRecoveryModeBefore),</span>
  268 |     | <span class='unexecuted'>                L_01</span>
  269 |     | <span class='neutral'>            );</span>
  270 |     | <span class='unexecuted'>            if (</span>
  271 |     | <span class='unexecuted'>                vars.lastGracePeriodStartTimestampIsSetBefore &amp;&amp;</span>
  272 |     | <span class='unexecuted'>                vars.isRecoveryModeBefore &amp;&amp;</span>
  273 |     | <span class='unexecuted'>                vars.isRecoveryModeAfter</span>
  274 |     | <span class='neutral'>            ) {</span>
  275 |     | <span class='unexecuted'>                eq(</span>
  276 |     | <span class='unexecuted'>                    vars.lastGracePeriodStartTimestampBefore,</span>
  277 |     | <span class='unexecuted'>                    vars.lastGracePeriodStartTimestampAfter,</span>
  278 |     | <span class='unexecuted'>                    L_14</span>
  279 |     | <span class='neutral'>                );</span>
  280 |     | <span class='neutral'>            }</span>
  281 |     | <span class='neutral'></span>
  282 |     | <span class='unexecuted'>            _checkL_15IfRecoveryMode();</span>
  283 |     | <span class='neutral'></span>
  284 |     | <span class='unexecuted'>            if (vars.isRecoveryModeBefore &amp;&amp; !vars.isRecoveryModeAfter) {</span>
  285 |     | <span class='unexecuted'>                t(!vars.lastGracePeriodStartTimestampIsSetAfter, L_16);</span>
  286 |     | <span class='neutral'>            }</span>
  287 |     | <span class='neutral'></span>
  288 |     | <span class='unexecuted'>            gte(</span>
  289 |     | <span class='unexecuted'>                vars.actorCollAfter,</span>
  290 |     | <span class='unexecuted'>                vars.actorCollBefore +</span>
  291 |     | <span class='unexecuted'>                    collateral.getPooledEthByShares(vars.liquidatorRewardSharesBefore),</span>
  292 |     | <span class='unexecuted'>                L_09</span>
  293 |     | <span class='neutral'>            );</span>
  294 |     | <span class='neutral'></span>
  295 |     | <span class='unexecuted'>            if (_icrToLiq &lt;= cdpManager.LICR()) {</span>
  296 |     | <span class='neutral'>                //bad debt to redistribute</span>
  297 | *   | <span class='executed'>                lt(cdpManager.lastEBTCDebtErrorRedistribution(), cdpManager.totalStakes(), L_17);</span>
  298 |     | <span class='unexecuted'>                totalCdpDustMaxCap += cdpManager.getActiveCdpsCount();</span>
  299 |     | <span class='neutral'>            }</span>
  300 |     | <span class='neutral'></span>
  301 |     | <span class='unexecuted'>            _checkStakeInvariants();</span>
  302 |     | <span class='unexecuted'>        } else if (vars.sortedCdpsSizeBefore &gt; _i) {</span>
  303 |     | <span class='unexecuted'>            assertRevertReasonNotEqual(returnData, &quot;Panic(17)&quot;);</span>
  304 |     | <span class='neutral'>        }</span>
  305 |     | <span class='neutral'>    }</span>
  306 |     | <span class='neutral'></span>
  307 | *   | <span class='executed'>    function partialLiquidate(uint _i, uint _partialAmount) public setup {</span>
  308 |     | <span class='neutral'>        bool success;</span>
  309 | *   | <span class='executed'>        bytes memory returnData;</span>
  310 |     | <span class='neutral'></span>
  311 | *   | <span class='executed'>        require(cdpManager.getActiveCdpsCount() &gt; 1, &quot;Cannot liquidate last CDP&quot;);</span>
  312 |     | <span class='neutral'></span>
  313 | *   | <span class='executed'>        bytes32 _cdpId = _getRandomCdp(_i);</span>
  314 |     | <span class='neutral'></span>
  315 | *   | <span class='executed'>        (uint256 entireDebt, ) = cdpManager.getSyncedDebtAndCollShares(_cdpId);</span>
  316 | *   | <span class='executed'>        require(entireDebt &gt; 0, &quot;CDP must have debt&quot;);</span>
  317 |     | <span class='neutral'></span>
  318 | *   | <span class='executed'>        _partialAmount = between(_partialAmount, 0, entireDebt);</span>
  319 |     | <span class='neutral'></span>
  320 | *   | <span class='executed'>        _before(_cdpId);</span>
  321 |     | <span class='neutral'></span>
  322 |     | <span class='unexecuted'>        (success, returnData) = actor.proxy(</span>
  323 |     | <span class='unexecuted'>            address(cdpManager),</span>
  324 |     | <span class='unexecuted'>            abi.encodeWithSelector(</span>
  325 |     | <span class='neutral'>                CdpManager.partiallyLiquidate.selector,</span>
  326 |     | <span class='neutral'>                _cdpId,</span>
  327 |     | <span class='neutral'>                _partialAmount,</span>
  328 |     | <span class='neutral'>                _cdpId,</span>
  329 |     | <span class='neutral'>                _cdpId</span>
  330 |     | <span class='neutral'>            )</span>
  331 |     | <span class='neutral'>        );</span>
  332 |     | <span class='neutral'></span>
  333 |     | <span class='unexecuted'>        _after(_cdpId);</span>
  334 |     | <span class='neutral'></span>
  335 |     | <span class='unexecuted'>        if (success) {</span>
  336 |     | <span class='unexecuted'>            lt(vars.cdpDebtAfter, vars.cdpDebtBefore, &quot;Partial liquidation must reduce CDP debt&quot;);</span>
  337 |     | <span class='neutral'></span>
  338 |     | <span class='unexecuted'>            if (</span>
  339 |     | <span class='unexecuted'>                vars.newIcrBefore &gt;= cdpManager.LICR() // 103% else liquidating locks in bad debt</span>
  340 |     | <span class='neutral'>            ) {</span>
  341 |     | <span class='neutral'>                // https://github.com/Badger-Finance/ebtc-fuzz-review/issues/5</span>
  342 |     | <span class='unexecuted'>                if (vars.newIcrBefore &lt;= vars.newTcrBefore) {</span>
  343 |     | <span class='unexecuted'>                    gte(vars.newTcrAfter, vars.newTcrBefore, L_12);</span>
  344 |     | <span class='neutral'>                }</span>
  345 |     | <span class='neutral'>            }</span>
  346 |     | <span class='neutral'>            // https://github.com/Badger-Finance/ebtc-fuzz-review/issues/12</span>
  347 |     | <span class='unexecuted'>            t(</span>
  348 |     | <span class='unexecuted'>                vars.newIcrBefore &lt; cdpManager.MCR() ||</span>
  349 |     | <span class='neutral'>                    (vars.newIcrBefore &lt; cdpManager.CCR() &amp;&amp; vars.isRecoveryModeBefore),</span>
  350 |     | <span class='neutral'>                L_01</span>
  351 |     | <span class='neutral'>            );</span>
  352 |     | <span class='neutral'></span>
  353 |     | <span class='unexecuted'>            eq(</span>
  354 |     | <span class='unexecuted'>                vars.sortedCdpsSizeAfter,</span>
  355 |     | <span class='unexecuted'>                vars.sortedCdpsSizeBefore,</span>
  356 |     | <span class='neutral'>                &quot;L-17 : Partial Liquidations do not close Cdps&quot;</span>
  357 |     | <span class='neutral'>            );</span>
  358 |     | <span class='neutral'></span>
  359 |     | <span class='neutral'>            // https://github.com/Badger-Finance/ebtc-fuzz-review/issues/4</span>
  360 |     | <span class='unexecuted'>            if (vars.sortedCdpsSizeAfter == vars.sortedCdpsSizeBefore) {</span>
  361 |     | <span class='neutral'>                // CDP was not fully liquidated</span>
  362 |     | <span class='unexecuted'>                gte(</span>
  363 |     | <span class='unexecuted'>                    collateral.getPooledEthByShares(cdpManager.getCdpCollShares(_cdpId)),</span>
  364 |     | <span class='neutral'>                    borrowerOperations.MIN_NET_STETH_BALANCE(),</span>
  365 |     | <span class='neutral'>                    GENERAL_10</span>
  366 |     | <span class='neutral'>                );</span>
  367 |     | <span class='neutral'>            }</span>
  368 |     | <span class='neutral'></span>
  369 |     | <span class='unexecuted'>            if (</span>
  370 |     | <span class='unexecuted'>                vars.lastGracePeriodStartTimestampIsSetBefore &amp;&amp;</span>
  371 |     | <span class='unexecuted'>                vars.isRecoveryModeBefore &amp;&amp;</span>
  372 |     | <span class='unexecuted'>                vars.isRecoveryModeAfter</span>
  373 |     | <span class='neutral'>            ) {</span>
  374 |     | <span class='unexecuted'>                eq(</span>
  375 |     | <span class='unexecuted'>                    vars.lastGracePeriodStartTimestampBefore,</span>
  376 |     | <span class='unexecuted'>                    vars.lastGracePeriodStartTimestampAfter,</span>
  377 |     | <span class='unexecuted'>                    L_14</span>
  378 |     | <span class='neutral'>                );</span>
  379 |     | <span class='neutral'>            }</span>
  380 |     | <span class='neutral'></span>
  381 |     | <span class='unexecuted'>            _checkL_15IfRecoveryMode();</span>
  382 |     | <span class='neutral'></span>
  383 |     | <span class='unexecuted'>            if (vars.isRecoveryModeBefore &amp;&amp; !vars.isRecoveryModeAfter) {</span>
  384 |     | <span class='unexecuted'>                t(!vars.lastGracePeriodStartTimestampIsSetAfter, L_16);</span>
  385 |     | <span class='neutral'>            }</span>
  386 |     | <span class='neutral'></span>
  387 |     | <span class='unexecuted'>            gte(_partialAmount, borrowerOperations.MIN_CHANGE(), GENERAL_16);</span>
  388 |     | <span class='unexecuted'>            gte(vars.cdpDebtAfter, borrowerOperations.MIN_CHANGE(), GENERAL_15);</span>
  389 |     | <span class='neutral'>        } else {</span>
  390 |     | <span class='neutral'>            assertRevertReasonNotEqual(returnData, &quot;Panic(17)&quot;);</span>
  391 |     | <span class='neutral'>        }</span>
  392 |     | <span class='neutral'>    }</span>
  393 |     | <span class='neutral'></span>
  394 | *   | <span class='executed'>    function _checkStakeInvariants() private {</span>
  395 | *   | <span class='executed'>        if (vars.cdpCollAfter &lt; vars.cdpCollBefore) {</span>
  396 | *   | <span class='executed'>            lt(vars.cdpStakeAfter, vars.cdpStakeBefore, CDPM_07);</span>
  397 |     | <span class='neutral'>        }</span>
  398 |     | <span class='neutral'></span>
  399 | *   | <span class='executed'>        if (vars.cdpCollAfter &gt; vars.cdpCollBefore) {</span>
  400 | *   | <span class='executed'>            gt(vars.cdpStakeAfter, vars.cdpStakeBefore, CDPM_08);</span>
  401 |     | <span class='neutral'>        }</span>
  402 |     | <span class='neutral'></span>
  403 | *   | <span class='executed'>        if (vars.totalCollateralSnapshotAfter &gt; 0) {</span>
  404 | *   | <span class='executed'>            eq(</span>
  405 | *   | <span class='executed'>                vars.cdpStakeAfter,</span>
  406 | *   | <span class='executed'>                (vars.cdpCollAfter * vars.totalStakesSnapshotAfter) /</span>
  407 | *   | <span class='executed'>                    vars.totalCollateralSnapshotAfter,</span>
  408 | *   | <span class='executed'>                CDPM_09</span>
  409 |     | <span class='neutral'>            );</span>
  410 |     | <span class='neutral'>        } else {</span>
  411 |     | <span class='unexecuted'>            eq(vars.cdpStakeAfter, vars.cdpCollAfter, CDPM_09);</span>
  412 |     | <span class='neutral'>        }</span>
  413 |     | <span class='neutral'>    }</span>
  414 |     | <span class='neutral'></span>
  415 |     | <span class='neutral'>    /** Active Pool TWAP Revert Checks */</span>
  416 | *   | <span class='executed'>    function observe() public {</span>
  417 |     | <span class='neutral'>        // We verify that any observation will never revert</span>
  418 | *   | <span class='executed'>        try activePool.observe() {} catch {</span>
  419 |     | <span class='unexecuted'>            t(false, &quot;Observe Should Never Revert&quot;);</span>
  420 |     | <span class='neutral'>        }</span>
  421 |     | <span class='neutral'>    }</span>
  422 |     | <span class='neutral'></span>
  423 | *   | <span class='executed'>    function update() public {</span>
  424 |     | <span class='neutral'>        // We verify that any observation will never revert</span>
  425 | *   | <span class='executed'>        try activePool.update() {} catch {</span>
  426 |     | <span class='unexecuted'>            t(false, &quot;Update Should Never Revert&quot;);</span>
  427 |     | <span class='neutral'>        }</span>
  428 |     | <span class='neutral'>    }</span>
  429 |     | <span class='neutral'></span>
  430 |     | <span class='neutral'>    // NOTE: Added a bunch of stuff in other function to check against overflow reverts</span>
  431 |     | <span class='neutral'></span>
  432 |     | <span class='neutral'>    /** END Active Pool TWAP Revert Checks */</span>
  433 |     | <span class='neutral'></span>
  434 | *   | <span class='executed'>    function liquidateCdps(uint _n) public setup {</span>
  435 |     | <span class='neutral'>        bool success;</span>
  436 | *   | <span class='executed'>        bytes memory returnData;</span>
  437 |     | <span class='neutral'></span>
  438 | *   | <span class='executed'>        require(cdpManager.getActiveCdpsCount() &gt; 1, &quot;Cannot liquidate last CDP&quot;);</span>
  439 |     | <span class='neutral'></span>
  440 | *   | <span class='executed'>        _n = between(_n, 1, cdpManager.getActiveCdpsCount());</span>
  441 |     | <span class='neutral'></span>
  442 | *   | <span class='executed'>        Cdp[] memory cdpsBefore = _getCdpIdsAndICRs();</span>
  443 |     | <span class='neutral'></span>
  444 | *   | <span class='executed'>        _before(bytes32(0));</span>
  445 |     | <span class='neutral'></span>
  446 | *   | <span class='executed'>        bytes32[] memory batch = liquidationSequencer.sequenceLiqToBatchLiqWithPrice(</span>
  447 | *   | <span class='executed'>            _n,</span>
  448 | *   | <span class='executed'>            vars.priceBefore</span>
  449 |     | <span class='neutral'>        );</span>
  450 |     | <span class='neutral'></span>
  451 | *   | <span class='executed'>        bool _badDebtToRedistribute = false;</span>
  452 | *   | <span class='executed'>        for (uint i; i &lt; batch.length; i++) {</span>
  453 | *   | <span class='executed'>            bytes32 _idToLiq = batch[i];</span>
  454 |     | <span class='neutral'>        }</span>
  455 |     | <span class='neutral'></span>
  456 | *   | <span class='executed'>        (success, returnData) = actor.proxy(</span>
  457 | *   | <span class='executed'>            address(cdpManager),</span>
  458 | *   | <span class='executed'>            abi.encodeWithSelector(CdpManager.batchLiquidateCdps.selector, batch)</span>
  459 |     | <span class='neutral'>        );</span>
  460 |     | <span class='neutral'></span>
  461 | *   | <span class='executed'>        _after(bytes32(0));</span>
  462 |     | <span class='neutral'></span>
  463 | *   | <span class='executed'>        if (success) {</span>
  464 | *   | <span class='executed'>            Cdp[] memory cdpsAfter = _getCdpIdsAndICRs();</span>
  465 |     | <span class='neutral'></span>
  466 | *   | <span class='executed'>            Cdp[] memory cdpsLiquidated = _cdpIdsAndICRsDiff(cdpsBefore, cdpsAfter);</span>
  467 | *   | <span class='executed'>            gte(</span>
  468 | *   | <span class='executed'>                cdpsLiquidated.length,</span>
  469 | *   | <span class='executed'>                1,</span>
  470 |     | <span class='neutral'>                &quot;liquidateCdps must liquidate at least 1 CDP when successful&quot;</span>
  471 |     | <span class='neutral'>            );</span>
  472 | *   | <span class='executed'>            lte(cdpsLiquidated.length, _n, &quot;liquidateCdps must not liquidate more than n CDPs&quot;);</span>
  473 | *   | <span class='executed'>            for (uint256 i = 0; i &lt; cdpsLiquidated.length; ++i) {</span>
  474 |     | <span class='neutral'>                // https://github.com/Badger-Finance/ebtc-fuzz-review/issues/12</span>
  475 | *   | <span class='executed'>                t(</span>
  476 | *   | <span class='executed'>                    cdpsLiquidated[i].icr &lt; cdpManager.MCR() ||</span>
  477 |     | <span class='unexecuted'>                        (cdpsLiquidated[i].icr &lt; cdpManager.CCR() &amp;&amp; vars.isRecoveryModeBefore),</span>
  478 |     | <span class='unexecuted'>                    L_01</span>
  479 |     | <span class='neutral'>                );</span>
  480 | *   | <span class='executed'>                if (cdpsLiquidated[i].icr &lt;= cdpManager.LICR()) {</span>
  481 | *   | <span class='executed'>                    _badDebtToRedistribute = true;</span>
  482 |     | <span class='neutral'>                }</span>
  483 |     | <span class='neutral'>            }</span>
  484 |     | <span class='neutral'></span>
  485 |     | <span class='neutral'>            // SURPLUS-CHECK-1 | The surplus is capped at 4 wei | NOTE: We use Liquidate for the exact CDP check</span>
  486 | *   | <span class='executed'>            bool hasCdpWithSurplus;</span>
  487 | *   | <span class='executed'>            for (uint256 i = 0; i &lt; cdpsLiquidated.length; ++i) {</span>
  488 | *   | <span class='executed'>                if (cdpsLiquidated[i].icr &gt; cdpManager.MCR()) {</span>
  489 |     | <span class='unexecuted'>                    hasCdpWithSurplus = true;</span>
  490 |     | <span class='unexecuted'>                    break;</span>
  491 |     | <span class='neutral'>                }</span>
  492 |     | <span class='neutral'>            }</span>
  493 |     | <span class='neutral'>            // At most, each liquidate cdp must generate 4 wei of rounding error in the surplus</span>
  494 | *   | <span class='executed'>            if (!hasCdpWithSurplus) {</span>
  495 | *   | <span class='executed'>                gte(</span>
  496 | *   | <span class='executed'>                    vars.collSurplusPoolBefore + 12 * cdpsLiquidated.length,</span>
  497 |     | <span class='neutral'>                    vars.collSurplusPoolAfter,</span>
  498 |     | <span class='neutral'>                    &quot;SURPLUS-CHECK-1_12&quot;</span>
  499 |     | <span class='neutral'>                );</span>
  500 | *   | <span class='executed'>                gte(</span>
  501 | *   | <span class='executed'>                    vars.collSurplusPoolBefore + 8 * cdpsLiquidated.length,</span>
  502 |     | <span class='neutral'>                    vars.collSurplusPoolAfter,</span>
  503 |     | <span class='neutral'>                    &quot;SURPLUS-CHECK-1_8&quot;</span>
  504 |     | <span class='neutral'>                );</span>
  505 | *   | <span class='executed'>                gte(</span>
  506 | *   | <span class='executed'>                    vars.collSurplusPoolBefore + 4 * cdpsLiquidated.length,</span>
  507 |     | <span class='neutral'>                    vars.collSurplusPoolAfter,</span>
  508 |     | <span class='neutral'>                    &quot;SURPLUS-CHECK-1_4&quot;</span>
  509 |     | <span class='neutral'>                );</span>
  510 |     | <span class='neutral'>            }</span>
  511 |     | <span class='neutral'></span>
  512 | *   | <span class='executed'>            if (</span>
  513 | *   | <span class='executed'>                vars.lastGracePeriodStartTimestampIsSetBefore &amp;&amp;</span>
  514 | *   | <span class='executed'>                vars.isRecoveryModeBefore &amp;&amp;</span>
  515 | *   | <span class='executed'>                vars.isRecoveryModeAfter</span>
  516 |     | <span class='neutral'>            ) {</span>
  517 | *   | <span class='executed'>                eq(</span>
  518 | *   | <span class='executed'>                    vars.lastGracePeriodStartTimestampBefore,</span>
  519 | *   | <span class='executed'>                    vars.lastGracePeriodStartTimestampAfter,</span>
  520 | *   | <span class='executed'>                    L_14</span>
  521 |     | <span class='neutral'>                );</span>
  522 |     | <span class='neutral'>            }</span>
  523 |     | <span class='neutral'></span>
  524 | *   | <span class='executed'>            _checkL_15IfRecoveryMode();</span>
  525 |     | <span class='neutral'></span>
  526 | *   | <span class='executed'>            if (vars.isRecoveryModeBefore &amp;&amp; !vars.isRecoveryModeAfter) {</span>
  527 | *   | <span class='executed'>                t(!vars.lastGracePeriodStartTimestampIsSetAfter, L_16);</span>
  528 |     | <span class='neutral'>            }</span>
  529 | *   | <span class='executed'>            if (_badDebtToRedistribute) {</span>
  530 | *   | <span class='executed'>                lt(cdpManager.lastEBTCDebtErrorRedistribution(), cdpManager.totalStakes(), L_17);</span>
  531 | *   | <span class='executed'>                totalCdpDustMaxCap += cdpManager.getActiveCdpsCount();</span>
  532 |     | <span class='neutral'>            }</span>
  533 |     | <span class='neutral'></span>
  534 | *   | <span class='executed'>            _checkStakeInvariants();</span>
  535 | *   | <span class='executed'>        } else if (vars.sortedCdpsSizeBefore &gt; _n) {</span>
  536 | *   | <span class='executed'>            if (_atLeastOneCdpIsLiquidatable(cdpsBefore, vars.isRecoveryModeBefore)) {</span>
  537 | *   | <span class='executed'>                assertRevertReasonNotEqual(returnData, &quot;Panic(17)&quot;);</span>
  538 |     | <span class='neutral'>            }</span>
  539 |     | <span class='neutral'>        }</span>
  540 |     | <span class='neutral'>    }</span>
  541 |     | <span class='neutral'></span>
  542 | *   | <span class='executed'>    function redeemCollateral(</span>
  543 |     | <span class='neutral'>        uint _EBTCAmount,</span>
  544 |     | <span class='neutral'>        uint _partialRedemptionHintNICR,</span>
  545 |     | <span class='neutral'>        uint _maxFeePercentage,</span>
  546 |     | <span class='neutral'>        uint _maxIterations</span>
  547 |     | <span class='neutral'>    ) public setup {</span>
  548 | *   | <span class='executed'>        _redeemCollateral(</span>
  549 | *   | <span class='executed'>            _EBTCAmount,</span>
  550 |     | <span class='neutral'>            bytes32(0),</span>
  551 | *   | <span class='executed'>            _partialRedemptionHintNICR,</span>
  552 |     | <span class='neutral'>            false,</span>
  553 |     | <span class='neutral'>            false,</span>
  554 |     | <span class='neutral'>            false,</span>
  555 | *   | <span class='executed'>            _maxFeePercentage,</span>
  556 | *   | <span class='executed'>            _maxIterations</span>
  557 |     | <span class='neutral'>        );</span>
  558 |     | <span class='neutral'>    }</span>
  559 |     | <span class='neutral'></span>
  560 | *   | <span class='executed'>    function redeemCollateral(</span>
  561 |     | <span class='neutral'>        uint _EBTCAmount,</span>
  562 |     | <span class='neutral'>        bytes32 _firstRedemptionHintFromMedusa,</span>
  563 |     | <span class='neutral'>        uint256 _partialRedemptionHintNICRFromMedusa,</span>
  564 |     | <span class='neutral'>        bool useProperFirstHint,</span>
  565 |     | <span class='neutral'>        bool useProperPartialHint,</span>
  566 |     | <span class='neutral'>        bool failPartialRedemption,</span>
  567 |     | <span class='neutral'>        uint _maxFeePercentage,</span>
  568 |     | <span class='neutral'>        uint _maxIterations</span>
  569 |     | <span class='neutral'>    ) public setup {</span>
  570 | *   | <span class='executed'>        _redeemCollateral(</span>
  571 | *   | <span class='executed'>            _EBTCAmount,</span>
  572 | *   | <span class='executed'>            _firstRedemptionHintFromMedusa,</span>
  573 | *   | <span class='executed'>            _partialRedemptionHintNICRFromMedusa,</span>
  574 | *   | <span class='executed'>            useProperFirstHint,</span>
  575 | *   | <span class='executed'>            useProperPartialHint,</span>
  576 | *   | <span class='executed'>            failPartialRedemption,</span>
  577 | *   | <span class='executed'>            _maxFeePercentage,</span>
  578 | *   | <span class='executed'>            _maxIterations</span>
  579 |     | <span class='neutral'>        );</span>
  580 |     | <span class='neutral'>    }</span>
  581 |     | <span class='neutral'></span>
  582 | *   | <span class='executed'>    function _redeemCollateral(</span>
  583 |     | <span class='neutral'>        uint _EBTCAmount,</span>
  584 |     | <span class='neutral'>        bytes32 _firstRedemptionHintFromMedusa,</span>
  585 |     | <span class='neutral'>        uint256 _partialRedemptionHintNICRFromMedusa,</span>
  586 |     | <span class='neutral'>        bool useProperFirstHint,</span>
  587 |     | <span class='neutral'>        bool useProperPartialHint,</span>
  588 |     | <span class='neutral'>        bool failPartialRedemption,</span>
  589 |     | <span class='neutral'>        uint _maxFeePercentage,</span>
  590 |     | <span class='neutral'>        uint _maxIterations</span>
  591 |     | <span class='unexecuted'>    ) internal {</span>
  592 | *   | <span class='executed'>        require(cdpManager.getActiveCdpsCount() &gt; 1, &quot;Cannot redeem last CDP&quot;);</span>
  593 |     | <span class='neutral'></span>
  594 | *   | <span class='executed'>        _EBTCAmount = between(_EBTCAmount, 0, eBTCToken.balanceOf(address(actor)));</span>
  595 |     | <span class='neutral'></span>
  596 | *   | <span class='executed'>        _maxIterations = between(_maxIterations, 0, 10);</span>
  597 |     | <span class='neutral'></span>
  598 | *   | <span class='executed'>        _maxFeePercentage = between(</span>
  599 | *   | <span class='executed'>            _maxFeePercentage,</span>
  600 | *   | <span class='executed'>            cdpManager.redemptionFeeFloor(),</span>
  601 | *   | <span class='executed'>            cdpManager.DECIMAL_PRECISION()</span>
  602 |     | <span class='neutral'>        );</span>
  603 |     | <span class='neutral'></span>
  604 | *   | <span class='executed'>        bytes32 _cdpId = _getFirstCdpWithIcrGteMcr();</span>
  605 |     | <span class='neutral'></span>
  606 | *   | <span class='executed'>        _before(_cdpId);</span>
  607 |     | <span class='neutral'></span>
  608 |     | <span class='unexecuted'>        {</span>
  609 |     | <span class='unexecuted'>            uint price = priceFeedMock.fetchPrice();</span>
  610 |     | <span class='neutral'></span>
  611 |     | <span class='unexecuted'>            (bytes32 firstRedemptionHintVal, uint256 partialRedemptionHintNICR, , ) = hintHelpers</span>
  612 |     | <span class='neutral'>                .getRedemptionHints(_EBTCAmount, price, _maxIterations);</span>
  613 |     | <span class='neutral'></span>
  614 |     | <span class='unexecuted'>            _firstRedemptionHintFromMedusa = useProperFirstHint</span>
  615 |     | <span class='unexecuted'>                ? firstRedemptionHintVal</span>
  616 |     | <span class='unexecuted'>                : _firstRedemptionHintFromMedusa;</span>
  617 |     | <span class='neutral'></span>
  618 |     | <span class='unexecuted'>            _partialRedemptionHintNICRFromMedusa = useProperPartialHint</span>
  619 |     | <span class='unexecuted'>                ? partialRedemptionHintNICR</span>
  620 |     | <span class='unexecuted'>                : _partialRedemptionHintNICRFromMedusa;</span>
  621 |     | <span class='neutral'>        }</span>
  622 |     | <span class='neutral'></span>
  623 |     | <span class='unexecuted'>        _syncAPDebtTwapToSpotValue();</span>
  624 |     | <span class='neutral'></span>
  625 |     | <span class='unexecuted'>        {</span>
  626 |     | <span class='unexecuted'>            bool success;</span>
  627 |     | <span class='neutral'></span>
  628 |     | <span class='unexecuted'>            (success, ) = actor.proxy(</span>
  629 |     | <span class='unexecuted'>                address(cdpManager),</span>
  630 |     | <span class='unexecuted'>                abi.encodeWithSelector(</span>
  631 |     | <span class='neutral'>                    CdpManager.redeemCollateral.selector,</span>
  632 |     | <span class='unexecuted'>                    _EBTCAmount,</span>
  633 |     | <span class='unexecuted'>                    _firstRedemptionHintFromMedusa,</span>
  634 |     | <span class='neutral'>                    bytes32(0),</span>
  635 |     | <span class='neutral'>                    bytes32(0),</span>
  636 |     | <span class='unexecuted'>                    failPartialRedemption ? 0 : _partialRedemptionHintNICRFromMedusa,</span>
  637 |     | <span class='neutral'>                    _maxIterations,</span>
  638 |     | <span class='neutral'>                    _maxFeePercentage</span>
  639 |     | <span class='neutral'>                )</span>
  640 |     | <span class='neutral'>            );</span>
  641 |     | <span class='neutral'></span>
  642 |     | <span class='unexecuted'>            require(success);</span>
  643 |     | <span class='neutral'>        }</span>
  644 |     | <span class='neutral'></span>
  645 |     | <span class='unexecuted'>        _after(_cdpId);</span>
  646 |     | <span class='neutral'></span>
  647 |     | <span class='unexecuted'>        gt(vars.tcrBefore, cdpManager.MCR(), EBTC_02);</span>
  648 |     | <span class='unexecuted'>        if (_maxIterations == 1) {</span>
  649 |     | <span class='unexecuted'>            gte(vars.activePoolDebtBefore, vars.activePoolDebtAfter, CDPM_05);</span>
  650 |     | <span class='unexecuted'>            gte(vars.cdpDebtBefore, vars.cdpDebtAfter, CDPM_06);</span>
  651 |     | <span class='neutral'>            // TODO: CHECK THIS</span>
  652 |     | <span class='neutral'>            // https://github.com/Badger-Finance/ebtc-fuzz-review/issues/10#issuecomment-1702685732</span>
  653 |     | <span class='unexecuted'>            if (vars.sortedCdpsSizeBefore == vars.sortedCdpsSizeAfter) {</span>
  654 |     | <span class='neutral'>                // Redemptions do not reduce TCR</span>
  655 |     | <span class='neutral'>                // If redemptions do not close any CDP that was healthy (low debt, high coll)</span>
  656 |     | <span class='unexecuted'>                gt(vars.newTcrAfter, vars.newTcrBefore, R_07);</span>
  657 |     | <span class='neutral'>            }</span>
  658 |     | <span class='unexecuted'>            t(invariant_CDPM_04(vars), CDPM_04);</span>
  659 |     | <span class='neutral'>        }</span>
  660 |     | <span class='unexecuted'>        gt(vars.actorEbtcBefore, vars.actorEbtcAfter, R_08);</span>
  661 |     | <span class='neutral'></span>
  662 |     | <span class='neutral'>        // Verify Fee Recipient Received the Fee</span>
  663 |     | <span class='unexecuted'>        gte(vars.feeRecipientCollSharesAfter, vars.feeRecipientCollSharesBefore, F_02);</span>
  664 |     | <span class='neutral'></span>
  665 |     | <span class='unexecuted'>        if (</span>
  666 |     | <span class='unexecuted'>            vars.lastGracePeriodStartTimestampIsSetBefore &amp;&amp;</span>
  667 |     | <span class='unexecuted'>            vars.isRecoveryModeBefore &amp;&amp;</span>
  668 |     | <span class='unexecuted'>            vars.isRecoveryModeAfter</span>
  669 |     | <span class='neutral'>        ) {</span>
  670 |     | <span class='unexecuted'>            eq(</span>
  671 |     | <span class='unexecuted'>                vars.lastGracePeriodStartTimestampBefore,</span>
  672 |     | <span class='unexecuted'>                vars.lastGracePeriodStartTimestampAfter,</span>
  673 |     | <span class='unexecuted'>                L_14</span>
  674 |     | <span class='neutral'>            );</span>
  675 |     | <span class='neutral'>        }</span>
  676 |     | <span class='neutral'></span>
  677 |     | <span class='unexecuted'>        _checkL_15IfRecoveryMode();</span>
  678 |     | <span class='neutral'></span>
  679 |     | <span class='unexecuted'>        if (vars.isRecoveryModeBefore &amp;&amp; !vars.isRecoveryModeAfter) {</span>
  680 |     | <span class='unexecuted'>            t(!vars.lastGracePeriodStartTimestampIsSetAfter, L_16);</span>
  681 |     | <span class='neutral'>        }</span>
  682 |     | <span class='neutral'></span>
  683 |     | <span class='unexecuted'>        _checkStakeInvariants();</span>
  684 |     | <span class='neutral'>    }</span>
  685 |     | <span class='neutral'></span>
  686 |     | <span class='neutral'>    ///////////////////////////////////////////////////////</span>
  687 |     | <span class='neutral'>    // ActivePool</span>
  688 |     | <span class='neutral'>    ///////////////////////////////////////////////////////</span>
  689 |     | <span class='neutral'></span>
  690 |     | <span class='unexecuted'>    function _syncAPDebtTwapToSpotValue() internal {</span>
  691 |     | <span class='unexecuted'>        hevm.warp(block.timestamp + activePool.PERIOD());</span>
  692 |     | <span class='unexecuted'>        activePool.update();</span>
  693 |     | <span class='neutral'>    }</span>
  694 |     | <span class='neutral'></span>
  695 | *   | <span class='executed'>    function flashLoanColl(uint _amount) public setup {</span>
  696 |     | <span class='neutral'>        bool success;</span>
  697 | *   | <span class='executed'>        bytes memory returnData;</span>
  698 |     | <span class='neutral'></span>
  699 | *   | <span class='executed'>        _amount = between(_amount, 0, activePool.maxFlashLoan(address(collateral)));</span>
  700 | *   | <span class='executed'>        uint _fee = activePool.flashFee(address(collateral), _amount);</span>
  701 |     | <span class='neutral'></span>
  702 | *   | <span class='executed'>        _before(bytes32(0));</span>
  703 |     | <span class='neutral'></span>
  704 |     | <span class='neutral'>        // take the flashloan which should always cost the fee paid by caller</span>
  705 | *   | <span class='executed'>        uint _balBefore = collateral.sharesOf(activePool.feeRecipientAddress());</span>
  706 | *   | <span class='executed'>        (success, returnData) = actor.proxy(</span>
  707 | *   | <span class='executed'>            address(activePool),</span>
  708 | *   | <span class='executed'>            abi.encodeWithSelector(</span>
  709 | *   | <span class='executed'>                ActivePool.flashLoan.selector,</span>
  710 |     | <span class='neutral'>                IERC3156FlashBorrower(address(actor)),</span>
  711 | *   | <span class='executed'>                address(collateral),</span>
  712 | *   | <span class='executed'>                _amount,</span>
  713 | *   | <span class='executed'>                _getFlashLoanActions(_amount)</span>
  714 |     | <span class='neutral'>            )</span>
  715 |     | <span class='neutral'>        );</span>
  716 |     | <span class='neutral'></span>
  717 | *r  | <span class='executed'>        require(success);</span>
  718 |     | <span class='neutral'></span>
  719 | *   | <span class='executed'>        _after(bytes32(0));</span>
  720 |     | <span class='neutral'></span>
  721 | *   | <span class='executed'>        uint _balAfter = collateral.sharesOf(activePool.feeRecipientAddress());</span>
  722 | *   | <span class='executed'>        eq(_balAfter - _balBefore, collateral.getSharesByPooledEth(_fee), F_03);</span>
  723 |     | <span class='neutral'></span>
  724 | *   | <span class='executed'>        if (</span>
  725 | *   | <span class='executed'>            vars.lastGracePeriodStartTimestampIsSetBefore &amp;&amp;</span>
  726 | *   | <span class='executed'>            vars.isRecoveryModeBefore &amp;&amp;</span>
  727 | *   | <span class='executed'>            vars.isRecoveryModeAfter</span>
  728 |     | <span class='neutral'>        ) {</span>
  729 | *   | <span class='executed'>            eq(</span>
  730 | *   | <span class='executed'>                vars.lastGracePeriodStartTimestampBefore,</span>
  731 | *   | <span class='executed'>                vars.lastGracePeriodStartTimestampAfter,</span>
  732 | *   | <span class='executed'>                L_14</span>
  733 |     | <span class='neutral'>            );</span>
  734 |     | <span class='neutral'>        }</span>
  735 |     | <span class='neutral'></span>
  736 | *   | <span class='executed'>        _checkL_15IfRecoveryMode();</span>
  737 |     | <span class='neutral'></span>
  738 | *   | <span class='executed'>        if (vars.isRecoveryModeBefore &amp;&amp; !vars.isRecoveryModeAfter) {</span>
  739 | *   | <span class='executed'>            t(!vars.lastGracePeriodStartTimestampIsSetAfter, L_16);</span>
  740 |     | <span class='neutral'>        }</span>
  741 |     | <span class='neutral'></span>
  742 | *   | <span class='executed'>        _checkStakeInvariants();</span>
  743 |     | <span class='neutral'>    }</span>
  744 |     | <span class='neutral'></span>
  745 |     | <span class='neutral'>    ///////////////////////////////////////////////////////</span>
  746 |     | <span class='neutral'>    // BorrowerOperations</span>
  747 |     | <span class='neutral'>    ///////////////////////////////////////////////////////</span>
  748 |     | <span class='neutral'></span>
  749 | *   | <span class='executed'>    function flashLoanEBTC(uint _amount) public setup {</span>
  750 |     | <span class='neutral'>        bool success;</span>
  751 | *   | <span class='executed'>        bytes memory returnData;</span>
  752 |     | <span class='neutral'></span>
  753 | *   | <span class='executed'>        _amount = between(_amount, 0, borrowerOperations.maxFlashLoan(address(eBTCToken)));</span>
  754 |     | <span class='neutral'></span>
  755 | *   | <span class='executed'>        uint _fee = borrowerOperations.flashFee(address(eBTCToken), _amount);</span>
  756 |     | <span class='neutral'></span>
  757 | *   | <span class='executed'>        _before(bytes32(0));</span>
  758 |     | <span class='neutral'></span>
  759 |     | <span class='neutral'>        // take the flashloan which should always cost the fee paid by caller</span>
  760 | *   | <span class='executed'>        uint _balBefore = eBTCToken.balanceOf(borrowerOperations.feeRecipientAddress());</span>
  761 | *   | <span class='executed'>        (success, returnData) = actor.proxy(</span>
  762 | *   | <span class='executed'>            address(borrowerOperations),</span>
  763 | *   | <span class='executed'>            abi.encodeWithSelector(</span>
  764 | *   | <span class='executed'>                BorrowerOperations.flashLoan.selector,</span>
  765 |     | <span class='neutral'>                IERC3156FlashBorrower(address(actor)),</span>
  766 | *   | <span class='executed'>                address(eBTCToken),</span>
  767 | *   | <span class='executed'>                _amount,</span>
  768 | *   | <span class='executed'>                _getFlashLoanActions(_amount)</span>
  769 |     | <span class='neutral'>            )</span>
  770 |     | <span class='neutral'>        );</span>
  771 |     | <span class='neutral'></span>
  772 |     | <span class='neutral'>        // BorrowerOperations.flashLoan may revert due to reentrancy</span>
  773 | *r  | <span class='executed'>        require(success);</span>
  774 |     | <span class='neutral'></span>
  775 | *   | <span class='executed'>        _after(bytes32(0));</span>
  776 |     | <span class='neutral'></span>
  777 | *   | <span class='executed'>        uint _balAfter = eBTCToken.balanceOf(borrowerOperations.feeRecipientAddress());</span>
  778 | *   | <span class='executed'>        eq(_balAfter - _balBefore, _fee, F_03);</span>
  779 |     | <span class='neutral'></span>
  780 |     | <span class='neutral'>        if (</span>
  781 |     | <span class='neutral'>            vars.lastGracePeriodStartTimestampIsSetBefore &amp;&amp;</span>
  782 |     | <span class='neutral'>            vars.isRecoveryModeBefore &amp;&amp;</span>
  783 |     | <span class='neutral'>            vars.isRecoveryModeAfter</span>
  784 |     | <span class='neutral'>        ) {</span>
  785 |     | <span class='neutral'>            eq(</span>
  786 |     | <span class='neutral'>                vars.lastGracePeriodStartTimestampBefore,</span>
  787 |     | <span class='neutral'>                vars.lastGracePeriodStartTimestampAfter,</span>
  788 |     | <span class='neutral'>                L_14</span>
  789 |     | <span class='neutral'>            );</span>
  790 |     | <span class='neutral'>        }</span>
  791 |     | <span class='neutral'></span>
  792 |     | <span class='neutral'>        _checkL_15IfRecoveryMode();</span>
  793 |     | <span class='neutral'></span>
  794 |     | <span class='neutral'>        if (vars.isRecoveryModeBefore &amp;&amp; !vars.isRecoveryModeAfter) {</span>
  795 |     | <span class='neutral'>            t(!vars.lastGracePeriodStartTimestampIsSetAfter, L_16);</span>
  796 |     | <span class='neutral'>        }</span>
  797 |     | <span class='neutral'></span>
  798 |     | <span class='neutral'>        _checkStakeInvariants();</span>
  799 |     | <span class='neutral'>    }</span>
  800 |     | <span class='neutral'></span>
  801 | *   | <span class='executed'>    function openCdp(uint256 _col, uint256 _EBTCAmount) public setup returns (bytes32 _cdpId) {</span>
  802 |     | <span class='neutral'>        bool success;</span>
  803 | *   | <span class='executed'>        bytes memory returnData;</span>
  804 |     | <span class='neutral'></span>
  805 |     | <span class='neutral'>        // we pass in CCR instead of MCR in case it&#39;s the first one</span>
  806 | *   | <span class='executed'>        uint price = priceFeedMock.fetchPrice();</span>
  807 |     | <span class='neutral'></span>
  808 | *   | <span class='executed'>        uint256 requiredCollAmount = (_EBTCAmount * cdpManager.CCR()) / (price);</span>
  809 | *   | <span class='executed'>        uint256 minCollAmount = max(</span>
  810 | *   | <span class='executed'>            cdpManager.MIN_NET_STETH_BALANCE() + borrowerOperations.LIQUIDATOR_REWARD(),</span>
  811 | *   | <span class='executed'>            requiredCollAmount</span>
  812 |     | <span class='neutral'>        );</span>
  813 | *   | <span class='executed'>        uint256 maxCollAmount = min(2 * minCollAmount, INITIAL_COLL_BALANCE / 10);</span>
  814 | *   | <span class='executed'>        _col = between(requiredCollAmount, minCollAmount, maxCollAmount);</span>
  815 |     | <span class='neutral'></span>
  816 | *   | <span class='executed'>        (success, ) = actor.proxy(</span>
  817 | *   | <span class='executed'>            address(collateral),</span>
  818 | *   | <span class='executed'>            abi.encodeWithSelector(</span>
  819 | *   | <span class='executed'>                CollateralTokenTester.approve.selector,</span>
  820 | *   | <span class='executed'>                address(borrowerOperations),</span>
  821 |     | <span class='neutral'>                _col</span>
  822 |     | <span class='neutral'>            )</span>
  823 |     | <span class='neutral'>        );</span>
  824 | *   | <span class='executed'>        t(success, &quot;Approve never fails&quot;);</span>
  825 |     | <span class='neutral'></span>
  826 | *   | <span class='executed'>        _before(bytes32(0));</span>
  827 |     | <span class='neutral'></span>
  828 | *   | <span class='executed'>        (success, returnData) = actor.proxy(</span>
  829 | *   | <span class='executed'>            address(borrowerOperations),</span>
  830 | *   | <span class='executed'>            abi.encodeWithSelector(</span>
  831 |     | <span class='neutral'>                BorrowerOperations.openCdp.selector,</span>
  832 |     | <span class='neutral'>                _EBTCAmount,</span>
  833 |     | <span class='neutral'>                bytes32(0),</span>
  834 |     | <span class='neutral'>                bytes32(0),</span>
  835 |     | <span class='neutral'>                _col</span>
  836 |     | <span class='neutral'>            )</span>
  837 |     | <span class='neutral'>        );</span>
  838 |     | <span class='neutral'></span>
  839 | *   | <span class='executed'>        if (success) {</span>
  840 | *   | <span class='executed'>            _cdpId = abi.decode(returnData, (bytes32));</span>
  841 | *   | <span class='executed'>            _after(_cdpId);</span>
  842 |     | <span class='neutral'></span>
  843 |     | <span class='unexecuted'>            t(invariant_GENERAL_01(vars), GENERAL_01);</span>
  844 |     | <span class='unexecuted'>            gt(vars.icrAfter, cdpManager.MCR(), BO_01);</span>
  845 |     | <span class='neutral'></span>
  846 |     | <span class='unexecuted'>            eq(vars.newTcrAfter, vars.tcrAfter, GENERAL_11);</span>
  847 |     | <span class='neutral'></span>
  848 |     | <span class='neutral'>            // https://github.com/Badger-Finance/ebtc-fuzz-review/issues/3</span>
  849 |     | <span class='unexecuted'>            t(invariant_GENERAL_09(cdpManager, vars), GENERAL_09);</span>
  850 |     | <span class='neutral'>            // https://github.com/Badger-Finance/ebtc-fuzz-review/issues/4</span>
  851 |     | <span class='unexecuted'>            gte(</span>
  852 |     | <span class='unexecuted'>                collateral.getPooledEthByShares(cdpManager.getCdpCollShares(_cdpId)),</span>
  853 |     | <span class='neutral'>                borrowerOperations.MIN_NET_STETH_BALANCE(),</span>
  854 |     | <span class='neutral'>                GENERAL_10</span>
  855 |     | <span class='neutral'>            );</span>
  856 |     | <span class='unexecuted'>            eq(</span>
  857 |     | <span class='unexecuted'>                vars.sortedCdpsSizeBefore + 1,</span>
  858 |     | <span class='unexecuted'>                vars.sortedCdpsSizeAfter,</span>
  859 |     | <span class='neutral'>                &quot;CDPs count must have increased&quot;</span>
  860 |     | <span class='neutral'>            );</span>
  861 |     | <span class='unexecuted'>            if (</span>
  862 |     | <span class='unexecuted'>                vars.lastGracePeriodStartTimestampIsSetBefore &amp;&amp;</span>
  863 |     | <span class='unexecuted'>                vars.isRecoveryModeBefore &amp;&amp;</span>
  864 |     | <span class='unexecuted'>                vars.isRecoveryModeAfter</span>
  865 |     | <span class='neutral'>            ) {</span>
  866 |     | <span class='unexecuted'>                eq(</span>
  867 |     | <span class='unexecuted'>                    vars.lastGracePeriodStartTimestampBefore,</span>
  868 |     | <span class='unexecuted'>                    vars.lastGracePeriodStartTimestampAfter,</span>
  869 |     | <span class='unexecuted'>                    L_14</span>
  870 |     | <span class='neutral'>                );</span>
  871 |     | <span class='neutral'>            }</span>
  872 |     | <span class='neutral'></span>
  873 |     | <span class='unexecuted'>            _checkL_15IfRecoveryMode();</span>
  874 |     | <span class='neutral'></span>
  875 |     | <span class='unexecuted'>            if (vars.isRecoveryModeBefore &amp;&amp; !vars.isRecoveryModeAfter) {</span>
  876 |     | <span class='unexecuted'>                t(!vars.lastGracePeriodStartTimestampIsSetAfter, L_16);</span>
  877 |     | <span class='neutral'>            }</span>
  878 |     | <span class='neutral'></span>
  879 |     | <span class='unexecuted'>            gte(_EBTCAmount, borrowerOperations.MIN_CHANGE(), GENERAL_16);</span>
  880 |     | <span class='unexecuted'>            gte(vars.cdpDebtAfter, borrowerOperations.MIN_CHANGE(), GENERAL_15);</span>
  881 |     | <span class='unexecuted'>            require(invariant_BO_09(cdpManager, priceFeedMock.getPrice(), _cdpId), BO_09);</span>
  882 |     | <span class='neutral'></span>
  883 |     | <span class='unexecuted'>            _checkStakeInvariants();</span>
  884 |     | <span class='neutral'>        } else {</span>
  885 | *   | <span class='executed'>            assertRevertReasonNotEqual(returnData, &quot;Panic(17)&quot;); /// Done</span>
  886 |     | <span class='neutral'>        }</span>
  887 |     | <span class='neutral'>    }</span>
  888 |     | <span class='neutral'></span>
  889 | *   | <span class='executed'>    function addColl(uint _coll, uint256 _i) public setup {</span>
  890 |     | <span class='neutral'>        bool success;</span>
  891 | *   | <span class='executed'>        bytes memory returnData;</span>
  892 |     | <span class='neutral'></span>
  893 | *   | <span class='executed'>        uint256 numberOfCdps = sortedCdps.cdpCountOf(address(actor));</span>
  894 | *   | <span class='executed'>        require(numberOfCdps &gt; 0, &quot;Actor must have at least one CDP open&quot;);</span>
  895 |     | <span class='neutral'></span>
  896 | *   | <span class='executed'>        _i = between(_i, 0, numberOfCdps - 1);</span>
  897 | *   | <span class='executed'>        bytes32 _cdpId = sortedCdps.cdpOfOwnerByIndex(address(actor), _i);</span>
  898 | *   | <span class='executed'>        t(_cdpId != bytes32(0), &quot;CDP ID must not be null if the index is valid&quot;);</span>
  899 |     | <span class='neutral'></span>
  900 | *   | <span class='executed'>        _coll = between(_coll, 0, INITIAL_COLL_BALANCE / 10);</span>
  901 |     | <span class='neutral'></span>
  902 | *   | <span class='executed'>        if (collateral.balanceOf(address(actor)) &lt; _coll) {</span>
  903 |     | <span class='unexecuted'>            (success, ) = actor.proxy(</span>
  904 |     | <span class='unexecuted'>                address(collateral),</span>
  905 |     | <span class='unexecuted'>                abi.encodeWithSelector(CollateralTokenTester.deposit.selector, &quot;&quot;),</span>
  906 |     | <span class='unexecuted'>                (_coll - collateral.balanceOf(address(actor)))</span>
  907 |     | <span class='neutral'>            );</span>
  908 |     | <span class='unexecuted'>            require(success);</span>
  909 | *   | <span class='executed'>            require(</span>
  910 |     | <span class='unexecuted'>                collateral.balanceOf(address(actor)) &gt; _coll,</span>
  911 |     | <span class='neutral'>                &quot;Actor has high enough balance to add&quot;</span>
  912 |     | <span class='neutral'>            );</span>
  913 |     | <span class='neutral'>        }</span>
  914 |     | <span class='neutral'></span>
  915 | *   | <span class='executed'>        (success, ) = actor.proxy(</span>
  916 | *   | <span class='executed'>            address(collateral),</span>
  917 | *   | <span class='executed'>            abi.encodeWithSelector(</span>
  918 | *   | <span class='executed'>                CollateralTokenTester.approve.selector,</span>
  919 | *   | <span class='executed'>                address(borrowerOperations),</span>
  920 | *   | <span class='executed'>                _coll</span>
  921 |     | <span class='neutral'>            )</span>
  922 |     | <span class='neutral'>        );</span>
  923 | *   | <span class='executed'>        t(success, &quot;Approve never fails&quot;);</span>
  924 |     | <span class='neutral'></span>
  925 | *   | <span class='executed'>        _before(_cdpId);</span>
  926 |     | <span class='neutral'></span>
  927 |     | <span class='unexecuted'>        (success, returnData) = actor.proxy(</span>
  928 |     | <span class='unexecuted'>            address(borrowerOperations),</span>
  929 |     | <span class='unexecuted'>            abi.encodeWithSelector(</span>
  930 |     | <span class='neutral'>                BorrowerOperations.addColl.selector,</span>
  931 |     | <span class='neutral'>                _cdpId,</span>
  932 |     | <span class='neutral'>                _cdpId,</span>
  933 |     | <span class='neutral'>                _cdpId,</span>
  934 |     | <span class='neutral'>                _coll</span>
  935 |     | <span class='neutral'>            )</span>
  936 |     | <span class='neutral'>        );</span>
  937 |     | <span class='neutral'></span>
  938 |     | <span class='unexecuted'>        _after(_cdpId);</span>
  939 |     | <span class='neutral'></span>
  940 |     | <span class='unexecuted'>        if (success) {</span>
  941 |     | <span class='unexecuted'>            emit L3(</span>
  942 |     | <span class='unexecuted'>                vars.isRecoveryModeBefore ? 1 : 0,</span>
  943 |     | <span class='unexecuted'>                vars.hasGracePeriodPassedBefore ? 1 : 0,</span>
  944 |     | <span class='unexecuted'>                vars.icrAfter</span>
  945 |     | <span class='neutral'>            );</span>
  946 |     | <span class='unexecuted'>            emit L3(</span>
  947 |     | <span class='unexecuted'>                block.timestamp,</span>
  948 |     | <span class='unexecuted'>                cdpManager.lastGracePeriodStartTimestamp(),</span>
  949 |     | <span class='unexecuted'>                cdpManager.recoveryModeGracePeriodDuration()</span>
  950 |     | <span class='neutral'>            );</span>
  951 |     | <span class='neutral'></span>
  952 |     | <span class='unexecuted'>            eq(vars.newTcrAfter, vars.tcrAfter, GENERAL_11);</span>
  953 |     | <span class='unexecuted'>            gte(vars.nicrAfter, vars.nicrBefore, BO_03);</span>
  954 |     | <span class='neutral'>            // https://github.com/Badger-Finance/ebtc-fuzz-review/issues/3</span>
  955 |     | <span class='unexecuted'>            t(invariant_GENERAL_09(cdpManager, vars), GENERAL_09);</span>
  956 |     | <span class='neutral'>            // https://github.com/Badger-Finance/ebtc-fuzz-review/issues/4</span>
  957 |     | <span class='unexecuted'>            gte(</span>
  958 |     | <span class='unexecuted'>                collateral.getPooledEthByShares(cdpManager.getCdpCollShares(_cdpId)),</span>
  959 |     | <span class='neutral'>                borrowerOperations.MIN_NET_STETH_BALANCE(),</span>
  960 |     | <span class='neutral'>                GENERAL_10</span>
  961 |     | <span class='neutral'>            );</span>
  962 |     | <span class='neutral'></span>
  963 |     | <span class='unexecuted'>            t(invariant_GENERAL_01(vars), GENERAL_01);</span>
  964 |     | <span class='neutral'></span>
  965 |     | <span class='neutral'>            if (</span>
  966 |     | <span class='neutral'>                vars.lastGracePeriodStartTimestampIsSetBefore &amp;&amp;</span>
  967 |     | <span class='neutral'>                vars.isRecoveryModeBefore &amp;&amp;</span>
  968 |     | <span class='neutral'>                vars.isRecoveryModeAfter</span>
  969 |     | <span class='neutral'>            ) {</span>
  970 |     | <span class='neutral'>                eq(</span>
  971 |     | <span class='neutral'>                    vars.lastGracePeriodStartTimestampBefore,</span>
  972 |     | <span class='neutral'>                    vars.lastGracePeriodStartTimestampAfter,</span>
  973 |     | <span class='neutral'>                    L_14</span>
  974 |     | <span class='neutral'>                );</span>
  975 |     | <span class='neutral'>            }</span>
  976 |     | <span class='neutral'></span>
  977 |     | <span class='neutral'>            _checkL_15IfRecoveryMode();</span>
  978 |     | <span class='neutral'></span>
  979 |     | <span class='neutral'>            if (vars.isRecoveryModeBefore &amp;&amp; !vars.isRecoveryModeAfter) {</span>
  980 |     | <span class='neutral'>                t(!vars.lastGracePeriodStartTimestampIsSetAfter, L_16);</span>
  981 |     | <span class='neutral'>            }</span>
  982 |     | <span class='neutral'></span>
  983 |     | <span class='neutral'>            gte(_coll, borrowerOperations.MIN_CHANGE(), GENERAL_16);</span>
  984 |     | <span class='neutral'></span>
  985 |     | <span class='neutral'>            _checkStakeInvariants();</span>
  986 |     | <span class='neutral'>        } else {</span>
  987 |     | <span class='neutral'>            assertRevertReasonNotEqual(returnData, &quot;Panic(17)&quot;);</span>
  988 |     | <span class='neutral'>        }</span>
  989 |     | <span class='neutral'>    }</span>
  990 |     | <span class='neutral'></span>
  991 | *   | <span class='executed'>    function withdrawColl(uint _amount, uint256 _i) public setup {</span>
  992 |     | <span class='neutral'>        bool success;</span>
  993 | *   | <span class='executed'>        bytes memory returnData;</span>
  994 |     | <span class='neutral'></span>
  995 | *   | <span class='executed'>        uint256 numberOfCdps = sortedCdps.cdpCountOf(address(actor));</span>
  996 | *   | <span class='executed'>        require(numberOfCdps &gt; 0, &quot;Actor must have at least one CDP open&quot;);</span>
  997 |     | <span class='neutral'></span>
  998 | *   | <span class='executed'>        _i = between(_i, 0, numberOfCdps - 1);</span>
  999 | *   | <span class='executed'>        bytes32 _cdpId = sortedCdps.cdpOfOwnerByIndex(address(actor), _i);</span>
 1000 | *   | <span class='executed'>        t(_cdpId != bytes32(0), &quot;CDP ID must not be null if the index is valid&quot;);</span>
 1001 |     | <span class='neutral'></span>
 1002 |     | <span class='neutral'>        // Can only withdraw up to CDP collateral amount, otherwise will revert with assert</span>
 1003 | *   | <span class='executed'>        _amount = between(</span>
 1004 | *   | <span class='executed'>            _amount,</span>
 1005 | *   | <span class='executed'>            0,</span>
 1006 | *   | <span class='executed'>            collateral.getPooledEthByShares(cdpManager.getCdpCollShares(_cdpId))</span>
 1007 |     | <span class='neutral'>        );</span>
 1008 |     | <span class='neutral'></span>
 1009 | *   | <span class='executed'>        _before(_cdpId);</span>
 1010 |     | <span class='neutral'></span>
 1011 |     | <span class='unexecuted'>        (success, returnData) = actor.proxy(</span>
 1012 |     | <span class='unexecuted'>            address(borrowerOperations),</span>
 1013 |     | <span class='unexecuted'>            abi.encodeWithSelector(</span>
 1014 |     | <span class='neutral'>                BorrowerOperations.withdrawColl.selector,</span>
 1015 |     | <span class='neutral'>                _cdpId,</span>
 1016 |     | <span class='neutral'>                _amount,</span>
 1017 |     | <span class='neutral'>                _cdpId,</span>
 1018 |     | <span class='neutral'>                _cdpId</span>
 1019 |     | <span class='neutral'>            )</span>
 1020 |     | <span class='neutral'>        );</span>
 1021 |     | <span class='neutral'></span>
 1022 |     | <span class='unexecuted'>        _after(_cdpId);</span>
 1023 |     | <span class='neutral'></span>
 1024 |     | <span class='unexecuted'>        if (success) {</span>
 1025 |     | <span class='unexecuted'>            eq(vars.newTcrAfter, vars.tcrAfter, GENERAL_11);</span>
 1026 |     | <span class='unexecuted'>            lte(vars.nicrAfter, vars.nicrBefore, BO_04);</span>
 1027 |     | <span class='neutral'>            // https://github.com/Badger-Finance/ebtc-fuzz-review/issues/3</span>
 1028 |     | <span class='unexecuted'>            t(invariant_GENERAL_09(cdpManager, vars), GENERAL_09);</span>
 1029 |     | <span class='unexecuted'>            t(invariant_GENERAL_01(vars), GENERAL_01);</span>
 1030 |     | <span class='neutral'>            // https://github.com/Badger-Finance/ebtc-fuzz-review/issues/4</span>
 1031 |     | <span class='unexecuted'>            gte(</span>
 1032 |     | <span class='unexecuted'>                collateral.getPooledEthByShares(cdpManager.getCdpCollShares(_cdpId)),</span>
 1033 |     | <span class='neutral'>                borrowerOperations.MIN_NET_STETH_BALANCE(),</span>
 1034 |     | <span class='neutral'>                GENERAL_10</span>
 1035 |     | <span class='neutral'>            );</span>
 1036 |     | <span class='neutral'></span>
 1037 |     | <span class='unexecuted'>            if (</span>
 1038 |     | <span class='unexecuted'>                vars.lastGracePeriodStartTimestampIsSetBefore &amp;&amp;</span>
 1039 |     | <span class='unexecuted'>                vars.isRecoveryModeBefore &amp;&amp;</span>
 1040 |     | <span class='unexecuted'>                vars.isRecoveryModeAfter</span>
 1041 |     | <span class='neutral'>            ) {</span>
 1042 |     | <span class='unexecuted'>                eq(</span>
 1043 |     | <span class='unexecuted'>                    vars.lastGracePeriodStartTimestampBefore,</span>
 1044 |     | <span class='unexecuted'>                    vars.lastGracePeriodStartTimestampAfter,</span>
 1045 |     | <span class='unexecuted'>                    L_14</span>
 1046 |     | <span class='neutral'>                );</span>
 1047 |     | <span class='neutral'>            }</span>
 1048 |     | <span class='neutral'></span>
 1049 |     | <span class='unexecuted'>            _checkL_15IfRecoveryMode();</span>
 1050 |     | <span class='neutral'></span>
 1051 |     | <span class='unexecuted'>            if (vars.isRecoveryModeBefore &amp;&amp; !vars.isRecoveryModeAfter) {</span>
 1052 |     | <span class='unexecuted'>                t(!vars.lastGracePeriodStartTimestampIsSetAfter, L_16);</span>
 1053 |     | <span class='neutral'>            }</span>
 1054 |     | <span class='neutral'></span>
 1055 |     | <span class='unexecuted'>            gte(_amount, borrowerOperations.MIN_CHANGE(), GENERAL_16);</span>
 1056 |     | <span class='neutral'></span>
 1057 |     | <span class='neutral'>            _checkStakeInvariants();</span>
 1058 |     | <span class='neutral'>        } else {</span>
 1059 |     | <span class='unexecuted'>            assertRevertReasonNotEqual(returnData, &quot;Panic(17)&quot;);</span>
 1060 |     | <span class='neutral'>        }</span>
 1061 |     | <span class='neutral'>    }</span>
 1062 |     | <span class='neutral'></span>
 1063 | *   | <span class='executed'>    function withdrawDebt(uint _amount, uint256 _i) public setup {</span>
 1064 |     | <span class='neutral'>        bool success;</span>
 1065 | *   | <span class='executed'>        bytes memory returnData;</span>
 1066 |     | <span class='neutral'></span>
 1067 | *   | <span class='executed'>        uint256 numberOfCdps = sortedCdps.cdpCountOf(address(actor));</span>
 1068 | *   | <span class='executed'>        require(numberOfCdps &gt; 0, &quot;Actor must have at least one CDP open&quot;);</span>
 1069 |     | <span class='neutral'></span>
 1070 | *   | <span class='executed'>        _i = between(_i, 0, numberOfCdps - 1);</span>
 1071 | *   | <span class='executed'>        bytes32 _cdpId = sortedCdps.cdpOfOwnerByIndex(address(actor), _i);</span>
 1072 | *   | <span class='executed'>        t(_cdpId != bytes32(0), &quot;CDP ID must not be null if the index is valid&quot;);</span>
 1073 |     | <span class='neutral'></span>
 1074 |     | <span class='neutral'>        // TODO verify the assumption below, maybe there&#39;s a more sensible (or Governance-defined/hardcoded) limit for the maximum amount of minted eBTC at a single operation</span>
 1075 |     | <span class='neutral'>        // Can only withdraw up to type(uint128).max eBTC, so that `BorrwerOperations._getNewCdpAmounts` does not overflow</span>
 1076 | *   | <span class='executed'>        _amount = between(_amount, 0, type(uint128).max); /// NOTE: Implicitly testing for caps</span>
 1077 |     | <span class='neutral'></span>
 1078 | *   | <span class='executed'>        _before(_cdpId);</span>
 1079 |     | <span class='neutral'></span>
 1080 |     | <span class='unexecuted'>        (success, returnData) = actor.proxy(</span>
 1081 |     | <span class='unexecuted'>            address(borrowerOperations),</span>
 1082 |     | <span class='unexecuted'>            abi.encodeWithSelector(</span>
 1083 |     | <span class='neutral'>                BorrowerOperations.withdrawDebt.selector,</span>
 1084 |     | <span class='neutral'>                _cdpId,</span>
 1085 |     | <span class='neutral'>                _amount,</span>
 1086 |     | <span class='neutral'>                _cdpId,</span>
 1087 |     | <span class='neutral'>                _cdpId</span>
 1088 |     | <span class='neutral'>            )</span>
 1089 |     | <span class='neutral'>        );</span>
 1090 |     | <span class='neutral'></span>
 1091 |     | <span class='neutral'>        // Require(success) -&gt; If success, we check same stuff</span>
 1092 |     | <span class='neutral'>        // Else we ony verify no overflow</span>
 1093 |     | <span class='unexecuted'>        if (success) {</span>
 1094 |     | <span class='unexecuted'>            _after(_cdpId);</span>
 1095 |     | <span class='neutral'></span>
 1096 |     | <span class='unexecuted'>            eq(vars.newTcrAfter, vars.tcrAfter, GENERAL_11);</span>
 1097 |     | <span class='unexecuted'>            gte(vars.cdpDebtAfter, vars.cdpDebtBefore, &quot;withdrawDebt must not decrease debt&quot;);</span>
 1098 |     | <span class='unexecuted'>            eq(</span>
 1099 |     | <span class='unexecuted'>                vars.actorEbtcAfter,</span>
 1100 |     | <span class='unexecuted'>                vars.actorEbtcBefore + _amount,</span>
 1101 |     | <span class='neutral'>                &quot;withdrawDebt must increase debt by requested amount&quot;</span>
 1102 |     | <span class='neutral'>            );</span>
 1103 |     | <span class='neutral'>            // https://github.com/Badger-Finance/ebtc-fuzz-review/issues/4</span>
 1104 |     | <span class='unexecuted'>            gte(</span>
 1105 |     | <span class='unexecuted'>                collateral.getPooledEthByShares(cdpManager.getCdpCollShares(_cdpId)),</span>
 1106 |     | <span class='neutral'>                borrowerOperations.MIN_NET_STETH_BALANCE(),</span>
 1107 |     | <span class='neutral'>                GENERAL_10</span>
 1108 |     | <span class='neutral'>            );</span>
 1109 |     | <span class='neutral'></span>
 1110 |     | <span class='unexecuted'>            if (</span>
 1111 |     | <span class='unexecuted'>                vars.lastGracePeriodStartTimestampIsSetBefore &amp;&amp;</span>
 1112 |     | <span class='unexecuted'>                vars.isRecoveryModeBefore &amp;&amp;</span>
 1113 |     | <span class='unexecuted'>                vars.isRecoveryModeAfter</span>
 1114 |     | <span class='neutral'>            ) {</span>
 1115 |     | <span class='unexecuted'>                eq(</span>
 1116 |     | <span class='unexecuted'>                    vars.lastGracePeriodStartTimestampBefore,</span>
 1117 |     | <span class='unexecuted'>                    vars.lastGracePeriodStartTimestampAfter,</span>
 1118 |     | <span class='unexecuted'>                    L_14</span>
 1119 |     | <span class='neutral'>                );</span>
 1120 |     | <span class='neutral'>            }</span>
 1121 |     | <span class='neutral'></span>
 1122 |     | <span class='unexecuted'>            _checkL_15IfRecoveryMode();</span>
 1123 |     | <span class='neutral'></span>
 1124 |     | <span class='unexecuted'>            if (vars.isRecoveryModeBefore &amp;&amp; !vars.isRecoveryModeAfter) {</span>
 1125 |     | <span class='unexecuted'>                t(!vars.lastGracePeriodStartTimestampIsSetAfter, L_16);</span>
 1126 |     | <span class='neutral'>            }</span>
 1127 |     | <span class='neutral'></span>
 1128 |     | <span class='unexecuted'>            gte(_amount, borrowerOperations.MIN_CHANGE(), GENERAL_16);</span>
 1129 |     | <span class='unexecuted'>            gte(vars.cdpDebtAfter, borrowerOperations.MIN_CHANGE(), GENERAL_15);</span>
 1130 |     | <span class='neutral'></span>
 1131 |     | <span class='neutral'>            _checkStakeInvariants();</span>
 1132 |     | <span class='neutral'>        } else {</span>
 1133 |     | <span class='neutral'>            assertRevertReasonNotEqual(returnData, &quot;Panic(17)&quot;);</span>
 1134 |     | <span class='neutral'>        }</span>
 1135 |     | <span class='neutral'>    }</span>
 1136 |     | <span class='neutral'></span>
 1137 | *   | <span class='executed'>    function repayDebt(uint _amount, uint256 _i) public setup {</span>
 1138 |     | <span class='neutral'>        bool success;</span>
 1139 | *   | <span class='executed'>        bytes memory returnData;</span>
 1140 |     | <span class='neutral'></span>
 1141 | *   | <span class='executed'>        uint256 numberOfCdps = sortedCdps.cdpCountOf(address(actor));</span>
 1142 | *r  | <span class='executed'>        require(numberOfCdps &gt; 0, &quot;Actor must have at least one CDP open&quot;);</span>
 1143 |     | <span class='neutral'></span>
 1144 | *   | <span class='executed'>        _i = between(_i, 0, numberOfCdps - 1);</span>
 1145 | *   | <span class='executed'>        bytes32 _cdpId = sortedCdps.cdpOfOwnerByIndex(address(actor), _i);</span>
 1146 | *   | <span class='executed'>        t(_cdpId != bytes32(0), &quot;CDP ID must not be null if the index is valid&quot;);</span>
 1147 |     | <span class='neutral'></span>
 1148 | *   | <span class='executed'>        (uint256 entireDebt, ) = cdpManager.getSyncedDebtAndCollShares(_cdpId);</span>
 1149 |     | <span class='neutral'></span>
 1150 | *   | <span class='executed'>        _amount = between(_amount, 0, entireDebt);</span>
 1151 |     | <span class='neutral'></span>
 1152 | *   | <span class='executed'>        _before(_cdpId);</span>
 1153 |     | <span class='neutral'></span>
 1154 |     | <span class='unexecuted'>        (success, returnData) = actor.proxy(</span>
 1155 |     | <span class='unexecuted'>            address(borrowerOperations),</span>
 1156 |     | <span class='unexecuted'>            abi.encodeWithSelector(</span>
 1157 |     | <span class='neutral'>                BorrowerOperations.repayDebt.selector,</span>
 1158 |     | <span class='neutral'>                _cdpId,</span>
 1159 |     | <span class='neutral'>                _amount,</span>
 1160 |     | <span class='neutral'>                _cdpId,</span>
 1161 |     | <span class='neutral'>                _cdpId</span>
 1162 |     | <span class='neutral'>            )</span>
 1163 |     | <span class='neutral'>        );</span>
 1164 |     | <span class='unexecuted'>        if (success) {</span>
 1165 |     | <span class='unexecuted'>            _after(_cdpId);</span>
 1166 |     | <span class='neutral'></span>
 1167 |     | <span class='unexecuted'>            eq(vars.newTcrAfter, vars.tcrAfter, GENERAL_11);</span>
 1168 |     | <span class='neutral'></span>
 1169 |     | <span class='neutral'>            // https://github.com/Badger-Finance/ebtc-fuzz-review/issues/3</span>
 1170 |     | <span class='unexecuted'>            gte(vars.newTcrAfter, vars.newTcrBefore, BO_08);</span>
 1171 |     | <span class='neutral'></span>
 1172 |     | <span class='unexecuted'>            eq(vars.ebtcTotalSupplyBefore - _amount, vars.ebtcTotalSupplyAfter, BO_07);</span>
 1173 |     | <span class='unexecuted'>            eq(vars.actorEbtcBefore - _amount, vars.actorEbtcAfter, BO_07);</span>
 1174 |     | <span class='neutral'>            // https://github.com/Badger-Finance/ebtc-fuzz-review/issues/3</span>
 1175 |     | <span class='unexecuted'>            t(invariant_GENERAL_09(cdpManager, vars), GENERAL_09);</span>
 1176 |     | <span class='unexecuted'>            t(invariant_GENERAL_01(vars), GENERAL_01);</span>
 1177 |     | <span class='neutral'>            // https://github.com/Badger-Finance/ebtc-fuzz-review/issues/4</span>
 1178 |     | <span class='unexecuted'>            gte(</span>
 1179 |     | <span class='unexecuted'>                collateral.getPooledEthByShares(cdpManager.getCdpCollShares(_cdpId)),</span>
 1180 |     | <span class='unexecuted'>                borrowerOperations.MIN_NET_STETH_BALANCE(),</span>
 1181 |     | <span class='unexecuted'>                GENERAL_10</span>
 1182 |     | <span class='neutral'>            );</span>
 1183 |     | <span class='neutral'></span>
 1184 |     | <span class='unexecuted'>            if (</span>
 1185 |     | <span class='unexecuted'>                vars.lastGracePeriodStartTimestampIsSetBefore &amp;&amp;</span>
 1186 |     | <span class='unexecuted'>                vars.isRecoveryModeBefore &amp;&amp;</span>
 1187 |     | <span class='unexecuted'>                vars.isRecoveryModeAfter</span>
 1188 |     | <span class='neutral'>            ) {</span>
 1189 |     | <span class='unexecuted'>                eq(</span>
 1190 |     | <span class='unexecuted'>                    vars.lastGracePeriodStartTimestampBefore,</span>
 1191 |     | <span class='unexecuted'>                    vars.lastGracePeriodStartTimestampAfter,</span>
 1192 |     | <span class='unexecuted'>                    L_14</span>
 1193 |     | <span class='neutral'>                );</span>
 1194 |     | <span class='neutral'>            }</span>
 1195 |     | <span class='neutral'></span>
 1196 |     | <span class='unexecuted'>            _checkL_15IfRecoveryMode();</span>
 1197 |     | <span class='neutral'></span>
 1198 |     | <span class='unexecuted'>            if (vars.isRecoveryModeBefore &amp;&amp; !vars.isRecoveryModeAfter) {</span>
 1199 |     | <span class='unexecuted'>                t(!vars.lastGracePeriodStartTimestampIsSetAfter, L_16);</span>
 1200 |     | <span class='neutral'>            }</span>
 1201 |     | <span class='neutral'></span>
 1202 |     | <span class='unexecuted'>            gte(_amount, borrowerOperations.MIN_CHANGE(), GENERAL_16);</span>
 1203 |     | <span class='unexecuted'>            gte(vars.cdpDebtAfter, borrowerOperations.MIN_CHANGE(), GENERAL_15);</span>
 1204 |     | <span class='neutral'></span>
 1205 |     | <span class='unexecuted'>            _checkStakeInvariants();</span>
 1206 |     | <span class='neutral'>        } else {</span>
 1207 |     | <span class='unexecuted'>            assertRevertReasonNotEqual(returnData, &quot;Panic(17)&quot;);</span>
 1208 |     | <span class='neutral'>        }</span>
 1209 |     | <span class='neutral'>    }</span>
 1210 |     | <span class='neutral'></span>
 1211 | *   | <span class='executed'>    function closeCdp(uint _i) public setup {</span>
 1212 |     | <span class='neutral'>        bool success;</span>
 1213 | *   | <span class='executed'>        bytes memory returnData;</span>
 1214 |     | <span class='neutral'></span>
 1215 | *   | <span class='executed'>        require(cdpManager.getActiveCdpsCount() &gt; 1, &quot;Cannot close last CDP&quot;);</span>
 1216 |     | <span class='neutral'></span>
 1217 | *   | <span class='executed'>        uint256 numberOfCdps = sortedCdps.cdpCountOf(address(actor));</span>
 1218 | *   | <span class='executed'>        require(numberOfCdps &gt; 0, &quot;Actor must have at least one CDP open&quot;);</span>
 1219 |     | <span class='neutral'></span>
 1220 | *   | <span class='executed'>        _i = between(_i, 0, numberOfCdps - 1);</span>
 1221 | *   | <span class='executed'>        bytes32 _cdpId = sortedCdps.cdpOfOwnerByIndex(address(actor), _i);</span>
 1222 | *   | <span class='executed'>        t(_cdpId != bytes32(0), &quot;CDP ID must not be null if the index is valid&quot;);</span>
 1223 |     | <span class='neutral'></span>
 1224 | *   | <span class='executed'>        _before(_cdpId);</span>
 1225 |     | <span class='neutral'></span>
 1226 |     | <span class='unexecuted'>        (success, returnData) = actor.proxy(</span>
 1227 |     | <span class='unexecuted'>            address(borrowerOperations),</span>
 1228 |     | <span class='unexecuted'>            abi.encodeWithSelector(BorrowerOperations.closeCdp.selector, _cdpId)</span>
 1229 |     | <span class='neutral'>        );</span>
 1230 |     | <span class='neutral'></span>
 1231 |     | <span class='unexecuted'>        _after(_cdpId);</span>
 1232 |     | <span class='neutral'></span>
 1233 |     | <span class='unexecuted'>        if (success) {</span>
 1234 |     | <span class='unexecuted'>            eq(vars.newTcrAfter, vars.tcrAfter, GENERAL_11);</span>
 1235 |     | <span class='unexecuted'>            eq(vars.cdpDebtAfter, 0, BO_02);</span>
 1236 |     | <span class='unexecuted'>            eq(</span>
 1237 |     | <span class='unexecuted'>                vars.sortedCdpsSizeBefore - 1,</span>
 1238 |     | <span class='unexecuted'>                vars.sortedCdpsSizeAfter,</span>
 1239 |     | <span class='neutral'>                &quot;closeCdp reduces list size by 1&quot;</span>
 1240 |     | <span class='neutral'>            );</span>
 1241 |     | <span class='unexecuted'>            gt(</span>
 1242 |     | <span class='unexecuted'>                vars.actorCollAfter,</span>
 1243 |     | <span class='unexecuted'>                vars.actorCollBefore,</span>
 1244 |     | <span class='neutral'>                &quot;closeCdp increases the collateral balance of the user&quot;</span>
 1245 |     | <span class='neutral'>            );</span>
 1246 |     | <span class='neutral'>            // https://github.com/Badger-Finance/ebtc-fuzz-review/issues/3</span>
 1247 |     | <span class='unexecuted'>            t(invariant_GENERAL_09(cdpManager, vars), GENERAL_09);</span>
 1248 |     | <span class='unexecuted'>            emit L4(</span>
 1249 |     | <span class='unexecuted'>                vars.actorCollBefore,</span>
 1250 |     | <span class='unexecuted'>                vars.cdpCollBefore,</span>
 1251 |     | <span class='unexecuted'>                vars.liquidatorRewardSharesBefore,</span>
 1252 |     | <span class='unexecuted'>                vars.actorCollAfter</span>
 1253 |     | <span class='neutral'>            );</span>
 1254 |     | <span class='unexecuted'>            gt(</span>
 1255 |     | <span class='neutral'>                // https://github.com/Badger-Finance/ebtc-fuzz-review/issues/11</span>
 1256 |     | <span class='neutral'>                // Note: not checking for strict equality since split fee is difficult to calculate a-priori, so the CDP collateral value may not be sent back to the user in full</span>
 1257 |     | <span class='unexecuted'>                vars.actorCollAfter,</span>
 1258 |     | <span class='unexecuted'>                vars.actorCollBefore +</span>
 1259 |     | <span class='neutral'>                    // ActivePool transfer SHARES not ETH directly</span>
 1260 |     | <span class='unexecuted'>                    collateral.getPooledEthByShares(vars.liquidatorRewardSharesBefore),</span>
 1261 |     | <span class='unexecuted'>                BO_05</span>
 1262 |     | <span class='neutral'>            );</span>
 1263 |     | <span class='unexecuted'>            t(invariant_GENERAL_01(vars), GENERAL_01);</span>
 1264 |     | <span class='neutral'></span>
 1265 |     | <span class='unexecuted'>            if (</span>
 1266 |     | <span class='unexecuted'>                vars.lastGracePeriodStartTimestampIsSetBefore &amp;&amp;</span>
 1267 |     | <span class='unexecuted'>                vars.isRecoveryModeBefore &amp;&amp;</span>
 1268 |     | <span class='unexecuted'>                vars.isRecoveryModeAfter</span>
 1269 |     | <span class='neutral'>            ) {</span>
 1270 |     | <span class='unexecuted'>                eq(</span>
 1271 |     | <span class='unexecuted'>                    vars.lastGracePeriodStartTimestampBefore,</span>
 1272 |     | <span class='unexecuted'>                    vars.lastGracePeriodStartTimestampAfter,</span>
 1273 |     | <span class='unexecuted'>                    L_14</span>
 1274 |     | <span class='neutral'>                );</span>
 1275 |     | <span class='neutral'>            }</span>
 1276 |     | <span class='neutral'></span>
 1277 |     | <span class='unexecuted'>            _checkL_15IfRecoveryMode();</span>
 1278 |     | <span class='neutral'></span>
 1279 |     | <span class='unexecuted'>            if (vars.isRecoveryModeBefore &amp;&amp; !vars.isRecoveryModeAfter) {</span>
 1280 |     | <span class='unexecuted'>                t(!vars.lastGracePeriodStartTimestampIsSetAfter, L_16);</span>
 1281 |     | <span class='neutral'>            }</span>
 1282 |     | <span class='neutral'></span>
 1283 |     | <span class='unexecuted'>            _checkStakeInvariants();</span>
 1284 |     | <span class='neutral'>        } else {</span>
 1285 |     | <span class='unexecuted'>            assertRevertReasonNotEqual(returnData, &quot;Panic(17)&quot;);</span>
 1286 |     | <span class='neutral'>        }</span>
 1287 |     | <span class='neutral'>    }</span>
 1288 |     | <span class='neutral'></span>
 1289 | *   | <span class='executed'>    function adjustCdp(</span>
 1290 |     | <span class='neutral'>        uint _i,</span>
 1291 |     | <span class='neutral'>        uint _collWithdrawal,</span>
 1292 |     | <span class='neutral'>        uint _EBTCChange,</span>
 1293 |     | <span class='neutral'>        bool _isDebtIncrease</span>
 1294 |     | <span class='unexecuted'>    ) public setup {</span>
 1295 |     | <span class='neutral'>        bool success;</span>
 1296 | *   | <span class='executed'>        bytes memory returnData;</span>
 1297 |     | <span class='neutral'></span>
 1298 | *   | <span class='executed'>        uint256 numberOfCdps = sortedCdps.cdpCountOf(address(actor));</span>
 1299 | *   | <span class='executed'>        require(numberOfCdps &gt; 0, &quot;Actor must have at least one CDP open&quot;);</span>
 1300 |     | <span class='neutral'></span>
 1301 | *   | <span class='executed'>        _i = between(_i, 0, numberOfCdps - 1);</span>
 1302 | *   | <span class='executed'>        bytes32 _cdpId = sortedCdps.cdpOfOwnerByIndex(address(actor), _i);</span>
 1303 | *   | <span class='executed'>        t(_cdpId != bytes32(0), &quot;CDP ID must not be null if the index is valid&quot;);</span>
 1304 |     | <span class='neutral'></span>
 1305 | *   | <span class='executed'>        (uint256 entireDebt, uint256 entireColl) = cdpManager.getSyncedDebtAndCollShares(_cdpId);</span>
 1306 | *   | <span class='executed'>        _collWithdrawal = between(_collWithdrawal, 0, entireColl);</span>
 1307 | *   | <span class='executed'>        _EBTCChange = between(_EBTCChange, 0, entireDebt);</span>
 1308 |     | <span class='neutral'></span>
 1309 | *   | <span class='executed'>        _before(_cdpId);</span>
 1310 |     | <span class='neutral'></span>
 1311 |     | <span class='unexecuted'>        (success, returnData) = actor.proxy(</span>
 1312 |     | <span class='unexecuted'>            address(borrowerOperations),</span>
 1313 |     | <span class='unexecuted'>            abi.encodeWithSelector(</span>
 1314 |     | <span class='neutral'>                BorrowerOperations.adjustCdp.selector,</span>
 1315 |     | <span class='neutral'>                _cdpId,</span>
 1316 |     | <span class='neutral'>                _collWithdrawal,</span>
 1317 |     | <span class='neutral'>                _EBTCChange,</span>
 1318 |     | <span class='neutral'>                _isDebtIncrease,</span>
 1319 |     | <span class='neutral'>                _cdpId,</span>
 1320 |     | <span class='neutral'>                _cdpId</span>
 1321 |     | <span class='neutral'>            )</span>
 1322 |     | <span class='neutral'>        );</span>
 1323 |     | <span class='neutral'></span>
 1324 |     | <span class='unexecuted'>        require(success);</span>
 1325 |     | <span class='neutral'></span>
 1326 |     | <span class='unexecuted'>        _after(_cdpId);</span>
 1327 |     | <span class='neutral'></span>
 1328 |     | <span class='unexecuted'>        eq(vars.newTcrAfter, vars.tcrAfter, GENERAL_11);</span>
 1329 |     | <span class='neutral'>        // https://github.com/Badger-Finance/ebtc-fuzz-review/issues/3</span>
 1330 |     | <span class='unexecuted'>        t(invariant_GENERAL_09(cdpManager, vars), GENERAL_09);</span>
 1331 |     | <span class='neutral'></span>
 1332 |     | <span class='unexecuted'>        t(invariant_GENERAL_01(vars), GENERAL_01);</span>
 1333 |     | <span class='neutral'>        // https://github.com/Badger-Finance/ebtc-fuzz-review/issues/4</span>
 1334 |     | <span class='unexecuted'>        gte(</span>
 1335 |     | <span class='unexecuted'>            collateral.getPooledEthByShares(cdpManager.getCdpCollShares(_cdpId)),</span>
 1336 |     | <span class='neutral'>            borrowerOperations.MIN_NET_STETH_BALANCE(),</span>
 1337 |     | <span class='neutral'>            GENERAL_10</span>
 1338 |     | <span class='neutral'>        );</span>
 1339 |     | <span class='neutral'></span>
 1340 |     | <span class='unexecuted'>        if (</span>
 1341 |     | <span class='unexecuted'>            vars.lastGracePeriodStartTimestampIsSetBefore &amp;&amp;</span>
 1342 |     | <span class='unexecuted'>            vars.isRecoveryModeBefore &amp;&amp;</span>
 1343 |     | <span class='unexecuted'>            vars.isRecoveryModeAfter</span>
 1344 |     | <span class='neutral'>        ) {</span>
 1345 |     | <span class='unexecuted'>            eq(</span>
 1346 |     | <span class='unexecuted'>                vars.lastGracePeriodStartTimestampBefore,</span>
 1347 |     | <span class='unexecuted'>                vars.lastGracePeriodStartTimestampAfter,</span>
 1348 |     | <span class='unexecuted'>                L_14</span>
 1349 |     | <span class='neutral'>            );</span>
 1350 |     | <span class='neutral'>        }</span>
 1351 |     | <span class='neutral'></span>
 1352 |     | <span class='unexecuted'>        _checkL_15IfRecoveryMode();</span>
 1353 |     | <span class='neutral'></span>
 1354 |     | <span class='unexecuted'>        if (vars.isRecoveryModeBefore &amp;&amp; !vars.isRecoveryModeAfter) {</span>
 1355 |     | <span class='unexecuted'>            t(!vars.lastGracePeriodStartTimestampIsSetAfter, L_16);</span>
 1356 |     | <span class='neutral'>        }</span>
 1357 |     | <span class='neutral'></span>
 1358 |     | <span class='unexecuted'>        if (_collWithdrawal &gt; 0) {</span>
 1359 |     | <span class='unexecuted'>            gte(_collWithdrawal, borrowerOperations.MIN_CHANGE(), GENERAL_16);</span>
 1360 |     | <span class='neutral'>        }</span>
 1361 |     | <span class='neutral'></span>
 1362 |     | <span class='unexecuted'>        if (_isDebtIncrease) {</span>
 1363 |     | <span class='unexecuted'>            gte(_EBTCChange, borrowerOperations.MIN_CHANGE(), GENERAL_16);</span>
 1364 |     | <span class='neutral'>        } else {</span>
 1365 |     | <span class='neutral'>            // it&#39;s ok for _EBTCChange to be 0 if we are not increasing debt (coll only operation)</span>
 1366 |     | <span class='unexecuted'>            if (_EBTCChange &gt; 0) {</span>
 1367 |     | <span class='unexecuted'>                gte(_EBTCChange, borrowerOperations.MIN_CHANGE(), GENERAL_16);</span>
 1368 |     | <span class='neutral'>            }</span>
 1369 |     | <span class='neutral'>        }</span>
 1370 |     | <span class='unexecuted'>        gte(vars.cdpDebtAfter, borrowerOperations.MIN_CHANGE(), GENERAL_15);</span>
 1371 |     | <span class='neutral'></span>
 1372 |     | <span class='unexecuted'>        _checkStakeInvariants();</span>
 1373 |     | <span class='neutral'>    }</span>
 1374 |     | <span class='neutral'></span>
 1375 |     | <span class='neutral'>    ///////////////////////////////////////////////////////</span>
 1376 |     | <span class='neutral'>    // Collateral Token (Test)</span>
 1377 |     | <span class='neutral'>    ///////////////////////////////////////////////////////</span>
 1378 |     | <span class='neutral'></span>
 1379 |     | <span class='neutral'>    // Example for real world slashing: https://twitter.com/LidoFinance/status/1646505631678107649</span>
 1380 |     | <span class='neutral'>    // &gt; There are 11 slashing ongoing with the RockLogic GmbH node operator in Lido.</span>
 1381 |     | <span class='neutral'>    // &gt; the total projected impact is around 20 ETH,</span>
 1382 |     | <span class='neutral'>    // &gt; or about 3% of average daily protocol rewards/0.0004% of TVL.</span>
 1383 |     | <span class='neutral'>    function setEthPerShare(uint256 _newEthPerShare) public virtual {</span>
 1384 |     | <span class='neutral'>        uint256 currentEthPerShare = collateral.getEthPerShare();</span>
 1385 |     | <span class='neutral'>        _newEthPerShare = between(</span>
 1386 |     | <span class='neutral'>            _newEthPerShare,</span>
 1387 |     | <span class='neutral'>            (currentEthPerShare * 1e18) / MAX_REBASE_PERCENT,</span>
 1388 |     | <span class='neutral'>            (currentEthPerShare * MAX_REBASE_PERCENT) / 1e18</span>
 1389 |     | <span class='neutral'>        );</span>
 1390 |     | <span class='neutral'>        vars.prevStEthFeeIndex = cdpManager.systemStEthFeePerUnitIndex();</span>
 1391 |     | <span class='neutral'>        collateral.setEthPerShare(_newEthPerShare);</span>
 1392 |     | <span class='neutral'>        AccruableCdpManager(address(cdpManager)).syncGlobalAccountingInternal();</span>
 1393 |     | <span class='neutral'>        vars.afterStEthFeeIndex = cdpManager.systemStEthFeePerUnitIndex();</span>
 1394 |     | <span class='neutral'></span>
 1395 |     | <span class='neutral'>        if (vars.afterStEthFeeIndex &gt; vars.prevStEthFeeIndex) {</span>
 1396 |     | <span class='neutral'>            vars.cumulativeCdpsAtTimeOfRebase += cdpManager.getActiveCdpsCount();</span>
 1397 |     | <span class='neutral'>        }</span>
 1398 |     | <span class='neutral'>    }</span>
 1399 |     | <span class='neutral'></span>
 1400 |     | <span class='neutral'>    ///////////////////////////////////////////////////////</span>
 1401 |     | <span class='neutral'>    // PriceFeed</span>
 1402 |     | <span class='neutral'>    ///////////////////////////////////////////////////////</span>
 1403 |     | <span class='neutral'></span>
 1404 |     | <span class='neutral'>    function setPrice(uint256 _newPrice) public virtual {</span>
 1405 |     | <span class='neutral'>        uint256 currentPrice = priceFeedMock.fetchPrice();</span>
 1406 |     | <span class='neutral'>        _newPrice = between(</span>
 1407 |     | <span class='neutral'>            _newPrice,</span>
 1408 |     | <span class='neutral'>            (currentPrice * 1e18) / MAX_PRICE_CHANGE_PERCENT,</span>
 1409 |     | <span class='neutral'>            (currentPrice * MAX_PRICE_CHANGE_PERCENT) / 1e18</span>
 1410 |     | <span class='neutral'>        );</span>
 1411 |     | <span class='neutral'>        priceFeedMock.setPrice(_newPrice);</span>
 1412 |     | <span class='neutral'>    }</span>
 1413 |     | <span class='neutral'></span>
 1414 |     | <span class='neutral'>    ///////////////////////////////////////////////////////</span>
 1415 |     | <span class='neutral'>    // Governance</span>
 1416 |     | <span class='neutral'>    ///////////////////////////////////////////////////////</span>
 1417 |     | <span class='neutral'></span>
 1418 |     | <span class='neutral'>    function setGovernanceParameters(uint256 parameter, uint256 value) public virtual {</span>
 1419 |     | <span class='neutral'>        parameter = between(parameter, 0, 6);</span>
 1420 |     | <span class='neutral'></span>
 1421 |     | <span class='neutral'>        if (parameter == 0) {</span>
 1422 |     | <span class='neutral'>            value = between(value, cdpManager.MINIMUM_GRACE_PERIOD(), type(uint128).max);</span>
 1423 |     | <span class='neutral'>            hevm.prank(defaultGovernance);</span>
 1424 |     | <span class='neutral'>            cdpManager.setGracePeriod(uint128(value));</span>
 1425 |     | <span class='neutral'>        } else if (parameter == 1) {</span>
 1426 |     | <span class='neutral'>            value = between(value, 0, activePool.getFeeRecipientClaimableCollShares());</span>
 1427 |     | <span class='neutral'>            _before(bytes32(0));</span>
 1428 |     | <span class='neutral'>            hevm.prank(defaultGovernance);</span>
 1429 |     | <span class='neutral'>            activePool.claimFeeRecipientCollShares(value);</span>
 1430 |     | <span class='neutral'>            _after(bytes32(0));</span>
 1431 |     | <span class='neutral'>            // If there was something to claim</span>
 1432 |     | <span class='neutral'>            if (value &gt; 0) {</span>
 1433 |     | <span class='neutral'>                // https://github.com/Badger-Finance/ebtc-fuzz-review/issues/22</span>
 1434 |     | <span class='neutral'>                // Claiming will increase the balance</span>
 1435 |     | <span class='neutral'>                // Strictly GT</span>
 1436 |     | <span class='neutral'>                gt(vars.feeRecipientCollSharesBalAfter, vars.feeRecipientCollSharesBalBefore, F_01);</span>
 1437 |     | <span class='neutral'>                gte(vars.feeRecipientTotalCollAfter, vars.feeRecipientTotalCollBefore, F_01);</span>
 1438 |     | <span class='neutral'>            }</span>
 1439 |     | <span class='neutral'>        } else if (parameter == 2) {</span>
 1440 |     | <span class='neutral'>            value = between(value, 0, cdpManager.MAX_REWARD_SPLIT());</span>
 1441 |     | <span class='neutral'>            hevm.prank(defaultGovernance);</span>
 1442 |     | <span class='neutral'>            cdpManager.setStakingRewardSplit(value);</span>
 1443 |     | <span class='neutral'>        } else if (parameter == 3) {</span>
 1444 |     | <span class='neutral'>            value = between(</span>
 1445 |     | <span class='neutral'>                value,</span>
 1446 |     | <span class='neutral'>                cdpManager.MIN_REDEMPTION_FEE_FLOOR(),</span>
 1447 |     | <span class='neutral'>                cdpManager.DECIMAL_PRECISION()</span>
 1448 |     | <span class='neutral'>            );</span>
 1449 |     | <span class='neutral'>            hevm.prank(defaultGovernance);</span>
 1450 |     | <span class='neutral'>            cdpManager.setRedemptionFeeFloor(value);</span>
 1451 |     | <span class='neutral'>        } else if (parameter == 4) {</span>
 1452 |     | <span class='neutral'>            value = between(</span>
 1453 |     | <span class='neutral'>                value,</span>
 1454 |     | <span class='neutral'>                cdpManager.MIN_MINUTE_DECAY_FACTOR(),</span>
 1455 |     | <span class='neutral'>                cdpManager.MAX_MINUTE_DECAY_FACTOR()</span>
 1456 |     | <span class='neutral'>            );</span>
 1457 |     | <span class='neutral'>            hevm.prank(defaultGovernance);</span>
 1458 |     | <span class='neutral'>            cdpManager.setMinuteDecayFactor(value);</span>
 1459 |     | <span class='neutral'>        } else if (parameter == 5) {</span>
 1460 |     | <span class='neutral'>            value = between(value, 0, cdpManager.DECIMAL_PRECISION());</span>
 1461 |     | <span class='neutral'>            hevm.prank(defaultGovernance);</span>
 1462 |     | <span class='neutral'>            cdpManager.setBeta(value);</span>
 1463 |     | <span class='neutral'>        } else if (parameter == 6) {</span>
 1464 |     | <span class='neutral'>            value = between(value, 0, 1);</span>
 1465 |     | <span class='neutral'>            hevm.prank(defaultGovernance);</span>
 1466 |     | <span class='neutral'>            cdpManager.setRedemptionsPaused(value == 1 ? true : false);</span>
 1467 |     | <span class='neutral'>        }</span>
 1468 |     | <span class='neutral'>    }</span>
 1469 |     | <span class='neutral'>}</span>
 1470 |     | <span class='neutral'></span>

</code>
<br />

<b>/mnt/c/Users/Lourens/Documents/Recon-Fuzz/collabs/ebtc/packages/contracts/contracts/TestContracts/invariants/echidna/EchidnaAsserts.sol</b>
<code>
  1 |     | <span class='neutral'>pragma solidity 0.8.17;</span>
  2 |     | <span class='neutral'></span>
  3 |     | <span class='neutral'>import &quot;@crytic/properties/contracts/util/PropertiesHelper.sol&quot;;</span>
  4 |     | <span class='neutral'>import &quot;../Asserts.sol&quot;;</span>
  5 |     | <span class='neutral'></span>
  6 |     | <span class='neutral'>abstract contract EchidnaAsserts is PropertiesAsserts, Asserts {</span>
  7 | *   | <span class='executed'>    function gt(uint256 a, uint256 b, string memory message) internal override {</span>
  8 | *   | <span class='executed'>        assertGt(a, b, message);</span>
  9 |     | <span class='neutral'>    }</span>
 10 |     | <span class='neutral'></span>
 11 | *   | <span class='executed'>    function lt(uint256 a, uint256 b, string memory message) internal override {</span>
 12 | *   | <span class='executed'>        assertLt(a, b, message);</span>
 13 |     | <span class='neutral'>    }</span>
 14 |     | <span class='neutral'></span>
 15 | *   | <span class='executed'>    function gte(uint256 a, uint256 b, string memory message) internal override {</span>
 16 | *   | <span class='executed'>        assertGte(a, b, message);</span>
 17 |     | <span class='neutral'>    }</span>
 18 |     | <span class='neutral'></span>
 19 | *   | <span class='executed'>    function lte(uint256 a, uint256 b, string memory message) internal override {</span>
 20 | *   | <span class='executed'>        assertLte(a, b, message);</span>
 21 |     | <span class='neutral'>    }</span>
 22 |     | <span class='neutral'></span>
 23 | *   | <span class='executed'>    function eq(uint256 a, uint256 b, string memory message) internal override {</span>
 24 | *   | <span class='executed'>        assertEq(a, b, message);</span>
 25 |     | <span class='neutral'>    }</span>
 26 |     | <span class='neutral'></span>
 27 | *   | <span class='executed'>    function t(bool a, string memory message) internal override {</span>
 28 | *   | <span class='executed'>        assertWithMsg(a, message);</span>
 29 |     | <span class='neutral'>    }</span>
 30 |     | <span class='neutral'></span>
 31 | *   | <span class='executed'>    function between(uint256 value, uint256 low, uint256 high) internal override returns (uint256) {</span>
 32 | *   | <span class='executed'>        return clampBetween(value, low, high);</span>
 33 |     | <span class='neutral'>    }</span>
 34 |     | <span class='neutral'>}</span>
 35 |     | <span class='neutral'></span>

</code>
<br />

<b>/mnt/c/Users/Lourens/Documents/Recon-Fuzz/collabs/ebtc/packages/contracts/contracts/TestContracts/invariants/echidna/EchidnaForkAssertions.sol</b>
<code>
   1 |     | <span class='neutral'>pragma solidity 0.8.17;</span>
   2 |     | <span class='neutral'></span>
   3 |     | <span class='neutral'>import {TargetContractSetup} from &quot;../TargetContractSetup.sol&quot;;</span>
   4 |     | <span class='neutral'>import {Properties} from &quot;../Properties.sol&quot;;</span>
   5 |     | <span class='neutral'></span>
   6 |     | <span class='neutral'>abstract contract EchidnaForkAssertions is TargetContractSetup, Properties {</span>
   7 |     | <span class='unexecuted'>    function echidna_canary_price() public {</span>
   8 |     | <span class='unexecuted'>        t(invariant_DUMMY_01(priceFeedMock), &quot;Dummy&quot;);</span>
   9 |     | <span class='neutral'>    }</span>
  10 |     | <span class='neutral'></span>
  11 |     | <span class='unexecuted'>    function echidna_active_pool_invariant_1() public {</span>
  12 |     | <span class='unexecuted'>        t(invariant_AP_01(collateral, activePool), AP_01);</span>
  13 |     | <span class='neutral'>    }</span>
  14 |     | <span class='neutral'></span>
  15 |     | <span class='unexecuted'>    function echidna_active_pool_invariant_2() public {</span>
  16 |     | <span class='unexecuted'>        t(invariant_AP_02(cdpManager, activePool), AP_02);</span>
  17 |     | <span class='neutral'>    }</span>
  18 |     | <span class='neutral'></span>
  19 |     | <span class='unexecuted'>    function echidna_active_pool_invariant_3() public {</span>
  20 |     | <span class='unexecuted'>        t(invariant_AP_03(eBTCToken, activePool), AP_03);</span>
  21 |     | <span class='neutral'>    }</span>
  22 |     | <span class='neutral'></span>
  23 |     | <span class='unexecuted'>    function echidna_active_pool_invariant_4() public {</span>
  24 |     | <span class='unexecuted'>        t(invariant_AP_04(cdpManager, activePool, diff_tolerance), AP_04);</span>
  25 |     | <span class='neutral'>    }</span>
  26 |     | <span class='neutral'></span>
  27 |     | <span class='unexecuted'>    function echidna_active_pool_invariant_5() public {</span>
  28 |     | <span class='unexecuted'>        t(invariant_AP_05(cdpManager, diff_tolerance), AP_05);</span>
  29 |     | <span class='neutral'>    }</span>
  30 |     | <span class='neutral'></span>
  31 |     | <span class='unexecuted'>    function echidna_cdp_manager_invariant_1() public {</span>
  32 |     | <span class='unexecuted'>        t(invariant_CDPM_01(cdpManager, sortedCdps), CDPM_01);</span>
  33 |     | <span class='neutral'>    }</span>
  34 |     | <span class='neutral'></span>
  35 |     | <span class='unexecuted'>    function echidna_cdp_manager_invariant_2() public {</span>
  36 |     | <span class='unexecuted'>        t(invariant_CDPM_02(cdpManager), CDPM_02);</span>
  37 |     | <span class='neutral'>    }</span>
  38 |     | <span class='neutral'></span>
  39 | *   | <span class='executed'>    function echidna_cdp_manager_invariant_3() public {</span>
  40 | *   | <span class='executed'>        t(invariant_CDPM_03(cdpManager), CDPM_03);</span>
  41 |     | <span class='neutral'>    }</span>
  42 |     | <span class='neutral'></span>
  43 |     | <span class='unexecuted'>    function echidna_cdp_manager_invariant_10() public {</span>
  44 |     | <span class='unexecuted'>        t(invariant_CDPM_10(cdpManager), CDPM_10);</span>
  45 |     | <span class='neutral'>    }</span>
  46 |     | <span class='neutral'></span>
  47 |     | <span class='unexecuted'>    function echidna_cdp_manager_invariant_11() public {</span>
  48 |     | <span class='unexecuted'>        t(invariant_CDPM_11(cdpManager), CDPM_11);</span>
  49 |     | <span class='neutral'>    }</span>
  50 |     | <span class='neutral'></span>
  51 |     | <span class='unexecuted'>    function echidna_cdp_manager_invariant_12() public {</span>
  52 |     | <span class='unexecuted'>        t(invariant_CDPM_12(sortedCdps, vars), CDPM_12);</span>
  53 |     | <span class='neutral'>    }</span>
  54 |     | <span class='neutral'></span>
  55 |     | <span class='neutral'>    // CDPM_04 is a vars invariant</span>
  56 |     | <span class='neutral'></span>
  57 |     | <span class='unexecuted'>    function echidna_coll_surplus_pool_invariant_1() public {</span>
  58 |     | <span class='unexecuted'>        t(invariant_CSP_01(collateral, collSurplusPool), CSP_01);</span>
  59 |     | <span class='neutral'>    }</span>
  60 |     | <span class='neutral'></span>
  61 |     | <span class='unexecuted'>    function echidna_coll_surplus_pool_invariant_2() public {</span>
  62 |     | <span class='unexecuted'>        t(invariant_CSP_02(collSurplusPool), CSP_02);</span>
  63 |     | <span class='neutral'>    }</span>
  64 |     | <span class='neutral'></span>
  65 |     | <span class='unexecuted'>    function echidna_sorted_list_invariant_1() public {</span>
  66 |     | <span class='unexecuted'>        t(invariant_SL_01(cdpManager, sortedCdps), SL_01);</span>
  67 |     | <span class='neutral'>    }</span>
  68 |     | <span class='neutral'></span>
  69 |     | <span class='unexecuted'>    function echidna_sorted_list_invariant_2() public {</span>
  70 |     | <span class='unexecuted'>        t(invariant_SL_02(cdpManager, sortedCdps, priceFeedMock), SL_02);</span>
  71 |     | <span class='neutral'>    }</span>
  72 |     | <span class='neutral'></span>
  73 |     | <span class='unexecuted'>    function echidna_sorted_list_invariant_3() public {</span>
  74 |     | <span class='unexecuted'>        t(invariant_SL_03(cdpManager, priceFeedMock, sortedCdps), SL_03);</span>
  75 |     | <span class='neutral'>    }</span>
  76 |     | <span class='neutral'></span>
  77 |     | <span class='neutral'>    // https://github.com/Badger-Finance/ebtc-fuzz-review/issues/15</span>
  78 |     | <span class='unexecuted'>    function echidna_sorted_list_invariant_5() public {</span>
  79 |     | <span class='unexecuted'>        t(invariant_SL_05(crLens, sortedCdps), SL_05);</span>
  80 |     | <span class='neutral'>    }</span>
  81 |     | <span class='neutral'></span>
  82 |     | <span class='neutral'>    // invariant_GENERAL_01 is a vars invariant</span>
  83 |     | <span class='neutral'></span>
  84 |     | <span class='unexecuted'>    function echidna_GENERAL_02() public {</span>
  85 |     | <span class='unexecuted'>        t(invariant_GENERAL_02(cdpManager, priceFeedMock, eBTCToken, collateral), GENERAL_02);</span>
  86 |     | <span class='neutral'>    }</span>
  87 |     | <span class='neutral'></span>
  88 |     | <span class='unexecuted'>    function echidna_GENERAL_03() public {</span>
  89 |     | <span class='unexecuted'>        t(invariant_GENERAL_03(cdpManager, borrowerOperations, eBTCToken, collateral), GENERAL_03);</span>
  90 |     | <span class='neutral'>    }</span>
  91 |     | <span class='neutral'></span>
  92 |     | <span class='unexecuted'>    function echidna_GENERAL_05() public {</span>
  93 |     | <span class='unexecuted'>        t(invariant_GENERAL_05(activePool, cdpManager, collateral), GENERAL_05);</span>
  94 |     | <span class='neutral'>    }</span>
  95 |     | <span class='neutral'></span>
  96 |     | <span class='unexecuted'>    function echidna_GENERAL_05_B() public {</span>
  97 |     | <span class='unexecuted'>        t(invariant_GENERAL_05_B(collSurplusPool, collateral), GENERAL_05);</span>
  98 |     | <span class='neutral'>    }</span>
  99 |     | <span class='neutral'></span>
 100 |     | <span class='unexecuted'>    function echidna_GENERAL_06() public {</span>
 101 |     | <span class='unexecuted'>        t(invariant_GENERAL_06(eBTCToken, cdpManager, sortedCdps), GENERAL_06);</span>
 102 |     | <span class='neutral'>    }</span>
 103 |     | <span class='neutral'></span>
 104 |     | <span class='unexecuted'>    function echidna_GENERAL_08() public {</span>
 105 |     | <span class='unexecuted'>        t(invariant_GENERAL_08(cdpManager, sortedCdps, priceFeedMock, collateral), GENERAL_08);</span>
 106 |     | <span class='neutral'>    }</span>
 107 |     | <span class='neutral'></span>
 108 |     | <span class='neutral'>    // invariant_GENERAL_09 is a vars</span>
 109 |     | <span class='neutral'></span>
 110 |     | <span class='unexecuted'>    function echidna_GENERAL_12() public {</span>
 111 |     | <span class='unexecuted'>        t(invariant_GENERAL_12(cdpManager, priceFeedMock, crLens), GENERAL_12);</span>
 112 |     | <span class='neutral'>    }</span>
 113 |     | <span class='neutral'></span>
 114 |     | <span class='unexecuted'>    function echidna_GENERAL_13() public {</span>
 115 |     | <span class='unexecuted'>        t(invariant_GENERAL_13(crLens, cdpManager, priceFeedMock, sortedCdps), GENERAL_13);</span>
 116 |     | <span class='neutral'>    }</span>
 117 |     | <span class='neutral'></span>
 118 |     | <span class='unexecuted'>    function echidna_GENERAL_14() public {</span>
 119 |     | <span class='unexecuted'>        t(invariant_GENERAL_14(crLens, cdpManager, sortedCdps), GENERAL_14);</span>
 120 |     | <span class='neutral'>    }</span>
 121 |     | <span class='neutral'></span>
 122 |     | <span class='neutral'>    // function echidna_GENERAL_15() public {</span>
 123 |     | <span class='neutral'>    //     t(invariant_GENERAL_15(), &quot;Failed&quot;);</span>
 124 |     | <span class='neutral'>    // }</span>
 125 |     | <span class='neutral'></span>
 126 |     | <span class='unexecuted'>    function echidna_GENERAL_17() public {</span>
 127 |     | <span class='unexecuted'>        t(invariant_GENERAL_17(cdpManager, sortedCdps, priceFeedMock, collateral), GENERAL_17);</span>
 128 |     | <span class='neutral'>    }</span>
 129 |     | <span class='neutral'></span>
 130 |     | <span class='neutral'>    // @audit Not testable on fork</span>
 131 |     | <span class='neutral'>    // function echidna_GENERAL_18() public {</span>
 132 |     | <span class='neutral'>    //    t(invariant_GENERAL_18(cdpManager, sortedCdps, priceFeedMock, collateral), &quot;Failed&quot;);</span>
 133 |     | <span class='neutral'>    //}</span>
 134 |     | <span class='neutral'></span>
 135 |     | <span class='unexecuted'>    function echidna_GENERAL_19() public {</span>
 136 |     | <span class='unexecuted'>        t(invariant_GENERAL_19(activePool), GENERAL_19);</span>
 137 |     | <span class='neutral'>    }</span>
 138 |     | <span class='neutral'></span>
 139 |     | <span class='unexecuted'>    function echidna_LS_01() public {</span>
 140 | *   | <span class='executed'>        t(invariant_LS_01(</span>
 141 |     | <span class='unexecuted'>                cdpManager,</span>
 142 |     | <span class='unexecuted'>                liquidationSequencer,</span>
 143 |     | <span class='unexecuted'>                syncedLiquidationSequencer,</span>
 144 |     | <span class='unexecuted'>                priceFeedMock</span>
 145 | *   | <span class='executed'>            ), L_01);</span>
 146 |     | <span class='neutral'>    }</span>
 147 |     | <span class='neutral'>}</span>
 148 |     | <span class='neutral'></span>

</code>
<br />

<b>/mnt/c/Users/Lourens/Documents/Recon-Fuzz/collabs/ebtc/packages/contracts/contracts/TestContracts/invariants/echidna/EchidnaRedemptionForkTester.sol</b>
<code>
   1 |     | <span class='neutral'>// SPDX-License-Identifier: MIT</span>
   2 |     | <span class='neutral'></span>
   3 |     | <span class='neutral'>pragma solidity 0.8.17;</span>
   4 |     | <span class='neutral'></span>
   5 |     | <span class='neutral'>import &quot;./EchidnaAsserts.sol&quot;;</span>
   6 |     | <span class='neutral'>import &quot;./EchidnaForkAssertions.sol&quot;;</span>
   7 |     | <span class='neutral'>import &quot;../TargetFunctions.sol&quot;;</span>
   8 |     | <span class='neutral'></span>
   9 |     | <span class='neutral'>// Run locally with: `echidna contracts/TestContracts/invariants/echidna/EchidnaRedemptionForkTester.sol --contract EchidnaRedemptionForkTester --test-mode property --rpc-url YOUR_RPC_URL --config fuzzTests/echidna_config.yaml`</span>
  10 | *r  | <span class='executed'>contract EchidnaRedemptionForkTester is EchidnaAsserts, EchidnaForkAssertions, TargetFunctions {</span>
  11 |     | <span class='unexecuted'>    constructor() payable {</span>
  12 |     | <span class='neutral'>        // We perform this check at a specific time</span>
  13 |     | <span class='neutral'>        // 6/27/2024 @ 08:22:47</span>
  14 |     | <span class='unexecuted'>        hevm.warp(1719476567);</span>
  15 |     | <span class='unexecuted'>        hevm.roll(20181802);</span>
  16 |     | <span class='neutral'></span>
  17 |     | <span class='neutral'>        // https://etherscan.io/tx/0xca4f2e9a7e8cc82969e435091576dbd8c8bfcc008e89906857056481e0542f23</span>
  18 |     | <span class='unexecuted'>        _setUpFork();</span>
  19 |     | <span class='unexecuted'>        _setUpActorsFork();</span>
  20 |     | <span class='neutral'></span>
  21 |     | <span class='neutral'>        // If the accounting hasn&#39;t been synced since the last rebase</span>
  22 |     | <span class='unexecuted'>        bytes32 currentCdp = sortedCdps.getFirst();</span>
  23 |     | <span class='neutral'></span>
  24 |     | <span class='unexecuted'>        while (currentCdp != bytes32(0)) {</span>
  25 |     | <span class='unexecuted'>            hevm.prank(address(borrowerOperations));</span>
  26 |     | <span class='unexecuted'>            cdpManager.syncAccounting(currentCdp);</span>
  27 |     | <span class='unexecuted'>            currentCdp = sortedCdps.getNext(currentCdp);</span>
  28 |     | <span class='neutral'>        }</span>
  29 |     | <span class='neutral'></span>
  30 |     | <span class='neutral'>        // Previous cumulative CDPs per each rebase</span>
  31 |     | <span class='neutral'>        // Will need to be adjusted</span>
  32 |     | <span class='neutral'>        // @audit Need to add the explanation for this - it will definitely not hold forever and is not accurate</span>
  33 |     | <span class='neutral'>        // Affects `invariant_GENERAL_18`</span>
  34 |     | <span class='neutral'>        // This is not going to be reliably testable on fork tests in any case</span>
  35 |     | <span class='unexecuted'>        vars.cumulativeCdpsAtTimeOfRebase = 200;</span>
  36 |     | <span class='neutral'></span>
  37 |     | <span class='neutral'>        // These are the fuzzed parameters</span>
  38 |     | <span class='neutral'>        // @audit We could do a version where the proposed gov transaction is provided and we do it as a low-level call</span>
  39 |     | <span class='unexecuted'>        hevm.prank(defaultGovernance);</span>
  40 |     | <span class='neutral'>        // First we set the Redemption Fee Floor</span>
  41 |     | <span class='unexecuted'>        try cdpManager.setRedemptionFeeFloor(25e15) {} catch {</span>
  42 |     | <span class='unexecuted'>            t(false, &quot;SetRedemptionFeeFloor failed&quot;);</span>
  43 |     | <span class='neutral'>        }</span>
  44 |     | <span class='neutral'></span>
  45 |     | <span class='unexecuted'>        hevm.prank(defaultGovernance);</span>
  46 |     | <span class='neutral'>        // We unpause the redemptions </span>
  47 |     | <span class='unexecuted'>        try cdpManager.setRedemptionsPaused(false) {} catch {</span>
  48 |     | <span class='unexecuted'>            t(false, &quot;Redemptions did not unpause successfully&quot;);</span>
  49 |     | <span class='neutral'>        }</span>
  50 |     | <span class='neutral'></span>
  51 |     | <span class='unexecuted'>        bool success;</span>
  52 |     | <span class='unexecuted'>        bytes memory returnData;</span>
  53 |     | <span class='neutral'></span>
  54 |     | <span class='neutral'>        // we pass in CCR instead of MCR in case it&#39;s the first one</span>
  55 |     | <span class='unexecuted'>        uint price = priceFeedMock.fetchPrice();</span>
  56 |     | <span class='neutral'></span>
  57 |     | <span class='unexecuted'>        (success, ) = actor.proxy(</span>
  58 |     | <span class='unexecuted'>            address(collateral),</span>
  59 |     | <span class='unexecuted'>            abi.encodeWithSelector(</span>
  60 |     | <span class='neutral'>                CollateralTokenTester.approve.selector,</span>
  61 |     | <span class='unexecuted'>                address(borrowerOperations),</span>
  62 |     | <span class='unexecuted'>                18e18</span>
  63 |     | <span class='neutral'>            )</span>
  64 |     | <span class='neutral'>        );</span>
  65 |     | <span class='neutral'></span>
  66 |     | <span class='unexecuted'>        t(success, &quot;Approve never fails&quot;);</span>
  67 |     | <span class='neutral'></span>
  68 |     | <span class='unexecuted'>        (success, returnData) = actor.proxy(</span>
  69 |     | <span class='unexecuted'>            address(borrowerOperations),</span>
  70 |     | <span class='unexecuted'>            abi.encodeWithSelector(</span>
  71 |     | <span class='neutral'>                BorrowerOperations.openCdp.selector,</span>
  72 |     | <span class='unexecuted'>                5e17,</span>
  73 |     | <span class='neutral'>                bytes32(0),</span>
  74 |     | <span class='neutral'>                bytes32(0),</span>
  75 |     | <span class='unexecuted'>                18e18</span>
  76 |     | <span class='neutral'>            )</span>
  77 |     | <span class='neutral'>        );</span>
  78 |     | <span class='neutral'></span>
  79 |     | <span class='neutral'></span>
  80 |     | <span class='unexecuted'>        t(eBTCToken.balanceOf(address(actor)) &gt; 0, &quot;CDP not opened&quot;);</span>
  81 |     | <span class='neutral'>    }</span>
  82 |     | <span class='neutral'></span>
  83 |     | <span class='neutral'>    // This overrides the PriceOracle&#39;s last good price</span>
  84 | *   | <span class='executed'>    function setPrice(uint256 newPrice) public override {</span>
  85 | *   | <span class='executed'>        _before(bytes32(0));</span>
  86 |     | <span class='neutral'></span>
  87 | *   | <span class='executed'>        hevm.store(</span>
  88 | *   | <span class='executed'>            address(priceFeedMock),</span>
  89 | *   | <span class='executed'>            0x0000000000000000000000000000000000000000000000000000000000000002,</span>
  90 |     | <span class='neutral'>            bytes32(0)</span>
  91 |     | <span class='neutral'>        );</span>
  92 |     | <span class='neutral'></span>
  93 |     | <span class='neutral'>        // Load last good price</span>
  94 | *   | <span class='executed'>        uint256 oldPrice = uint256(</span>
  95 | *   | <span class='executed'>            hevm.load(</span>
  96 | *   | <span class='executed'>                address(priceFeedMock),</span>
  97 |     | <span class='neutral'>                0x0000000000000000000000000000000000000000000000000000000000000001</span>
  98 |     | <span class='neutral'>            )</span>
  99 |     | <span class='neutral'>        );</span>
 100 |     | <span class='neutral'>        // New Price</span>
 101 | *   | <span class='executed'>        newPrice = between(</span>
 102 | *   | <span class='executed'>            newPrice,</span>
 103 | *   | <span class='executed'>            (oldPrice * 1e18) / MAX_PRICE_CHANGE_PERCENT,</span>
 104 | *   | <span class='executed'>            (oldPrice * MAX_PRICE_CHANGE_PERCENT) / 1e18</span>
 105 |     | <span class='neutral'>        );</span>
 106 |     | <span class='neutral'></span>
 107 |     | <span class='neutral'>        // Set new price by etching last good price</span>
 108 | *   | <span class='executed'>        hevm.store(</span>
 109 | *   | <span class='executed'>            address(priceFeedMock),</span>
 110 |     | <span class='neutral'>            0x0000000000000000000000000000000000000000000000000000000000000001,</span>
 111 |     | <span class='neutral'>            bytes32(newPrice)</span>
 112 |     | <span class='neutral'>        );</span>
 113 |     | <span class='neutral'></span>
 114 | *   | <span class='executed'>        cdpManager.syncGlobalAccountingAndGracePeriod();</span>
 115 |     | <span class='neutral'></span>
 116 | *   | <span class='executed'>        _after(bytes32(0));</span>
 117 |     | <span class='neutral'>    }</span>
 118 |     | <span class='neutral'></span>
 119 |     | <span class='neutral'>    // Don&#39;t need to etch storage, mocking it as a call from default governance should be enough</span>
 120 |     | <span class='neutral'>    // as the timelock logic happens in the TimelockController, and governance params only care about who is the caller</span>
 121 | *   | <span class='executed'>    function setGovernanceParameters(uint256 parameter, uint256 value) public override {</span>
 122 | *   | <span class='executed'>        parameter = between(parameter, 0, 6);</span>
 123 |     | <span class='neutral'></span>
 124 | *   | <span class='executed'>        if (parameter == 0) {</span>
 125 | *   | <span class='executed'>            value = between(value, cdpManager.MINIMUM_GRACE_PERIOD(), type(uint128).max);</span>
 126 | *   | <span class='executed'>            hevm.prank(defaultGovernance);</span>
 127 | *r  | <span class='executed'>            cdpManager.setGracePeriod(uint128(value));</span>
 128 | *   | <span class='executed'>        } else if (parameter == 1) {</span>
 129 | *   | <span class='executed'>            value = between(value, 0, activePool.getFeeRecipientClaimableCollShares());</span>
 130 | *   | <span class='executed'>            _before(bytes32(0));</span>
 131 | *   | <span class='executed'>            hevm.prank(defaultGovernance);</span>
 132 | *   | <span class='executed'>            activePool.claimFeeRecipientCollShares(value);</span>
 133 | *   | <span class='executed'>            _after(bytes32(0));</span>
 134 |     | <span class='neutral'>            // If there was something to claim</span>
 135 | *   | <span class='executed'>            if (value &gt; 0) {</span>
 136 |     | <span class='neutral'>                // https://github.com/Badger-Finance/ebtc-fuzz-review/issues/22</span>
 137 |     | <span class='neutral'>                // Claiming will increase the balance</span>
 138 |     | <span class='neutral'>                // Strictly GT</span>
 139 | *   | <span class='executed'>                gt(vars.feeRecipientCollSharesBalAfter, vars.feeRecipientCollSharesBalBefore, F_01);</span>
 140 | *   | <span class='executed'>                gte(vars.feeRecipientTotalCollAfter, vars.feeRecipientTotalCollBefore, F_01);</span>
 141 |     | <span class='neutral'>            }</span>
 142 | *   | <span class='executed'>        } else if (parameter == 2) {</span>
 143 | *   | <span class='executed'>            value = between(value, 0, cdpManager.MAX_REWARD_SPLIT());</span>
 144 | *   | <span class='executed'>            hevm.prank(defaultGovernance);</span>
 145 | *   | <span class='executed'>            cdpManager.setStakingRewardSplit(value);</span>
 146 | *   | <span class='executed'>        } else if (parameter == 3) {</span>
 147 |     | <span class='neutral'>            // Do not change redemption floor again</span>
 148 | *   | <span class='executed'>        } else if (parameter == 4) {</span>
 149 | *   | <span class='executed'>            value = between(</span>
 150 | *   | <span class='executed'>                value,</span>
 151 | *   | <span class='executed'>                cdpManager.MIN_MINUTE_DECAY_FACTOR(),</span>
 152 | *   | <span class='executed'>                cdpManager.MAX_MINUTE_DECAY_FACTOR()</span>
 153 |     | <span class='neutral'>            );</span>
 154 | *   | <span class='executed'>            hevm.prank(defaultGovernance);</span>
 155 | *   | <span class='executed'>            cdpManager.setMinuteDecayFactor(value);</span>
 156 | *   | <span class='executed'>        } else if (parameter == 5) {</span>
 157 | *   | <span class='executed'>            value = between(value, 0, cdpManager.DECIMAL_PRECISION());</span>
 158 | *   | <span class='executed'>            hevm.prank(defaultGovernance);</span>
 159 | *   | <span class='executed'>            cdpManager.setBeta(value);</span>
 160 |     | <span class='neutral'>        } else if (parameter == 6) {</span>
 161 |     | <span class='neutral'>            // Do not set redemptions false again</span>
 162 |     | <span class='neutral'>        }</span>
 163 |     | <span class='neutral'>    }</span>
 164 |     | <span class='neutral'></span>
 165 | *   | <span class='executed'>    function setEthPerShare(uint256 newValue) public override {</span>
 166 | *   | <span class='executed'>        _before(bytes32(0));</span>
 167 |     | <span class='neutral'>        // Our approach is to to increase the amount of ether without increasing the number of shares</span>
 168 |     | <span class='neutral'>        // We load the bulk share of staked ether, then modify it, then change the value in the slot directly.</span>
 169 | *   | <span class='executed'>        uint256 oldValue = uint256(</span>
 170 | *   | <span class='executed'>            hevm.load(</span>
 171 | *   | <span class='executed'>                address(collateral),</span>
 172 | *   | <span class='executed'>                0xa66d35f054e68143c18f32c990ed5cb972bb68a68f500cd2dd3a16bbf3686483</span>
 173 |     | <span class='neutral'>            )</span>
 174 |     | <span class='neutral'>        );</span>
 175 |     | <span class='neutral'></span>
 176 | *   | <span class='executed'>        newValue = between(</span>
 177 | *   | <span class='executed'>            newValue,</span>
 178 | *   | <span class='executed'>            (oldValue * 1e18) / MAX_REBASE_PERCENT,</span>
 179 | *   | <span class='executed'>            (oldValue * MAX_REBASE_PERCENT) / 1e18</span>
 180 |     | <span class='neutral'>        );</span>
 181 |     | <span class='neutral'></span>
 182 | *   | <span class='executed'>        hevm.store(</span>
 183 | *   | <span class='executed'>            address(collateral),</span>
 184 | *   | <span class='executed'>            0xa66d35f054e68143c18f32c990ed5cb972bb68a68f500cd2dd3a16bbf3686483,</span>
 185 |     | <span class='neutral'>            bytes32(newValue)</span>
 186 |     | <span class='neutral'>        );</span>
 187 |     | <span class='neutral'>        cdpManager.syncGlobalAccountingAndGracePeriod();</span>
 188 |     | <span class='neutral'></span>
 189 |     | <span class='neutral'>        _after(bytes32(0));</span>
 190 |     | <span class='neutral'>    }</span>
 191 |     | <span class='neutral'>}</span>
 192 |     | <span class='neutral'></span>

</code>
<br />

<b>/mnt/c/Users/Lourens/Documents/Recon-Fuzz/collabs/ebtc/packages/contracts/contracts/TestContracts/testnet/PriceFeedTestnet.sol</b>
<code>
   1 |     | <span class='neutral'>// SPDX-License-Identifier: MIT</span>
   2 |     | <span class='neutral'></span>
   3 |     | <span class='neutral'>pragma solidity 0.8.17;</span>
   4 |     | <span class='neutral'></span>
   5 |     | <span class='neutral'>import &quot;../../Interfaces/IPriceFeed.sol&quot;;</span>
   6 |     | <span class='neutral'>import &quot;../../Interfaces/IFallbackCaller.sol&quot;;</span>
   7 |     | <span class='neutral'>import &quot;../../Dependencies/Ownable.sol&quot;;</span>
   8 |     | <span class='neutral'>import &quot;../../Dependencies/AuthNoOwner.sol&quot;;</span>
   9 |     | <span class='neutral'></span>
  10 |     | <span class='neutral'>/*</span>
  11 |     | <span class='neutral'> * PriceFeed placeholder for testnet and development. The price can be manually input or fetched from</span>
  12 |     | <span class='neutral'>   the Fallback&#39;s TestNet implementation. Backwards compatible with local test environment as it defaults to use</span>
  13 |     | <span class='neutral'>   the manual price.</span>
  14 |     | <span class='neutral'> */</span>
  15 |     | <span class='unexecuted'>contract PriceFeedTestnet is IPriceFeed, Ownable, AuthNoOwner {</span>
  16 |     | <span class='neutral'>    // --- variables ---</span>
  17 |     | <span class='neutral'></span>
  18 |     | <span class='unexecuted'>    uint256 private _price = 7428 * 1e13; // stETH/BTC price == ~15.8118 ETH per BTC</span>
  19 |     | <span class='unexecuted'>    bool public _useFallback;</span>
  20 |     | <span class='unexecuted'>    IFallbackCaller public fallbackCaller; // Wrapper contract that calls the Fallback system</span>
  21 |     | <span class='neutral'></span>
  22 |     | <span class='unexecuted'>    constructor(address _authorityAddress) {</span>
  23 |     | <span class='unexecuted'>        _initializeAuthority(_authorityAddress);</span>
  24 |     | <span class='neutral'>    }</span>
  25 |     | <span class='neutral'></span>
  26 |     | <span class='neutral'>    // --- Dependency setters ---</span>
  27 |     | <span class='neutral'></span>
  28 |     | <span class='unexecuted'>    function setAddresses(</span>
  29 |     | <span class='neutral'>        address _priceAggregatorAddress, // Not used but kept for compatibility with deployment script</span>
  30 |     | <span class='neutral'>        address _fallbackCallerAddress,</span>
  31 |     | <span class='neutral'>        address _authorityAddress</span>
  32 |     | <span class='neutral'>    ) external onlyOwner {</span>
  33 |     | <span class='unexecuted'>        fallbackCaller = IFallbackCaller(_fallbackCallerAddress);</span>
  34 |     | <span class='neutral'></span>
  35 |     | <span class='unexecuted'>        _initializeAuthority(_authorityAddress);</span>
  36 |     | <span class='neutral'></span>
  37 |     | <span class='unexecuted'>        renounceOwnership();</span>
  38 |     | <span class='neutral'>    }</span>
  39 |     | <span class='neutral'></span>
  40 |     | <span class='neutral'>    // --- Functions ---</span>
  41 |     | <span class='neutral'></span>
  42 |     | <span class='neutral'>    // View price getter for simplicity in tests</span>
  43 |     | <span class='unexecuted'>    function getPrice() external view returns (uint256) {</span>
  44 |     | <span class='unexecuted'>        return _price;</span>
  45 |     | <span class='neutral'>    }</span>
  46 |     | <span class='neutral'></span>
  47 |     | <span class='unexecuted'>    function fetchPrice() external override returns (uint256) {</span>
  48 |     | <span class='neutral'>        // Fire an event just like the mainnet version would.</span>
  49 |     | <span class='neutral'>        // This lets the subgraph rely on events to get the latest price even when developing locally.</span>
  50 |     | <span class='unexecuted'>        if (_useFallback) {</span>
  51 |     | <span class='unexecuted'>            FallbackResponse memory fallbackResponse = _getCurrentFallbackResponse();</span>
  52 |     | <span class='unexecuted'>            if (fallbackResponse.success) {</span>
  53 |     | <span class='unexecuted'>                _price = fallbackResponse.answer;</span>
  54 |     | <span class='neutral'>            }</span>
  55 |     | <span class='neutral'>        }</span>
  56 |     | <span class='unexecuted'>        emit LastGoodPriceUpdated(_price);</span>
  57 |     | <span class='unexecuted'>        return _price;</span>
  58 |     | <span class='neutral'>    }</span>
  59 |     | <span class='neutral'></span>
  60 |     | <span class='neutral'>    // Manual external price setter.</span>
  61 |     | <span class='unexecuted'>    function setPrice(uint256 price) external returns (bool) {</span>
  62 |     | <span class='unexecuted'>        _price = price;</span>
  63 |     | <span class='unexecuted'>        return true;</span>
  64 |     | <span class='neutral'>    }</span>
  65 |     | <span class='neutral'></span>
  66 |     | <span class='neutral'>    // Manual toggle use of Tellor testnet feed</span>
  67 |     | <span class='unexecuted'>    function toggleUseFallback() external returns (bool) {</span>
  68 |     | <span class='unexecuted'>        _useFallback = !_useFallback;</span>
  69 |     | <span class='unexecuted'>        return _useFallback;</span>
  70 |     | <span class='neutral'>    }</span>
  71 |     | <span class='neutral'></span>
  72 |     | <span class='unexecuted'>    function setFallbackCaller(address _fallbackCaller) external requiresAuth {</span>
  73 |     | <span class='unexecuted'>        address oldFallbackCaller = address(fallbackCaller);</span>
  74 |     | <span class='unexecuted'>        fallbackCaller = IFallbackCaller(_fallbackCaller);</span>
  75 |     | <span class='unexecuted'>        emit FallbackCallerChanged(oldFallbackCaller, _fallbackCaller);</span>
  76 |     | <span class='neutral'>    }</span>
  77 |     | <span class='neutral'></span>
  78 |     | <span class='neutral'>    // --- Oracle response wrapper functions ---</span>
  79 |     | <span class='neutral'>    /*</span>
  80 |     | <span class='neutral'>     * &quot;_getCurrentFallbackResponse&quot; fetches stETH/BTC from the Fallback, and returns it as a</span>
  81 |     | <span class='neutral'>     * FallbackResponse struct.</span>
  82 |     | <span class='neutral'>     */</span>
  83 |     | <span class='unexecuted'>    function _getCurrentFallbackResponse()</span>
  84 |     | <span class='neutral'>        internal</span>
  85 |     | <span class='neutral'>        view</span>
  86 |     | <span class='unexecuted'>        returns (FallbackResponse memory fallbackResponse)</span>
  87 |     | <span class='neutral'>    {</span>
  88 |     | <span class='unexecuted'>        uint256 stEthBtcValue;</span>
  89 |     | <span class='unexecuted'>        uint256 stEthBtcTimestamp;</span>
  90 |     | <span class='unexecuted'>        bool stEthBtcRetrieved;</span>
  91 |     | <span class='neutral'></span>
  92 |     | <span class='neutral'>        // Attempt to get the Fallback&#39;s stETH/BTC price</span>
  93 |     | <span class='unexecuted'>        try fallbackCaller.getFallbackResponse() returns (</span>
  94 |     | <span class='neutral'>            uint256 answer,</span>
  95 |     | <span class='neutral'>            uint256 timestampRetrieved,</span>
  96 |     | <span class='neutral'>            bool success</span>
  97 |     | <span class='neutral'>        ) {</span>
  98 |     | <span class='unexecuted'>            fallbackResponse.answer = answer;</span>
  99 |     | <span class='unexecuted'>            fallbackResponse.timestamp = timestampRetrieved;</span>
 100 |     | <span class='unexecuted'>            fallbackResponse.success = success;</span>
 101 |     | <span class='neutral'>        } catch {</span>
 102 |     | <span class='unexecuted'>            return (fallbackResponse);</span>
 103 |     | <span class='neutral'>        }</span>
 104 |     | <span class='unexecuted'>        return (fallbackResponse);</span>
 105 |     | <span class='neutral'>    }</span>
 106 |     | <span class='neutral'>}</span>
 107 |     | <span class='neutral'></span>

</code>
<br />

<b>/mnt/c/Users/Lourens/Documents/Recon-Fuzz/collabs/ebtc/packages/contracts/node_modules/@crytic/properties/contracts/util/Hevm.sol</b>
<code>
  1 |     | <span class='neutral'>// SPDX-License-Identifier: Unlicense</span>
  2 |     | <span class='neutral'>pragma solidity ^0.8.0;</span>
  3 |     | <span class='neutral'></span>
  4 |     | <span class='neutral'>interface IHevm {</span>
  5 |     | <span class='neutral'>    // Set block.timestamp to newTimestamp</span>
  6 |     | <span class='neutral'>    function warp(uint256 newTimestamp) external;</span>
  7 |     | <span class='neutral'></span>
  8 |     | <span class='neutral'>    // Set block.number to newNumber</span>
  9 |     | <span class='neutral'>    function roll(uint256 newNumber) external;</span>
 10 |     | <span class='neutral'></span>
 11 |     | <span class='neutral'>    // Loads a storage slot from an address</span>
 12 |     | <span class='neutral'>    function load(address where, bytes32 slot) external returns (bytes32);</span>
 13 |     | <span class='neutral'></span>
 14 |     | <span class='neutral'>    // Stores a value to an address&#39; storage slot</span>
 15 |     | <span class='neutral'>    function store(address where, bytes32 slot, bytes32 value) external;</span>
 16 |     | <span class='neutral'></span>
 17 |     | <span class='neutral'>    // Signs data (privateKey, digest) =&gt; (r, v, s)</span>
 18 |     | <span class='neutral'>    function sign(</span>
 19 |     | <span class='neutral'>        uint256 privateKey,</span>
 20 |     | <span class='neutral'>        bytes32 digest</span>
 21 |     | <span class='neutral'>    ) external returns (uint8 r, bytes32 v, bytes32 s);</span>
 22 |     | <span class='neutral'></span>
 23 |     | <span class='neutral'>    // Gets address for a given private key</span>
 24 |     | <span class='neutral'>    function addr(uint256 privateKey) external returns (address addr);</span>
 25 |     | <span class='neutral'></span>
 26 |     | <span class='neutral'>    // Performs a foreign function call via terminal</span>
 27 |     | <span class='neutral'>    function ffi(</span>
 28 |     | <span class='neutral'>        string[] calldata inputs</span>
 29 |     | <span class='neutral'>    ) external returns (bytes memory result);</span>
 30 |     | <span class='neutral'></span>
 31 |     | <span class='neutral'>    // Performs the next smart contract call with specified `msg.sender`</span>
 32 |     | <span class='neutral'>    function prank(address newSender) external;</span>
 33 |     | <span class='neutral'>}</span>
 34 |     | <span class='neutral'></span>
 35 | *   | <span class='executed'>IHevm constant hevm = IHevm(0x7109709ECfa91a80626fF3989D68f67F5b1DD12D);</span>
 36 |     | <span class='neutral'></span>

</code>
<br />

<b>/mnt/c/Users/Lourens/Documents/Recon-Fuzz/collabs/ebtc/packages/contracts/node_modules/@crytic/properties/contracts/util/PropertiesConstants.sol</b>
<code>
  1 |     | <span class='neutral'>pragma solidity ^0.8.0;</span>
  2 |     | <span class='neutral'></span>
  3 |     | <span class='neutral'>abstract contract PropertiesConstants {</span>
  4 |     | <span class='neutral'>    // Constant echidna addresses</span>
  5 |     | <span class='unexecuted'>    address constant USER1 = address(0x10000);</span>
  6 |     | <span class='unexecuted'>    address constant USER2 = address(0x20000);</span>
  7 |     | <span class='unexecuted'>    address constant USER3 = address(0x30000);</span>
  8 |     | <span class='neutral'>    uint256 constant INITIAL_BALANCE = 1000e18;</span>
  9 |     | <span class='neutral'>}</span>
 10 |     | <span class='neutral'></span>

</code>
<br />

<b>/mnt/c/Users/Lourens/Documents/Recon-Fuzz/collabs/ebtc/packages/contracts/node_modules/@crytic/properties/contracts/util/PropertiesHelper.sol</b>
<code>
   1 |     | <span class='neutral'>pragma solidity ^0.8.0;</span>
   2 |     | <span class='neutral'></span>
   3 |     | <span class='neutral'>abstract contract PropertiesAsserts {</span>
   4 |     | <span class='neutral'>    event LogUint256(string, uint256);</span>
   5 |     | <span class='neutral'>    event LogAddress(string, address);</span>
   6 |     | <span class='neutral'>    event LogString(string);</span>
   7 |     | <span class='neutral'></span>
   8 |     | <span class='neutral'>    event AssertFail(string);</span>
   9 |     | <span class='neutral'>    event AssertEqFail(string);</span>
  10 |     | <span class='neutral'>    event AssertNeqFail(string);</span>
  11 |     | <span class='neutral'>    event AssertGteFail(string);</span>
  12 |     | <span class='neutral'>    event AssertGtFail(string);</span>
  13 |     | <span class='neutral'>    event AssertLteFail(string);</span>
  14 |     | <span class='neutral'>    event AssertLtFail(string);</span>
  15 |     | <span class='neutral'></span>
  16 | *   | <span class='executed'>    function assertWithMsg(bool b, string memory reason) internal {</span>
  17 | *   | <span class='executed'>        if (!b) {</span>
  18 |     | <span class='unexecuted'>            emit AssertFail(reason);</span>
  19 |     | <span class='unexecuted'>            assert(false);</span>
  20 |     | <span class='neutral'>        }</span>
  21 |     | <span class='neutral'>    }</span>
  22 |     | <span class='neutral'></span>
  23 |     | <span class='neutral'>    /// @notice asserts that a is equal to b. Violations are logged using reason.</span>
  24 | *   | <span class='executed'>    function assertEq(uint256 a, uint256 b, string memory reason) internal {</span>
  25 | *   | <span class='executed'>        if (a != b) {</span>
  26 |     | <span class='unexecuted'>            string memory aStr = PropertiesLibString.toString(a);</span>
  27 |     | <span class='unexecuted'>            string memory bStr = PropertiesLibString.toString(b);</span>
  28 |     | <span class='unexecuted'>            bytes memory assertMsg = abi.encodePacked(</span>
  29 |     | <span class='neutral'>                &quot;Invalid: &quot;,</span>
  30 |     | <span class='unexecuted'>                aStr,</span>
  31 |     | <span class='neutral'>                &quot;!=&quot;,</span>
  32 |     | <span class='unexecuted'>                bStr,</span>
  33 |     | <span class='neutral'>                &quot;, reason: &quot;,</span>
  34 |     | <span class='unexecuted'>                reason</span>
  35 |     | <span class='neutral'>            );</span>
  36 |     | <span class='unexecuted'>            emit AssertEqFail(string(assertMsg));</span>
  37 |     | <span class='unexecuted'>            assert(false);</span>
  38 |     | <span class='neutral'>        }</span>
  39 |     | <span class='neutral'>    }</span>
  40 |     | <span class='neutral'></span>
  41 |     | <span class='neutral'>    /// @notice int256 version of assertEq</span>
  42 |     | <span class='neutral'>    function assertEq(int256 a, int256 b, string memory reason) internal {</span>
  43 |     | <span class='neutral'>        if (a != b) {</span>
  44 |     | <span class='neutral'>            string memory aStr = PropertiesLibString.toString(a);</span>
  45 |     | <span class='neutral'>            string memory bStr = PropertiesLibString.toString(b);</span>
  46 |     | <span class='neutral'>            bytes memory assertMsg = abi.encodePacked(</span>
  47 |     | <span class='neutral'>                &quot;Invalid: &quot;,</span>
  48 |     | <span class='neutral'>                aStr,</span>
  49 |     | <span class='neutral'>                &quot;!=&quot;,</span>
  50 |     | <span class='neutral'>                bStr,</span>
  51 |     | <span class='neutral'>                &quot;, reason: &quot;,</span>
  52 |     | <span class='neutral'>                reason</span>
  53 |     | <span class='neutral'>            );</span>
  54 |     | <span class='neutral'>            emit AssertEqFail(string(assertMsg));</span>
  55 |     | <span class='neutral'>            assert(false);</span>
  56 |     | <span class='neutral'>        }</span>
  57 |     | <span class='neutral'>    }</span>
  58 |     | <span class='neutral'></span>
  59 |     | <span class='neutral'>    /// @notice asserts that a is not equal to b. Violations are logged using reason.</span>
  60 |     | <span class='neutral'>    function assertNeq(uint256 a, uint256 b, string memory reason) internal {</span>
  61 |     | <span class='neutral'>        if (a == b) {</span>
  62 |     | <span class='neutral'>            string memory aStr = PropertiesLibString.toString(a);</span>
  63 |     | <span class='neutral'>            string memory bStr = PropertiesLibString.toString(b);</span>
  64 |     | <span class='neutral'>            bytes memory assertMsg = abi.encodePacked(</span>
  65 |     | <span class='neutral'>                &quot;Invalid: &quot;,</span>
  66 |     | <span class='neutral'>                aStr,</span>
  67 |     | <span class='neutral'>                &quot;==&quot;,</span>
  68 |     | <span class='neutral'>                bStr,</span>
  69 |     | <span class='neutral'>                &quot;, reason: &quot;,</span>
  70 |     | <span class='neutral'>                reason</span>
  71 |     | <span class='neutral'>            );</span>
  72 |     | <span class='neutral'>            emit AssertNeqFail(string(assertMsg));</span>
  73 |     | <span class='neutral'>            assert(false);</span>
  74 |     | <span class='neutral'>        }</span>
  75 |     | <span class='neutral'>    }</span>
  76 |     | <span class='neutral'></span>
  77 |     | <span class='neutral'>    /// @notice int256 version of assertNeq</span>
  78 |     | <span class='neutral'>    function assertNeq(int256 a, int256 b, string memory reason) internal {</span>
  79 |     | <span class='neutral'>        if (a == b) {</span>
  80 |     | <span class='neutral'>            string memory aStr = PropertiesLibString.toString(a);</span>
  81 |     | <span class='neutral'>            string memory bStr = PropertiesLibString.toString(b);</span>
  82 |     | <span class='neutral'>            bytes memory assertMsg = abi.encodePacked(</span>
  83 |     | <span class='neutral'>                &quot;Invalid: &quot;,</span>
  84 |     | <span class='neutral'>                aStr,</span>
  85 |     | <span class='neutral'>                &quot;==&quot;,</span>
  86 |     | <span class='neutral'>                bStr,</span>
  87 |     | <span class='neutral'>                &quot;, reason: &quot;,</span>
  88 |     | <span class='neutral'>                reason</span>
  89 |     | <span class='neutral'>            );</span>
  90 |     | <span class='neutral'>            emit AssertNeqFail(string(assertMsg));</span>
  91 |     | <span class='neutral'>            assert(false);</span>
  92 |     | <span class='neutral'>        }</span>
  93 |     | <span class='neutral'>    }</span>
  94 |     | <span class='neutral'></span>
  95 |     | <span class='neutral'>    /// @notice asserts that a is greater than or equal to b. Violations are logged using reason.</span>
  96 | *   | <span class='executed'>    function assertGte(uint256 a, uint256 b, string memory reason) internal {</span>
  97 | *   | <span class='executed'>        if (!(a &gt;= b)) {</span>
  98 |     | <span class='unexecuted'>            string memory aStr = PropertiesLibString.toString(a);</span>
  99 |     | <span class='unexecuted'>            string memory bStr = PropertiesLibString.toString(b);</span>
 100 |     | <span class='unexecuted'>            bytes memory assertMsg = abi.encodePacked(</span>
 101 |     | <span class='neutral'>                &quot;Invalid: &quot;,</span>
 102 |     | <span class='unexecuted'>                aStr,</span>
 103 |     | <span class='neutral'>                &quot;&lt;&quot;,</span>
 104 |     | <span class='unexecuted'>                bStr,</span>
 105 |     | <span class='neutral'>                &quot; failed, reason: &quot;,</span>
 106 |     | <span class='unexecuted'>                reason</span>
 107 |     | <span class='neutral'>            );</span>
 108 |     | <span class='unexecuted'>            emit AssertGteFail(string(assertMsg));</span>
 109 |     | <span class='neutral'>            assert(false);</span>
 110 |     | <span class='neutral'>        }</span>
 111 |     | <span class='neutral'>    }</span>
 112 |     | <span class='neutral'></span>
 113 |     | <span class='neutral'>    /// @notice int256 version of assertGte</span>
 114 |     | <span class='neutral'>    function assertGte(int256 a, int256 b, string memory reason) internal {</span>
 115 |     | <span class='neutral'>        if (!(a &gt;= b)) {</span>
 116 |     | <span class='neutral'>            string memory aStr = PropertiesLibString.toString(a);</span>
 117 |     | <span class='neutral'>            string memory bStr = PropertiesLibString.toString(b);</span>
 118 |     | <span class='neutral'>            bytes memory assertMsg = abi.encodePacked(</span>
 119 |     | <span class='neutral'>                &quot;Invalid: &quot;,</span>
 120 |     | <span class='neutral'>                aStr,</span>
 121 |     | <span class='neutral'>                &quot;&lt;&quot;,</span>
 122 |     | <span class='neutral'>                bStr,</span>
 123 |     | <span class='neutral'>                &quot; failed, reason: &quot;,</span>
 124 |     | <span class='neutral'>                reason</span>
 125 |     | <span class='neutral'>            );</span>
 126 |     | <span class='neutral'>            emit AssertGteFail(string(assertMsg));</span>
 127 |     | <span class='neutral'>            assert(false);</span>
 128 |     | <span class='neutral'>        }</span>
 129 |     | <span class='neutral'>    }</span>
 130 |     | <span class='neutral'></span>
 131 |     | <span class='neutral'>    /// @notice asserts that a is greater than b. Violations are logged using reason.</span>
 132 | *   | <span class='executed'>    function assertGt(uint256 a, uint256 b, string memory reason) internal {</span>
 133 | *   | <span class='executed'>        if (!(a &gt; b)) {</span>
 134 |     | <span class='unexecuted'>            string memory aStr = PropertiesLibString.toString(a);</span>
 135 |     | <span class='unexecuted'>            string memory bStr = PropertiesLibString.toString(b);</span>
 136 |     | <span class='unexecuted'>            bytes memory assertMsg = abi.encodePacked(</span>
 137 |     | <span class='neutral'>                &quot;Invalid: &quot;,</span>
 138 |     | <span class='unexecuted'>                aStr,</span>
 139 |     | <span class='neutral'>                &quot;&lt;=&quot;,</span>
 140 |     | <span class='unexecuted'>                bStr,</span>
 141 |     | <span class='neutral'>                &quot; failed, reason: &quot;,</span>
 142 |     | <span class='unexecuted'>                reason</span>
 143 |     | <span class='neutral'>            );</span>
 144 |     | <span class='unexecuted'>            emit AssertGtFail(string(assertMsg));</span>
 145 |     | <span class='neutral'>            assert(false);</span>
 146 |     | <span class='neutral'>        }</span>
 147 |     | <span class='neutral'>    }</span>
 148 |     | <span class='neutral'></span>
 149 |     | <span class='neutral'>    /// @notice int256 version of assertGt</span>
 150 |     | <span class='neutral'>    function assertGt(int256 a, int256 b, string memory reason) internal {</span>
 151 |     | <span class='neutral'>        if (!(a &gt; b)) {</span>
 152 |     | <span class='neutral'>            string memory aStr = PropertiesLibString.toString(a);</span>
 153 |     | <span class='neutral'>            string memory bStr = PropertiesLibString.toString(b);</span>
 154 |     | <span class='neutral'>            bytes memory assertMsg = abi.encodePacked(</span>
 155 |     | <span class='neutral'>                &quot;Invalid: &quot;,</span>
 156 |     | <span class='neutral'>                aStr,</span>
 157 |     | <span class='neutral'>                &quot;&lt;=&quot;,</span>
 158 |     | <span class='neutral'>                bStr,</span>
 159 |     | <span class='neutral'>                &quot; failed, reason: &quot;,</span>
 160 |     | <span class='neutral'>                reason</span>
 161 |     | <span class='neutral'>            );</span>
 162 |     | <span class='neutral'>            emit AssertGtFail(string(assertMsg));</span>
 163 |     | <span class='neutral'>            assert(false);</span>
 164 |     | <span class='neutral'>        }</span>
 165 |     | <span class='neutral'>    }</span>
 166 |     | <span class='neutral'></span>
 167 |     | <span class='neutral'>    /// @notice asserts that a is less than or equal to b. Violations are logged using reason.</span>
 168 | *   | <span class='executed'>    function assertLte(uint256 a, uint256 b, string memory reason) internal {</span>
 169 | *   | <span class='executed'>        if (!(a &lt;= b)) {</span>
 170 |     | <span class='unexecuted'>            string memory aStr = PropertiesLibString.toString(a);</span>
 171 |     | <span class='unexecuted'>            string memory bStr = PropertiesLibString.toString(b);</span>
 172 |     | <span class='unexecuted'>            bytes memory assertMsg = abi.encodePacked(</span>
 173 |     | <span class='neutral'>                &quot;Invalid: &quot;,</span>
 174 |     | <span class='unexecuted'>                aStr,</span>
 175 |     | <span class='neutral'>                &quot;&gt;&quot;,</span>
 176 |     | <span class='unexecuted'>                bStr,</span>
 177 |     | <span class='neutral'>                &quot; failed, reason: &quot;,</span>
 178 |     | <span class='unexecuted'>                reason</span>
 179 |     | <span class='neutral'>            );</span>
 180 |     | <span class='unexecuted'>            emit AssertLteFail(string(assertMsg));</span>
 181 |     | <span class='neutral'>            assert(false);</span>
 182 |     | <span class='neutral'>        }</span>
 183 |     | <span class='neutral'>    }</span>
 184 |     | <span class='neutral'></span>
 185 |     | <span class='neutral'>    /// @notice int256 version of assertLte</span>
 186 |     | <span class='neutral'>    function assertLte(int256 a, int256 b, string memory reason) internal {</span>
 187 |     | <span class='neutral'>        if (!(a &lt;= b)) {</span>
 188 |     | <span class='neutral'>            string memory aStr = PropertiesLibString.toString(a);</span>
 189 |     | <span class='neutral'>            string memory bStr = PropertiesLibString.toString(b);</span>
 190 |     | <span class='neutral'>            bytes memory assertMsg = abi.encodePacked(</span>
 191 |     | <span class='neutral'>                &quot;Invalid: &quot;,</span>
 192 |     | <span class='neutral'>                aStr,</span>
 193 |     | <span class='neutral'>                &quot;&gt;&quot;,</span>
 194 |     | <span class='neutral'>                bStr,</span>
 195 |     | <span class='neutral'>                &quot; failed, reason: &quot;,</span>
 196 |     | <span class='neutral'>                reason</span>
 197 |     | <span class='neutral'>            );</span>
 198 |     | <span class='neutral'>            emit AssertLteFail(string(assertMsg));</span>
 199 |     | <span class='neutral'>            assert(false);</span>
 200 |     | <span class='neutral'>        }</span>
 201 |     | <span class='neutral'>    }</span>
 202 |     | <span class='neutral'></span>
 203 |     | <span class='neutral'>    /// @notice asserts that a is less than b. Violations are logged using reason.</span>
 204 | *   | <span class='executed'>    function assertLt(uint256 a, uint256 b, string memory reason) internal {</span>
 205 | *   | <span class='executed'>        if (!(a &lt; b)) {</span>
 206 |     | <span class='unexecuted'>            string memory aStr = PropertiesLibString.toString(a);</span>
 207 |     | <span class='unexecuted'>            string memory bStr = PropertiesLibString.toString(b);</span>
 208 |     | <span class='unexecuted'>            bytes memory assertMsg = abi.encodePacked(</span>
 209 |     | <span class='neutral'>                &quot;Invalid: &quot;,</span>
 210 |     | <span class='unexecuted'>                aStr,</span>
 211 |     | <span class='neutral'>                &quot;&gt;=&quot;,</span>
 212 |     | <span class='unexecuted'>                bStr,</span>
 213 |     | <span class='neutral'>                &quot; failed, reason: &quot;,</span>
 214 |     | <span class='unexecuted'>                reason</span>
 215 |     | <span class='neutral'>            );</span>
 216 |     | <span class='unexecuted'>            emit AssertLtFail(string(assertMsg));</span>
 217 |     | <span class='neutral'>            assert(false);</span>
 218 |     | <span class='neutral'>        }</span>
 219 |     | <span class='neutral'>    }</span>
 220 |     | <span class='neutral'></span>
 221 |     | <span class='neutral'>    /// @notice int256 version of assertLt</span>
 222 |     | <span class='neutral'>    function assertLt(int256 a, int256 b, string memory reason) internal {</span>
 223 |     | <span class='neutral'>        if (!(a &lt; b)) {</span>
 224 |     | <span class='neutral'>            string memory aStr = PropertiesLibString.toString(a);</span>
 225 |     | <span class='neutral'>            string memory bStr = PropertiesLibString.toString(b);</span>
 226 |     | <span class='neutral'>            bytes memory assertMsg = abi.encodePacked(</span>
 227 |     | <span class='neutral'>                &quot;Invalid: &quot;,</span>
 228 |     | <span class='neutral'>                aStr,</span>
 229 |     | <span class='neutral'>                &quot;&gt;=&quot;,</span>
 230 |     | <span class='neutral'>                bStr,</span>
 231 |     | <span class='neutral'>                &quot; failed, reason: &quot;,</span>
 232 |     | <span class='neutral'>                reason</span>
 233 |     | <span class='neutral'>            );</span>
 234 |     | <span class='neutral'>            emit AssertLtFail(string(assertMsg));</span>
 235 |     | <span class='neutral'>            assert(false);</span>
 236 |     | <span class='neutral'>        }</span>
 237 |     | <span class='neutral'>    }</span>
 238 |     | <span class='neutral'></span>
 239 |     | <span class='neutral'>    /// @notice Clamps value to be between low and high, both inclusive</span>
 240 | *   | <span class='executed'>    function clampBetween(</span>
 241 |     | <span class='neutral'>        uint256 value,</span>
 242 |     | <span class='neutral'>        uint256 low,</span>
 243 |     | <span class='neutral'>        uint256 high</span>
 244 | *   | <span class='executed'>    ) internal returns (uint256) {</span>
 245 | *   | <span class='executed'>        if (value &lt; low || value &gt; high) {</span>
 246 | *   | <span class='executed'>            uint ans = low + (value % (high - low + 1));</span>
 247 | *   | <span class='executed'>            string memory valueStr = PropertiesLibString.toString(value);</span>
 248 | *   | <span class='executed'>            string memory ansStr = PropertiesLibString.toString(ans);</span>
 249 | *   | <span class='executed'>            bytes memory message = abi.encodePacked(</span>
 250 |     | <span class='neutral'>                &quot;Clamping value &quot;,</span>
 251 | *   | <span class='executed'>                valueStr,</span>
 252 |     | <span class='neutral'>                &quot; to &quot;,</span>
 253 | *   | <span class='executed'>                ansStr</span>
 254 |     | <span class='neutral'>            );</span>
 255 | *   | <span class='executed'>            emit LogString(string(message));</span>
 256 | *   | <span class='executed'>            return ans;</span>
 257 |     | <span class='neutral'>        }</span>
 258 | *   | <span class='executed'>        return value;</span>
 259 |     | <span class='neutral'>    }</span>
 260 |     | <span class='neutral'></span>
 261 |     | <span class='neutral'>    /// @notice int256 version of clampBetween</span>
 262 |     | <span class='neutral'>    function clampBetween(</span>
 263 |     | <span class='neutral'>        int256 value,</span>
 264 |     | <span class='neutral'>        int256 low,</span>
 265 |     | <span class='neutral'>        int256 high</span>
 266 |     | <span class='neutral'>    ) internal returns (int256) {</span>
 267 |     | <span class='neutral'>        if (value &lt; low || value &gt; high) {</span>
 268 |     | <span class='neutral'>            int range = high - low + 1;</span>
 269 |     | <span class='neutral'>            int clamped = (value - low) % (range);</span>
 270 |     | <span class='neutral'>            if (clamped &lt; 0) clamped += range;</span>
 271 |     | <span class='neutral'>            int ans = low + clamped;</span>
 272 |     | <span class='neutral'>            string memory valueStr = PropertiesLibString.toString(value);</span>
 273 |     | <span class='neutral'>            string memory ansStr = PropertiesLibString.toString(ans);</span>
 274 |     | <span class='neutral'>            bytes memory message = abi.encodePacked(</span>
 275 |     | <span class='neutral'>                &quot;Clamping value &quot;,</span>
 276 |     | <span class='neutral'>                valueStr,</span>
 277 |     | <span class='neutral'>                &quot; to &quot;,</span>
 278 |     | <span class='neutral'>                ansStr</span>
 279 |     | <span class='neutral'>            );</span>
 280 |     | <span class='neutral'>            emit LogString(string(message));</span>
 281 |     | <span class='neutral'>            return ans;</span>
 282 |     | <span class='neutral'>        }</span>
 283 |     | <span class='neutral'>        return value;</span>
 284 |     | <span class='neutral'>    }</span>
 285 |     | <span class='neutral'></span>
 286 |     | <span class='neutral'>    /// @notice clamps a to be less than b</span>
 287 |     | <span class='neutral'>    function clampLt(uint256 a, uint256 b) internal returns (uint256) {</span>
 288 |     | <span class='neutral'>        if (!(a &lt; b)) {</span>
 289 |     | <span class='neutral'>            assertNeq(</span>
 290 |     | <span class='neutral'>                b,</span>
 291 |     | <span class='neutral'>                0,</span>
 292 |     | <span class='neutral'>                &quot;clampLt cannot clamp value a to be less than zero. Check your inputs/assumptions.&quot;</span>
 293 |     | <span class='neutral'>            );</span>
 294 |     | <span class='neutral'>            uint256 value = a % b;</span>
 295 |     | <span class='neutral'>            string memory aStr = PropertiesLibString.toString(a);</span>
 296 |     | <span class='neutral'>            string memory valueStr = PropertiesLibString.toString(value);</span>
 297 |     | <span class='neutral'>            bytes memory message = abi.encodePacked(</span>
 298 |     | <span class='neutral'>                &quot;Clamping value &quot;,</span>
 299 |     | <span class='neutral'>                aStr,</span>
 300 |     | <span class='neutral'>                &quot; to &quot;,</span>
 301 |     | <span class='neutral'>                valueStr</span>
 302 |     | <span class='neutral'>            );</span>
 303 |     | <span class='neutral'>            emit LogString(string(message));</span>
 304 |     | <span class='neutral'>            return value;</span>
 305 |     | <span class='neutral'>        }</span>
 306 |     | <span class='neutral'>        return a;</span>
 307 |     | <span class='neutral'>    }</span>
 308 |     | <span class='neutral'></span>
 309 |     | <span class='neutral'>    /// @notice int256 version of clampLt</span>
 310 |     | <span class='neutral'>    function clampLt(int256 a, int256 b) internal returns (int256) {</span>
 311 |     | <span class='neutral'>        if (!(a &lt; b)) {</span>
 312 |     | <span class='neutral'>            int256 value = b - 1;</span>
 313 |     | <span class='neutral'>            string memory aStr = PropertiesLibString.toString(a);</span>
 314 |     | <span class='neutral'>            string memory valueStr = PropertiesLibString.toString(value);</span>
 315 |     | <span class='neutral'>            bytes memory message = abi.encodePacked(</span>
 316 |     | <span class='neutral'>                &quot;Clamping value &quot;,</span>
 317 |     | <span class='neutral'>                aStr,</span>
 318 |     | <span class='neutral'>                &quot; to &quot;,</span>
 319 |     | <span class='neutral'>                valueStr</span>
 320 |     | <span class='neutral'>            );</span>
 321 |     | <span class='neutral'>            emit LogString(string(message));</span>
 322 |     | <span class='neutral'>            return value;</span>
 323 |     | <span class='neutral'>        }</span>
 324 |     | <span class='neutral'>        return a;</span>
 325 |     | <span class='neutral'>    }</span>
 326 |     | <span class='neutral'></span>
 327 |     | <span class='neutral'>    /// @notice clamps a to be less than or equal to b</span>
 328 |     | <span class='neutral'>    function clampLte(uint256 a, uint256 b) internal returns (uint256) {</span>
 329 |     | <span class='neutral'>        if (!(a &lt;= b)) {</span>
 330 |     | <span class='neutral'>            uint256 value = a % (b + 1);</span>
 331 |     | <span class='neutral'>            string memory aStr = PropertiesLibString.toString(a);</span>
 332 |     | <span class='neutral'>            string memory valueStr = PropertiesLibString.toString(value);</span>
 333 |     | <span class='neutral'>            bytes memory message = abi.encodePacked(</span>
 334 |     | <span class='neutral'>                &quot;Clamping value &quot;,</span>
 335 |     | <span class='neutral'>                aStr,</span>
 336 |     | <span class='neutral'>                &quot; to &quot;,</span>
 337 |     | <span class='neutral'>                valueStr</span>
 338 |     | <span class='neutral'>            );</span>
 339 |     | <span class='neutral'>            emit LogString(string(message));</span>
 340 |     | <span class='neutral'>            return value;</span>
 341 |     | <span class='neutral'>        }</span>
 342 |     | <span class='neutral'>        return a;</span>
 343 |     | <span class='neutral'>    }</span>
 344 |     | <span class='neutral'></span>
 345 |     | <span class='neutral'>    /// @notice int256 version of clampLte</span>
 346 |     | <span class='neutral'>    function clampLte(int256 a, int256 b) internal returns (int256) {</span>
 347 |     | <span class='neutral'>        if (!(a &lt;= b)) {</span>
 348 |     | <span class='neutral'>            int256 value = b;</span>
 349 |     | <span class='neutral'>            string memory aStr = PropertiesLibString.toString(a);</span>
 350 |     | <span class='neutral'>            string memory valueStr = PropertiesLibString.toString(value);</span>
 351 |     | <span class='neutral'>            bytes memory message = abi.encodePacked(</span>
 352 |     | <span class='neutral'>                &quot;Clamping value &quot;,</span>
 353 |     | <span class='neutral'>                aStr,</span>
 354 |     | <span class='neutral'>                &quot; to &quot;,</span>
 355 |     | <span class='neutral'>                valueStr</span>
 356 |     | <span class='neutral'>            );</span>
 357 |     | <span class='neutral'>            emit LogString(string(message));</span>
 358 |     | <span class='neutral'>            return value;</span>
 359 |     | <span class='neutral'>        }</span>
 360 |     | <span class='neutral'>        return a;</span>
 361 |     | <span class='neutral'>    }</span>
 362 |     | <span class='neutral'></span>
 363 |     | <span class='neutral'>    /// @notice clamps a to be greater than b</span>
 364 |     | <span class='neutral'>    function clampGt(uint256 a, uint256 b) internal returns (uint256) {</span>
 365 |     | <span class='neutral'>        if (!(a &gt; b)) {</span>
 366 |     | <span class='neutral'>            assertNeq(</span>
 367 |     | <span class='neutral'>                b,</span>
 368 |     | <span class='neutral'>                type(uint256).max,</span>
 369 |     | <span class='neutral'>                &quot;clampGt cannot clamp value a to be larger than uint256.max. Check your inputs/assumptions.&quot;</span>
 370 |     | <span class='neutral'>            );</span>
 371 |     | <span class='neutral'>            uint256 value = b + 1;</span>
 372 |     | <span class='neutral'>            string memory aStr = PropertiesLibString.toString(a);</span>
 373 |     | <span class='neutral'>            string memory valueStr = PropertiesLibString.toString(value);</span>
 374 |     | <span class='neutral'>            bytes memory message = abi.encodePacked(</span>
 375 |     | <span class='neutral'>                &quot;Clamping value &quot;,</span>
 376 |     | <span class='neutral'>                aStr,</span>
 377 |     | <span class='neutral'>                &quot; to &quot;,</span>
 378 |     | <span class='neutral'>                valueStr</span>
 379 |     | <span class='neutral'>            );</span>
 380 |     | <span class='neutral'>            emit LogString(string(message));</span>
 381 |     | <span class='neutral'>            return value;</span>
 382 |     | <span class='neutral'>        } else {</span>
 383 |     | <span class='neutral'>            return a;</span>
 384 |     | <span class='neutral'>        }</span>
 385 |     | <span class='neutral'>    }</span>
 386 |     | <span class='neutral'></span>
 387 |     | <span class='neutral'>    /// @notice int256 version of clampGt</span>
 388 |     | <span class='neutral'>    function clampGt(int256 a, int256 b) internal returns (int256) {</span>
 389 |     | <span class='neutral'>        if (!(a &gt; b)) {</span>
 390 |     | <span class='neutral'>            int256 value = b + 1;</span>
 391 |     | <span class='neutral'>            string memory aStr = PropertiesLibString.toString(a);</span>
 392 |     | <span class='neutral'>            string memory valueStr = PropertiesLibString.toString(value);</span>
 393 |     | <span class='neutral'>            bytes memory message = abi.encodePacked(</span>
 394 |     | <span class='neutral'>                &quot;Clamping value &quot;,</span>
 395 |     | <span class='neutral'>                aStr,</span>
 396 |     | <span class='neutral'>                &quot; to &quot;,</span>
 397 |     | <span class='neutral'>                valueStr</span>
 398 |     | <span class='neutral'>            );</span>
 399 |     | <span class='neutral'>            emit LogString(string(message));</span>
 400 |     | <span class='neutral'>            return value;</span>
 401 |     | <span class='neutral'>        } else {</span>
 402 |     | <span class='neutral'>            return a;</span>
 403 |     | <span class='neutral'>        }</span>
 404 |     | <span class='neutral'>    }</span>
 405 |     | <span class='neutral'></span>
 406 |     | <span class='neutral'>    /// @notice clamps a to be greater than or equal to b</span>
 407 |     | <span class='neutral'>    function clampGte(uint256 a, uint256 b) internal returns (uint256) {</span>
 408 |     | <span class='neutral'>        if (!(a &gt; b)) {</span>
 409 |     | <span class='neutral'>            uint256 value = b;</span>
 410 |     | <span class='neutral'>            string memory aStr = PropertiesLibString.toString(a);</span>
 411 |     | <span class='neutral'>            string memory valueStr = PropertiesLibString.toString(value);</span>
 412 |     | <span class='neutral'>            bytes memory message = abi.encodePacked(</span>
 413 |     | <span class='neutral'>                &quot;Clamping value &quot;,</span>
 414 |     | <span class='neutral'>                aStr,</span>
 415 |     | <span class='neutral'>                &quot; to &quot;,</span>
 416 |     | <span class='neutral'>                valueStr</span>
 417 |     | <span class='neutral'>            );</span>
 418 |     | <span class='neutral'>            emit LogString(string(message));</span>
 419 |     | <span class='neutral'>            return value;</span>
 420 |     | <span class='neutral'>        }</span>
 421 |     | <span class='neutral'>        return a;</span>
 422 |     | <span class='neutral'>    }</span>
 423 |     | <span class='neutral'></span>
 424 |     | <span class='neutral'>    /// @notice int256 version of clampGte</span>
 425 |     | <span class='neutral'>    function clampGte(int256 a, int256 b) internal returns (int256) {</span>
 426 |     | <span class='neutral'>        if (!(a &gt; b)) {</span>
 427 |     | <span class='neutral'>            int256 value = b;</span>
 428 |     | <span class='neutral'>            string memory aStr = PropertiesLibString.toString(a);</span>
 429 |     | <span class='neutral'>            string memory valueStr = PropertiesLibString.toString(value);</span>
 430 |     | <span class='neutral'>            bytes memory message = abi.encodePacked(</span>
 431 |     | <span class='neutral'>                &quot;Clamping value &quot;,</span>
 432 |     | <span class='neutral'>                aStr,</span>
 433 |     | <span class='neutral'>                &quot; to &quot;,</span>
 434 |     | <span class='neutral'>                valueStr</span>
 435 |     | <span class='neutral'>            );</span>
 436 |     | <span class='neutral'>            emit LogString(string(message));</span>
 437 |     | <span class='neutral'>            return value;</span>
 438 |     | <span class='neutral'>        }</span>
 439 |     | <span class='neutral'>        return a;</span>
 440 |     | <span class='neutral'>    }</span>
 441 |     | <span class='neutral'>}</span>
 442 |     | <span class='neutral'></span>
 443 |     | <span class='neutral'>/// @notice Efficient library for creating string representations of integers.</span>
 444 |     | <span class='neutral'>/// @author Solmate (https://github.com/transmissions11/solmate/blob/main/src/utils/LibString.sol)</span>
 445 |     | <span class='neutral'>/// @author Modified from Solady (https://github.com/Vectorized/solady/blob/main/src/utils/LibString.sol)</span>
 446 |     | <span class='neutral'>/// @dev Name of the library is modified to prevent collisions with contract-under-test uses of LibString</span>
 447 |     | <span class='unexecuted'>library PropertiesLibString {</span>
 448 |     | <span class='neutral'>    function toString(int256 value) internal pure returns (string memory str) {</span>
 449 |     | <span class='neutral'>        uint256 absValue = value &gt;= 0 ? uint256(value) : uint256(-value);</span>
 450 |     | <span class='neutral'>        str = toString(absValue);</span>
 451 |     | <span class='neutral'></span>
 452 |     | <span class='neutral'>        if (value &lt; 0) {</span>
 453 |     | <span class='neutral'>            str = string(abi.encodePacked(&quot;-&quot;, str));</span>
 454 |     | <span class='neutral'>        }</span>
 455 |     | <span class='neutral'>    }</span>
 456 |     | <span class='neutral'></span>
 457 | *   | <span class='executed'>    function toString(uint256 value) internal pure returns (string memory str) {</span>
 458 |     | <span class='neutral'>        /// @solidity memory-safe-assembly</span>
 459 |     | <span class='neutral'>        assembly {</span>
 460 |     | <span class='neutral'>            // The maximum value of a uint256 contains 78 digits (1 byte per digit), but we allocate 160 bytes</span>
 461 |     | <span class='neutral'>            // to keep the free memory pointer word aligned. We&#39;ll need 1 word for the length, 1 word for the</span>
 462 |     | <span class='neutral'>            // trailing zeros padding, and 3 other words for a max of 78 digits. In total: 5 * 32 = 160 bytes.</span>
 463 | *   | <span class='executed'>            let newFreeMemoryPointer := add(mload(0x40), 160)</span>
 464 |     | <span class='neutral'></span>
 465 |     | <span class='neutral'>            // Update the free memory pointer to avoid overriding our string.</span>
 466 | *   | <span class='executed'>            mstore(0x40, newFreeMemoryPointer)</span>
 467 |     | <span class='neutral'></span>
 468 |     | <span class='neutral'>            // Assign str to the end of the zone of newly allocated memory.</span>
 469 | *   | <span class='executed'>            str := sub(newFreeMemoryPointer, 32)</span>
 470 |     | <span class='neutral'></span>
 471 |     | <span class='neutral'>            // Clean the last word of memory it may not be overwritten.</span>
 472 | *   | <span class='executed'>            mstore(str, 0)</span>
 473 |     | <span class='neutral'></span>
 474 |     | <span class='neutral'>            // Cache the end of the memory to calculate the length later.</span>
 475 | *   | <span class='executed'>            let end := str</span>
 476 |     | <span class='neutral'></span>
 477 |     | <span class='neutral'>            // We write the string from rightmost digit to leftmost digit.</span>
 478 |     | <span class='neutral'>            // The following is essentially a do-while loop that also handles the zero case.</span>
 479 |     | <span class='neutral'>            // prettier-ignore</span>
 480 | *   | <span class='executed'>            for { let temp := value } 1 {} {</span>
 481 |     | <span class='neutral'>                // Move the pointer 1 byte to the left.</span>
 482 | *   | <span class='executed'>                str := sub(str, 1)</span>
 483 |     | <span class='neutral'></span>
 484 |     | <span class='neutral'>                // Write the character to the pointer.</span>
 485 |     | <span class='neutral'>                // The ASCII index of the &#39;0&#39; character is 48.</span>
 486 | *   | <span class='executed'>                mstore8(str, add(48, mod(temp, 10)))</span>
 487 |     | <span class='neutral'></span>
 488 |     | <span class='neutral'>                // Keep dividing temp until zero.</span>
 489 | *   | <span class='executed'>                temp := div(temp, 10)</span>
 490 |     | <span class='neutral'></span>
 491 |     | <span class='neutral'>                 // prettier-ignore</span>
 492 | *   | <span class='executed'>                if iszero(temp) { break }</span>
 493 |     | <span class='neutral'>            }</span>
 494 |     | <span class='neutral'></span>
 495 |     | <span class='neutral'>            // Compute and cache the final total length of the string.</span>
 496 | *   | <span class='executed'>            let length := sub(end, str)</span>
 497 |     | <span class='neutral'></span>
 498 |     | <span class='neutral'>            // Move the pointer 32 bytes leftwards to make room for the length.</span>
 499 | *   | <span class='executed'>            str := sub(str, 32)</span>
 500 |     | <span class='neutral'></span>
 501 |     | <span class='neutral'>            // Store the string&#39;s length at the start of memory allocated for our string.</span>
 502 | *   | <span class='executed'>            mstore(str, length)</span>
 503 |     | <span class='neutral'>        }</span>
 504 |     | <span class='neutral'>    }</span>
 505 |     | <span class='neutral'></span>
 506 |     | <span class='neutral'>    function toString(address value) internal pure returns (string memory str) {</span>
 507 |     | <span class='neutral'>        bytes memory s = new bytes(40);</span>
 508 |     | <span class='neutral'>        for (uint i = 0; i &lt; 20; i++) {</span>
 509 |     | <span class='neutral'>            bytes1 b = bytes1(</span>
 510 |     | <span class='neutral'>                uint8(uint(uint160(value)) / (2 ** (8 * (19 - i))))</span>
 511 |     | <span class='neutral'>            );</span>
 512 |     | <span class='neutral'>            bytes1 hi = bytes1(uint8(b) / 16);</span>
 513 |     | <span class='neutral'>            bytes1 lo = bytes1(uint8(b) - 16 * uint8(hi));</span>
 514 |     | <span class='neutral'>            s[2 * i] = char(hi);</span>
 515 |     | <span class='neutral'>            s[2 * i + 1] = char(lo);</span>
 516 |     | <span class='neutral'>        }</span>
 517 |     | <span class='neutral'>        return string(s);</span>
 518 |     | <span class='neutral'>    }</span>
 519 |     | <span class='neutral'></span>
 520 |     | <span class='neutral'>    function char(bytes1 b) internal pure returns (bytes1 c) {</span>
 521 |     | <span class='neutral'>        if (uint8(b) &lt; 10) return bytes1(uint8(b) + 0x30);</span>
 522 |     | <span class='neutral'>        else return bytes1(uint8(b) + 0x57);</span>
 523 |     | <span class='neutral'>    }</span>
 524 |     | <span class='neutral'>}</span>
 525 |     | <span class='neutral'></span>

</code>
<br />

