/mnt/c/Users/Lourens/Documents/Recon-Fuzz/collabs/ebtc/packages/contracts/contracts/ActivePool.sol
   1 |     | // SPDX-License-Identifier: MIT
   2 |     | 
   3 |     | pragma solidity 0.8.17;
   4 |     | 
   5 |     | import "./Interfaces/IActivePool.sol";
   6 |     | import "./Interfaces/ICollSurplusPool.sol";
   7 |     | import "./Dependencies/ICollateralToken.sol";
   8 |     | import "./Interfaces/ICdpManagerData.sol";
   9 |     | import "./Interfaces/IBorrowerOperations.sol";
  10 |     | import "./Dependencies/ERC3156FlashLender.sol";
  11 |     | import "./Dependencies/SafeERC20.sol";
  12 |     | import "./Dependencies/ReentrancyGuard.sol";
  13 |     | import "./Dependencies/AuthNoOwner.sol";
  14 |     | import "./Dependencies/BaseMath.sol";
  15 |     | import "./Dependencies/TwapWeightedObserver.sol";
  16 |     | import "./Dependencies/EbtcMath.sol";
  17 |     | 
  18 |     | /**
  19 |     |  * @title The Active Pool holds the collateral and EBTC debt (only accounting but not EBTC tokens) for all active cdps.
  20 |     |  *
  21 |     |  * @notice When a cdp is liquidated, it's collateral will be transferred from the Active Pool
  22 |     |  * @notice (destination may vary depending on the liquidation conditions).
  23 |     |  * @dev ActivePool also allows ERC3156 compatible flashloan of stETH token
  24 |     |  */
  25 |     | contract ActivePool is
  26 |     |     IActivePool,
  27 |     |     ERC3156FlashLender,
  28 |     |     ReentrancyGuard,
  29 |     |     BaseMath,
  30 |     |     AuthNoOwner,
  31 |     |     TwapWeightedObserver
  32 |     | {
  33 |     |     using SafeERC20 for IERC20;
  34 |     |     string public constant NAME = "ActivePool";
  35 |     | 
  36 |     |     address public immutable borrowerOperationsAddress;
  37 |     |     address public immutable cdpManagerAddress;
  38 |     |     address public immutable collSurplusPoolAddress;
  39 |     |     address public immutable feeRecipientAddress;
  40 |     | 
  41 |     |     uint256 internal systemCollShares; // deposited collateral tracker
  42 |     |     uint256 internal systemDebt;
  43 |     |     uint256 internal feeRecipientCollShares; // coll shares claimable by fee recipient
  44 |     |     ICollateralToken public immutable collateral;
  45 |     | 
  46 |     |     // --- Contract setters ---
  47 |     | 
  48 |     |     /// @notice Constructor for the ActivePool contract
  49 |     |     /// @dev Initializes the contract with the borrowerOperationsAddress, cdpManagerAddress, collateral token address, collSurplusAddress, and feeRecipientAddress
  50 |     |     /// @param _borrowerOperationsAddress The address of the Borrower Operations contract
  51 |     |     /// @param _cdpManagerAddress The address of the Cdp Manager contract
  52 |     |     /// @param _collTokenAddress The address of the collateral token
  53 |     |     /// @param _collSurplusAddress The address of the collateral surplus pool
  54 |     | 
  55 |     |     constructor(
  56 |     |         address _borrowerOperationsAddress,
  57 |     |         address _cdpManagerAddress,
  58 |     |         address _collTokenAddress,
  59 |     |         address _collSurplusAddress
  60 |     |     ) TwapWeightedObserver(0) {
  61 |     |         borrowerOperationsAddress = _borrowerOperationsAddress;
  62 |     |         cdpManagerAddress = _cdpManagerAddress;
  63 |     |         collateral = ICollateralToken(_collTokenAddress);
  64 |     |         collSurplusPoolAddress = _collSurplusAddress;
  65 |     |         feeRecipientAddress = IBorrowerOperations(borrowerOperationsAddress).feeRecipientAddress();
  66 |     | 
  67 |     |         // TEMP: read authority to avoid signature change
  68 |     |         address _authorityAddress = address(AuthNoOwner(cdpManagerAddress).authority());
  69 |     |         if (_authorityAddress != address(0)) {
  70 |     |             _initializeAuthority(_authorityAddress);
  71 |     |         }
  72 |     | 
  73 |     |         require(systemDebt == 0, "ActivePool: systemDebt should be 0 for TWAP initialization");
  74 |     |     }
  75 |     | 
  76 |     |     // --- Getters for public variables. Required by IPool interface ---
  77 |     | 
  78 |     |     /// @notice Amount of stETH collateral shares in the contract
  79 |     |     /// @dev Not necessarily equal to the the contract's raw systemCollShares balance - tokens can be forcibly sent to contracts
  80 |     |     /// @return uint256 The amount of systemCollShares allocated to the pool
  81 |     | 
  82 |     |     function getSystemCollShares() external view override returns (uint256) {
  83 |     |         return systemCollShares;
  84 |     |     }
  85 |     | 
  86 |     |     /// @notice Returns the systemDebt state variable
  87 |     |     /// @dev The amount of EBTC debt in the pool. Like systemCollShares, this is not necessarily equal to the contract's EBTC token balance - tokens can be forcibly sent to contracts
  88 |     |     /// @return uint256 The amount of EBTC debt in the pool
  89 |     | 
  90 |     |     function getSystemDebt() external view override returns (uint256) {
  91 |     |         return systemDebt;
  92 |     |     }
  93 |     | 
  94 |     |     /// @notice The amount of stETH collateral shares claimable by the fee recipient
  95 |     |     /// @return uint256 The amount of collateral shares claimable by the fee recipient
  96 |     | 
  97 |     |     function getFeeRecipientClaimableCollShares() external view override returns (uint256) {
  98 |     |         return feeRecipientCollShares;
  99 |     |     }
 100 |     | 
 101 |     |     // --- Pool functionality ---
 102 |     | 
 103 |     |     /// @notice Sends stETH collateral shares to a specified account
 104 |     |     /// @dev Only for use by system contracts, the caller must be either BorrowerOperations or CdpManager
 105 |     |     /// @param _account The address of the account to send stETH to
 106 |     |     /// @param _shares The amount of stETH shares to send
 107 |     | 
 108 |     |     function transferSystemCollShares(address _account, uint256 _shares) public override {
 109 |     |         _requireCallerIsBOorCdpM();
 110 |     | 
 111 |     |         uint256 cachedSystemCollShares = systemCollShares;
 112 |     |         require(cachedSystemCollShares >= _shares, "!ActivePoolBal");
 113 |     |         unchecked {
 114 |     |             // Can use unchecked due to above
 115 |     |             cachedSystemCollShares -= _shares; // Updating here avoids an SLOAD
 116 |     |         }
 117 |     | 
 118 |     |         systemCollShares = cachedSystemCollShares;
 119 |     | 
 120 |     |         emit SystemCollSharesUpdated(cachedSystemCollShares);
 121 |     |         emit CollSharesTransferred(_account, _shares);
 122 |     | 
 123 |     |         _transferCollSharesWithContractHooks(_account, _shares);
 124 |     |     }
 125 |     | 
 126 |     |     /// @notice Sends stETH to a specified account, drawing from both core shares and liquidator rewards shares
 127 |     |     /// @notice Liquidator reward shares are not tracked via internal accounting in the active pool and are assumed to be present in expected amount as part of the intended behavior of BorowerOperations and CdpManager
 128 |     |     /// @dev Liquidator reward shares are added when a cdp is opened, and removed when it is closed
 129 |     |     /// @dev closeCdp() or liqudations result in the actor (borrower or liquidator respectively) receiving the liquidator reward shares
 130 |     |     /// @dev Redemptions result in the shares being sent to the coll surplus pool for claiming by the CDP owner
 131 |     |     /// @dev Note that funds in the coll surplus pool, just like liquidator reward shares, are not tracked as part of the system CR or coll of a CDP.
 132 |     |     /// @dev Requires that the caller is either BorrowerOperations or CdpManager
 133 |     |     /// @param _account The address of the account to send systemCollShares and the liquidator reward to
 134 |     |     /// @param _shares The amount of systemCollShares to send
 135 |     |     /// @param _liquidatorRewardShares The amount of the liquidator reward shares to send
 136 |     | 
 137 |     |     function transferSystemCollSharesAndLiquidatorReward(
 138 |     |         address _account,
 139 |     |         uint256 _shares,
 140 |     |         uint256 _liquidatorRewardShares
 141 |     |     ) external override {
 142 |     |         _requireCallerIsBOorCdpM();
 143 |     | 
 144 |     |         uint256 cachedSystemCollShares = systemCollShares;
 145 |     |         require(cachedSystemCollShares >= _shares, "ActivePool: Insufficient collateral shares");
 146 |     |         uint256 totalShares = _shares + _liquidatorRewardShares;
 147 |     |         unchecked {
 148 |     |             // Safe per the check above
 149 |     |             cachedSystemCollShares -= _shares;
 150 |     |         }
 151 |     |         systemCollShares = cachedSystemCollShares;
 152 |     | 
 153 |     |         emit SystemCollSharesUpdated(cachedSystemCollShares);
 154 |     |         emit CollSharesTransferred(_account, totalShares);
 155 |     | 
 156 |     |         _transferCollSharesWithContractHooks(_account, totalShares);
 157 |     |     }
 158 |     | 
 159 |     |     /// @notice Allocate stETH shares from the system to the fee recipient to claim at-will (pull model)
 160 |     |     /// @dev Requires that the caller is CdpManager
 161 |     |     /// @dev Only the current fee recipient address is able to claim the shares
 162 |     |     /// @dev If the fee recipient address is changed while outstanding claimable coll is available, only the new fee recipient will be able to claim the outstanding coll
 163 |     |     /// @param _shares The amount of systemCollShares to allocate to the fee recipient
 164 |     | 
 165 |     |     function allocateSystemCollSharesToFeeRecipient(uint256 _shares) external override {
 166 |     |         _requireCallerIsCdpManager();
 167 |     | 
 168 |     |         uint256 cachedSystemCollShares = systemCollShares;
 169 |     | 
 170 |     |         require(cachedSystemCollShares >= _shares, "ActivePool: Insufficient collateral shares");
 171 |     |         unchecked {
 172 |     |             // Safe per the check above
 173 |     |             cachedSystemCollShares -= _shares;
 174 |     |         }
 175 |     | 
 176 |     |         systemCollShares = cachedSystemCollShares;
 177 |     | 
 178 |     |         uint256 cachedFeeRecipientCollShares = feeRecipientCollShares + _shares;
 179 |     |         feeRecipientCollShares = cachedFeeRecipientCollShares;
 180 |     | 
 181 |     |         emit SystemCollSharesUpdated(cachedSystemCollShares);
 182 |     |         emit FeeRecipientClaimableCollSharesIncreased(cachedFeeRecipientCollShares, _shares);
 183 |     |     }
 184 |     | 
 185 |     |     /// @notice Helper function to transfer stETH shares to another address, ensuring to call hooks into other system pools if they are the recipient
 186 |     |     /// @param _account The address to transfer shares to
 187 |     |     /// @param _shares The amount of shares to transfer
 188 |     | 
 189 |     |     function _transferCollSharesWithContractHooks(address _account, uint256 _shares) internal {
 190 |     |         // NOTE: No need for safe transfer if the collateral asset is standard. Make sure this is the case!
 191 |     |         collateral.transferShares(_account, _shares);
 192 |     | 
 193 |     |         if (_account == collSurplusPoolAddress) {
 194 |     |             ICollSurplusPool(_account).increaseTotalSurplusCollShares(_shares);
 195 |     |         }
 196 |     |     }
 197 |     | 
 198 |     |     /// @notice Increases the tracked EBTC debt of the system by a specified amount
 199 |     |     /// @dev Managed by system contracts - requires that the caller is either BorrowerOperations or CdpManager
 200 |     |     /// @param _amount: The amount to increase the system EBTC debt by
 201 |     | 
 202 |     |     function increaseSystemDebt(uint256 _amount) external override {
 203 |     |         _requireCallerIsBOorCdpM();
 204 |     | 
 205 |     |         uint256 cachedSystemDebt = systemDebt + _amount;
 206 |     |         uint128 castedSystemDebt = EbtcMath.toUint128(cachedSystemDebt);
 207 |     | 
 208 |     |         if (!twapDisabled) {
 209 |     |             /// @audit If TWAP fails it should allow transaction to continue. Failure is preferrable to permanent DOS and can practically be mitigated by managing the redemption baseFee.
 210 |     |             try this.setValueAndUpdate(castedSystemDebt) {} catch {
 211 |     |                 twapDisabled = true;
 212 |     |                 emit TwapDisabled();
 213 |     |             }
 214 |     |         }
 215 |     | 
 216 |     |         /// @audit If above uint128 max, will have reverted in safeCast
 217 |     |         systemDebt = cachedSystemDebt;
 218 |     |         emit ActivePoolEBTCDebtUpdated(cachedSystemDebt);
 219 |     |     }
 220 |     | 
 221 |     |     /// @notice Decreases the tracked EBTC debt of the system by a specified amount
 222 |     |     /// @dev Managed by system contracts - requires that the caller is either BorrowerOperations or CdpManager
 223 |     |     /// @param _amount: The amount to decrease the system EBTC debt by
 224 |     | 
 225 |     |     function decreaseSystemDebt(uint256 _amount) external override {
 226 |     |         _requireCallerIsBOorCdpM();
 227 |     | 
 228 |     |         uint256 cachedSystemDebt = systemDebt - _amount;
 229 |     |         uint128 castedSystemDebt = EbtcMath.toUint128(cachedSystemDebt);
 230 |     | 
 231 |     |         if (!twapDisabled) {
 232 |     |             /// @audit If TWAP fails it should allow transaction to continue. Failure is preferrable to permanent DOS and can practically be mitigated by managing the redemption baseFee.
 233 |     |             try this.setValueAndUpdate(EbtcMath.toUint128(castedSystemDebt)) {} catch {
 234 |     |                 twapDisabled = true;
 235 |     |                 emit TwapDisabled();
 236 |     |             }
 237 |     |         }
 238 |     | 
 239 |     |         /// @audit If above uint128 max, will have reverted in safeCast
 240 |     |         systemDebt = cachedSystemDebt;
 241 |     |         emit ActivePoolEBTCDebtUpdated(cachedSystemDebt);
 242 |     |     }
 243 |     | 
 244 |     |     // --- 'require' functions ---
 245 |     | 
 246 |     |     /// @notice Checks if the caller is BorrowerOperations
 247 |     |     function _requireCallerIsBorrowerOperations() internal view {
 248 |     |         require(
 249 |     |             msg.sender == borrowerOperationsAddress,
 250 |     |             "ActivePool: Caller is not BorrowerOperations"
 251 |     |         );
 252 |     |     }
 253 |     | 
 254 |     |     /// @notice Checks if the caller is either BorrowerOperations or CdpManager
 255 |     |     function _requireCallerIsBOorCdpM() internal view {
 256 |     |         require(
 257 |     |             msg.sender == borrowerOperationsAddress || msg.sender == cdpManagerAddress,
 258 |     |             "ActivePool: Caller is neither BorrowerOperations nor CdpManager"
 259 |     |         );
 260 |     |     }
 261 |     | 
 262 |     |     /// @notice Checks if the caller is CdpManager
 263 |     |     function _requireCallerIsCdpManager() internal view {
 264 |     |         require(msg.sender == cdpManagerAddress, "ActivePool: Caller is not CdpManager");
 265 |     |     }
 266 |     | 
 267 |     |     /// @notice Notify that stETH collateral shares have been recieved, updating internal accounting accordingly
 268 |     |     /// @param _value The amount of collateral to receive
 269 |     | 
 270 |     |     function increaseSystemCollShares(uint256 _value) external override {
 271 |     |         _requireCallerIsBorrowerOperations();
 272 |     | 
 273 |     |         uint256 cachedSystemCollShares = systemCollShares + _value;
 274 |     |         systemCollShares = cachedSystemCollShares;
 275 |     |         emit SystemCollSharesUpdated(cachedSystemCollShares);
 276 |     |     }
 277 |     | 
 278 |     |     // === Flashloans === //
 279 |     | 
 280 |     |     /// @notice Borrow assets with a flash loan
 281 |     |     /// @dev The Collateral checks may cause reverts if you trigger a fee change big enough
 282 |     |     ///         consider calling `cdpManagerAddress.syncGlobalAccountingAndGracePeriod()`
 283 |     |     /// @param receiver The address to receive the flash loan
 284 |     |     /// @param token The address of the token to loan
 285 |     |     /// @param amount The amount of tokens to loan
 286 |     |     /// @param data Additional data
 287 |     |     /// @return A boolean value indicating whether the operation was successful
 288 |     | 
 289 |     |     function flashLoan(
 290 |     |         IERC3156FlashBorrower receiver,
 291 |     |         address token,
 292 |     |         uint256 amount,
 293 |     |         bytes calldata data
 294 |     |     ) external override returns (bool) {
 295 |     |         require(amount > 0, "ActivePool: 0 Amount");
 296 |     |         uint256 fee = flashFee(token, amount); // NOTE: Check for `token` is implicit in the requires above // also checks for paused
 297 |     |         require(amount <= maxFlashLoan(token), "ActivePool: Too much");
 298 |     | 
 299 |     |         uint256 amountWithFee = amount + fee;
 300 |     |         uint256 oldRate = collateral.getPooledEthByShares(DECIMAL_PRECISION);
 301 |     | 
 302 |     |         collateral.transfer(address(receiver), amount);
 303 |     | 
 304 |     |         // Callback
 305 |     |         require(
 306 |     |             receiver.onFlashLoan(msg.sender, token, amount, fee, data) == FLASH_SUCCESS_VALUE,
 307 |     |             "ActivePool: IERC3156: Callback failed"
 308 |     |         );
 309 |     | 
 310 |     |         // Transfer of (principal + Fee) from flashloan receiver
 311 |     |         collateral.transferFrom(address(receiver), address(this), amountWithFee);
 312 |     | 
 313 |     |         // Send earned fee to designated recipient
 314 |     |         collateral.transfer(feeRecipientAddress, fee);
 315 |     | 
 316 |     |         // Check new balance
 317 |     |         // NOTE: Invariant Check, technically breaks CEI but I think we must use it
 318 |     |         // NOTE: This means any balance > systemCollShares is stuck, this is also present in LUSD as is
 319 |     | 
 320 |     |         // NOTE: This check effectively prevents running 2 FL at the same time
 321 |     |         //  You technically could, but you'd be having to repay any amount below systemCollShares to get Fl2 to not revert
 322 |     |         require(
 323 |     |             collateral.balanceOf(address(this)) >= collateral.getPooledEthByShares(systemCollShares),
 324 |     |             "ActivePool: Must repay Balance"
 325 |     |         );
 326 |     |         require(
 327 |     |             collateral.sharesOf(address(this)) >= systemCollShares,
 328 |     |             "ActivePool: Must repay Share"
 329 |     |         );
 330 |     |         require(
 331 |     |             collateral.getPooledEthByShares(DECIMAL_PRECISION) == oldRate,
 332 |     |             "ActivePool: Should keep same collateral share rate"
 333 |     |         );
 334 |     | 
 335 |     |         emit FlashLoanSuccess(address(receiver), token, amount, fee);
 336 |     | 
 337 |     |         return true;
 338 |     |     }
 339 |     | 
 340 |     |     /// @notice Calculate the flash loan fee for a given token and amount loaned
 341 |     |     /// @param token The address of the token to calculate the fee for
 342 |     |     /// @param amount The amount of tokens to calculate the fee for
 343 |     |     /// @return The flashloan fee calcualted for given token and loan amount
 344 |     | 
 345 |     |     function flashFee(address token, uint256 amount) public view override returns (uint256) {
 346 |     |         require(token == address(collateral), "ActivePool: collateral Only");
 347 |     |         require(!flashLoansPaused, "ActivePool: Flash Loans Paused");
 348 |     | 
 349 |     |         return (amount * feeBps) / MAX_BPS;
 350 |     |     }
 351 |     | 
 352 |     |     /// @notice Get the maximum flash loan amount for a specific token
 353 |     |     /// @dev Exclusively used here for stETH collateral, equal to the current balance of the pool
 354 |     |     /// @param token The address of the token to get the maximum flash loan amount for
 355 |     |     /// @return The maximum available flashloan amount for the token
 356 |     |     function maxFlashLoan(address token) public view override returns (uint256) {
 357 |     |         if (token != address(collateral)) {
 358 |     |             return 0;
 359 |     |         }
 360 |     | 
 361 |     |         if (flashLoansPaused) {
 362 |     |             return 0;
 363 |     |         }
 364 |     | 
 365 |     |         return collateral.balanceOf(address(this));
 366 |     |     }
 367 |     | 
 368 |     |     // === Governed Functions === //
 369 |     | 
 370 |     |     /// @notice Claim outstanding shares for fee recipient, updating internal accounting and transferring the shares.
 371 |     |     /// @dev Call permissinos are managed via authority for flexibility, rather than gating call to just feeRecipient.
 372 |     |     /// @dev Is likely safe as an open permission though caution should be taken.
 373 |     |     /// @param _shares The amount of shares to claim to feeRecipient
 374 |     |     function claimFeeRecipientCollShares(uint256 _shares) external override requiresAuth {
 375 |     |         ICdpManagerData(cdpManagerAddress).syncGlobalAccountingAndGracePeriod(); // Calling this increases shares so do it first
 376 |     | 
 377 |     |         uint256 cachedFeeRecipientCollShares = feeRecipientCollShares;
 378 |     |         require(
 379 |     |             cachedFeeRecipientCollShares >= _shares,
 380 |     |             "ActivePool: Insufficient fee recipient coll"
 381 |     |         );
 382 |     | 
 383 |     |         unchecked {
 384 |     |             cachedFeeRecipientCollShares -= _shares;
 385 |     |         }
 386 |     | 
 387 |     |         feeRecipientCollShares = cachedFeeRecipientCollShares;
 388 |     |         emit FeeRecipientClaimableCollSharesDecreased(cachedFeeRecipientCollShares, _shares);
 389 |     | 
 390 |     |         collateral.transferShares(feeRecipientAddress, _shares);
 391 |     |     }
 392 |     | 
 393 |     |     /// @dev Function to move unintended dust that are not protected
 394 |     |     /// @notice moves given amount of given token (collateral is NOT allowed)
 395 |     |     /// @notice because recipient are fixed, this function is safe to be called by anyone
 396 |     |     /// @param token The token address to be swept
 397 |     |     /// @param amount The token amount to be swept
 398 |     | 
 399 |     |     function sweepToken(address token, uint256 amount) public nonReentrant requiresAuth {
 400 |     |         ICdpManagerData(cdpManagerAddress).syncGlobalAccountingAndGracePeriod(); // Accrue State First
 401 |     | 
 402 |     |         require(token != address(collateral), "ActivePool: Cannot Sweep Collateral");
 403 |     | 
 404 |     |         uint256 balance = IERC20(token).balanceOf(address(this));
 405 |     |         require(amount <= balance, "ActivePool: Attempt to sweep more than balance");
 406 |     | 
 407 |     |         address cachedFeeRecipientAddress = feeRecipientAddress; // Saves an SLOAD
 408 |     | 
 409 |     |         IERC20(token).safeTransfer(cachedFeeRecipientAddress, amount);
 410 |     | 
 411 |     |         emit SweepTokenSuccess(token, amount, cachedFeeRecipientAddress);
 412 |     |     }
 413 |     | 
 414 |     |     /// @notice Sets new Fee for FlashLoans
 415 |     |     /// @param _newFee The new flashloan fee to be set
 416 |     |     function setFeeBps(uint256 _newFee) external requiresAuth {
 417 |     |         ICdpManagerData(cdpManagerAddress).syncGlobalAccountingAndGracePeriod(); // Accrue State First
 418 |     | 
 419 |     |         require(_newFee <= MAX_FEE_BPS, "ERC3156FlashLender: _newFee should <= MAX_FEE_BPS");
 420 |     | 
 421 |     |         // set new flash fee
 422 |     |         uint256 _oldFee = feeBps;
 423 |     |         feeBps = uint16(_newFee);
 424 |     |         emit FlashFeeSet(msg.sender, _oldFee, _newFee);
 425 |     |     }
 426 |     | 
 427 |     |     /// @notice Should Flashloans be paused?
 428 |     |     /// @param _paused The flag (true or false) whether flashloan will be paused
 429 |     |     function setFlashLoansPaused(bool _paused) external requiresAuth {
 430 |     |         ICdpManagerData(cdpManagerAddress).syncGlobalAccountingAndGracePeriod(); // Accrue State First
 431 |     | 
 432 |     |         flashLoansPaused = _paused;
 433 |     |         emit FlashLoansPaused(msg.sender, _paused);
 434 |     |     }
 435 |     | }
 436 |     | 

/mnt/c/Users/Lourens/Documents/Recon-Fuzz/collabs/ebtc/packages/contracts/contracts/BorrowerOperations.sol
    1 |     | // SPDX-License-Identifier: MIT
    2 |     | 
    3 |     | pragma solidity 0.8.17;
    4 |     | 
    5 |     | import "./Interfaces/IBorrowerOperations.sol";
    6 |     | import "./Interfaces/ICdpManager.sol";
    7 |     | import "./Interfaces/ICdpManagerData.sol";
    8 |     | import "./Interfaces/IEBTCToken.sol";
    9 |     | import "./Interfaces/ICollSurplusPool.sol";
   10 |     | import "./Interfaces/ISortedCdps.sol";
   11 |     | import "./Dependencies/EbtcBase.sol";
   12 |     | import "./Dependencies/ReentrancyGuard.sol";
   13 |     | import "./Dependencies/Ownable.sol";
   14 |     | import "./Dependencies/AuthNoOwner.sol";
   15 |     | import "./Dependencies/ERC3156FlashLender.sol";
   16 |     | import "./Dependencies/PermitNonce.sol";
   17 |     | 
   18 |     | /// @title BorrowerOperations is mainly in charge of all end user interactions like Cdp open, adjust, close etc
   19 |     | /// @notice End users could approve delegate via IPositionManagers for authorized actions on their behalf
   20 |     | /// @dev BorrowerOperations also allows ERC3156 compatible flashmint of eBTC token
   21 |     | contract BorrowerOperations is
   22 |     |     EbtcBase,
   23 |     |     ReentrancyGuard,
   24 |     |     IBorrowerOperations,
   25 |     |     ERC3156FlashLender,
   26 |     |     AuthNoOwner,
   27 |     |     PermitNonce
   28 |     | {
   29 |     |     string public constant NAME = "BorrowerOperations";
   30 |     | 
   31 |     |     // keccak256("permitPositionManagerApproval(address borrower,address positionManager,uint8 status,uint256 nonce,uint256 deadline)");
   32 |     |     bytes32 private constant _PERMIT_POSITION_MANAGER_TYPEHASH =
   33 |     |         keccak256(
   34 |     |             "PermitPositionManagerApproval(address borrower,address positionManager,uint8 status,uint256 nonce,uint256 deadline)"
   35 |     |         );
   36 |     | 
   37 |     |     // keccak256("EIP712Domain(string name,string version,uint256 chainId,address verifyingContract)");
   38 |     |     bytes32 private constant _TYPE_HASH =
   39 |     |         0x8b73c3c69bb8fe3d512ecc4cf759cc79239f7b179b0ffacaa9a75d522b39400f;
   40 |     | 
   41 |     |     string internal constant _VERSION = "1";
   42 |     | 
   43 |     |     // Cache the domain separator as an immutable value, but also store the chain id that it corresponds to, in order to
   44 |     |     // invalidate the cached domain separator if the chain id changes.
   45 |     |     bytes32 private immutable _CACHED_DOMAIN_SEPARATOR;
   46 |     |     uint256 private immutable _CACHED_CHAIN_ID;
   47 |     | 
   48 |     |     bytes32 private immutable _HASHED_NAME;
   49 |     |     bytes32 private immutable _HASHED_VERSION;
   50 |     | 
   51 |     |     // --- Connected contract declarations ---
   52 |     | 
   53 |     |     ICdpManager public immutable cdpManager;
   54 |     | 
   55 |     |     ICollSurplusPool public immutable collSurplusPool;
   56 |     | 
   57 |     |     address public immutable feeRecipientAddress;
   58 |     | 
   59 |     |     IEBTCToken public immutable ebtcToken;
   60 |     | 
   61 |     |     // A doubly linked list of Cdps, sorted by their collateral ratios
   62 |     |     ISortedCdps public immutable sortedCdps;
   63 |     | 
   64 |     |     // Mapping of borrowers to approved position managers, by approval status: cdpOwner(borrower) -> positionManager -> PositionManagerApproval (None, OneTime, Persistent)
   65 |     |     mapping(address => mapping(address => PositionManagerApproval)) public positionManagers;
   66 |     | 
   67 |     |     /* --- Variable container structs  ---
   68 |     | 
   69 |     |     Used to hold, return and assign variables inside a function, in order to avoid the error:
   70 |     |     "CompilerError: Stack too deep". */
   71 |     | 
   72 |     |     struct AdjustCdpLocals {
   73 |     |         uint256 price;
   74 |     |         uint256 collSharesChange;
   75 |     |         uint256 netDebtChange;
   76 |     |         bool isCollIncrease;
   77 |     |         uint256 debt;
   78 |     |         uint256 collShares;
   79 |     |         uint256 oldICR;
   80 |     |         uint256 newICR;
   81 |     |         uint256 newTCR;
   82 |     |         uint256 newDebt;
   83 |     |         uint256 newCollShares;
   84 |     |         uint256 stake;
   85 |     |     }
   86 |     | 
   87 |     |     struct OpenCdpLocals {
   88 |     |         uint256 price;
   89 |     |         uint256 debt;
   90 |     |         uint256 netStEthBalance;
   91 |     |         uint256 ICR;
   92 |     |         uint256 NICR;
   93 |     |         uint256 stake;
   94 |     |     }
   95 |     | 
   96 |     |     struct MoveTokensParams {
   97 |     |         address user;
   98 |     |         uint256 collSharesChange;
   99 |     |         uint256 collAddUnderlying; // ONLY for isCollIncrease=true
  100 |     |         bool isCollIncrease;
  101 |     |         uint256 netDebtChange;
  102 |     |         bool isDebtIncrease;
  103 |     |     }
  104 |     | 
  105 |     |     // --- Dependency setters ---
  106 |     |     constructor(
  107 |     |         address _cdpManagerAddress,
  108 |     |         address _activePoolAddress,
  109 |     |         address _collSurplusPoolAddress,
  110 |     |         address _priceFeedAddress,
  111 |     |         address _sortedCdpsAddress,
  112 |     |         address _ebtcTokenAddress,
  113 |     |         address _feeRecipientAddress,
  114 |     |         address _collTokenAddress
  115 |     |     ) EbtcBase(_activePoolAddress, _priceFeedAddress, _collTokenAddress) {
  116 |     |         cdpManager = ICdpManager(_cdpManagerAddress);
  117 |     |         collSurplusPool = ICollSurplusPool(_collSurplusPoolAddress);
  118 |     |         sortedCdps = ISortedCdps(_sortedCdpsAddress);
  119 |     |         ebtcToken = IEBTCToken(_ebtcTokenAddress);
  120 |     |         feeRecipientAddress = _feeRecipientAddress;
  121 |     | 
  122 |     |         address _authorityAddress = address(AuthNoOwner(_cdpManagerAddress).authority());
  123 |     |         if (_authorityAddress != address(0)) {
  124 |     |             _initializeAuthority(_authorityAddress);
  125 |     |         }
  126 |     | 
  127 |     |         bytes32 hashedName = keccak256(bytes(NAME));
  128 |     |         bytes32 hashedVersion = keccak256(bytes(_VERSION));
  129 |     | 
  130 |     |         _HASHED_NAME = hashedName;
  131 |     |         _HASHED_VERSION = hashedVersion;
  132 |     |         _CACHED_CHAIN_ID = _chainID();
  133 |     |         _CACHED_DOMAIN_SEPARATOR = _buildDomainSeparator(_TYPE_HASH, hashedName, hashedVersion);
  134 |     |     }
  135 |     | 
  136 |     |     /**
  137 |     |         @notice BorrowerOperations and CdpManager share reentrancy status by confirming the other's locked flag before beginning operation
  138 |     |         @dev This is an alternative to the more heavyweight solution of both being able to set the reentrancy flag on a 3rd contract.
  139 |     |         @dev Prevents multi-contract reentrancy between these two contracts
  140 |     |      */
  141 |     |     modifier nonReentrantSelfAndCdpM() {
  142 |     |         require(locked == OPEN, "BorrowerOperations: Reentrancy in nonReentrant call");
  143 |     |         require(
  144 |     |             ReentrancyGuard(address(cdpManager)).locked() == OPEN,
  145 |     |             "CdpManager: Reentrancy in nonReentrant call"
  146 |     |         );
  147 |     | 
  148 |     |         locked = LOCKED;
  149 |     | 
  150 |     |         _;
  151 |     | 
  152 |     |         locked = OPEN;
  153 |     |     }
  154 |     | 
  155 |     |     // --- Borrower Cdp Operations ---
  156 |     | 
  157 |     |     /// @notice Function that creates a Cdp for the caller with the requested debt, and the stETH received as collateral.
  158 |     |     /// @notice Successful execution is conditional mainly on the resulting collateralization ratio which must exceed minimum requirement, e.g., MCR.
  159 |     |     /// @notice Upon Cdp open, a separate gas stipend (denominated in stETH) will be allocated for possible liquidation.
  160 |     |     /// @param _debt The expected debt for this new Cdp
  161 |     |     /// @param _upperHint The expected CdpId of neighboring higher ICR within SortedCdps, could be simply bytes32(0)
  162 |     |     /// @param _lowerHint The expected CdpId of neighboring lower ICR within SortedCdps, could be simply bytes32(0)
  163 |     |     /// @param _stEthBalance The total stETH collateral amount deposited for the specified Cdp
  164 |     |     /// @return The CdpId for this newly created Cdp
  165 |     |     function openCdp(
  166 |     |         uint256 _debt,
  167 |     |         bytes32 _upperHint,
  168 |     |         bytes32 _lowerHint,
  169 |     |         uint256 _stEthBalance
  170 |     |     ) external override nonReentrantSelfAndCdpM returns (bytes32) {
  171 |     |         return _openCdp(_debt, _upperHint, _lowerHint, _stEthBalance, msg.sender);
  172 |     |     }
  173 |     | 
  174 |     |     /// @notice Function that creates a Cdp for the specified _borrower by caller with the requested debt, and the stETH received as collateral.
  175 |     |     /// @dev Caller will need approval from _borrower via IPositionManagers if they are different address
  176 |     |     /// @notice Successful execution is conditional mainly on the resulting collateralization ratio which must exceed minimum requirement, e.g., MCR.
  177 |     |     /// @notice Upon Cdp open, a separate gas stipend (denominated in stETH) will be allocated for possible liquidation.
  178 |     |     /// @param _debt The expected debt for this new Cdp
  179 |     |     /// @param _upperHint The expected CdpId of neighboring higher ICR within SortedCdps, could be simply bytes32(0)
  180 |     |     /// @param _lowerHint The expected CdpId of neighboring lower ICR within SortedCdps, could be simply bytes32(0)
  181 |     |     /// @param _stEthBalance The total stETH collateral amount deposited for the specified Cdp
  182 |     |     /// @param _borrower The Cdp owner for this new Cdp.
  183 |     |     /// @return The CdpId for this newly created Cdp
  184 |     |     function openCdpFor(
  185 |     |         uint256 _debt,
  186 |     |         bytes32 _upperHint,
  187 |     |         bytes32 _lowerHint,
  188 |     |         uint256 _stEthBalance,
  189 |     |         address _borrower
  190 |     |     ) external override nonReentrantSelfAndCdpM returns (bytes32) {
  191 |     |         return _openCdp(_debt, _upperHint, _lowerHint, _stEthBalance, _borrower);
  192 |     |     }
  193 |     | 
  194 |     |     /// @notice Function that adds the received stETH to the specified Cdp.
  195 |     |     /// @dev If caller is different from Cdp owner, it will need approval from Cdp owner for this call
  196 |     |     /// @param _cdpId The CdpId on which this operation is operated
  197 |     |     /// @param _upperHint The expected CdpId of neighboring higher ICR within SortedCdps, could be simply bytes32(0)
  198 |     |     /// @param _lowerHint The expected CdpId of neighboring lower ICR within SortedCdps, could be simply bytes32(0)
  199 |     |     /// @param _stEthBalanceIncrease The total stETH collateral amount deposited (added) for the specified Cdp
  200 |     |     function addColl(
  201 |     |         bytes32 _cdpId,
  202 |     |         bytes32 _upperHint,
  203 |     |         bytes32 _lowerHint,
  204 |     |         uint256 _stEthBalanceIncrease
  205 |     |     ) external override nonReentrantSelfAndCdpM {
  206 |     |         _adjustCdpInternal(_cdpId, 0, 0, false, _upperHint, _lowerHint, _stEthBalanceIncrease);
  207 |     |     }
  208 |     | 
  209 |     |     /// @notice Function that withdraws `_stEthBalanceDecrease` amount of collateral from the specified Cdp
  210 |     |     /// @dev If caller is different from Cdp owner, it will need approval from Cdp owner for this call
  211 |     |     /// @notice Successful execution is conditional on whether the withdrawal would bring down the ICR or TCR to the minimum requirement, e.g., MCR or CCR
  212 |     |     /// @param _cdpId The CdpId on which this operation is operated
  213 |     |     /// @param _stEthBalanceDecrease The total stETH collateral amount withdrawn (reduced) for the specified Cdp
  214 |     |     /// @param _upperHint The expected CdpId of neighboring higher ICR within SortedCdps, could be simply bytes32(0)
  215 |     |     /// @param _lowerHint The expected CdpId of neighboring lower ICR within SortedCdps, could be simply bytes32(0)
  216 |     |     function withdrawColl(
  217 |     |         bytes32 _cdpId,
  218 |     |         uint256 _stEthBalanceDecrease,
  219 |     |         bytes32 _upperHint,
  220 |     |         bytes32 _lowerHint
  221 |     |     ) external override nonReentrantSelfAndCdpM {
  222 |     |         _adjustCdpInternal(_cdpId, _stEthBalanceDecrease, 0, false, _upperHint, _lowerHint, 0);
  223 |     |     }
  224 |     | 
  225 |     |     /// @notice Function that withdraws `_debt` amount of eBTC token from the specified Cdp, thus increasing its debt accounting
  226 |     |     /// @dev If caller is different from Cdp owner, it will need approval from Cdp owner for this call
  227 |     |     /// @notice Successful execution is conditional on whether the withdrawal would bring down the ICR or TCR to the minimum requirement, e.g., MCR or CCR
  228 |     |     /// @param _cdpId The CdpId on which this operation is operated
  229 |     |     /// @param _debt The total debt collateral amount increased for the specified Cdp
  230 |     |     /// @param _upperHint The expected CdpId of neighboring higher ICR within SortedCdps, could be simply bytes32(0)
  231 |     |     /// @param _lowerHint The expected CdpId of neighboring lower ICR within SortedCdps, could be simply bytes32(0)
  232 |     |     function withdrawDebt(
  233 |     |         bytes32 _cdpId,
  234 |     |         uint256 _debt,
  235 |     |         bytes32 _upperHint,
  236 |     |         bytes32 _lowerHint
  237 |     |     ) external override nonReentrantSelfAndCdpM {
  238 |     |         _adjustCdpInternal(_cdpId, 0, _debt, true, _upperHint, _lowerHint, 0);
  239 |     |     }
  240 |     | 
  241 |     |     /// @notice Function that repays the received eBTC token to the specified Cdp, thus reducing its debt accounting.
  242 |     |     /// @dev If caller is different from Cdp owner, it will need approval from Cdp owner for this call
  243 |     |     /// @param _cdpId The CdpId on which this operation is operated
  244 |     |     /// @param _upperHint The expected CdpId of neighboring higher ICR within SortedCdps, could be simply bytes32(0)
  245 |     |     /// @param _lowerHint The expected CdpId of neighboring lower ICR within SortedCdps, could be simply bytes32(0)
  246 |     |     /// @param _debt The total eBTC debt amount repaid for the specified Cdp
  247 |     |     function repayDebt(
  248 |     |         bytes32 _cdpId,
  249 |     |         uint256 _debt,
  250 |     |         bytes32 _upperHint,
  251 |     |         bytes32 _lowerHint
  252 |     |     ) external override nonReentrantSelfAndCdpM {
  253 |     |         _adjustCdpInternal(_cdpId, 0, _debt, false, _upperHint, _lowerHint, 0);
  254 |     |     }
  255 |     | 
  256 |     |     /// @notice Function that allows various operations which might change both collateral and debt
  257 |     |     /// @notice like taking more risky position (withdraws eBTC token and reduces stETH collateral)
  258 |     |     /// @notice or holding more safer position (repays eBTC token) with the specified Cdp.
  259 |     |     /// @notice If end user want to add collateral and change debt at the same time, use adjustCdpWithColl() instead
  260 |     |     /// @dev If caller is different from Cdp owner, it will need approval from Cdp owner for this call
  261 |     |     /// @param _cdpId The CdpId on which this operation is operated
  262 |     |     /// @param _stEthBalanceDecrease The total stETH collateral amount withdrawn from the specified Cdp
  263 |     |     /// @param _debtChange The total eBTC debt amount withdrawn or repaid for the specified Cdp
  264 |     |     /// @param _isDebtIncrease The flag (true or false) to indicate whether this is a eBTC token withdrawal (debt increase) or a repayment (debt reduce)
  265 |     |     /// @param _upperHint The expected CdpId of neighboring higher ICR within SortedCdps, could be simply bytes32(0)
  266 |     |     /// @param _lowerHint The expected CdpId of neighboring lower ICR within SortedCdps, could be simply bytes32(0)
  267 |     |     function adjustCdp(
  268 |     |         bytes32 _cdpId,
  269 |     |         uint256 _stEthBalanceDecrease,
  270 |     |         uint256 _debtChange,
  271 |     |         bool _isDebtIncrease,
  272 |     |         bytes32 _upperHint,
  273 |     |         bytes32 _lowerHint
  274 |     |     ) external override nonReentrantSelfAndCdpM {
  275 |     |         _adjustCdpInternal(
  276 |     |             _cdpId,
  277 |     |             _stEthBalanceDecrease,
  278 |     |             _debtChange,
  279 |     |             _isDebtIncrease,
  280 |     |             _upperHint,
  281 |     |             _lowerHint,
  282 |     |             0
  283 |     |         );
  284 |     |     }
  285 |     | 
  286 |     |     /// @notice Function that allows various operations which might change both collateral and debt
  287 |     |     /// @notice like taking more risky position (withdraws eBTC token and reduces stETH collateral)
  288 |     |     /// @notice or holding more safer position (repays eBTC token and adds stETH collateral) with the specified Cdp.
  289 |     |     /// @dev If caller is different from Cdp owner, it will need approval from Cdp owner for this call
  290 |     |     /// @param _cdpId The CdpId on which this operation is operated
  291 |     |     /// @param _stEthBalanceDecrease The total stETH collateral amount withdrawn from the specified Cdp
  292 |     |     /// @param _debtChange The total eBTC debt amount withdrawn or repaid for the specified Cdp
  293 |     |     /// @param _isDebtIncrease The flag (true or false) to indicate whether this is a eBTC token withdrawal (debt increase) or a repayment (debt reduce)
  294 |     |     /// @param _upperHint The expected CdpId of neighboring higher ICR within SortedCdps, could be simply bytes32(0)
  295 |     |     /// @param _lowerHint The expected CdpId of neighboring lower ICR within SortedCdps, could be simply bytes32(0)
  296 |     |     /// @param _stEthBalanceIncrease The total stETH collateral amount deposited (added) for the specified Cdp
  297 |     |     function adjustCdpWithColl(
  298 |     |         bytes32 _cdpId,
  299 |     |         uint256 _stEthBalanceDecrease,
  300 |     |         uint256 _debtChange,
  301 |     |         bool _isDebtIncrease,
  302 |     |         bytes32 _upperHint,
  303 |     |         bytes32 _lowerHint,
  304 |     |         uint256 _stEthBalanceIncrease
  305 |     |     ) external override nonReentrantSelfAndCdpM {
  306 |     |         _adjustCdpInternal(
  307 |     |             _cdpId,
  308 |     |             _stEthBalanceDecrease,
  309 |     |             _debtChange,
  310 |     |             _isDebtIncrease,
  311 |     |             _upperHint,
  312 |     |             _lowerHint,
  313 |     |             _stEthBalanceIncrease
  314 |     |         );
  315 |     |     }
  316 |     | 
  317 |     |     /*
  318 |     |      * _adjustCdpInternal(): Alongside a debt change, this function can perform either
  319 |     |      * a collateral top-up or a collateral withdrawal.
  320 |     |      *
  321 |     |      * It therefore expects either a positive _stEthBalanceIncrease, or a positive _stEthBalanceDecrease argument.
  322 |     |      *
  323 |     |      * If both are positive, it will revert.
  324 |     |      */
  325 |     |     function _adjustCdpInternal(
  326 |     |         bytes32 _cdpId,
  327 |     |         uint256 _stEthBalanceDecrease,
  328 |     |         uint256 _debtChange,
  329 |     |         bool _isDebtIncrease,
  330 |     |         bytes32 _upperHint,
  331 |     |         bytes32 _lowerHint,
  332 |     |         uint256 _stEthBalanceIncrease
  333 |     |     ) internal {
  334 |     |         // Confirm the operation is the borrower or approved position manager adjusting its own cdp
  335 |     |         address _borrower = sortedCdps.getOwnerAddress(_cdpId);
  336 |     |         _requireBorrowerOrPositionManagerAndUpdateManagerApproval(_borrower);
  337 |     | 
  338 |     |         _requireCdpisActive(cdpManager, _cdpId);
  339 |     | 
  340 |     |         cdpManager.syncAccounting(_cdpId);
  341 |     | 
  342 |     |         AdjustCdpLocals memory vars;
  343 |     | 
  344 |     |         vars.price = priceFeed.fetchPrice();
  345 |     | 
  346 |     |         if (_isDebtIncrease) {
  347 |     |             _requireMinDebtChange(_debtChange);
  348 |     |         } else {
  349 |     |             _requireZeroOrMinAdjustment(_debtChange);
  350 |     |         }
  351 |     | 
  352 |     |         _requireSingularCollChange(_stEthBalanceIncrease, _stEthBalanceDecrease);
  353 |     |         _requireNonZeroAdjustment(_stEthBalanceIncrease, _stEthBalanceDecrease, _debtChange);
  354 |     |         _requireZeroOrMinAdjustment(_stEthBalanceIncrease);
  355 |     |         _requireZeroOrMinAdjustment(_stEthBalanceDecrease);
  356 |     |         // min debt adjustment checked above
  357 |     | 
  358 |     |         // Get the collSharesChange based on the collateral value transferred in the transaction
  359 |     |         (vars.collSharesChange, vars.isCollIncrease) = _getCollSharesChangeFromStEthChange(
  360 |     |             _stEthBalanceIncrease,
  361 |     |             _stEthBalanceDecrease
  362 |     |         );
  363 |     | 
  364 |     |         vars.netDebtChange = _debtChange;
  365 |     | 
  366 |     |         vars.debt = cdpManager.getCdpDebt(_cdpId);
  367 |     |         vars.collShares = cdpManager.getCdpCollShares(_cdpId);
  368 |     | 
  369 |     |         // Get the cdp's old ICR before the adjustment, and what its new ICR will be after the adjustment
  370 |     |         uint256 _cdpStEthBalance = collateral.getPooledEthByShares(vars.collShares);
  371 |     |         require(
  372 |     |             _stEthBalanceDecrease <= _cdpStEthBalance,
  373 |     |             "BorrowerOperations: Cannot withdraw greater stEthBalance than the value in Cdp"
  374 |     |         );
  375 |     |         vars.oldICR = EbtcMath._computeCR(_cdpStEthBalance, vars.debt, vars.price);
  376 |     |         vars.newICR = _getNewICRFromCdpChange(
  377 |     |             vars.collShares,
  378 |     |             vars.debt,
  379 |     |             vars.collSharesChange,
  380 |     |             vars.isCollIncrease,
  381 |     |             vars.netDebtChange,
  382 |     |             _isDebtIncrease,
  383 |     |             vars.price
  384 |     |         );
  385 |     | 
  386 |     |         // Check the adjustment satisfies all conditions for the current system mode
  387 |     |         bool isRecoveryMode = _checkRecoveryModeForTCR(_getCachedTCR(vars.price));
  388 |     |         _requireValidAdjustmentInCurrentMode(
  389 |     |             isRecoveryMode,
  390 |     |             _stEthBalanceDecrease,
  391 |     |             _isDebtIncrease,
  392 |     |             vars
  393 |     |         );
  394 |     | 
  395 |     |         // When the adjustment is a debt repayment, check it's a valid amount, that the caller has enough EBTC, and that the resulting debt is >0
  396 |     |         if (!_isDebtIncrease && _debtChange > 0) {
  397 |     |             _requireValidDebtRepayment(vars.debt, vars.netDebtChange);
  398 |     |             _requireSufficientEbtcTokenBalance(msg.sender, vars.netDebtChange);
  399 |     |             _requireMinDebt(vars.debt - vars.netDebtChange);
  400 |     |         }
  401 |     | 
  402 |     |         (vars.newCollShares, vars.newDebt) = _getNewCdpAmounts(
  403 |     |             vars.collShares,
  404 |     |             vars.debt,
  405 |     |             vars.collSharesChange,
  406 |     |             vars.isCollIncrease,
  407 |     |             vars.netDebtChange,
  408 |     |             _isDebtIncrease
  409 |     |         );
  410 |     | 
  411 |     |         _requireMinDebt(vars.newDebt);
  412 |     |         _requireAtLeastMinNetStEthBalance(collateral.getPooledEthByShares(vars.newCollShares));
  413 |     | 
  414 |     |         cdpManager.updateCdp(
  415 |     |             _cdpId,
  416 |     |             _borrower,
  417 |     |             vars.collShares,
  418 |     |             vars.debt,
  419 |     |             vars.newCollShares,
  420 |     |             vars.newDebt
  421 |     |         );
  422 |     | 
  423 |     |         // Re-insert cdp in to the sorted list
  424 |     |         {
  425 |     |             uint256 newNICR = _getNewNominalICRFromCdpChange(vars, _isDebtIncrease);
  426 |     |             sortedCdps.reInsert(_cdpId, newNICR, _upperHint, _lowerHint);
  427 |     |         }
  428 |     | 
  429 |     |         // CEI: Process token movements
  430 |     |         {
  431 |     |             MoveTokensParams memory _varMvTokens = MoveTokensParams(
  432 |     |                 msg.sender,
  433 |     |                 vars.collSharesChange,
  434 |     |                 (vars.isCollIncrease ? _stEthBalanceIncrease : 0),
  435 |     |                 vars.isCollIncrease,
  436 |     |                 _debtChange,
  437 |     |                 _isDebtIncrease
  438 |     |             );
  439 |     |             _processTokenMovesFromAdjustment(_varMvTokens);
  440 |     |         }
  441 |     |     }
  442 |     | 
  443 |     |     function _openCdp(
  444 |     |         uint256 _debt,
  445 |     |         bytes32 _upperHint,
  446 |     |         bytes32 _lowerHint,
  447 |     |         uint256 _stEthBalance,
  448 |     |         address _borrower
  449 |     |     ) internal returns (bytes32) {
  450 |     |         _requireMinDebt(_debt);
  451 |     |         _requireBorrowerOrPositionManagerAndUpdateManagerApproval(_borrower);
  452 |     | 
  453 |     |         OpenCdpLocals memory vars;
  454 |     | 
  455 |     |         // ICR is based on the net stEth balance, i.e. the specified stEth balance amount - fixed liquidator incentive gas comp.
  456 |     |         vars.netStEthBalance = _calcNetStEthBalance(_stEthBalance);
  457 |     | 
  458 |     |         _requireAtLeastMinNetStEthBalance(vars.netStEthBalance);
  459 |     | 
  460 |     |         // Update global pending index before any operations
  461 |     |         cdpManager.syncGlobalAccounting();
  462 |     | 
  463 |     |         vars.price = priceFeed.fetchPrice();
  464 |     |         vars.debt = _debt;
  465 |     | 
  466 |     |         // Sanity check
  467 |     |         require(vars.netStEthBalance > 0, "BorrowerOperations: zero collateral for openCdp()!");
  468 |     | 
  469 |     |         uint256 _netCollAsShares = collateral.getSharesByPooledEth(vars.netStEthBalance);
  470 |     |         uint256 _liquidatorRewardShares = collateral.getSharesByPooledEth(LIQUIDATOR_REWARD);
  471 |     | 
  472 |     |         // ICR is based on the net coll, i.e. the requested coll amount - fixed liquidator incentive gas comp.
  473 |     |         vars.ICR = EbtcMath._computeCR(vars.netStEthBalance, vars.debt, vars.price);
  474 |     | 
  475 |     |         // NICR uses shares to normalize NICR across Cdps opened at different pooled ETH / shares ratios
  476 |     |         vars.NICR = EbtcMath._computeNominalCR(_netCollAsShares, vars.debt);
  477 |     | 
  478 |     |         /**
  479 |     |             In recovery move, ICR must be greater than CCR
  480 |     |             CCR > MCR (125% vs 110%)
  481 |     | 
  482 |     |             In normal mode, ICR must be greater thatn MCR
  483 |     |             Additionally, the new system TCR after the Cdps addition must be >CCR
  484 |     |         */
  485 |     |         bool isRecoveryMode = _checkRecoveryModeForTCR(_getCachedTCR(vars.price));
  486 |     |         uint256 newTCR = _getNewTCRFromCdpChange(
  487 |     |             vars.netStEthBalance,
  488 |     |             true,
  489 |     |             vars.debt,
  490 |     |             true,
  491 |     |             vars.price
  492 |     |         );
  493 |     |         if (isRecoveryMode) {
  494 |     |             _requireICRisNotBelowCCR(vars.ICR);
  495 |     | 
  496 |     |             // == Grace Period == //
  497 |     |             // We are in RM, Edge case is Depositing Coll could exit RM
  498 |     |             // We check with newTCR
  499 |     |             if (newTCR < CCR) {
  500 |     |                 // Notify RM
  501 |     |                 cdpManager.notifyStartGracePeriod(newTCR);
  502 |     |             } else {
  503 |     |                 // Notify Back to Normal Mode
  504 |     |                 cdpManager.notifyEndGracePeriod(newTCR);
  505 |     |             }
  506 |     |         } else {
  507 |     |             _requireICRisNotBelowMCR(vars.ICR);
  508 |     |             _requireNewTCRisNotBelowCCR(newTCR);
  509 |     | 
  510 |     |             // == Grace Period == //
  511 |     |             // We are not in RM, no edge case, we always stay above RM
  512 |     |             // Always Notify Back to Normal Mode
  513 |     |             cdpManager.notifyEndGracePeriod(newTCR);
  514 |     |         }
  515 |     | 
  516 |     |         // Set the cdp struct's properties
  517 |     |         bytes32 _cdpId = sortedCdps.insert(_borrower, vars.NICR, _upperHint, _lowerHint);
  518 |     | 
  519 |     |         // Collision check: collisions should never occur
  520 |     |         // Explicitly prevent it by checking for `nonExistent`
  521 |     |         _requireCdpIsNonExistent(_cdpId);
  522 |     | 
  523 |     |         // Collateral is stored in shares form for normalization
  524 |     |         cdpManager.initializeCdp(
  525 |     |             _cdpId,
  526 |     |             vars.debt,
  527 |     |             _netCollAsShares,
  528 |     |             _liquidatorRewardShares,
  529 |     |             _borrower
  530 |     |         );
  531 |     | 
  532 |     |         // CEI: Mint the full debt amount, in eBTC tokens, to the caller
  533 |     |         _withdrawDebt(msg.sender, _debt);
  534 |     | 
  535 |     |         /**
  536 |     |             Note that only NET stEth balance (as shares) is considered part of the Cdp.
  537 |     |             The static liqudiation incentive is stored in the gas pool and can be considered a deposit / voucher to be returned upon Cdp close, to the closer.
  538 |     |             The close can happen from the borrower closing their own Cdp, a full liquidation, or a redemption.
  539 |     |         */
  540 |     | 
  541 |     |         // CEI: Move the collateral and liquidator gas compensation to the Active Pool. Track only net collateral for TCR purposes.
  542 |     |         _activePoolAddColl(_stEthBalance, _netCollAsShares);
  543 |     | 
  544 |     |         // Invariant check
  545 |     |         require(
  546 |     |             vars.netStEthBalance + LIQUIDATOR_REWARD == _stEthBalance,
  547 |     |             "BorrowerOperations: deposited collateral mismatch!"
  548 |     |         );
  549 |     | 
  550 |     |         return _cdpId;
  551 |     |     }
  552 |     | 
  553 |     |     /// @notice Function that allows the caller to repay all debt, withdraw collateral, and close the specified Cdp
  554 |     |     /// @notice Caller should have enough eBTC token to repay off the debt fully for specified Cdp
  555 |     |     /// @dev If caller is different from Cdp owner, it will need approval from Cdp owner for this call
  556 |     |     /// @param _cdpId The CdpId on which this operation is operated
  557 |     |     function closeCdp(bytes32 _cdpId) external override {
  558 |     |         address _borrower = sortedCdps.getOwnerAddress(_cdpId);
  559 |     |         _requireBorrowerOrPositionManagerAndUpdateManagerApproval(_borrower);
  560 |     | 
  561 |     |         _requireCdpisActive(cdpManager, _cdpId);
  562 |     | 
  563 |     |         cdpManager.syncAccounting(_cdpId);
  564 |     | 
  565 |     |         uint256 price = priceFeed.fetchPrice();
  566 |     |         _requireNotInRecoveryMode(_getCachedTCR(price));
  567 |     | 
  568 |     |         uint256 collShares = cdpManager.getCdpCollShares(_cdpId);
  569 |     |         uint256 debt = cdpManager.getCdpDebt(_cdpId);
  570 |     |         uint256 liquidatorRewardShares = cdpManager.getCdpLiquidatorRewardShares(_cdpId);
  571 |     | 
  572 |     |         _requireSufficientEbtcTokenBalance(msg.sender, debt);
  573 |     | 
  574 |     |         uint256 newTCR = _getNewTCRFromCdpChange(
  575 |     |             collateral.getPooledEthByShares(collShares),
  576 |     |             false,
  577 |     |             debt,
  578 |     |             false,
  579 |     |             price
  580 |     |         );
  581 |     |         _requireNewTCRisNotBelowCCR(newTCR);
  582 |     | 
  583 |     |         // == Grace Period == //
  584 |     |         // By definition we are not in RM, notify CDPManager to ensure "Glass is on"
  585 |     |         cdpManager.notifyEndGracePeriod(newTCR);
  586 |     | 
  587 |     |         cdpManager.closeCdp(_cdpId, _borrower, debt, collShares);
  588 |     | 
  589 |     |         // Burn the repaid EBTC from the user's balance
  590 |     |         _repayDebt(msg.sender, debt);
  591 |     | 
  592 |     |         // CEI: Send the collateral and liquidator reward shares back to the user
  593 |     |         activePool.transferSystemCollSharesAndLiquidatorReward(
  594 |     |             msg.sender,
  595 |     |             collShares,
  596 |     |             liquidatorRewardShares
  597 |     |         );
  598 |     |     }
  599 |     | 
  600 |     |     /// @notice Claim remaining collateral from a redemption or from a liquidation with ICR > MCR in Recovery Mode
  601 |     |     /// @notice when a Cdp has been fully redeemed from and closed, or liquidated in Recovery Mode with a collateralization ratio higher enough (like over MCR)
  602 |     |     /// @notice the borrower is allowed to claim their stETH collateral surplus that remains in the system if any
  603 |     |     function claimSurplusCollShares() external override {
  604 |     |         // send ETH from CollSurplus Pool to owner
  605 |     |         collSurplusPool.claimSurplusCollShares(msg.sender);
  606 |     |     }
  607 |     | 
  608 |     |     /// @notice Returns true if the borrower is allowing position manager to act on their behalf
  609 |     |     /// @return PositionManagerApproval (None/OneTime/Persistent) status for given _borrower and _positionManager
  610 |     |     /// @param _borrower The Cdp owner who use eBTC
  611 |     |     /// @param _positionManager The position manager address in question whether it gets valid approval from _borrower
  612 |     |     function getPositionManagerApproval(
  613 |     |         address _borrower,
  614 |     |         address _positionManager
  615 |     |     ) external view override returns (PositionManagerApproval) {
  616 |     |         return _getPositionManagerApproval(_borrower, _positionManager);
  617 |     |     }
  618 |     | 
  619 |     |     function _getPositionManagerApproval(
  620 |     |         address _borrower,
  621 |     |         address _positionManager
  622 |     |     ) internal view returns (PositionManagerApproval) {
  623 |     |         return positionManagers[_borrower][_positionManager];
  624 |     |     }
  625 |     | 
  626 |     |     /// @notice Approve an account (_positionManager) to take arbitrary actions on your Cdps.
  627 |     |     /// @notice Position managers with 'Persistent' status will be able to take actions indefinitely
  628 |     |     /// @notice Position managers with 'OneTIme' status will be able to take a single action on one Cdp. Approval will be automatically revoked after one Cdp-related action.
  629 |     |     /// @notice Similar to approving tokens, approving a position manager allows _stealing of all positions_ if given to a malicious account.
  630 |     |     /// @param _positionManager The position manager address which will get the specified approval from caller
  631 |     |     /// @param _approval PositionManagerApproval (None/OneTime/Persistent) status set to the specified _positionManager for caller's Cdp
  632 |     |     function setPositionManagerApproval(
  633 |     |         address _positionManager,
  634 |     |         PositionManagerApproval _approval
  635 |     |     ) external override {
  636 |     |         _setPositionManagerApproval(msg.sender, _positionManager, _approval);
  637 |     |     }
  638 |     | 
  639 |     |     function _setPositionManagerApproval(
  640 |     |         address _borrower,
  641 |     |         address _positionManager,
  642 |     |         PositionManagerApproval _approval
  643 |     |     ) internal {
  644 |     |         positionManagers[_borrower][_positionManager] = _approval;
  645 |     |         emit PositionManagerApprovalSet(_borrower, _positionManager, _approval);
  646 |     |     }
  647 |     | 
  648 |     |     /// @notice Revoke a position manager from taking further actions on your Cdps
  649 |     |     /// @notice Similar to approving tokens, approving a position manager allows _stealing of all positions_ if given to a malicious account.
  650 |     |     /// @param _positionManager The position manager address which will get all approval revoked by caller (a Cdp owner)
  651 |     |     function revokePositionManagerApproval(address _positionManager) external override {
  652 |     |         _setPositionManagerApproval(msg.sender, _positionManager, PositionManagerApproval.None);
  653 |     |     }
  654 |     | 
  655 |     |     /// @notice Allows recipient of delegation to renounce it
  656 |     |     /// @param _borrower The Cdp owner address which will have all approval to the caller (a PositionManager) revoked.
  657 |     |     function renouncePositionManagerApproval(address _borrower) external override {
  658 |     |         _setPositionManagerApproval(_borrower, msg.sender, PositionManagerApproval.None);
  659 |     |     }
  660 |     | 
  661 |     |     /// @notice This function returns the domain separator for current chain
  662 |     |     /// @return EIP712 compatible Domain definition
  663 |     |     function DOMAIN_SEPARATOR() external view returns (bytes32) {
  664 |     |         return domainSeparator();
  665 |     |     }
  666 |     | 
  667 |     |     /// @notice This function returns the domain separator for current chain
  668 |     |     /// @return EIP712 compatible Domain definition
  669 |     |     function domainSeparator() public view override returns (bytes32) {
  670 |     |         if (_chainID() == _CACHED_CHAIN_ID) {
  671 |     |             return _CACHED_DOMAIN_SEPARATOR;
  672 |     |         } else {
  673 |     |             return _buildDomainSeparator(_TYPE_HASH, _HASHED_NAME, _HASHED_VERSION);
  674 |     |         }
  675 |     |     }
  676 |     | 
  677 |     |     function _chainID() private view returns (uint256) {
  678 |     |         return block.chainid;
  679 |     |     }
  680 |     | 
  681 |     |     function _buildDomainSeparator(
  682 |     |         bytes32 typeHash,
  683 |     |         bytes32 name,
  684 |     |         bytes32 version
  685 |     |     ) private view returns (bytes32) {
  686 |     |         return keccak256(abi.encode(typeHash, name, version, _chainID(), address(this)));
  687 |     |     }
  688 |     | 
  689 |     |     /// @notice This function returns the version parameter for the EIP712 domain
  690 |     |     /// @return EIP712 compatible version parameter
  691 |     |     function version() external pure override returns (string memory) {
  692 |     |         return _VERSION;
  693 |     |     }
  694 |     | 
  695 |     |     /// @notice This function returns hash of the fully encoded EIP712 message for the permitPositionManagerApproval.
  696 |     |     /// @return EIP712 compatible hash of Positon Manager permit
  697 |     |     function permitTypeHash() external pure override returns (bytes32) {
  698 |     |         return _PERMIT_POSITION_MANAGER_TYPEHASH;
  699 |     |     }
  700 |     | 
  701 |     |     /// @notice This function set given _approval for specified _borrower and _positionManager
  702 |     |     /// @notice by verifying the validity of given deadline and signature parameters (v, r, s).
  703 |     |     /// @param _borrower The Cdp owner
  704 |     |     /// @param _positionManager The delegate to which _borrower want to grant approval
  705 |     |     /// @param _approval The PositionManagerApproval (None/OneTime/Persistent) status to be set
  706 |     |     /// @param _deadline The permit valid deadline
  707 |     |     /// @param v The v part of signature from _borrower
  708 |     |     /// @param r The r part of signature from _borrower
  709 |     |     /// @param s The s part of signature from _borrower
  710 |     |     function permitPositionManagerApproval(
  711 |     |         address _borrower,
  712 |     |         address _positionManager,
  713 |     |         PositionManagerApproval _approval,
  714 |     |         uint256 _deadline,
  715 |     |         uint8 v,
  716 |     |         bytes32 r,
  717 |     |         bytes32 s
  718 |     |     ) external override {
  719 |     |         require(_deadline >= block.timestamp, "BorrowerOperations: Position manager permit expired");
  720 |     | 
  721 |     |         bytes32 digest = keccak256(
  722 |     |             abi.encodePacked(
  723 |     |                 "\x19\x01",
  724 |     |                 domainSeparator(),
  725 |     |                 keccak256(
  726 |     |                     abi.encode(
  727 |     |                         _PERMIT_POSITION_MANAGER_TYPEHASH,
  728 |     |                         _borrower,
  729 |     |                         _positionManager,
  730 |     |                         _approval,
  731 |     |                         _nonces[_borrower]++,
  732 |     |                         _deadline
  733 |     |                     )
  734 |     |                 )
  735 |     |             )
  736 |     |         );
  737 |     |         address recoveredAddress = ecrecover(digest, v, r, s);
  738 |     |         require(
  739 |     |             recoveredAddress != address(0) && recoveredAddress == _borrower,
  740 |     |             "BorrowerOperations: Invalid signature"
  741 |     |         );
  742 |     | 
  743 |     |         _setPositionManagerApproval(_borrower, _positionManager, _approval);
  744 |     |     }
  745 |     | 
  746 |     |     // --- Helper functions ---
  747 |     | 
  748 |     |     function _getCollSharesChangeFromStEthChange(
  749 |     |         uint256 _collReceived,
  750 |     |         uint256 _requestedCollWithdrawal
  751 |     |     ) internal view returns (uint256 collSharesChange, bool isCollIncrease) {
  752 |     |         if (_collReceived != 0) {
  753 |     |             collSharesChange = collateral.getSharesByPooledEth(_collReceived);
  754 |     |             isCollIncrease = true;
  755 |     |         } else {
  756 |     |             collSharesChange = collateral.getSharesByPooledEth(_requestedCollWithdrawal);
  757 |     |         }
  758 |     |     }
  759 |     | 
  760 |     |     /**
  761 |     |         @notice Process the token movements required by a Cdp adjustment.
  762 |     |         @notice Handles the cases of a debt increase / decrease, and/or a collateral increase / decrease.
  763 |     |      */
  764 |     |     function _processTokenMovesFromAdjustment(MoveTokensParams memory _varMvTokens) internal {
  765 |     |         // Debt increase: mint change value of new eBTC to user, increment ActivePool eBTC internal accounting
  766 |     |         if (_varMvTokens.isDebtIncrease) {
  767 |     |             _withdrawDebt(_varMvTokens.user, _varMvTokens.netDebtChange);
  768 |     |         } else {
  769 |     |             // Debt decrease: burn change value of eBTC from user, decrement ActivePool eBTC internal accounting
  770 |     |             _repayDebt(_varMvTokens.user, _varMvTokens.netDebtChange);
  771 |     |         }
  772 |     | 
  773 |     |         if (_varMvTokens.isCollIncrease) {
  774 |     |             // Coll increase: send change value of stETH to Active Pool, increment ActivePool stETH internal accounting
  775 |     |             _activePoolAddColl(_varMvTokens.collAddUnderlying, _varMvTokens.collSharesChange);
  776 |     |         } else {
  777 |     |             // Coll decrease: send change value of stETH to user, decrement ActivePool stETH internal accounting
  778 |     |             activePool.transferSystemCollShares(_varMvTokens.user, _varMvTokens.collSharesChange);
  779 |     |         }
  780 |     |     }
  781 |     | 
  782 |     |     /// @notice Send stETH to Active Pool and increase its recorded ETH balance
  783 |     |     /// @param _stEthBalance total balance of stETH to send, inclusive of coll and liquidatorRewardShares
  784 |     |     /// @param _sharesToTrack coll as shares (exclsuive of liquidator reward shares)
  785 |     |     /// @dev Liquidator reward shares are not considered as part of the system for CR purposes.
  786 |     |     /// @dev These number of liquidator shares associated with each Cdp are stored in the Cdp, while the actual tokens float in the active pool
  787 |     |     function _activePoolAddColl(uint256 _stEthBalance, uint256 _sharesToTrack) internal {
  788 |     |         // NOTE: No need for safe transfer if the collateral asset is standard. Make sure this is the case!
  789 |     |         collateral.transferFrom(msg.sender, address(activePool), _stEthBalance);
  790 |     |         activePool.increaseSystemCollShares(_sharesToTrack);
  791 |     |     }
  792 |     | 
  793 |     |     /// @dev Mint specified debt tokens to account and change global debt accounting accordingly
  794 |     |     function _withdrawDebt(address _account, uint256 _debt) internal {
  795 |     |         activePool.increaseSystemDebt(_debt);
  796 |     |         ebtcToken.mint(_account, _debt);
  797 |     |     }
  798 |     | 
  799 |     |     // Burn the specified amount of EBTC from _account and decreases the total active debt
  800 |     |     function _repayDebt(address _account, uint256 _debt) internal {
  801 |     |         activePool.decreaseSystemDebt(_debt);
  802 |     |         ebtcToken.burn(_account, _debt);
  803 |     |     }
  804 |     | 
  805 |     |     // --- 'Require' wrapper functions ---
  806 |     | 
  807 |     |     function _requireSingularCollChange(
  808 |     |         uint256 _stEthBalanceIncrease,
  809 |     |         uint256 _stEthBalanceDecrease
  810 |     |     ) internal pure {
  811 |     |         require(
  812 |     |             _stEthBalanceIncrease == 0 || _stEthBalanceDecrease == 0,
  813 |     |             "BorrowerOperations: Cannot add and withdraw collateral in same operation"
  814 |     |         );
  815 |     |     }
  816 |     | 
  817 |     |     function _requireNonZeroAdjustment(
  818 |     |         uint256 _stEthBalanceIncrease,
  819 |     |         uint256 _debtChange,
  820 |     |         uint256 _stEthBalanceDecrease
  821 |     |     ) internal pure {
  822 |     |         require(
  823 |     |             _stEthBalanceIncrease > 0 || _stEthBalanceDecrease > 0 || _debtChange > 0,
  824 |     |             "BorrowerOperations: There must be either a collateral or debt change"
  825 |     |         );
  826 |     |     }
  827 |     | 
  828 |     |     function _requireZeroOrMinAdjustment(uint256 _change) internal pure {
  829 |     |         require(
  830 |     |             _change == 0 || _change >= MIN_CHANGE,
  831 |     |             "BorrowerOperations: Collateral or debt change must be zero or above min"
  832 |     |         );
  833 |     |     }
  834 |     | 
  835 |     |     function _requireCdpisActive(ICdpManager _cdpManager, bytes32 _cdpId) internal view {
  836 |     |         uint256 status = _cdpManager.getCdpStatus(_cdpId);
  837 |     |         require(status == 1, "BorrowerOperations: Cdp does not exist or is closed");
  838 |     |     }
  839 |     | 
  840 |     |     function _requireCdpIsNonExistent(bytes32 _cdpId) internal view {
  841 |     |         uint status = cdpManager.getCdpStatus(_cdpId);
  842 |     |         require(status == 0, "BorrowerOperations: Cdp is active or has been previously closed");
  843 |     |     }
  844 |     | 
  845 |     |     function _requireMinDebtChange(uint _debtChange) internal pure {
  846 |     |         require(
  847 |     |             _debtChange >= MIN_CHANGE,
  848 |     |             "BorrowerOperations: Debt increase requires min debtChange"
  849 |     |         );
  850 |     |     }
  851 |     | 
  852 |     |     function _requireNotInRecoveryMode(uint256 _tcr) internal view {
  853 |     |         require(
  854 |     |             !_checkRecoveryModeForTCR(_tcr),
  855 |     |             "BorrowerOperations: Operation not permitted during Recovery Mode"
  856 |     |         );
  857 |     |     }
  858 |     | 
  859 |     |     function _requireNoStEthBalanceDecrease(uint256 _stEthBalanceDecrease) internal pure {
  860 |     |         require(
  861 |     |             _stEthBalanceDecrease == 0,
  862 |     |             "BorrowerOperations: Collateral withdrawal not permitted during Recovery Mode"
  863 |     |         );
  864 |     |     }
  865 |     | 
  866 |     |     function _requireValidAdjustmentInCurrentMode(
  867 |     |         bool _isRecoveryMode,
  868 |     |         uint256 _stEthBalanceDecrease,
  869 |     |         bool _isDebtIncrease,
  870 |     |         AdjustCdpLocals memory _vars
  871 |     |     ) internal {
  872 |     |         /*
  873 |     |          *In Recovery Mode, only allow:
  874 |     |          *
  875 |     |          * - Pure collateral top-up
  876 |     |          * - Pure debt repayment
  877 |     |          * - Collateral top-up with debt repayment
  878 |     |          * - A debt increase combined with a collateral top-up which makes the
  879 |     |          * ICR >= 150% and improves the ICR (and by extension improves the TCR).
  880 |     |          *
  881 |     |          * In Normal Mode, ensure:
  882 |     |          *
  883 |     |          * - The new ICR is above MCR
  884 |     |          * - The adjustment won't pull the TCR below CCR
  885 |     |          */
  886 |     | 
  887 |     |         _vars.newTCR = _getNewTCRFromCdpChange(
  888 |     |             collateral.getPooledEthByShares(_vars.collSharesChange),
  889 |     |             _vars.isCollIncrease,
  890 |     |             _vars.netDebtChange,
  891 |     |             _isDebtIncrease,
  892 |     |             _vars.price
  893 |     |         );
  894 |     | 
  895 |     |         if (_isRecoveryMode) {
  896 |     |             _requireNoStEthBalanceDecrease(_stEthBalanceDecrease);
  897 |     |             if (_isDebtIncrease) {
  898 |     |                 _requireICRisNotBelowCCR(_vars.newICR);
  899 |     |                 _requireNoDecreaseOfICR(_vars.newICR, _vars.oldICR);
  900 |     |             }
  901 |     | 
  902 |     |             // == Grace Period == //
  903 |     |             // We are in RM, Edge case is Depositing Coll could exit RM
  904 |     |             // We check with newTCR
  905 |     |             if (_vars.newTCR < CCR) {
  906 |     |                 // Notify RM
  907 |     |                 cdpManager.notifyStartGracePeriod(_vars.newTCR);
  908 |     |             } else {
  909 |     |                 // Notify Back to Normal Mode
  910 |     |                 cdpManager.notifyEndGracePeriod(_vars.newTCR);
  911 |     |             }
  912 |     |         } else {
  913 |     |             // if Normal Mode
  914 |     |             _requireICRisNotBelowMCR(_vars.newICR);
  915 |     |             _requireNewTCRisNotBelowCCR(_vars.newTCR);
  916 |     | 
  917 |     |             // == Grace Period == //
  918 |     |             // We are not in RM, no edge case, we always stay above RM
  919 |     |             // Always Notify Back to Normal Mode
  920 |     |             cdpManager.notifyEndGracePeriod(_vars.newTCR);
  921 |     |         }
  922 |     |     }
  923 |     | 
  924 |     |     function _requireICRisNotBelowMCR(uint256 _newICR) internal pure {
  925 |     |         require(
  926 |     |             _newICR >= MCR,
  927 |     |             "BorrowerOperations: An operation that would result in ICR < MCR is not permitted"
  928 |     |         );
  929 |     |     }
  930 |     | 
  931 |     |     function _requireICRisNotBelowCCR(uint256 _newICR) internal pure {
  932 |     |         require(_newICR >= CCR, "BorrowerOperations: Operation must leave cdp with ICR >= CCR");
  933 |     |     }
  934 |     | 
  935 |     |     function _requireNoDecreaseOfICR(uint256 _newICR, uint256 _oldICR) internal pure {
  936 |     |         require(
  937 |     |             _newICR >= _oldICR,
  938 |     |             "BorrowerOperations: Cannot decrease your Cdp's ICR in Recovery Mode"
  939 |     |         );
  940 |     |     }
  941 |     | 
  942 |     |     function _requireNewTCRisNotBelowCCR(uint256 _newTCR) internal pure {
  943 |     |         require(
  944 |     |             _newTCR >= CCR,
  945 |     |             "BorrowerOperations: An operation that would result in TCR < CCR is not permitted"
  946 |     |         );
  947 |     |     }
  948 |     | 
  949 |     |     function _requireMinDebt(uint256 _debt) internal pure {
  950 |     |         require(_debt >= MIN_CHANGE, "BorrowerOperations: Debt must be above min");
  951 |     |     }
  952 |     | 
  953 |     |     function _requireAtLeastMinNetStEthBalance(uint256 _stEthBalance) internal pure {
  954 |     |         require(
  955 |     |             _stEthBalance >= MIN_NET_STETH_BALANCE,
  956 |     |             "BorrowerOperations: Cdp's net stEth balance must not fall below minimum"
  957 |     |         );
  958 |     |     }
  959 |     | 
  960 |     |     function _requireValidDebtRepayment(uint256 _currentDebt, uint256 _debtRepayment) internal pure {
  961 |     |         require(
  962 |     |             _debtRepayment <= _currentDebt,
  963 |     |             "BorrowerOperations: Amount repaid must not be larger than the Cdp's debt"
  964 |     |         );
  965 |     |     }
  966 |     | 
  967 |     |     function _requireSufficientEbtcTokenBalance(
  968 |     |         address _account,
  969 |     |         uint256 _debtRepayment
  970 |     |     ) internal view {
  971 |     |         require(
  972 |     |             ebtcToken.balanceOf(_account) >= _debtRepayment,
  973 |     |             "BorrowerOperations: Caller doesnt have enough eBTC to make repayment"
  974 |     |         );
  975 |     |     }
  976 |     | 
  977 |     |     function _requireBorrowerOrPositionManagerAndUpdateManagerApproval(address _borrower) internal {
  978 |     |         if (_borrower == msg.sender) {
  979 |     |             return; // Early return, no delegation
  980 |     |         }
  981 |     | 
  982 |     |         PositionManagerApproval _approval = _getPositionManagerApproval(_borrower, msg.sender);
  983 |     |         // Must be an approved position manager at this point
  984 |     |         require(
  985 |     |             _approval != PositionManagerApproval.None,
  986 |     |             "BorrowerOperations: Only borrower account or approved position manager can OpenCdp on borrower's behalf"
  987 |     |         );
  988 |     | 
  989 |     |         // Conditional Adjustment
  990 |     |         /// @dev If this is a position manager operation with a one-time approval, clear that approval
  991 |     |         /// @dev If the PositionManagerApproval was none, we should have failed with the check in _requireBorrowerOrPositionManagerAndUpdateManagerApproval
  992 |     |         if (_approval == PositionManagerApproval.OneTime) {
  993 |     |             _setPositionManagerApproval(_borrower, msg.sender, PositionManagerApproval.None);
  994 |     |         }
  995 |     |     }
  996 |     | 
  997 |     |     // --- ICR and TCR getters ---
  998 |     | 
  999 |     |     // Compute the new collateral ratio, considering the change in coll and debt. Assumes 0 pending rewards.
 1000 |     |     function _getNewNominalICRFromCdpChange(
 1001 |     |         AdjustCdpLocals memory vars,
 1002 |     |         bool _isDebtIncrease
 1003 |     |     ) internal pure returns (uint256) {
 1004 |     |         (uint256 newCollShares, uint256 newDebt) = _getNewCdpAmounts(
 1005 |     |             vars.collShares,
 1006 |     |             vars.debt,
 1007 |     |             vars.collSharesChange,
 1008 |     |             vars.isCollIncrease,
 1009 |     |             vars.netDebtChange,
 1010 |     |             _isDebtIncrease
 1011 |     |         );
 1012 |     | 
 1013 |     |         uint256 newNICR = EbtcMath._computeNominalCR(newCollShares, newDebt);
 1014 |     |         return newNICR;
 1015 |     |     }
 1016 |     | 
 1017 |     |     // Compute the new collateral ratio, considering the change in coll and debt. Assumes 0 pending rewards.
 1018 |     |     function _getNewICRFromCdpChange(
 1019 |     |         uint256 _collShares,
 1020 |     |         uint256 _debt,
 1021 |     |         uint256 _collSharesChange,
 1022 |     |         bool _isCollIncrease,
 1023 |     |         uint256 _debtChange,
 1024 |     |         bool _isDebtIncrease,
 1025 |     |         uint256 _price
 1026 |     |     ) internal view returns (uint256) {
 1027 |     |         (uint256 newCollShares, uint256 newDebt) = _getNewCdpAmounts(
 1028 |     |             _collShares,
 1029 |     |             _debt,
 1030 |     |             _collSharesChange,
 1031 |     |             _isCollIncrease,
 1032 |     |             _debtChange,
 1033 |     |             _isDebtIncrease
 1034 |     |         );
 1035 |     | 
 1036 |     |         uint256 newICR = EbtcMath._computeCR(
 1037 |     |             collateral.getPooledEthByShares(newCollShares),
 1038 |     |             newDebt,
 1039 |     |             _price
 1040 |     |         );
 1041 |     |         return newICR;
 1042 |     |     }
 1043 |     | 
 1044 |     |     function _getNewCdpAmounts(
 1045 |     |         uint256 _collShares,
 1046 |     |         uint256 _debt,
 1047 |     |         uint256 _collSharesChange,
 1048 |     |         bool _isCollIncrease,
 1049 |     |         uint256 _debtChange,
 1050 |     |         bool _isDebtIncrease
 1051 |     |     ) internal pure returns (uint256, uint256) {
 1052 |     |         uint256 newCollShares = _collShares;
 1053 |     |         uint256 newDebt = _debt;
 1054 |     | 
 1055 |     |         newCollShares = _isCollIncrease
 1056 |     |             ? _collShares + _collSharesChange
 1057 |     |             : _collShares - _collSharesChange;
 1058 |     |         newDebt = _isDebtIncrease ? _debt + _debtChange : _debt - _debtChange;
 1059 |     | 
 1060 |     |         return (newCollShares, newDebt);
 1061 |     |     }
 1062 |     | 
 1063 |     |     function _getNewTCRFromCdpChange(
 1064 |     |         uint256 _stEthBalanceChange,
 1065 |     |         bool _isCollIncrease,
 1066 |     |         uint256 _debtChange,
 1067 |     |         bool _isDebtIncrease,
 1068 |     |         uint256 _price
 1069 |     |     ) internal view returns (uint256) {
 1070 |     |         uint256 _systemCollShares = getSystemCollShares();
 1071 |     |         uint256 systemStEthBalance = collateral.getPooledEthByShares(_systemCollShares);
 1072 |     |         uint256 systemDebt = _getSystemDebt();
 1073 |     | 
 1074 |     |         systemStEthBalance = _isCollIncrease
 1075 |     |             ? systemStEthBalance + _stEthBalanceChange
 1076 |     |             : systemStEthBalance - _stEthBalanceChange;
 1077 |     |         systemDebt = _isDebtIncrease ? systemDebt + _debtChange : systemDebt - _debtChange;
 1078 |     | 
 1079 |     |         uint256 newTCR = EbtcMath._computeCR(systemStEthBalance, systemDebt, _price);
 1080 |     |         return newTCR;
 1081 |     |     }
 1082 |     | 
 1083 |     |     // === Flash Loans === //
 1084 |     | 
 1085 |     |     /// @notice Borrow assets with a flash loan
 1086 |     |     /// @param receiver The address to receive the flash loan
 1087 |     |     /// @param token The address of the token to loan
 1088 |     |     /// @param amount The amount of tokens to loan
 1089 |     |     /// @param data Additional data
 1090 |     |     /// @return A boolean value indicating whether the operation was successful
 1091 |     |     function flashLoan(
 1092 |     |         IERC3156FlashBorrower receiver,
 1093 |     |         address token,
 1094 |     |         uint256 amount,
 1095 |     |         bytes calldata data
 1096 |     |     ) external override returns (bool) {
 1097 |     |         require(amount > 0, "BorrowerOperations: 0 Amount");
 1098 |     |         uint256 fee = flashFee(token, amount); // NOTE: Check for `eBTCToken` is implicit here // NOTE: Pause check is here
 1099 |     |         require(amount <= maxFlashLoan(token), "BorrowerOperations: Too much");
 1100 |     | 
 1101 |     |         // Issue EBTC
 1102 |     |         ebtcToken.mint(address(receiver), amount);
 1103 |     | 
 1104 |     |         // Callback
 1105 |     |         require(
 1106 |     |             receiver.onFlashLoan(msg.sender, token, amount, fee, data) == FLASH_SUCCESS_VALUE,
 1107 |     |             "IERC3156: Callback failed"
 1108 |     |         );
 1109 |     | 
 1110 |     |         // Gas: Repay from user balance, so we don't trigger a new SSTORE
 1111 |     |         // Safe to use transferFrom and unchecked as it's a standard token
 1112 |     |         // Also saves gas
 1113 |     |         // Send both fee and amount to FEE_RECIPIENT, to burn allowance per EIP-3156
 1114 |     |         ebtcToken.transferFrom(address(receiver), feeRecipientAddress, fee + amount);
 1115 |     | 
 1116 |     |         // Burn amount, from FEE_RECIPIENT
 1117 |     |         ebtcToken.burn(feeRecipientAddress, amount);
 1118 |     | 
 1119 |     |         emit FlashLoanSuccess(address(receiver), token, amount, fee);
 1120 |     | 
 1121 |     |         return true;
 1122 |     |     }
 1123 |     | 
 1124 |     |     /// @notice Calculate the flash loan fee for a given token and amount loaned
 1125 |     |     /// @param token The address of the token to calculate the fee for
 1126 |     |     /// @param amount The amount of tokens to calculate the fee for
 1127 |     |     /// @return The flashloan fee calcualted for given token and loan amount
 1128 |     |     function flashFee(address token, uint256 amount) public view override returns (uint256) {
 1129 |     |         require(token == address(ebtcToken), "BorrowerOperations: EBTC Only");
 1130 |     |         require(!flashLoansPaused, "BorrowerOperations: Flash Loans Paused");
 1131 |     | 
 1132 |     |         return (amount * feeBps) / MAX_BPS;
 1133 |     |     }
 1134 |     | 
 1135 |     |     /// @notice Get the maximum flash loan amount for a specific token
 1136 |     |     /// @param token The address of the token to get the maximum flash loan amount for, exclusively used here for eBTC token
 1137 |     |     /// @return The maximum available flashloan amount for the token, equals to `type(uint112).max`
 1138 |     |     function maxFlashLoan(address token) public view override returns (uint256) {
 1139 |     |         if (token != address(ebtcToken)) {
 1140 |     |             return 0;
 1141 |     |         }
 1142 |     | 
 1143 |     |         if (flashLoansPaused) {
 1144 |     |             return 0;
 1145 |     |         }
 1146 |     | 
 1147 |     |         return type(uint112).max;
 1148 |     |     }
 1149 |     | 
 1150 |     |     // === Governed Functions ==
 1151 |     | 
 1152 |     |     /// @notice Sets new Fee for FlashLoans
 1153 |     |     /// @param _newFee The new flashloan fee to be set
 1154 |     |     function setFeeBps(uint256 _newFee) external requiresAuth {
 1155 |     |         require(_newFee <= MAX_FEE_BPS, "ERC3156FlashLender: _newFee should <= MAX_FEE_BPS");
 1156 |     | 
 1157 |     |         cdpManager.syncGlobalAccounting();
 1158 |     | 
 1159 |     |         // set new flash fee
 1160 |     |         uint256 _oldFee = feeBps;
 1161 |     |         feeBps = uint16(_newFee);
 1162 |     |         emit FlashFeeSet(msg.sender, _oldFee, _newFee);
 1163 |     |     }
 1164 |     | 
 1165 |     |     /// @notice Should Flashloans be paused?
 1166 |     |     /// @param _paused The flag (true or false) whether flashloan will be paused
 1167 |     |     function setFlashLoansPaused(bool _paused) external requiresAuth {
 1168 |     |         cdpManager.syncGlobalAccounting();
 1169 |     | 
 1170 |     |         flashLoansPaused = _paused;
 1171 |     |         emit FlashLoansPaused(msg.sender, _paused);
 1172 |     |     }
 1173 |     | }
 1174 |     | 

/mnt/c/Users/Lourens/Documents/Recon-Fuzz/collabs/ebtc/packages/contracts/contracts/CdpManager.sol
    1 |     | // SPDX-License-Identifier: MIT
    2 |     | 
    3 |     | pragma solidity 0.8.17;
    4 |     | 
    5 |     | import "./Interfaces/ICdpManager.sol";
    6 |     | import "./Interfaces/ICollSurplusPool.sol";
    7 |     | import "./Interfaces/IEBTCToken.sol";
    8 |     | import "./Interfaces/ISortedCdps.sol";
    9 |     | import "./Dependencies/ICollateralTokenOracle.sol";
   10 |     | import "./CdpManagerStorage.sol";
   11 |     | import "./Dependencies/Proxy.sol";
   12 |     | import "./Dependencies/EbtcBase.sol";
   13 |     | import "./Dependencies/EbtcMath.sol";
   14 |     | 
   15 |     | /// @title CdpManager is mainly in charge of all Cdp related core processing like collateral & debt accounting, split fee calculation, redemption, etc
   16 |     | /// @notice Except for redemption, end user typically will interact with BorrowerOeprations for individual Cdp actions
   17 |     | /// @dev CdpManager also handles liquidation through delegatecall to LiquidationLibrary
   18 |     | contract CdpManager is CdpManagerStorage, ICdpManager, Proxy {
   19 |     |     // --- Dependency setter ---
   20 |     | 
   21 |     |     /// @notice Constructor for CdpManager contract.
   22 |     |     /// @dev Sets up dependencies and initial staking reward split.
   23 |     |     /// @param _liquidationLibraryAddress Address of the liquidation library.
   24 |     |     /// @param _authorityAddress Address of the authority.
   25 |     |     /// @param _borrowerOperationsAddress Address of BorrowerOperations.
   26 |     |     /// @param _collSurplusPoolAddress Address of CollSurplusPool.
   27 |     |     /// @param _ebtcTokenAddress Address of the eBTC token.
   28 |     |     /// @param _sortedCdpsAddress Address of the SortedCDPs.
   29 |     |     /// @param _activePoolAddress Address of the ActivePool.
   30 |     |     /// @param _priceFeedAddress Address of the price feed.
   31 |     |     /// @param _collTokenAddress Address of the collateral token.
   32 |     |     constructor(
   33 |     |         address _liquidationLibraryAddress,
   34 |     |         address _authorityAddress,
   35 |     |         address _borrowerOperationsAddress,
   36 |     |         address _collSurplusPoolAddress,
   37 |     |         address _ebtcTokenAddress,
   38 |     |         address _sortedCdpsAddress,
   39 |     |         address _activePoolAddress,
   40 |     |         address _priceFeedAddress,
   41 |     |         address _collTokenAddress
   42 |     |     )
   43 |     |         CdpManagerStorage(
   44 |     |             _liquidationLibraryAddress,
   45 |     |             _authorityAddress,
   46 |     |             _borrowerOperationsAddress,
   47 |     |             _collSurplusPoolAddress,
   48 |     |             _ebtcTokenAddress,
   49 |     |             _sortedCdpsAddress,
   50 |     |             _activePoolAddress,
   51 |     |             _priceFeedAddress,
   52 |     |             _collTokenAddress
   53 |     |         )
   54 |     |     {
   55 |     |         stakingRewardSplit = STAKING_REWARD_SPLIT;
   56 |     |         // Emit initial value for analytics
   57 |     |         emit StakingRewardSplitSet(stakingRewardSplit);
   58 |     | 
   59 |     |         (uint256 _oldIndex, uint256 _newIndex) = _readStEthIndex();
   60 |     |         _syncStEthIndex(_oldIndex, _newIndex);
   61 |     |         systemStEthFeePerUnitIndex = DECIMAL_PRECISION;
   62 |     |     }
   63 |     | 
   64 |     |     // --- Cdp Liquidation functions ---
   65 |     |     // -----------------------------------------------------------------
   66 |     |     //    Cdp ICR     |       Liquidation Behavior (TODO gas compensation?)
   67 |     |     //
   68 |     |     //  < MCR         |  debt could be fully repaid by liquidator
   69 |     |     //                |  and ALL collateral transferred to liquidator
   70 |     |     //                |  OR debt could be partially repaid by liquidator and
   71 |     |     //                |  liquidator could get collateral of (repaidDebt * max(LICR, min(ICR, MCR)) / price)
   72 |     |     //
   73 |     |     //  > MCR & < TCR |  only liquidatable in Recovery Mode (TCR < CCR)
   74 |     |     //                |  debt could be fully repaid by liquidator
   75 |     |     //                |  and up to (repaid debt * MCR) worth of collateral
   76 |     |     //                |  transferred to liquidator while the residue of collateral
   77 |     |     //                |  will be available in CollSurplusPool for owner to claim
   78 |     |     //                |  OR debt could be partially repaid by liquidator and
   79 |     |     //                |  liquidator could get collateral of (repaidDebt * max(LICR, min(ICR, MCR)) / price)
   80 |     |     // -----------------------------------------------------------------
   81 |     | 
   82 |     |     /// @notice Fully liquidate a single Cdp by ID. Cdp must meet the criteria for liquidation at the time of execution.
   83 |     |     /// @notice callable by anyone, attempts to liquidate the CdpId. Executes successfully if Cdp meets the conditions for liquidation (e.g. in Normal Mode, it liquidates if the Cdp's ICR < the system MCR).
   84 |     |     /// @dev forwards msg.data directly to the liquidation library using OZ proxy core delegation function
   85 |     |     /// @param _cdpId ID of the Cdp to liquidate.
   86 |     |     function liquidate(bytes32 _cdpId) external override {
   87 |     |         _delegate(liquidationLibrary);
   88 |     |     }
   89 |     | 
   90 |     |     /// @notice Partially liquidate a single Cdp.
   91 |     |     /// @dev forwards msg.data directly to the liquidation library using OZ proxy core delegation function
   92 |     |     /// @param _cdpId ID of the Cdp to partially liquidate.
   93 |     |     /// @param _partialAmount Amount to partially liquidate.
   94 |     |     /// @param _upperPartialHint Upper hint for reinsertion of the Cdp into the linked list.
   95 |     |     /// @param _lowerPartialHint Lower hint for reinsertion of the Cdp into the linked list.
   96 |     |     function partiallyLiquidate(
   97 |     |         bytes32 _cdpId,
   98 |     |         uint256 _partialAmount,
   99 |     |         bytes32 _upperPartialHint,
  100 |     |         bytes32 _lowerPartialHint
  101 |     |     ) external override {
  102 |     |         _requireAmountGreaterThanMin(_partialAmount);
  103 |     |         _delegate(liquidationLibrary);
  104 |     |     }
  105 |     | 
  106 |     |     // --- Batch/Sequence liquidation functions ---
  107 |     | 
  108 |     |     /// @notice Attempt to liquidate a custom list of Cdps provided by the caller
  109 |     |     /// @notice Callable by anyone, accepts a custom list of Cdps addresses as an argument.
  110 |     |     /// @notice Steps through the provided list and attempts to liquidate every Cdp, until it reaches the end or it runs out of gas.
  111 |     |     /// @notice A Cdp is liquidated only if it meets the conditions for liquidation.
  112 |     |     /// @dev forwards msg.data directly to the liquidation library using OZ proxy core delegation function
  113 |     |     /// @param _cdpArray Array of Cdps to liquidate.
  114 |     |     function batchLiquidateCdps(bytes32[] memory _cdpArray) external override {
  115 |     |         _delegate(liquidationLibrary);
  116 |     |     }
  117 |     | 
  118 |     |     // --- Redemption functions ---
  119 |     | 
  120 |     |     /// @notice // Redeem as much collateral as possible from given Cdp in exchange for EBTC up to specified maximum
  121 |     |     /// @param _redeemColFromCdp Struct containing variables for redeeming collateral.
  122 |     |     /// @return singleRedemption Struct containing redemption values.
  123 |     |     function _redeemCollateralFromCdp(
  124 |     |         SingleRedemptionInputs memory _redeemColFromCdp
  125 |     |     ) internal returns (SingleRedemptionValues memory singleRedemption) {
  126 |     |         // Determine the remaining amount (lot) to be redeemed,
  127 |     |         // capped by the entire debt of the Cdp minus the liquidation reserve
  128 |     |         singleRedemption.debtToRedeem = EbtcMath._min(
  129 |     |             _redeemColFromCdp.maxEBTCamount,
  130 |     |             Cdps[_redeemColFromCdp.cdpId].debt /// @audit Redeem everything
  131 |     |         );
  132 |     | 
  133 |     |         singleRedemption.collSharesDrawn = collateral.getSharesByPooledEth(
  134 |     |             (singleRedemption.debtToRedeem * DECIMAL_PRECISION) / _redeemColFromCdp.price
  135 |     |         );
  136 |     | 
  137 |     |         // Repurposing this struct here to avoid stack too deep.
  138 |     |         CdpDebtAndCollShares memory _oldDebtAndColl = CdpDebtAndCollShares(
  139 |     |             Cdps[_redeemColFromCdp.cdpId].debt,
  140 |     |             Cdps[_redeemColFromCdp.cdpId].coll
  141 |     |         );
  142 |     | 
  143 |     |         // Decrease the debt and collateral of the current Cdp according to the EBTC lot and corresponding ETH to send
  144 |     |         uint256 newDebt = _oldDebtAndColl.debt - singleRedemption.debtToRedeem;
  145 |     |         uint256 newColl = _oldDebtAndColl.collShares - singleRedemption.collSharesDrawn;
  146 |     | 
  147 |     |         if (newDebt == 0) {
  148 |     |             // No debt remains, close Cdp
  149 |     |             // No debt left in the Cdp, therefore the cdp gets closed
  150 |     |             {
  151 |     |                 address _borrower = sortedCdps.getOwnerAddress(_redeemColFromCdp.cdpId);
  152 |     |                 uint256 _liquidatorRewardShares = uint256(
  153 |     |                     Cdps[_redeemColFromCdp.cdpId].liquidatorRewardShares
  154 |     |                 );
  155 |     | 
  156 |     |                 singleRedemption.collSurplus = newColl; // Collateral surplus processed on full redemption
  157 |     |                 singleRedemption.liquidatorRewardShares = _liquidatorRewardShares;
  158 |     |                 singleRedemption.fullRedemption = true;
  159 |     | 
  160 |     |                 _closeCdpByRedemption(
  161 |     |                     _redeemColFromCdp.cdpId,
  162 |     |                     0,
  163 |     |                     newColl,
  164 |     |                     _liquidatorRewardShares,
  165 |     |                     _borrower
  166 |     |                 );
  167 |     | 
  168 |     |                 emit CdpUpdated(
  169 |     |                     _redeemColFromCdp.cdpId,
  170 |     |                     _borrower,
  171 |     |                     msg.sender,
  172 |     |                     _oldDebtAndColl.debt,
  173 |     |                     _oldDebtAndColl.collShares,
  174 |     |                     0,
  175 |     |                     0,
  176 |     |                     0,
  177 |     |                     CdpOperation.redeemCollateral
  178 |     |                 );
  179 |     |             }
  180 |     |         } else {
  181 |     |             // Debt remains, reinsert Cdp
  182 |     |             uint256 newNICR = EbtcMath._computeNominalCR(newColl, newDebt);
  183 |     | 
  184 |     |             /*
  185 |     |              * If the provided hint is out of date, we bail since trying to reinsert without a good hint will almost
  186 |     |              * certainly result in running out of gas.
  187 |     |              *
  188 |     |              * If the resultant net coll of the partial is less than the minimum, we bail.
  189 |     |              */
  190 |     |             if (
  191 |     |                 newNICR != _redeemColFromCdp.partialRedemptionHintNICR ||
  192 |     |                 collateral.getPooledEthByShares(newColl) < MIN_NET_STETH_BALANCE ||
  193 |     |                 newDebt < MIN_CHANGE
  194 |     |             ) {
  195 |     |                 _updateStakeAndTotalStakes(_redeemColFromCdp.cdpId);
  196 |     | 
  197 |     |                 emit CdpUpdated(
  198 |     |                     _redeemColFromCdp.cdpId,
  199 |     |                     ISortedCdps(sortedCdps).getOwnerAddress(_redeemColFromCdp.cdpId),
  200 |     |                     msg.sender,
  201 |     |                     _oldDebtAndColl.debt,
  202 |     |                     _oldDebtAndColl.collShares,
  203 |     |                     _oldDebtAndColl.debt,
  204 |     |                     _oldDebtAndColl.collShares,
  205 |     |                     Cdps[_redeemColFromCdp.cdpId].stake,
  206 |     |                     CdpOperation.failedPartialRedemption
  207 |     |                 );
  208 |     | 
  209 |     |                 singleRedemption.cancelledPartial = true;
  210 |     |                 return singleRedemption;
  211 |     |             }
  212 |     | 
  213 |     |             singleRedemption.newPartialNICR = newNICR;
  214 |     | 
  215 |     |             Cdps[_redeemColFromCdp.cdpId].debt = newDebt;
  216 |     |             Cdps[_redeemColFromCdp.cdpId].coll = newColl;
  217 |     |             _updateStakeAndTotalStakes(_redeemColFromCdp.cdpId);
  218 |     | 
  219 |     |             emit CdpUpdated(
  220 |     |                 _redeemColFromCdp.cdpId,
  221 |     |                 ISortedCdps(sortedCdps).getOwnerAddress(_redeemColFromCdp.cdpId),
  222 |     |                 msg.sender,
  223 |     |                 _oldDebtAndColl.debt,
  224 |     |                 _oldDebtAndColl.collShares,
  225 |     |                 newDebt,
  226 |     |                 newColl,
  227 |     |                 Cdps[_redeemColFromCdp.cdpId].stake,
  228 |     |                 CdpOperation.redeemCollateral
  229 |     |             );
  230 |     |         }
  231 |     | 
  232 |     |         return singleRedemption;
  233 |     |     }
  234 |     | 
  235 |     |     /*
  236 |     |      * Called when a full redemption occurs, and closes the cdp.
  237 |     |      * The redeemer swaps (debt) EBTC for (debt)
  238 |     |      * worth of stETH, so the stETH liquidation reserve is all that remains.
  239 |     |      * In order to close the cdp, the stETH liquidation reserve is returned to the Cdp owner,
  240 |     |      * The debt recorded on the cdp's struct is zero'd elswhere, in _closeCdp.
  241 |     |      * Any surplus stETH left in the cdp, is sent to the Coll surplus pool, and can be later claimed by the borrower.
  242 |     |      */
  243 |     |     function _closeCdpByRedemption(
  244 |     |         bytes32 _cdpId,
  245 |     |         uint256 _EBTC,
  246 |     |         uint256 _collSurplus,
  247 |     |         uint256 _liquidatorRewardShares,
  248 |     |         address _borrower
  249 |     |     ) internal {
  250 |     |         _closeCdpWithoutRemovingSortedCdps(_cdpId, Status.closedByRedemption);
  251 |     | 
  252 |     |         // Update Active Pool EBTC, and send ETH to account
  253 |     |         activePool.decreaseSystemDebt(_EBTC);
  254 |     | 
  255 |     |         // Register stETH surplus from upcoming transfers of stETH collateral and liquidator reward shares
  256 |     |         collSurplusPool.increaseSurplusCollShares(
  257 |     |             _cdpId,
  258 |     |             _borrower,
  259 |     |             _collSurplus,
  260 |     |             _liquidatorRewardShares
  261 |     |         );
  262 |     | 
  263 |     |         // CEI: send stETH coll and liquidator reward shares from Active Pool to CollSurplus Pool
  264 |     |         activePool.transferSystemCollSharesAndLiquidatorReward(
  265 |     |             address(collSurplusPool),
  266 |     |             _collSurplus,
  267 |     |             _liquidatorRewardShares
  268 |     |         );
  269 |     |     }
  270 |     | 
  271 |     |     /// @notice Returns true if the CdpId specified is the lowest-ICR Cdp in the linked list that still has MCR > ICR
  272 |     |     /// @dev Returns false if the specified CdpId hint is blank
  273 |     |     /// @dev Returns false if the specified CdpId hint doesn't exist in the list
  274 |     |     /// @dev Returns false if the ICR of the specified CdpId is < MCR
  275 |     |     /// @dev Returns true if the specified CdpId is not blank, exists in the list, has an ICR > MCR, and the next lower Cdp in the list is either blank or has an ICR < MCR.
  276 |     |     function _isValidFirstRedemptionHint(
  277 |     |         bytes32 _firstRedemptionHint,
  278 |     |         uint256 _price
  279 |     |     ) internal view returns (bool) {
  280 |     |         if (
  281 |     |             _firstRedemptionHint == sortedCdps.nonExistId() ||
  282 |     |             !sortedCdps.contains(_firstRedemptionHint) ||
  283 |     |             getSyncedICR(_firstRedemptionHint, _price) < MCR
  284 |     |         ) {
  285 |     |             return false;
  286 |     |         }
  287 |     | 
  288 |     |         bytes32 nextCdp = sortedCdps.getNext(_firstRedemptionHint);
  289 |     |         return nextCdp == sortedCdps.nonExistId() || getSyncedICR(nextCdp, _price) < MCR;
  290 |     |     }
  291 |     | 
  292 |     |     /// @notice Send _debt EBTC to the system and redeem the corresponding amount of collateral
  293 |     |     /// @notice from as many Cdps as are needed to fill the redemption request.
  294 |     |     /// @notice
  295 |     |     /// @notice Note that if _debt is very large, this function can run out of gas, specially if traversed cdps are small (meaning many small Cdps are redeemed against).
  296 |     |     /// @notice This can be easily avoided by splitting the total _debt in appropriate chunks and calling the function multiple times.
  297 |     |     /// @notice
  298 |     |     /// @notice There is a optional parameter `_maxIterations` which can also be provided, so the loop through Cdps is capped (if it’s zero, it will be ignored).
  299 |     |     /// @notice This makes it easier to avoid OOG for the frontend, as only knowing approximately the average cost of an iteration is enough,
  300 |     |     /// @notice without needing to know the "topology" of the cdp list. It also avoids the need to set the cap in stone in the contract,
  301 |     |     /// @notice nor doing gas calculations, as both gas price and opcode costs can vary.
  302 |     |     /// @notice
  303 |     |     /// @notice All Cdps that are redeemed from -- with the likely exception of the last one -- will end up with no debt left,
  304 |     |     /// @notice therefore they will be closed.
  305 |     |     /// @notice If the last Cdp does have some remaining debt & collateral (it has a valid meaningful ICR) then reinsertion of the CDP
  306 |     |     /// @notice could be anywhere in the entire SortedCdps list, therefore this redemption requires a hint.
  307 |     |     /// @notice
  308 |     |     /// @notice A frontend should use HintHelper.getRedemptionHints() to calculate what the ICR of this Cdp will be after redemption,
  309 |     |     /// @notice and pass a hint for its position in the SortedCdps list along with the ICR value that the hint was found for.
  310 |     |     /// @notice
  311 |     |     /// @notice If another transaction modifies the list between calling getRedemptionHints()
  312 |     |     /// @notice and passing the hints to redeemCollateral(), it is very likely that the last (partially)
  313 |     |     /// @notice redeemed Cdp would end up with a different ICR than what the hint is for.
  314 |     |     /// @notice
  315 |     |     /// @notice In this case, the redemption will stop after the last completely redeemed Cdp and the sender will keep the
  316 |     |     /// @notice remaining EBTC amount, which they can attempt to redeem later.
  317 |     |     /// @param _debt The total eBTC debt amount to be redeemed
  318 |     |     /// @param _firstRedemptionHint The first CdpId to be considered for redemption, could get from HintHelper.getRedemptionHints()
  319 |     |     /// @param _upperPartialRedemptionHint The first CdpId to be considered for redemption, could get from HintHelper.getApproxHint(_partialRedemptionHintNICR) then SortedCdps.findInsertPosition(_partialRedemptionHintNICR)
  320 |     |     /// @param _lowerPartialRedemptionHint The first CdpId to be considered for redemption, could get from HintHelper.getApproxHint(_partialRedemptionHintNICR) then SortedCdps.findInsertPosition(_partialRedemptionHintNICR)
  321 |     |     /// @param _partialRedemptionHintNICR The new Nominal Collateral Ratio (NICR) of the last redeemed CDP after partial redemption, could get from HintHelper.getRedemptionHints()
  322 |     |     /// @param _maxIterations The maximum allowed iteration along the SortedCdps loop, if zero then there is no limit
  323 |     |     /// @param _maxFeePercentage The maximum allowed redemption fee for this redemption
  324 |     |     function redeemCollateral(
  325 |     |         uint256 _debt,
  326 |     |         bytes32 _firstRedemptionHint,
  327 |     |         bytes32 _upperPartialRedemptionHint,
  328 |     |         bytes32 _lowerPartialRedemptionHint,
  329 |     |         uint256 _partialRedemptionHintNICR,
  330 |     |         uint256 _maxIterations,
  331 |     |         uint256 _maxFeePercentage
  332 |     |     ) external override nonReentrantSelfAndBOps {
  333 |     |         RedemptionTotals memory totals;
  334 |     | 
  335 |     |         // early check to ensure redemption is not paused
  336 |     |         require(redemptionsPaused == false, "CdpManager: Redemptions Paused");
  337 |     | 
  338 |     |         _requireValidMaxFeePercentage(_maxFeePercentage);
  339 |     | 
  340 |     |         _syncGlobalAccounting(); // Apply state, we will syncGracePeriod at end of function
  341 |     | 
  342 |     |         totals.price = priceFeed.fetchPrice();
  343 |     |         {
  344 |     |             (
  345 |     |                 uint256 tcrAtStart,
  346 |     |                 uint256 systemCollSharesAtStart,
  347 |     |                 uint256 systemDebtAtStart
  348 |     |             ) = _getTCRWithSystemDebtAndCollShares(totals.price);
  349 |     |             totals.tcrAtStart = tcrAtStart;
  350 |     |             totals.systemCollSharesAtStart = systemCollSharesAtStart;
  351 |     |             totals.systemDebtAtStart = systemDebtAtStart;
  352 |     | 
  353 |     |             if (!activePool.twapDisabled()) {
  354 |     |                 try activePool.observe() returns (uint256 _twapSystemDebtAtStart) {
  355 |     |                     // @audit Return the smaller value of the two, bias towards a larger redemption scaling fee
  356 |     |                     totals.twapSystemDebtAtStart = EbtcMath._min(
  357 |     |                         _twapSystemDebtAtStart,
  358 |     |                         systemDebtAtStart
  359 |     |                     );
  360 |     |                 } catch {
  361 |     |                     totals.twapSystemDebtAtStart = systemDebtAtStart;
  362 |     |                 }
  363 |     |             } else {
  364 |     |                 totals.twapSystemDebtAtStart = systemDebtAtStart;
  365 |     |             }
  366 |     |         }
  367 |     | 
  368 |     |         _requireTCRisNotBelowMCR(totals.price, totals.tcrAtStart);
  369 |     |         _requireAmountGreaterThanMin(_debt);
  370 |     | 
  371 |     |         _requireEbtcBalanceCoversRedemptionAndWithinSupply(
  372 |     |             msg.sender,
  373 |     |             _debt,
  374 |     |             totals.systemDebtAtStart
  375 |     |         );
  376 |     | 
  377 |     |         totals.remainingDebtToRedeem = _debt;
  378 |     |         address currentBorrower;
  379 |     |         bytes32 _cId = _firstRedemptionHint;
  380 |     | 
  381 |     |         if (_isValidFirstRedemptionHint(_firstRedemptionHint, totals.price)) {
  382 |     |             currentBorrower = sortedCdps.getOwnerAddress(_firstRedemptionHint);
  383 |     |         } else {
  384 |     |             _cId = sortedCdps.getLast();
  385 |     |             currentBorrower = sortedCdps.getOwnerAddress(_cId);
  386 |     |             // Find the first cdp with ICR >= MCR
  387 |     |             while (currentBorrower != address(0) && getSyncedICR(_cId, totals.price) < MCR) {
  388 |     |                 _cId = sortedCdps.getPrev(_cId);
  389 |     |                 currentBorrower = sortedCdps.getOwnerAddress(_cId);
  390 |     |             }
  391 |     |         }
  392 |     | 
  393 |     |         // Loop through the Cdps starting from the one with lowest collateral
  394 |     |         // ratio until _amount of EBTC is exchanged for collateral
  395 |     |         if (_maxIterations == 0) {
  396 |     |             _maxIterations = type(uint256).max;
  397 |     |         }
  398 |     | 
  399 |     |         bytes32 _firstRedeemed = _cId;
  400 |     |         bytes32 _lastRedeemed = _cId;
  401 |     |         uint256 _numCdpsFullyRedeemed;
  402 |     | 
  403 |     |         /**
  404 |     |             Core Redemption Loop
  405 |     |         */
  406 |     |         uint256 _partialRedeemedNewNICR;
  407 |     |         while (
  408 |     |             currentBorrower != address(0) && totals.remainingDebtToRedeem > 0 && _maxIterations > 0
  409 |     |         ) {
  410 |     |             // Save the address of the Cdp preceding the current one, before potentially modifying the list
  411 |     |             {
  412 |     |                 _syncAccounting(_cId); /// @audit This happens even if the re-insertion doesn't
  413 |     | 
  414 |     |                 SingleRedemptionInputs memory _redeemColFromCdp = SingleRedemptionInputs(
  415 |     |                     _cId,
  416 |     |                     totals.remainingDebtToRedeem,
  417 |     |                     totals.price,
  418 |     |                     _upperPartialRedemptionHint,
  419 |     |                     _lowerPartialRedemptionHint,
  420 |     |                     _partialRedemptionHintNICR
  421 |     |                 );
  422 |     |                 SingleRedemptionValues memory singleRedemption = _redeemCollateralFromCdp(
  423 |     |                     _redeemColFromCdp
  424 |     |                 );
  425 |     |                 // Partial redemption was cancelled (out-of-date hint, or new net debt < minimum),
  426 |     |                 // therefore we could not redeem from the last Cdp
  427 |     |                 if (singleRedemption.cancelledPartial) break;
  428 |     | 
  429 |     |                 // prepare for reinsertion if there is partial redemption
  430 |     |                 if (singleRedemption.newPartialNICR > 0) {
  431 |     |                     _partialRedeemedNewNICR = singleRedemption.newPartialNICR;
  432 |     |                 }
  433 |     | 
  434 |     |                 totals.debtToRedeem = totals.debtToRedeem + singleRedemption.debtToRedeem;
  435 |     |                 totals.collSharesDrawn = totals.collSharesDrawn + singleRedemption.collSharesDrawn;
  436 |     |                 totals.remainingDebtToRedeem =
  437 |     |                     totals.remainingDebtToRedeem -
  438 |     |                     singleRedemption.debtToRedeem;
  439 |     |                 totals.totalCollSharesSurplus =
  440 |     |                     totals.totalCollSharesSurplus +
  441 |     |                     singleRedemption.collSurplus;
  442 |     | 
  443 |     |                 bytes32 _nextId = sortedCdps.getPrev(_cId);
  444 |     |                 if (singleRedemption.fullRedemption) {
  445 |     |                     _lastRedeemed = _cId;
  446 |     |                     _numCdpsFullyRedeemed = _numCdpsFullyRedeemed + 1;
  447 |     |                     _cId = _nextId;
  448 |     |                 }
  449 |     | 
  450 |     |                 address nextUserToCheck = sortedCdps.getOwnerAddress(_nextId);
  451 |     |                 currentBorrower = nextUserToCheck;
  452 |     |             }
  453 |     |             _maxIterations--;
  454 |     |         }
  455 |     |         require(totals.collSharesDrawn > 0, "CdpManager: Unable to redeem any amount");
  456 |     | 
  457 |     |         // remove from sortedCdps
  458 |     |         if (_numCdpsFullyRedeemed == 1) {
  459 |     |             sortedCdps.remove(_firstRedeemed);
  460 |     |         } else if (_numCdpsFullyRedeemed > 1) {
  461 |     |             bytes32[] memory _toRemoveIds = _getCdpIdsToRemove(
  462 |     |                 _lastRedeemed,
  463 |     |                 _numCdpsFullyRedeemed,
  464 |     |                 _firstRedeemed
  465 |     |             );
  466 |     |             sortedCdps.batchRemove(_toRemoveIds);
  467 |     |         }
  468 |     | 
  469 |     |         // reinsert partially redemeed CDP if any
  470 |     |         if (_cId != bytes32(0) && _partialRedeemedNewNICR > 0) {
  471 |     |             sortedCdps.reInsert(
  472 |     |                 _cId,
  473 |     |                 _partialRedeemedNewNICR,
  474 |     |                 _upperPartialRedemptionHint,
  475 |     |                 _lowerPartialRedemptionHint
  476 |     |             );
  477 |     |         }
  478 |     | 
  479 |     |         // Decay the baseRate due to time passed, and then increase it according to the size of this redemption.
  480 |     |         // Use the saved total EBTC supply value, from before it was reduced by the redemption.
  481 |     |         _updateBaseRateFromRedemption(
  482 |     |             totals.collSharesDrawn,
  483 |     |             totals.price,
  484 |     |             totals.twapSystemDebtAtStart
  485 |     |         );
  486 |     | 
  487 |     |         // Calculate the ETH fee
  488 |     |         totals.feeCollShares = _getRedemptionFee(totals.collSharesDrawn);
  489 |     | 
  490 |     |         _requireUserAcceptsFee(totals.feeCollShares, totals.collSharesDrawn, _maxFeePercentage);
  491 |     | 
  492 |     |         totals.collSharesToRedeemer = totals.collSharesDrawn - totals.feeCollShares;
  493 |     | 
  494 |     |         _syncGracePeriodForGivenValues(
  495 |     |             totals.systemCollSharesAtStart - totals.collSharesDrawn - totals.totalCollSharesSurplus,
  496 |     |             totals.systemDebtAtStart - totals.debtToRedeem,
  497 |     |             totals.price
  498 |     |         );
  499 |     | 
  500 |     |         emit Redemption(
  501 |     |             _debt,
  502 |     |             totals.debtToRedeem,
  503 |     |             totals.collSharesDrawn,
  504 |     |             totals.feeCollShares,
  505 |     |             msg.sender
  506 |     |         );
  507 |     | 
  508 |     |         // Burn the total eBTC that is redeemed
  509 |     |         ebtcToken.burn(msg.sender, totals.debtToRedeem);
  510 |     | 
  511 |     |         // Update Active Pool eBTC debt internal accounting
  512 |     |         activePool.decreaseSystemDebt(totals.debtToRedeem);
  513 |     | 
  514 |     |         // Allocate the stETH fee to the FeeRecipient
  515 |     |         activePool.allocateSystemCollSharesToFeeRecipient(totals.feeCollShares);
  516 |     | 
  517 |     |         // CEI: Send the stETH drawn to the redeemer
  518 |     |         activePool.transferSystemCollShares(msg.sender, totals.collSharesToRedeemer);
  519 |     | 
  520 |     |         // final check if we not in RecoveryMode at redemption start
  521 |     |         if (!_checkRecoveryModeForTCR(totals.tcrAtStart)) {
  522 |     |             require(
  523 |     |                 !_checkRecoveryMode(totals.price),
  524 |     |                 "CdpManager: redemption should not trigger RecoveryMode"
  525 |     |             );
  526 |     |         }
  527 |     |     }
  528 |     | 
  529 |     |     // --- Helper functions ---
  530 |     | 
  531 |     |     function _getCdpIdsToRemove(
  532 |     |         bytes32 _start,
  533 |     |         uint256 _total,
  534 |     |         bytes32 _end
  535 |     |     ) internal view returns (bytes32[] memory) {
  536 |     |         uint256 _cnt = _total;
  537 |     |         bytes32 _id = _start;
  538 |     |         bytes32[] memory _toRemoveIds = new bytes32[](_total);
  539 |     |         while (_cnt > 0 && _id != bytes32(0)) {
  540 |     |             _toRemoveIds[_total - _cnt] = _id;
  541 |     |             _cnt = _cnt - 1;
  542 |     |             _id = sortedCdps.getNext(_id);
  543 |     |         }
  544 |     |         require(_toRemoveIds[0] == _start, "CdpManager: batchRemoveSortedCdpIds check start error");
  545 |     |         require(
  546 |     |             _toRemoveIds[_total - 1] == _end,
  547 |     |             "CdpManager: batchRemoveSortedCdpIds check end error"
  548 |     |         );
  549 |     |         return _toRemoveIds;
  550 |     |     }
  551 |     | 
  552 |     |     /// @notice Synchorize the accounting for the specified Cdp
  553 |     |     /// @notice It will synchronize global accounting with stETH share index first
  554 |     |     /// @notice then apply split fee and debt redistribution if any
  555 |     |     /// @param _cdpId cdpId to sync pending accounting state for
  556 |     |     function syncAccounting(bytes32 _cdpId) external virtual override {
  557 |     |         /// @audit Opening can cause invalid reordering of Cdps due to changing values without reInserting into sortedCdps
  558 |     |         _requireCallerIsBorrowerOperations();
  559 |     |         return _syncAccounting(_cdpId);
  560 |     |     }
  561 |     | 
  562 |     |     /// @notice Update stake for the specified Cdp and total stake within the system.
  563 |     |     /// @dev Only BorrowerOperations is allowed to call this function
  564 |     |     /// @param _cdpId cdpId to update stake for
  565 |     |     function updateStakeAndTotalStakes(bytes32 _cdpId) external override returns (uint256) {
  566 |     |         _requireCallerIsBorrowerOperations();
  567 |     |         return _updateStakeAndTotalStakes(_cdpId);
  568 |     |     }
  569 |     | 
  570 |     |     /// @notice Close the specified Cdp by ID.
  571 |     |     /// @dev Only BorrowerOperations is allowed to call this function.
  572 |     |     /// @dev This will close the Cdp and update its status to `closedByOwner`
  573 |     |     /// @dev The collateral and debt will be zero'd out
  574 |     |     /// @dev The Cdp will be removed from the sorted list
  575 |     |     /// @dev The close will emit a `CdpUpdated` event containing closing details
  576 |     |     /// @param _cdpId ID of the Cdp to close
  577 |     |     /// @param _borrower Address of the Cdp borrower
  578 |     |     /// @param _debt The recorded Cdp debt prior to closing
  579 |     |     /// @param _coll The recorded Cdp collateral shares prior to closing
  580 |     |     function closeCdp(
  581 |     |         bytes32 _cdpId,
  582 |     |         address _borrower,
  583 |     |         uint256 _debt,
  584 |     |         uint256 _coll
  585 |     |     ) external override {
  586 |     |         _requireCallerIsBorrowerOperations();
  587 |     |         emit CdpUpdated(_cdpId, _borrower, msg.sender, _debt, _coll, 0, 0, 0, CdpOperation.closeCdp);
  588 |     |         return _closeCdp(_cdpId, Status.closedByOwner);
  589 |     |     }
  590 |     | 
  591 |     |     // --- Recovery Mode and TCR functions ---
  592 |     | 
  593 |     |     /// @notice Get the sum of debt units assigned to all Cdps within eBTC system
  594 |     |     /// @dev It is actually the `systemDebt` value of the ActivePool.
  595 |     |     /// @return entireSystemDebt entire system debt accounting value
  596 |     |     function getSystemDebt() public view returns (uint256 entireSystemDebt) {
  597 |     |         return _getSystemDebt();
  598 |     |     }
  599 |     | 
  600 |     |     /// @notice The total collateralization ratio (TCR) of the system as a cached "view" (maybe outdated)
  601 |     |     /// @dev It is based on the current recorded system debt and collateral.
  602 |     |     /// @dev Possible split fee is not considered with this function.
  603 |     |     /// @dev Please use getSyncedTCR() otherwise
  604 |     |     /// @param _price The current stETH:BTC price
  605 |     |     /// @return TCR The cached total collateralization ratio (TCR) of the system (does not take into account pending global state)
  606 |     |     function getCachedTCR(uint256 _price) external view override returns (uint256) {
  607 |     |         return _getCachedTCR(_price);
  608 |     |     }
  609 |     | 
  610 |     |     /// @notice Whether or not the system is in Recovery Mode (TCR is below the CCR)
  611 |     |     /// @dev Possible split fee is not considered with this function.
  612 |     |     /// @dev Please use getSyncedTCR() otherwise
  613 |     |     /// @param _price The current stETH:BTC price
  614 |     |     /// @return True if system is in recovery mode with cached values (TCR < CCR), false otherwise
  615 |     |     function checkRecoveryMode(uint256 _price) external view override returns (bool) {
  616 |     |         return _checkRecoveryMode(_price);
  617 |     |     }
  618 |     | 
  619 |     |     // Check whether or not the system *would be* in Recovery Mode,
  620 |     |     // given an ETH:USD price, and the entire system coll and debt.
  621 |     |     function _checkPotentialRecoveryMode(
  622 |     |         uint256 _systemCollShares,
  623 |     |         uint256 _systemDebt,
  624 |     |         uint256 _price
  625 |     |     ) internal view returns (bool) {
  626 |     |         uint256 TCR = _computeTCRWithGivenSystemValues(_systemCollShares, _systemDebt, _price);
  627 |     |         return TCR < CCR;
  628 |     |     }
  629 |     | 
  630 |     |     // --- Redemption fee functions ---
  631 |     | 
  632 |     |     /*
  633 |     |      * This function has two impacts on the baseRate state variable:
  634 |     |      * 1) decays the baseRate based on time passed since last redemption or EBTC borrowing operation.
  635 |     |      * then,
  636 |     |      * 2) increases the baseRate based on the amount redeemed, as a proportion of total supply
  637 |     |      */
  638 |     |     function _updateBaseRateFromRedemption(
  639 |     |         uint256 _ETHDrawn,
  640 |     |         uint256 _price,
  641 |     |         uint256 _totalEBTCSupply
  642 |     |     ) internal returns (uint256) {
  643 |     |         uint256 decayedBaseRate = _calcDecayedBaseRate();
  644 |     | 
  645 |     |         /* Convert the drawn ETH back to EBTC at face value rate (1 EBTC:1 USD), in order to get
  646 |     |          * the fraction of total supply that was redeemed at face value. */
  647 |     |         uint256 redeemedEBTCFraction = (collateral.getPooledEthByShares(_ETHDrawn) * _price) /
  648 |     |             _totalEBTCSupply;
  649 |     | 
  650 |     |         uint256 newBaseRate = decayedBaseRate + (redeemedEBTCFraction / beta);
  651 |     |         newBaseRate = EbtcMath._min(newBaseRate, DECIMAL_PRECISION); // cap baseRate at a maximum of 100%
  652 |     |         require(newBaseRate > 0, "CdpManager: new baseRate is zero!"); // Base rate is always non-zero after redemption
  653 |     | 
  654 |     |         // Update the baseRate state variable
  655 |     |         baseRate = newBaseRate;
  656 |     |         emit BaseRateUpdated(newBaseRate);
  657 |     | 
  658 |     |         _updateLastRedemptionTimestamp();
  659 |     | 
  660 |     |         return newBaseRate;
  661 |     |     }
  662 |     | 
  663 |     |     /// @return current fee rate for redemption with base rate
  664 |     |     function getRedemptionRate() public view override returns (uint256) {
  665 |     |         return _calcRedemptionRate(baseRate);
  666 |     |     }
  667 |     | 
  668 |     |     /// @return current fee rate for redemption with decayed base rate
  669 |     |     function getRedemptionRateWithDecay() public view override returns (uint256) {
  670 |     |         return _calcRedemptionRate(_calcDecayedBaseRate());
  671 |     |     }
  672 |     | 
  673 |     |     function _calcRedemptionRate(uint256 _baseRate) internal view returns (uint256) {
  674 |     |         return
  675 |     |             EbtcMath._min(
  676 |     |                 redemptionFeeFloor + _baseRate,
  677 |     |                 DECIMAL_PRECISION // cap at a maximum of 100%
  678 |     |             );
  679 |     |     }
  680 |     | 
  681 |     |     function _getRedemptionFee(uint256 _ETHDrawn) internal view returns (uint256) {
  682 |     |         return _calcRedemptionFee(getRedemptionRate(), _ETHDrawn);
  683 |     |     }
  684 |     | 
  685 |     |     /// @return redemption fee for the specified collateral amount
  686 |     |     /// @param _stETHToRedeem The total expected stETH amount to redeem
  687 |     |     function getRedemptionFeeWithDecay(
  688 |     |         uint256 _stETHToRedeem
  689 |     |     ) external view override returns (uint256) {
  690 |     |         return _calcRedemptionFee(getRedemptionRateWithDecay(), _stETHToRedeem);
  691 |     |     }
  692 |     | 
  693 |     |     function _calcRedemptionFee(
  694 |     |         uint256 _redemptionRate,
  695 |     |         uint256 _ETHDrawn
  696 |     |     ) internal pure returns (uint256) {
  697 |     |         uint256 redemptionFee = (_redemptionRate * _ETHDrawn) / DECIMAL_PRECISION;
  698 |     |         require(redemptionFee < _ETHDrawn, "CdpManager: Fee would eat up all returned collateral");
  699 |     |         return redemptionFee;
  700 |     |     }
  701 |     | 
  702 |     |     function _decayBaseRate() internal {
  703 |     |         uint256 decayedBaseRate = _calcDecayedBaseRate();
  704 |     |         require(decayedBaseRate <= DECIMAL_PRECISION, "CdpManager: baseRate too large!"); // The baseRate can decay to 0
  705 |     | 
  706 |     |         baseRate = decayedBaseRate;
  707 |     |         emit BaseRateUpdated(decayedBaseRate);
  708 |     | 
  709 |     |         _updateLastRedemptionTimestamp();
  710 |     |     }
  711 |     | 
  712 |     |     // --- Internal fee functions ---
  713 |     | 
  714 |     |     // Update the last fee operation time only if time passed >= decay interval. This prevents base rate griefing.
  715 |     |     function _updateLastRedemptionTimestamp() internal {
  716 |     |         uint256 timePassed = block.timestamp > lastRedemptionTimestamp
  717 |     |             ? block.timestamp - lastRedemptionTimestamp
  718 |     |             : 0;
  719 |     | 
  720 |     |         if (timePassed >= SECONDS_IN_ONE_MINUTE) {
  721 |     |             // Using the effective elapsed time that is consumed so far to update lastRedemptionTimestamp
  722 |     |             // instead block.timestamp for consistency with _calcDecayedBaseRate()
  723 |     |             lastRedemptionTimestamp += _minutesPassedSinceLastRedemption() * SECONDS_IN_ONE_MINUTE;
  724 |     |             emit LastRedemptionTimestampUpdated(block.timestamp);
  725 |     |         }
  726 |     |     }
  727 |     | 
  728 |     |     function _calcDecayedBaseRate() internal view returns (uint256) {
  729 |     |         uint256 minutesPassed = _minutesPassedSinceLastRedemption();
  730 |     |         uint256 decayFactor = EbtcMath._decPow(minuteDecayFactor, minutesPassed);
  731 |     | 
  732 |     |         return (baseRate * decayFactor) / DECIMAL_PRECISION;
  733 |     |     }
  734 |     | 
  735 |     |     function _minutesPassedSinceLastRedemption() internal view returns (uint256) {
  736 |     |         return
  737 |     |             block.timestamp > lastRedemptionTimestamp
  738 |     |                 ? ((block.timestamp - lastRedemptionTimestamp) / SECONDS_IN_ONE_MINUTE)
  739 |     |                 : 0;
  740 |     |     }
  741 |     | 
  742 |     |     /// @return timestamp when this contract is deployed
  743 |     |     function getDeploymentStartTime() public view returns (uint256) {
  744 |     |         return deploymentStartTime;
  745 |     |     }
  746 |     | 
  747 |     |     /// @notice Check whether or not the system *would be* in Recovery Mode,
  748 |     |     /// @notice given an ETH:eBTC price, and the entire system coll and debt.
  749 |     |     /// @param _systemCollShares The total collateral of the system to be used for the TCR calculation
  750 |     |     /// @param _systemDebt The total debt of the system to be used for the TCR calculation
  751 |     |     /// @param _price The ETH:eBTC price to be used for the TCR calculation
  752 |     |     /// @return flag (true or false) whether the system would be in Recovery Mode for specified status parameters
  753 |     |     function checkPotentialRecoveryMode(
  754 |     |         uint256 _systemCollShares,
  755 |     |         uint256 _systemDebt,
  756 |     |         uint256 _price
  757 |     |     ) external view returns (bool) {
  758 |     |         return _checkPotentialRecoveryMode(_systemCollShares, _systemDebt, _price);
  759 |     |     }
  760 |     | 
  761 |     |     // --- 'require' wrapper functions ---
  762 |     | 
  763 |     |     function _requireEbtcBalanceCoversRedemptionAndWithinSupply(
  764 |     |         address _redeemer,
  765 |     |         uint256 _amount,
  766 |     |         uint256 _totalSupply
  767 |     |     ) internal view {
  768 |     |         uint256 callerBalance = ebtcToken.balanceOf(_redeemer);
  769 |     |         require(
  770 |     |             callerBalance >= _amount,
  771 |     |             "CdpManager: Requested redemption amount must be <= user's EBTC token balance"
  772 |     |         );
  773 |     |         require(
  774 |     |             callerBalance <= _totalSupply,
  775 |     |             "CdpManager: redeemer's EBTC balance exceeds total supply!"
  776 |     |         );
  777 |     |     }
  778 |     | 
  779 |     |     function _requireAmountGreaterThanMin(uint256 _amount) internal pure {
  780 |     |         require(_amount >= MIN_CHANGE, "CdpManager: Amount must be greater than min");
  781 |     |     }
  782 |     | 
  783 |     |     function _requireTCRisNotBelowMCR(uint256 _price, uint256 _TCR) internal view {
  784 |     |         require(_TCR >= MCR, "CdpManager: Cannot redeem when TCR < MCR");
  785 |     |     }
  786 |     | 
  787 |     |     function _requireValidMaxFeePercentage(uint256 _maxFeePercentage) internal view {
  788 |     |         require(
  789 |     |             _maxFeePercentage >= redemptionFeeFloor && _maxFeePercentage <= DECIMAL_PRECISION,
  790 |     |             "Max fee percentage must be between redemption fee floor and 100%"
  791 |     |         );
  792 |     |     }
  793 |     | 
  794 |     |     // --- Governance Parameters ---
  795 |     | 
  796 |     |     /// @notice Set the staking reward split percentage
  797 |     |     /// @dev Only callable by authorized addresses
  798 |     |     /// @param _stakingRewardSplit New staking reward split percentage value
  799 |     |     function setStakingRewardSplit(uint256 _stakingRewardSplit) external requiresAuth {
  800 |     |         require(
  801 |     |             _stakingRewardSplit <= MAX_REWARD_SPLIT,
  802 |     |             "CDPManager: new staking reward split exceeds max"
  803 |     |         );
  804 |     | 
  805 |     |         syncGlobalAccountingAndGracePeriod();
  806 |     | 
  807 |     |         stakingRewardSplit = _stakingRewardSplit;
  808 |     |         emit StakingRewardSplitSet(_stakingRewardSplit);
  809 |     |     }
  810 |     | 
  811 |     |     /// @notice Set the minimum redemption fee floor percentage
  812 |     |     /// @dev Only callable by authorized addresses
  813 |     |     /// @param _redemptionFeeFloor New minimum redemption fee floor percentage
  814 |     |     function setRedemptionFeeFloor(uint256 _redemptionFeeFloor) external requiresAuth {
  815 |     |         require(
  816 |     |             _redemptionFeeFloor >= MIN_REDEMPTION_FEE_FLOOR,
  817 |     |             "CDPManager: new redemption fee floor is lower than minimum"
  818 |     |         );
  819 |     |         require(
  820 |     |             _redemptionFeeFloor <= DECIMAL_PRECISION,
  821 |     |             "CDPManager: new redemption fee floor is higher than maximum"
  822 |     |         );
  823 |     | 
  824 |     |         syncGlobalAccountingAndGracePeriod();
  825 |     | 
  826 |     |         redemptionFeeFloor = _redemptionFeeFloor;
  827 |     |         emit RedemptionFeeFloorSet(_redemptionFeeFloor);
  828 |     |     }
  829 |     | 
  830 |     |     /// @notice Set the minute decay factor for the redemption fee rate
  831 |     |     /// @dev Only callable by authorized addresses
  832 |     |     /// @param _minuteDecayFactor New minute decay factor value
  833 |     |     function setMinuteDecayFactor(uint256 _minuteDecayFactor) external requiresAuth {
  834 |     |         require(
  835 |     |             _minuteDecayFactor >= MIN_MINUTE_DECAY_FACTOR,
  836 |     |             "CDPManager: new minute decay factor out of range"
  837 |     |         );
  838 |     |         require(
  839 |     |             _minuteDecayFactor <= MAX_MINUTE_DECAY_FACTOR,
  840 |     |             "CDPManager: new minute decay factor out of range"
  841 |     |         );
  842 |     | 
  843 |     |         syncGlobalAccountingAndGracePeriod();
  844 |     | 
  845 |     |         // decay first according to previous factor
  846 |     |         _decayBaseRate();
  847 |     | 
  848 |     |         // set new factor after decaying
  849 |     |         minuteDecayFactor = _minuteDecayFactor;
  850 |     |         emit MinuteDecayFactorSet(_minuteDecayFactor);
  851 |     |     }
  852 |     | 
  853 |     |     /// @notice Set the beta value that controls redemption fee rate
  854 |     |     /// @dev Only callable by authorized addresses
  855 |     |     /// @param _beta New beta value
  856 |     |     function setBeta(uint256 _beta) external requiresAuth {
  857 |     |         syncGlobalAccountingAndGracePeriod();
  858 |     | 
  859 |     |         _decayBaseRate();
  860 |     | 
  861 |     |         beta = _beta;
  862 |     |         emit BetaSet(_beta);
  863 |     |     }
  864 |     | 
  865 |     |     /// @notice Pause or unpause redemptions
  866 |     |     /// @dev Only callable by authorized addresses
  867 |     |     /// @param _paused True to pause redemptions, false to unpause
  868 |     | 
  869 |     |     function setRedemptionsPaused(bool _paused) external requiresAuth {
  870 |     |         syncGlobalAccountingAndGracePeriod();
  871 |     |         _decayBaseRate();
  872 |     | 
  873 |     |         redemptionsPaused = _paused;
  874 |     |         emit RedemptionsPaused(_paused);
  875 |     |     }
  876 |     | 
  877 |     |     // --- Cdp property getters ---
  878 |     | 
  879 |     |     /// @notice Get status of a Cdp. Named enum values can be found in ICdpManagerData.Status
  880 |     |     /// @param _cdpId ID of the Cdp to get status for
  881 |     |     /// @return Status code of the Cdp
  882 |     |     function getCdpStatus(bytes32 _cdpId) external view override returns (uint256) {
  883 |     |         return uint256(Cdps[_cdpId].status);
  884 |     |     }
  885 |     | 
  886 |     |     /// @notice Get stake value of a Cdp
  887 |     |     /// @param _cdpId ID of the Cdp to get stake for
  888 |     |     /// @return Stake value of the Cdp
  889 |     |     function getCdpStake(bytes32 _cdpId) external view override returns (uint256) {
  890 |     |         return Cdps[_cdpId].stake;
  891 |     |     }
  892 |     | 
  893 |     |     /// @notice Get stored debt value of a Cdp, in eBTC units
  894 |     |     /// @notice Cached value - does not include pending changes from redistributions
  895 |     |     /// @param _cdpId ID of the Cdp to get debt for
  896 |     |     /// @return Debt value of the Cdp in eBTC
  897 |     |     function getCdpDebt(bytes32 _cdpId) external view override returns (uint256) {
  898 |     |         return Cdps[_cdpId].debt;
  899 |     |     }
  900 |     | 
  901 |     |     /// @notice Get stored collateral value of a Cdp, in stETH shares
  902 |     |     /// @notice Cached value - does not include pending changes from staking yield
  903 |     |     /// @param _cdpId ID of the Cdp to get collateral for
  904 |     |     /// @return Collateral value of the Cdp in stETH shares
  905 |     |     function getCdpCollShares(bytes32 _cdpId) external view override returns (uint256) {
  906 |     |         return Cdps[_cdpId].coll;
  907 |     |     }
  908 |     | 
  909 |     |     /// @notice Get shares value of the liquidator gas incentive reward stored for a Cdp.
  910 |     |     /// @notice The value stored is processed when a Cdp closes.
  911 |     |     /// @dev Upon closing by borrower, This value is returned directly to the borrower.
  912 |     |     /// @dev Upon closing by a position manager, This value is returned directly to the position manager.
  913 |     |     /// @dev Upon a full liquidation, This value is given to liquidators upon fully liquidating the Cdp
  914 |     |     /// @dev Upon redemption, This value is sent to the CollSurplusPool for reclaiming by the borrower.
  915 |     |     /// @param _cdpId ID of the Cdp to get liquidator reward shares for
  916 |     |     /// @return Liquidator reward shares value of the Cdp
  917 |     |     function getCdpLiquidatorRewardShares(bytes32 _cdpId) external view override returns (uint256) {
  918 |     |         return uint256(Cdps[_cdpId].liquidatorRewardShares);
  919 |     |     }
  920 |     | 
  921 |     |     // --- Cdp property setters, called by BorrowerOperations ---
  922 |     | 
  923 |     |     /// @notice Initialize all state for new Cdp
  924 |     |     /// @dev Only callable by BorrowerOperations, critical trust assumption
  925 |     |     /// @dev Requires Cdp to be already inserted into linked list correctly
  926 |     |     /// @param _cdpId ID of Cdp to initialize state for
  927 |     |     /// @param _debt Initial debt units of Cdp
  928 |     |     /// @param _coll Initial collateral shares of Cdp
  929 |     |     /// @param _liquidatorRewardShares Liquidator reward shares for Cdp liquidation gas stipend
  930 |     |     /// @param _borrower Address of the Cdp borrower
  931 |     |     function initializeCdp(
  932 |     |         bytes32 _cdpId,
  933 |     |         uint256 _debt,
  934 |     |         uint256 _coll,
  935 |     |         uint256 _liquidatorRewardShares,
  936 |     |         address _borrower
  937 |     |     ) external {
  938 |     |         _requireCallerIsBorrowerOperations();
  939 |     | 
  940 |     |         Cdps[_cdpId].debt = _debt;
  941 |     |         Cdps[_cdpId].coll = _coll;
  942 |     |         Cdps[_cdpId].status = Status.active;
  943 |     |         Cdps[_cdpId].liquidatorRewardShares = EbtcMath.toUint128(_liquidatorRewardShares);
  944 |     | 
  945 |     |         cdpStEthFeePerUnitIndex[_cdpId] = systemStEthFeePerUnitIndex; /// @audit We critically assume global accounting is synced here
  946 |     |         _updateRedistributedDebtIndex(_cdpId);
  947 |     |         uint256 stake = _updateStakeAndTotalStakes(_cdpId);
  948 |     | 
  949 |     |         // Previous debt and coll are known to be zero upon opening a new Cdp
  950 |     |         emit CdpUpdated(
  951 |     |             _cdpId,
  952 |     |             _borrower,
  953 |     |             msg.sender,
  954 |     |             0,
  955 |     |             0,
  956 |     |             _debt,
  957 |     |             _coll,
  958 |     |             stake,
  959 |     |             CdpOperation.openCdp
  960 |     |         );
  961 |     |     }
  962 |     | 
  963 |     |     /// @notice Set new Cdp debt and collateral values, updating stake accordingly
  964 |     |     /// @dev Only callable by BorrowerOperations, critical trust assumption
  965 |     |     /// @param _cdpId ID of Cdp to update state for
  966 |     |     /// @param _borrower Address of the Cdp borrower
  967 |     |     /// @param _coll Previous collateral shares of Cdp, before update
  968 |     |     /// @param _debt Previous debt units of Cdp, before update.
  969 |     |     /// @param _newColl New collateral shares of Cdp after update operation
  970 |     |     /// @param _newDebt New debt units of Cdp after update operation
  971 |     |     function updateCdp(
  972 |     |         bytes32 _cdpId,
  973 |     |         address _borrower,
  974 |     |         uint256 _coll,
  975 |     |         uint256 _debt,
  976 |     |         uint256 _newColl,
  977 |     |         uint256 _newDebt
  978 |     |     ) external {
  979 |     |         _requireCallerIsBorrowerOperations();
  980 |     | 
  981 |     |         _setCdpCollShares(_cdpId, _newColl);
  982 |     |         _setCdpDebt(_cdpId, _newDebt);
  983 |     | 
  984 |     |         uint256 stake = _updateStakeAndTotalStakes(_cdpId);
  985 |     | 
  986 |     |         emit CdpUpdated(
  987 |     |             _cdpId,
  988 |     |             _borrower,
  989 |     |             msg.sender,
  990 |     |             _debt,
  991 |     |             _coll,
  992 |     |             _newDebt,
  993 |     |             _newColl,
  994 |     |             stake,
  995 |     |             CdpOperation.adjustCdp
  996 |     |         );
  997 |     |     }
  998 |     | 
  999 |     |     /// @notice Set the collateral of a Cdp
 1000 |     |     /// @param _cdpId The ID of the Cdp
 1001 |     |     /// @param _newColl New collateral value, in stETH shares
 1002 |     |     function _setCdpCollShares(bytes32 _cdpId, uint256 _newColl) internal {
 1003 |     |         Cdps[_cdpId].coll = _newColl;
 1004 |     |     }
 1005 |     | 
 1006 |     |     /// @notice Set the debt of a Cdp
 1007 |     |     /// @param _cdpId The ID of the Cdp
 1008 |     |     /// @param _newDebt New debt units value
 1009 |     |     function _setCdpDebt(bytes32 _cdpId, uint256 _newDebt) internal {
 1010 |     |         Cdps[_cdpId].debt = _newDebt;
 1011 |     |     }
 1012 |     | }
 1013 |     | 

/mnt/c/Users/Lourens/Documents/Recon-Fuzz/collabs/ebtc/packages/contracts/contracts/CdpManagerStorage.sol
   1 |     | // SPDX-License-Identifier: MIT
   2 |     | 
   3 |     | pragma solidity 0.8.17;
   4 |     | 
   5 |     | import "./Interfaces/ICdpManager.sol";
   6 |     | import "./Interfaces/ICollSurplusPool.sol";
   7 |     | import "./Interfaces/IEBTCToken.sol";
   8 |     | import "./Interfaces/ISortedCdps.sol";
   9 |     | import "./Dependencies/EbtcBase.sol";
  10 |     | import "./Dependencies/ReentrancyGuard.sol";
  11 |     | import "./Dependencies/ICollateralTokenOracle.sol";
  12 |     | import "./Dependencies/AuthNoOwner.sol";
  13 |     | 
  14 |     | /// @title CDP Manager storage and shared functions with LiquidationLibrary
  15 |     | /// @dev All features around Cdp management are split into separate parts to get around contract size limitations.
  16 |     | /// @dev Liquidation related functions are delegated to LiquidationLibrary contract code.
  17 |     | /// @dev Both CdpManager and LiquidationLibrary must maintain **the same storage layout**, so shared storage components
  18 |     | /// @dev and shared functions are added here in CdpManagerStorage to de-dup code
  19 |     | contract CdpManagerStorage is EbtcBase, ReentrancyGuard, ICdpManagerData, AuthNoOwner {
  20 |     |     // NOTE: No packing cause it's the last var, no need for u64
  21 |     |     uint128 public constant UNSET_TIMESTAMP = type(uint128).max;
  22 |     |     uint128 public constant MINIMUM_GRACE_PERIOD = 15 minutes;
  23 |     | 
  24 |     |     uint128 public lastGracePeriodStartTimestamp = UNSET_TIMESTAMP; // use max to signify
  25 |     |     uint128 public recoveryModeGracePeriodDuration = MINIMUM_GRACE_PERIOD;
  26 |     | 
  27 |     |     /// @notice Start the recovery mode grace period, if the system is in RM and the grace period timestamp has not already been set
  28 |     |     /// @dev Trusted function to allow BorrowerOperations actions to set RM Grace Period
  29 |     |     /// @dev Assumes BorrowerOperations has correctly calculated and passed in the new system TCR
  30 |     |     /// @dev To maintain CEI compliance we use this trusted function
  31 |     |     /// @param tcr The TCR to be checked whether Grace Period should be started
  32 |     |     function notifyStartGracePeriod(uint256 tcr) external {
  33 |     |         _requireCallerIsBorrowerOperations();
  34 |     |         _startGracePeriod(tcr);
  35 |     |     }
  36 |     | 
  37 |     |     /// @notice End the recovery mode grace period, if the system is no longer in RM
  38 |     |     /// @dev Trusted function to allow BorrowerOperations actions to set RM Grace Period
  39 |     |     /// @dev Assumes BorrowerOperations has correctly calculated and passed in the new system TCR
  40 |     |     /// @dev To maintain CEI compliance we use this trusted function
  41 |     |     /// @param tcr The TCR to be checked whether Grace Period should be ended
  42 |     |     function notifyEndGracePeriod(uint256 tcr) external {
  43 |     |         _requireCallerIsBorrowerOperations();
  44 |     |         _endGracePeriod(tcr);
  45 |     |     }
  46 |     | 
  47 |     |     /// @dev Internal notify called by Redemptions and Liquidations
  48 |     |     /// @dev Specified TCR is emitted for notification pruposes regardless of whether the Grace Period timestamp is set
  49 |     |     function _startGracePeriod(uint256 _tcr) internal {
  50 |     |         emit TCRNotified(_tcr);
  51 |     | 
  52 |     |         if (lastGracePeriodStartTimestamp == UNSET_TIMESTAMP) {
  53 |     |             lastGracePeriodStartTimestamp = uint128(block.timestamp);
  54 |     | 
  55 |     |             emit GracePeriodStart();
  56 |     |         }
  57 |     |     }
  58 |     | 
  59 |     |     /// @notice Clear RM Grace Period timestamp if it has been set
  60 |     |     /// @notice No input validation, calling function must confirm that the system is not in recovery mode to be valid
  61 |     |     /// @dev Specified TCR is emitted for notification pruposes regardless of whether the Grace Period timestamp is set
  62 |     |     /// @dev Internal notify called by Redemptions and Liquidations
  63 |     |     function _endGracePeriod(uint256 _tcr) internal {
  64 |     |         emit TCRNotified(_tcr);
  65 |     | 
  66 |     |         if (lastGracePeriodStartTimestamp != UNSET_TIMESTAMP) {
  67 |     |             lastGracePeriodStartTimestamp = UNSET_TIMESTAMP;
  68 |     | 
  69 |     |             emit GracePeriodEnd();
  70 |     |         }
  71 |     |     }
  72 |     | 
  73 |     |     function _syncGracePeriod() internal {
  74 |     |         uint256 price = priceFeed.fetchPrice();
  75 |     |         uint256 tcr = _getCachedTCR(price);
  76 |     |         bool isRecoveryMode = _checkRecoveryModeForTCR(tcr);
  77 |     | 
  78 |     |         if (isRecoveryMode) {
  79 |     |             _startGracePeriod(tcr);
  80 |     |         } else {
  81 |     |             _endGracePeriod(tcr);
  82 |     |         }
  83 |     |     }
  84 |     | 
  85 |     |     /// @dev Set RM grace period based on specified system collShares, system debt, and price
  86 |     |     /// @dev Variant for internal use in redemptions and liquidations
  87 |     |     function _syncGracePeriodForGivenValues(
  88 |     |         uint256 systemCollShares,
  89 |     |         uint256 systemDebt,
  90 |     |         uint256 price
  91 |     |     ) internal {
  92 |     |         // Compute TCR with specified values
  93 |     |         uint256 newTCR = EbtcMath._computeCR(
  94 |     |             collateral.getPooledEthByShares(systemCollShares),
  95 |     |             systemDebt,
  96 |     |             price
  97 |     |         );
  98 |     | 
  99 |     |         if (newTCR < CCR) {
 100 |     |             // Notify system is in RM
 101 |     |             _startGracePeriod(newTCR);
 102 |     |         } else {
 103 |     |             // Notify system is outside RM
 104 |     |             _endGracePeriod(newTCR);
 105 |     |         }
 106 |     |     }
 107 |     | 
 108 |     |     /// @notice Set grace period duratin
 109 |     |     /// @notice Permissioned governance function, must set grace period duration above hardcoded minimum
 110 |     |     /// @param _gracePeriod new grace period duration, in seconds
 111 |     |     function setGracePeriod(uint128 _gracePeriod) external requiresAuth {
 112 |     |         require(
 113 |     |             _gracePeriod >= MINIMUM_GRACE_PERIOD,
 114 |     |             "CdpManager: Grace period below minimum duration"
 115 |     |         );
 116 |     | 
 117 |     |         syncGlobalAccountingAndGracePeriod();
 118 |     |         recoveryModeGracePeriodDuration = _gracePeriod;
 119 |     |         emit GracePeriodDurationSet(_gracePeriod);
 120 |     |     }
 121 |     | 
 122 |     |     string public constant NAME = "CdpManager";
 123 |     | 
 124 |     |     // --- Connected contract declarations ---
 125 |     | 
 126 |     |     address public immutable borrowerOperationsAddress;
 127 |     | 
 128 |     |     ICollSurplusPool immutable collSurplusPool;
 129 |     | 
 130 |     |     IEBTCToken public immutable override ebtcToken;
 131 |     | 
 132 |     |     address public immutable liquidationLibrary;
 133 |     | 
 134 |     |     // A doubly linked list of Cdps, sorted by their sorted by their collateral ratios
 135 |     |     ISortedCdps public immutable sortedCdps;
 136 |     | 
 137 |     |     // --- Data structures ---
 138 |     | 
 139 |     |     uint256 public constant SECONDS_IN_ONE_MINUTE = 60;
 140 |     | 
 141 |     |     uint256 public constant MIN_REDEMPTION_FEE_FLOOR = (DECIMAL_PRECISION * 5) / 1000; // 0.5%
 142 |     |     uint256 public redemptionFeeFloor = MIN_REDEMPTION_FEE_FLOOR;
 143 |     |     bool public redemptionsPaused;
 144 |     |     /*
 145 |     |      * Half-life of 12h. 12h = 720 min
 146 |     |      * (1/2) = d^720 => d = (1/2)^(1/720)
 147 |     |      */
 148 |     |     uint256 public minuteDecayFactor = 999037758833783000;
 149 |     |     uint256 public constant MIN_MINUTE_DECAY_FACTOR = 1; // Non-zero
 150 |     |     uint256 public constant MAX_MINUTE_DECAY_FACTOR = 999999999999999999; // Corresponds to a very fast decay rate, but not too extreme
 151 |     | 
 152 |     |     uint256 internal immutable deploymentStartTime;
 153 |     | 
 154 |     |     /*
 155 |     |      * BETA: 18 digit decimal. Parameter by which to divide the redeemed fraction,
 156 |     |      * in order to calc the new base rate from a redemption.
 157 |     |      * Corresponds to (1 / ALPHA) in the Liquity white paper.
 158 |     |      */
 159 |     |     uint256 public beta = 2;
 160 |     | 
 161 |     |     uint256 public baseRate;
 162 |     | 
 163 |     |     uint256 public stakingRewardSplit;
 164 |     | 
 165 |     |     // The timestamp of the latest fee operation (redemption or new EBTC issuance)
 166 |     |     uint256 public lastRedemptionTimestamp;
 167 |     | 
 168 |     |     mapping(bytes32 => Cdp) public Cdps;
 169 |     | 
 170 |     |     uint256 public override totalStakes;
 171 |     | 
 172 |     |     // Snapshot of the value of totalStakes, taken immediately after the latest liquidation and split fee claim
 173 |     |     uint256 public totalStakesSnapshot;
 174 |     | 
 175 |     |     // Snapshot of the total collateral across the ActivePool, immediately after the latest liquidation and split fee claim
 176 |     |     uint256 public totalCollateralSnapshot;
 177 |     | 
 178 |     |     /*
 179 |     |      * systemDebtRedistributionIndex track the sums of accumulated socialized liquidations per unit staked.
 180 |     |      * During its lifetime, each stake earns:
 181 |     |      *
 182 |     |      * A systemDebt increase  of ( stake * [systemDebtRedistributionIndex - systemDebtRedistributionIndex(0)] )
 183 |     |      *
 184 |     |      * Where systemDebtRedistributionIndex(0) are snapshots of systemDebtRedistributionIndex
 185 |     |      * for the active Cdp taken at the instant the stake was made
 186 |     |      */
 187 |     |     uint256 public systemDebtRedistributionIndex;
 188 |     | 
 189 |     |     // Map active cdps to their RewardSnapshot (eBTC debt redistributed)
 190 |     |     mapping(bytes32 => uint256) public cdpDebtRedistributionIndex;
 191 |     | 
 192 |     |     // Error trackers for the cdp redistribution calculation
 193 |     |     uint256 public lastEBTCDebtErrorRedistribution;
 194 |     | 
 195 |     |     /* Global Index for (Full Price Per Share) of underlying collateral token */
 196 |     |     uint256 public override stEthIndex;
 197 |     |     /* Global Fee accumulator (never decreasing) per stake unit in CDPManager, similar to systemDebtRedistributionIndex */
 198 |     |     uint256 public override systemStEthFeePerUnitIndex;
 199 |     |     /* Global Fee accumulator calculation error due to integer division, similar to redistribution calculation */
 200 |     |     uint256 public override systemStEthFeePerUnitIndexError;
 201 |     |     /* Individual CDP Fee accumulator tracker, used to calculate fee split distribution */
 202 |     |     mapping(bytes32 => uint256) public cdpStEthFeePerUnitIndex;
 203 |     | 
 204 |     |     /// @notice Initializes the contract with the provided addresses and sets up the required initial state
 205 |     |     /// @param _liquidationLibraryAddress The address of the Liquidation Library
 206 |     |     /// @param _authorityAddress The address of the Authority
 207 |     |     /// @param _borrowerOperationsAddress The address of Borrower Operations
 208 |     |     /// @param _collSurplusPool The address of the Collateral Surplus Pool
 209 |     |     /// @param _ebtcToken The address of the eBTC Token contract
 210 |     |     /// @param _sortedCdps The address of the Sorted CDPs contract
 211 |     |     /// @param _activePool The address of the Active Pool
 212 |     |     /// @param _priceFeed The address of the Price Feed
 213 |     |     /// @param _collateral The address of the Collateral token
 214 |     |     constructor(
 215 |     |         address _liquidationLibraryAddress,
 216 |     |         address _authorityAddress,
 217 |     |         address _borrowerOperationsAddress,
 218 |     |         address _collSurplusPool,
 219 |     |         address _ebtcToken,
 220 |     |         address _sortedCdps,
 221 |     |         address _activePool,
 222 |     |         address _priceFeed,
 223 |     |         address _collateral
 224 |     |     ) EbtcBase(_activePool, _priceFeed, _collateral) {
 225 |     |         deploymentStartTime = block.timestamp;
 226 |     |         liquidationLibrary = _liquidationLibraryAddress;
 227 |     | 
 228 |     |         _initializeAuthority(_authorityAddress);
 229 |     | 
 230 |     |         borrowerOperationsAddress = _borrowerOperationsAddress;
 231 |     |         collSurplusPool = ICollSurplusPool(_collSurplusPool);
 232 |     |         ebtcToken = IEBTCToken(_ebtcToken);
 233 |     |         sortedCdps = ISortedCdps(_sortedCdps);
 234 |     |     }
 235 |     | 
 236 |     |     /// @notice BorrowerOperations and CdpManager share reentrancy status by confirming the other's locked flag before beginning operation
 237 |     |     /// @dev This is an alternative to the more heavyweight solution of both being able to set the reentrancy flag on a 3rd contract.
 238 |     |     modifier nonReentrantSelfAndBOps() {
 239 |     |         require(locked == OPEN, "CdpManager: Reentrancy in nonReentrant call");
 240 |     |         require(
 241 |     |             ReentrancyGuard(borrowerOperationsAddress).locked() == OPEN,
 242 |     |             "BorrowerOperations: Reentrancy in nonReentrant call"
 243 |     |         );
 244 |     | 
 245 |     |         locked = LOCKED;
 246 |     | 
 247 |     |         _;
 248 |     | 
 249 |     |         locked = OPEN;
 250 |     |     }
 251 |     | 
 252 |     |     function _closeCdp(bytes32 _cdpId, Status closedStatus) internal {
 253 |     |         _closeCdpWithoutRemovingSortedCdps(_cdpId, closedStatus);
 254 |     |         sortedCdps.remove(_cdpId);
 255 |     |     }
 256 |     | 
 257 |     |     function _closeCdpWithoutRemovingSortedCdps(bytes32 _cdpId, Status closedStatus) internal {
 258 |     |         require(
 259 |     |             closedStatus != Status.nonExistent && closedStatus != Status.active,
 260 |     |             "CdpManagerStorage: close non-exist or non-active CDP!"
 261 |     |         );
 262 |     | 
 263 |     |         uint256 cdpIdsArrayLength = getActiveCdpsCount();
 264 |     |         _requireMoreThanOneCdpInSystem(cdpIdsArrayLength);
 265 |     | 
 266 |     |         _removeStake(_cdpId);
 267 |     | 
 268 |     |         Cdps[_cdpId].status = closedStatus;
 269 |     |         Cdps[_cdpId].coll = 0;
 270 |     |         Cdps[_cdpId].debt = 0;
 271 |     |         Cdps[_cdpId].liquidatorRewardShares = 0;
 272 |     | 
 273 |     |         cdpDebtRedistributionIndex[_cdpId] = 0;
 274 |     |         cdpStEthFeePerUnitIndex[_cdpId] = 0;
 275 |     |     }
 276 |     | 
 277 |     |     /*
 278 |     |      * Updates snapshots of system total stakes and total collateral,
 279 |     |      * excluding a given collateral remainder from the calculation.
 280 |     |      * Used in a liquidation sequence.
 281 |     |      *
 282 |     |      * The calculation excludes a portion of collateral that is in the ActivePool:
 283 |     |      *
 284 |     |      * the total stETH liquidator reward compensation from the liquidation sequence
 285 |     |      *
 286 |     |      * The stETH as compensation must be excluded as it is always sent out at the very end of the liquidation sequence.
 287 |     |      */
 288 |     |     function _updateSystemSnapshotsExcludeCollRemainder(uint256 _collRemainder) internal {
 289 |     |         uint256 _totalStakesSnapshot = totalStakes;
 290 |     |         totalStakesSnapshot = _totalStakesSnapshot;
 291 |     | 
 292 |     |         uint256 _totalCollateralSnapshot = activePool.getSystemCollShares() - _collRemainder;
 293 |     |         totalCollateralSnapshot = _totalCollateralSnapshot;
 294 |     | 
 295 |     |         emit SystemSnapshotsUpdated(_totalStakesSnapshot, _totalCollateralSnapshot);
 296 |     |     }
 297 |     | 
 298 |     |     /// @dev get the pending Cdp debt "reward" (i.e. the amount of extra debt assigned to the Cdp) from liquidation redistribution events, earned by their stake
 299 |     |     function _getPendingRedistributedDebt(
 300 |     |         bytes32 _cdpId
 301 |     |     ) internal view returns (uint256 pendingEBTCDebtReward, uint256 _debtIndexDiff) {
 302 |     |         Cdp storage cdp = Cdps[_cdpId];
 303 |     | 
 304 |     |         if (cdp.status != Status.active) {
 305 |     |             return (0, 0);
 306 |     |         }
 307 |     | 
 308 |     |         _debtIndexDiff = systemDebtRedistributionIndex - cdpDebtRedistributionIndex[_cdpId];
 309 |     | 
 310 |     |         if (_debtIndexDiff > 0) {
 311 |     |             pendingEBTCDebtReward = (cdp.stake * _debtIndexDiff) / DECIMAL_PRECISION;
 312 |     |         } else {
 313 |     |             return (0, 0);
 314 |     |         }
 315 |     |     }
 316 |     | 
 317 |     |     /*
 318 |     |      * A Cdp has pending redistributed debt if its snapshot is less than the current rewards per-unit-staked sum:
 319 |     |      * this indicates that redistributions have occured since the snapshot was made, and the user therefore has
 320 |     |      * pending debt
 321 |     |      */
 322 |     |     function _hasRedistributedDebt(bytes32 _cdpId) internal view returns (bool) {
 323 |     |         if (Cdps[_cdpId].status != Status.active) {
 324 |     |             return false;
 325 |     |         }
 326 |     | 
 327 |     |         return (cdpDebtRedistributionIndex[_cdpId] < systemDebtRedistributionIndex);
 328 |     |     }
 329 |     | 
 330 |     |     /// @dev Sync Cdp debt redistribution index to global value
 331 |     |     function _updateRedistributedDebtIndex(bytes32 _cdpId) internal {
 332 |     |         uint256 _systemDebtRedistributionIndex = systemDebtRedistributionIndex;
 333 |     | 
 334 |     |         cdpDebtRedistributionIndex[_cdpId] = _systemDebtRedistributionIndex;
 335 |     |         emit CdpDebtRedistributionIndexUpdated(_cdpId, _systemDebtRedistributionIndex);
 336 |     |     }
 337 |     | 
 338 |     |     /// @dev Calculate the new collateral and debt values for a given CDP, based on pending state changes
 339 |     |     function _syncAccounting(bytes32 _cdpId) internal {
 340 |     |         // Ensure global states like systemStEthFeePerUnitIndex get updated in a timely fashion
 341 |     |         // whenever there is a CDP modification operation,
 342 |     |         // such as opening, closing, adding collateral, repaying debt, or liquidating
 343 |     |         _syncGlobalAccounting();
 344 |     | 
 345 |     |         uint256 _oldPerUnitCdp = cdpStEthFeePerUnitIndex[_cdpId];
 346 |     |         uint256 _systemStEthFeePerUnitIndex = systemStEthFeePerUnitIndex;
 347 |     | 
 348 |     |         (
 349 |     |             uint256 _newColl,
 350 |     |             uint256 _newDebt,
 351 |     |             uint256 _feeSplitDistributed,
 352 |     |             uint _pendingDebt,
 353 |     |             uint256 _debtIndexDelta
 354 |     |         ) = _calcSyncedAccounting(_cdpId, _oldPerUnitCdp, _systemStEthFeePerUnitIndex);
 355 |     | 
 356 |     |         // If any collShares or debt changes occured
 357 |     |         if (_feeSplitDistributed > 0 || _debtIndexDelta > 0) {
 358 |     |             Cdp storage _cdp = Cdps[_cdpId];
 359 |     | 
 360 |     |             uint prevCollShares = _cdp.coll;
 361 |     |             uint256 prevDebt = _cdp.debt;
 362 |     | 
 363 |     |             // Apply Fee Split
 364 |     |             if (_feeSplitDistributed > 0) {
 365 |     |                 _applyAccumulatedFeeSplit(
 366 |     |                     _cdpId,
 367 |     |                     _newColl,
 368 |     |                     _feeSplitDistributed,
 369 |     |                     _oldPerUnitCdp,
 370 |     |                     _systemStEthFeePerUnitIndex
 371 |     |                 );
 372 |     |             }
 373 |     | 
 374 |     |             // Apply Debt Redistribution
 375 |     |             if (_debtIndexDelta > 0) {
 376 |     |                 _updateRedistributedDebtIndex(_cdpId);
 377 |     | 
 378 |     |                 if (prevDebt != _newDebt) {
 379 |     |                     {
 380 |     |                         // Apply pending debt redistribution to this CDP
 381 |     |                         _cdp.debt = _newDebt;
 382 |     |                     }
 383 |     |                 }
 384 |     |             }
 385 |     |             emit CdpUpdated(
 386 |     |                 _cdpId,
 387 |     |                 ISortedCdps(sortedCdps).getOwnerAddress(_cdpId),
 388 |     |                 msg.sender,
 389 |     |                 prevDebt,
 390 |     |                 prevCollShares,
 391 |     |                 _newDebt,
 392 |     |                 _newColl,
 393 |     |                 _cdp.stake,
 394 |     |                 CdpOperation.syncAccounting
 395 |     |             );
 396 |     |         }
 397 |     | 
 398 |     |         // sync per stake index for given CDP
 399 |     |         if (_oldPerUnitCdp != _systemStEthFeePerUnitIndex) {
 400 |     |             cdpStEthFeePerUnitIndex[_cdpId] = _systemStEthFeePerUnitIndex;
 401 |     |         }
 402 |     |     }
 403 |     | 
 404 |     |     // Remove borrower's stake from the totalStakes sum, and set their stake to 0
 405 |     |     function _removeStake(bytes32 _cdpId) internal {
 406 |     |         uint256 _newTotalStakes = totalStakes - Cdps[_cdpId].stake;
 407 |     |         totalStakes = _newTotalStakes;
 408 |     |         Cdps[_cdpId].stake = 0;
 409 |     |         emit TotalStakesUpdated(_newTotalStakes);
 410 |     |     }
 411 |     | 
 412 |     |     // Update borrower's stake based on their latest collateral value
 413 |     |     // and update totalStakes accordingly as well
 414 |     |     function _updateStakeAndTotalStakes(bytes32 _cdpId) internal returns (uint256) {
 415 |     |         (uint256 newStake, uint256 oldStake) = _updateStakeForCdp(_cdpId);
 416 |     | 
 417 |     |         uint256 _newTotalStakes = totalStakes + newStake - oldStake;
 418 |     |         totalStakes = _newTotalStakes;
 419 |     | 
 420 |     |         emit TotalStakesUpdated(_newTotalStakes);
 421 |     | 
 422 |     |         return newStake;
 423 |     |     }
 424 |     | 
 425 |     |     // Update borrower's stake based on their latest collateral value
 426 |     |     function _updateStakeForCdp(bytes32 _cdpId) internal returns (uint256, uint256) {
 427 |     |         Cdp storage _cdp = Cdps[_cdpId];
 428 |     |         uint256 newStake = _computeNewStake(_cdp.coll);
 429 |     |         uint256 oldStake = _cdp.stake;
 430 |     |         _cdp.stake = newStake;
 431 |     | 
 432 |     |         return (newStake, oldStake);
 433 |     |     }
 434 |     | 
 435 |     |     // Calculate a new stake based on the snapshots of the totalStakes and totalCollateral taken at the last liquidation
 436 |     |     function _computeNewStake(uint256 _coll) internal view returns (uint256) {
 437 |     |         uint256 stake;
 438 |     |         if (totalCollateralSnapshot == 0) {
 439 |     |             stake = _coll;
 440 |     |         } else {
 441 |     |             /*
 442 |     |              * The following check holds true because:
 443 |     |              * - The system always contains >= 1 cdp
 444 |     |              * - When we close or liquidate a cdp, we redistribute the pending rewards,
 445 |     |              * so if all cdps were closed/liquidated,
 446 |     |              * rewards would’ve been emptied and totalCollateralSnapshot would be zero too.
 447 |     |              */
 448 |     |             require(totalStakesSnapshot > 0, "CdpManagerStorage: zero totalStakesSnapshot!");
 449 |     |             stake = (_coll * totalStakesSnapshot) / totalCollateralSnapshot;
 450 |     |         }
 451 |     |         return stake;
 452 |     |     }
 453 |     | 
 454 |     |     // --- Recovery Mode and TCR functions ---
 455 |     | 
 456 |     |     // Calculate TCR given an price, and the entire system coll and debt.
 457 |     |     function _computeTCRWithGivenSystemValues(
 458 |     |         uint256 _systemCollShares,
 459 |     |         uint256 _systemDebt,
 460 |     |         uint256 _price
 461 |     |     ) internal view returns (uint256) {
 462 |     |         uint256 _totalColl = collateral.getPooledEthByShares(_systemCollShares);
 463 |     |         return EbtcMath._computeCR(_totalColl, _systemDebt, _price);
 464 |     |     }
 465 |     | 
 466 |     |     // --- Staking-Reward Fee split functions ---
 467 |     | 
 468 |     |     /// @notice Claim split fee if there is staking-reward coming
 469 |     |     /// @notice and update global index & fee-per-unit variables
 470 |     |     /// @dev only BorrowerOperations is allowed to call this
 471 |     |     /// @dev otherwise use syncGlobalAccountingAndGracePeriod()
 472 |     |     function syncGlobalAccounting() external {
 473 |     |         _requireCallerIsBorrowerOperations();
 474 |     |         _syncGlobalAccounting();
 475 |     |     }
 476 |     | 
 477 |     |     function _syncGlobalAccounting() internal {
 478 |     |         (uint256 _oldIndex, uint256 _newIndex) = _readStEthIndex();
 479 |     |         _syncStEthIndex(_oldIndex, _newIndex);
 480 |     |         if (_newIndex > _oldIndex && totalStakes > 0) {
 481 |     |             (
 482 |     |                 uint256 _feeTaken,
 483 |     |                 uint256 _newFeePerUnit,
 484 |     |                 uint256 _perUnitError
 485 |     |             ) = _calcSyncedGlobalAccounting(_newIndex, _oldIndex);
 486 |     |             _takeSplitAndUpdateFeePerUnit(_feeTaken, _newFeePerUnit, _perUnitError);
 487 |     |             _updateSystemSnapshotsExcludeCollRemainder(0);
 488 |     |         }
 489 |     |     }
 490 |     | 
 491 |     |     /// @notice Claim fee split, if there is staking-reward coming
 492 |     |     /// @notice and update global index & fee-per-unit variables
 493 |     |     /// @notice and toggles Grace Period accordingly.
 494 |     |     /// @dev Call this if you want to help eBTC system to accrue split fee
 495 |     |     function syncGlobalAccountingAndGracePeriod() public {
 496 |     |         _syncGlobalAccounting(); // Apply // Could trigger RM
 497 |     |         _syncGracePeriod(); // Synch Grace Period
 498 |     |     }
 499 |     | 
 500 |     |     /// @return existing(old) local stETH index AND
 501 |     |     /// @return current(new) stETH index from collateral token
 502 |     |     function _readStEthIndex() internal view returns (uint256, uint256) {
 503 |     |         return (stEthIndex, collateral.getPooledEthByShares(DECIMAL_PRECISION));
 504 |     |     }
 505 |     | 
 506 |     |     // Update the global index via collateral token
 507 |     |     function _syncStEthIndex(uint256 _oldIndex, uint256 _newIndex) internal {
 508 |     |         if (_newIndex != _oldIndex) {
 509 |     |             stEthIndex = _newIndex;
 510 |     |             emit StEthIndexUpdated(_oldIndex, _newIndex, block.timestamp);
 511 |     |         }
 512 |     |     }
 513 |     | 
 514 |     |     /// @notice Calculate fee for given pair of collateral indexes
 515 |     |     /// @param _newIndex The value synced with stETH.getPooledEthByShares(1e18)
 516 |     |     /// @param _prevIndex The cached global value of `stEthIndex`
 517 |     |     /// @return _feeTaken The fee split in collateral token which will be deduced from current total system collateral
 518 |     |     /// @return _deltaFeePerUnit The fee split increase per unit, used to added to `systemStEthFeePerUnitIndex`
 519 |     |     /// @return _perUnitError The fee split calculation error, used to update `systemStEthFeePerUnitIndexError`
 520 |     |     function calcFeeUponStakingReward(
 521 |     |         uint256 _newIndex,
 522 |     |         uint256 _prevIndex
 523 |     |     ) public view returns (uint256, uint256, uint256) {
 524 |     |         require(_newIndex > _prevIndex, "CDPManager: only take fee with bigger new index");
 525 |     |         uint256 deltaIndex = _newIndex - _prevIndex;
 526 |     |         uint256 deltaIndexFees = (deltaIndex * stakingRewardSplit) / MAX_REWARD_SPLIT;
 527 |     | 
 528 |     |         // we take the fee for all CDPs immediately which is scaled by index precision
 529 |     |         uint256 _deltaFeeSplit = deltaIndexFees * getSystemCollShares();
 530 |     |         uint256 _cachedAllStakes = totalStakes;
 531 |     |         // return the values to update the global fee accumulator
 532 |     |         uint256 _feeTaken = collateral.getSharesByPooledEth(_deltaFeeSplit) / DECIMAL_PRECISION;
 533 |     |         uint256 _deltaFeeSplitShare = (_feeTaken * DECIMAL_PRECISION) +
 534 |     |             systemStEthFeePerUnitIndexError;
 535 |     |         uint256 _deltaFeePerUnit = _deltaFeeSplitShare / _cachedAllStakes;
 536 |     |         uint256 _perUnitError = _deltaFeeSplitShare - (_deltaFeePerUnit * _cachedAllStakes);
 537 |     |         return (_feeTaken, _deltaFeePerUnit, _perUnitError);
 538 |     |     }
 539 |     | 
 540 |     |     // Take the cut from staking reward
 541 |     |     // and update global fee-per-unit accumulator
 542 |     |     function _takeSplitAndUpdateFeePerUnit(
 543 |     |         uint256 _feeTaken,
 544 |     |         uint256 _newPerUnit,
 545 |     |         uint256 _newErrorPerUnit
 546 |     |     ) internal {
 547 |     |         uint256 _oldPerUnit = systemStEthFeePerUnitIndex;
 548 |     | 
 549 |     |         systemStEthFeePerUnitIndex = _newPerUnit;
 550 |     |         systemStEthFeePerUnitIndexError = _newErrorPerUnit;
 551 |     | 
 552 |     |         require(activePool.getSystemCollShares() > _feeTaken, "CDPManager: fee split is too big");
 553 |     |         activePool.allocateSystemCollSharesToFeeRecipient(_feeTaken);
 554 |     | 
 555 |     |         emit CollateralFeePerUnitUpdated(_oldPerUnit, _newPerUnit, _feeTaken);
 556 |     |     }
 557 |     | 
 558 |     |     // Apply accumulated fee split distributed to the CDP
 559 |     |     // and update its accumulator tracker accordingly
 560 |     |     function _applyAccumulatedFeeSplit(
 561 |     |         bytes32 _cdpId,
 562 |     |         uint256 _newColl,
 563 |     |         uint256 _feeSplitDistributed,
 564 |     |         uint256 _oldPerUnitCdp,
 565 |     |         uint256 _systemStEthFeePerUnitIndex
 566 |     |     ) internal {
 567 |     |         // apply split fee to given CDP
 568 |     |         Cdps[_cdpId].coll = _newColl;
 569 |     | 
 570 |     |         emit CdpFeeSplitApplied(
 571 |     |             _cdpId,
 572 |     |             _oldPerUnitCdp,
 573 |     |             _systemStEthFeePerUnitIndex,
 574 |     |             _feeSplitDistributed,
 575 |     |             _newColl
 576 |     |         );
 577 |     |     }
 578 |     | 
 579 |     |     /// @notice Calculate the applied split fee(scaled by 1e18) and the resulting CDP collateral share after applied
 580 |     |     /// @param _cdpId The Cdp to which the calculated split fee is going to be applied
 581 |     |     /// @param _systemStEthFeePerUnitIndex The fee-per-stake-unit value to be used in fee split calculation, could be result of calcFeeUponStakingReward()
 582 |     |     /// @return _feeSplitDistributed The applied fee split to the specified Cdp (scaled up by 1e18)
 583 |     |     /// @return _cdpCol The new collateral share of the specified Cdp after fe split applied
 584 |     |     function getAccumulatedFeeSplitApplied(
 585 |     |         bytes32 _cdpId,
 586 |     |         uint256 _systemStEthFeePerUnitIndex
 587 |     |     ) public view returns (uint256, uint256) {
 588 |     |         uint256 _cdpStEthFeePerUnitIndex = cdpStEthFeePerUnitIndex[_cdpId];
 589 |     |         uint256 _cdpCol = Cdps[_cdpId].coll;
 590 |     | 
 591 |     |         if (
 592 |     |             _cdpStEthFeePerUnitIndex == 0 ||
 593 |     |             _cdpCol == 0 ||
 594 |     |             _cdpStEthFeePerUnitIndex == _systemStEthFeePerUnitIndex
 595 |     |         ) {
 596 |     |             return (0, _cdpCol);
 597 |     |         }
 598 |     | 
 599 |     |         uint256 _feeSplitDistributed = Cdps[_cdpId].stake *
 600 |     |             (_systemStEthFeePerUnitIndex - _cdpStEthFeePerUnitIndex);
 601 |     | 
 602 |     |         uint256 _scaledCdpColl = _cdpCol * DECIMAL_PRECISION;
 603 |     | 
 604 |     |         if (_scaledCdpColl > _feeSplitDistributed) {
 605 |     |             return (
 606 |     |                 _feeSplitDistributed,
 607 |     |                 (_scaledCdpColl - _feeSplitDistributed) / DECIMAL_PRECISION
 608 |     |             );
 609 |     |         } else {
 610 |     |             // extreme unlikely case to skip fee split on this CDP to avoid revert
 611 |     |             return (0, _cdpCol);
 612 |     |         }
 613 |     |     }
 614 |     | 
 615 |     |     // -- Modifier functions --
 616 |     |     function _requireCdpIsActive(bytes32 _cdpId) internal view {
 617 |     |         require(Cdps[_cdpId].status == Status.active, "CdpManager: Cdp does not exist or is closed");
 618 |     |     }
 619 |     | 
 620 |     |     function _requireMoreThanOneCdpInSystem(uint256 CdpOwnersArrayLength) internal view {
 621 |     |         require(
 622 |     |             CdpOwnersArrayLength > 1 && sortedCdps.getSize() > 1,
 623 |     |             "CdpManager: Only one cdp in the system"
 624 |     |         );
 625 |     |     }
 626 |     | 
 627 |     |     function _requireCallerIsBorrowerOperations() internal view {
 628 |     |         require(
 629 |     |             msg.sender == borrowerOperationsAddress,
 630 |     |             "CdpManager: Caller is not the BorrowerOperations contract"
 631 |     |         );
 632 |     |     }
 633 |     | 
 634 |     |     // --- Helper functions ---
 635 |     | 
 636 |     |     /// @notice Return the Nominal Collateral Ratio (NICR) of the specified Cdp as "cached view" (maybe outdated).
 637 |     |     /// @dev Takes a cdp's pending coll and debt rewards from redistributions into account.
 638 |     |     /// @param _cdpId The CdpId whose NICR to be queried
 639 |     |     /// @return The Nominal Collateral Ratio (NICR) of the specified Cdp.
 640 |     |     /// @dev Use getSyncedNominalICR() instead if pending fee split and debt redistribution should be considered
 641 |     |     function getCachedNominalICR(bytes32 _cdpId) external view returns (uint256) {
 642 |     |         (uint256 currentEBTCDebt, uint256 currentCollShares) = getSyncedDebtAndCollShares(_cdpId);
 643 |     | 
 644 |     |         uint256 NICR = EbtcMath._computeNominalCR(currentCollShares, currentEBTCDebt);
 645 |     |         return NICR;
 646 |     |     }
 647 |     | 
 648 |     |     /// @notice Return the Nominal Collateral Ratio (NICR) of the specified Cdp.
 649 |     |     /// @dev Takes a cdp's pending coll and debt rewards as well as stETH Index into account.
 650 |     |     /// @param _cdpId The CdpId whose NICR to be queried
 651 |     |     /// @return The Nominal Collateral Ratio (NICR) of the specified Cdp with fee split and debt redistribution considered.
 652 |     |     function getSyncedNominalICR(bytes32 _cdpId) external view returns (uint256) {
 653 |     |         (uint256 _oldIndex, uint256 _newIndex) = _readStEthIndex();
 654 |     |         (, uint256 _newGlobalSplitIdx, ) = _calcSyncedGlobalAccounting(_newIndex, _oldIndex);
 655 |     |         (uint256 _newColl, uint256 _newDebt, , uint256 _pendingDebt, ) = _calcSyncedAccounting(
 656 |     |             _cdpId,
 657 |     |             cdpStEthFeePerUnitIndex[_cdpId],
 658 |     |             _newGlobalSplitIdx /// NOTE: This is latest index
 659 |     |         );
 660 |     | 
 661 |     |         uint256 NICR = EbtcMath._computeNominalCR(_newColl, _newDebt);
 662 |     |         return NICR;
 663 |     |     }
 664 |     | 
 665 |     |     /// @notice Return the Individual Collateral Ratio (ICR) of the specified Cdp as "cached view" (maybe outdated).
 666 |     |     /// @param _cdpId The CdpId whose ICR to be queried
 667 |     |     /// @return The Individual Collateral Ratio (ICR) of the specified Cdp.
 668 |     |     /// @dev Use getSyncedICR() instead if pending fee split and debt redistribution should be considered
 669 |     |     function getCachedICR(bytes32 _cdpId, uint256 _price) public view returns (uint256) {
 670 |     |         (uint256 currentEBTCDebt, uint256 currentCollShares) = getSyncedDebtAndCollShares(_cdpId);
 671 |     |         uint256 ICR = _calculateCR(currentCollShares, currentEBTCDebt, _price);
 672 |     |         return ICR;
 673 |     |     }
 674 |     | 
 675 |     |     function _calculateCR(
 676 |     |         uint256 currentCollShare,
 677 |     |         uint256 currentDebt,
 678 |     |         uint256 _price
 679 |     |     ) internal view returns (uint256) {
 680 |     |         uint256 _underlyingCollateral = collateral.getPooledEthByShares(currentCollShare);
 681 |     |         return EbtcMath._computeCR(_underlyingCollateral, currentDebt, _price);
 682 |     |     }
 683 |     | 
 684 |     |     /// @notice Return the pending extra debt assigned to the Cdp from liquidation redistribution, calcualted by Cdp's stake
 685 |     |     /// @param _cdpId The CdpId whose pending debt redistribution to be queried
 686 |     |     /// @return pendingEBTCDebtReward The pending debt redistribution of the specified Cdp.
 687 |     |     function getPendingRedistributedDebt(
 688 |     |         bytes32 _cdpId
 689 |     |     ) public view returns (uint256 pendingEBTCDebtReward) {
 690 |     |         (uint256 _pendingDebt, ) = _getPendingRedistributedDebt(_cdpId);
 691 |     |         return _pendingDebt;
 692 |     |     }
 693 |     | 
 694 |     |     /// @return Whether the debt redistribution tracking index of the specified Cdp is less than the global tracking one (meaning it might get pending debt redistribution)
 695 |     |     /// @param _cdpId The CdpId whose debt redistribution tracking index to be queried against the gloabl one
 696 |     |     function hasPendingRedistributedDebt(bytes32 _cdpId) public view returns (bool) {
 697 |     |         return _hasRedistributedDebt(_cdpId);
 698 |     |     }
 699 |     | 
 700 |     |     // Return the Cdps entire debt and coll struct
 701 |     |     function _getSyncedDebtAndCollShares(
 702 |     |         bytes32 _cdpId
 703 |     |     ) internal view returns (CdpDebtAndCollShares memory) {
 704 |     |         (uint256 entireDebt, uint256 entireColl) = getSyncedDebtAndCollShares(_cdpId);
 705 |     |         return CdpDebtAndCollShares(entireDebt, entireColl);
 706 |     |     }
 707 |     | 
 708 |     |     /// @notice Calculate the Cdps entire debt and coll, including pending debt redistributions and collateral reduction from split fee.
 709 |     |     /// @param _cdpId The CdpId to be queried
 710 |     |     /// @return debt The total debt value of the Cdp including debt redistribution considered
 711 |     |     /// @return coll The total collateral value of the Cdp including possible fee split considered
 712 |     |     /// @dev Should always use this as the first(default) choice for Cdp position size query
 713 |     |     function getSyncedDebtAndCollShares(
 714 |     |         bytes32 _cdpId
 715 |     |     ) public view returns (uint256 debt, uint256 coll) {
 716 |     |         (uint256 _newColl, uint256 _newDebt, , , ) = _calcSyncedAccounting(
 717 |     |             _cdpId,
 718 |     |             cdpStEthFeePerUnitIndex[_cdpId],
 719 |     |             systemStEthFeePerUnitIndex
 720 |     |         );
 721 |     |         coll = _newColl;
 722 |     |         debt = _newDebt;
 723 |     |     }
 724 |     | 
 725 |     |     /// @dev calculate pending global state change to be applied:
 726 |     |     /// @return split fee taken (if any) AND
 727 |     |     /// @return new split index per stake unit AND
 728 |     |     /// @return new split index error
 729 |     |     function _calcSyncedGlobalAccounting(
 730 |     |         uint256 _newIndex,
 731 |     |         uint256 _oldIndex
 732 |     |     ) internal view returns (uint256, uint256, uint256) {
 733 |     |         if (_newIndex > _oldIndex && totalStakes > 0) {
 734 |     |             /// @audit-ok We don't take the fee if we had a negative rebase
 735 |     |             (
 736 |     |                 uint256 _feeTaken,
 737 |     |                 uint256 _deltaFeePerUnit,
 738 |     |                 uint256 _perUnitError
 739 |     |             ) = calcFeeUponStakingReward(_newIndex, _oldIndex);
 740 |     | 
 741 |     |             // calculate new split per stake unit
 742 |     |             uint256 _newPerUnit = systemStEthFeePerUnitIndex + _deltaFeePerUnit;
 743 |     |             return (_feeTaken, _newPerUnit, _perUnitError);
 744 |     |         } else {
 745 |     |             return (0, systemStEthFeePerUnitIndex, systemStEthFeePerUnitIndexError);
 746 |     |         }
 747 |     |     }
 748 |     | 
 749 |     |     /// @dev calculate pending state change to be applied for given CDP and global split index(typically already synced):
 750 |     |     /// @return new CDP collateral share after pending change applied
 751 |     |     /// @return new CDP debt after pending change applied
 752 |     |     /// @return split fee applied to given CDP
 753 |     |     /// @return redistributed debt applied to given CDP
 754 |     |     /// @return delta between debt redistribution index of given CDP and global tracking index
 755 |     |     function _calcSyncedAccounting(
 756 |     |         bytes32 _cdpId,
 757 |     |         uint256 _cdpPerUnitIdx,
 758 |     |         uint256 _systemStEthFeePerUnitIndex
 759 |     |     ) internal view returns (uint256, uint256, uint256, uint256, uint256) {
 760 |     |         uint256 _feeSplitApplied;
 761 |     |         uint256 _newCollShare = Cdps[_cdpId].coll;
 762 |     | 
 763 |     |         // processing split fee to be applied
 764 |     |         if (_cdpPerUnitIdx != _systemStEthFeePerUnitIndex && _cdpPerUnitIdx > 0) {
 765 |     |             (
 766 |     |                 uint256 _feeSplitDistributed,
 767 |     |                 uint256 _newCollShareAfter
 768 |     |             ) = getAccumulatedFeeSplitApplied(_cdpId, _systemStEthFeePerUnitIndex);
 769 |     |             _feeSplitApplied = _feeSplitDistributed;
 770 |     |             _newCollShare = _newCollShareAfter;
 771 |     |         }
 772 |     | 
 773 |     |         // processing redistributed debt to be applied
 774 |     |         (
 775 |     |             uint256 _newDebt,
 776 |     |             uint256 pendingDebtRedistributed,
 777 |     |             uint256 _debtIndexDelta
 778 |     |         ) = _getSyncedCdpDebtAndRedistribution(_cdpId);
 779 |     | 
 780 |     |         return (
 781 |     |             _newCollShare,
 782 |     |             _newDebt,
 783 |     |             _feeSplitApplied,
 784 |     |             pendingDebtRedistributed,
 785 |     |             _debtIndexDelta
 786 |     |         );
 787 |     |     }
 788 |     | 
 789 |     |     /// @return CDP debt and pending redistribution from liquidation applied
 790 |     |     function _getSyncedCdpDebtAndRedistribution(
 791 |     |         bytes32 _cdpId
 792 |     |     ) internal view returns (uint256, uint256, uint256) {
 793 |     |         (uint256 pendingDebtRedistributed, uint256 _debtIndexDelta) = _getPendingRedistributedDebt(
 794 |     |             _cdpId
 795 |     |         );
 796 |     |         uint256 _newDebt = Cdps[_cdpId].debt;
 797 |     |         if (pendingDebtRedistributed > 0) {
 798 |     |             _newDebt = _newDebt + pendingDebtRedistributed;
 799 |     |         }
 800 |     |         return (_newDebt, pendingDebtRedistributed, _debtIndexDelta);
 801 |     |     }
 802 |     | 
 803 |     |     /// @notice Calculate the Cdps entire debt, including pending debt redistributions.
 804 |     |     /// @param _cdpId The CdpId to be queried
 805 |     |     /// @return _newDebt The total debt value of the Cdp including debt redistribution considered
 806 |     |     /// @dev Should always use this as the first(default) choice for Cdp debt query
 807 |     |     function getSyncedCdpDebt(bytes32 _cdpId) public view returns (uint256) {
 808 |     |         (uint256 _newDebt, , ) = _getSyncedCdpDebtAndRedistribution(_cdpId);
 809 |     |         return _newDebt;
 810 |     |     }
 811 |     | 
 812 |     |     /// @notice Calculate the Cdps entire collateral, including pending fee split to be applied
 813 |     |     /// @param _cdpId The CdpId to be queried
 814 |     |     /// @return _newColl The total collateral value of the Cdp including fee split considered
 815 |     |     /// @dev Should always use this as the first(default) choice for Cdp collateral query
 816 |     |     function getSyncedCdpCollShares(bytes32 _cdpId) public view returns (uint256) {
 817 |     |         (uint256 _oldIndex, uint256 _newIndex) = _readStEthIndex();
 818 |     |         (, uint256 _newGlobalSplitIdx, ) = _calcSyncedGlobalAccounting(_newIndex, _oldIndex);
 819 |     |         (uint256 _newColl, , , , ) = _calcSyncedAccounting(
 820 |     |             _cdpId,
 821 |     |             cdpStEthFeePerUnitIndex[_cdpId],
 822 |     |             _newGlobalSplitIdx
 823 |     |         );
 824 |     |         return _newColl;
 825 |     |     }
 826 |     | 
 827 |     |     /// @notice Calculate the Cdps ICR, including pending debt distribution and fee split to be applied
 828 |     |     /// @param _cdpId The CdpId to be queried
 829 |     |     /// @param _price The ETH:eBTC price to be used in ICR calculation
 830 |     |     /// @return The ICR of the Cdp including debt distribution and fee split considered
 831 |     |     /// @dev Should always use this as the first(default) choice for Cdp ICR query
 832 |     |     function getSyncedICR(bytes32 _cdpId, uint256 _price) public view returns (uint256) {
 833 |     |         uint256 _debt = getSyncedCdpDebt(_cdpId);
 834 |     |         uint256 _collShare = getSyncedCdpCollShares(_cdpId);
 835 |     |         return _calculateCR(_collShare, _debt, _price);
 836 |     |     }
 837 |     | 
 838 |     |     /// @notice return system collateral share, including pending fee split to be taken
 839 |     |     function getSyncedSystemCollShares() public view returns (uint256) {
 840 |     |         (uint256 _oldIndex, uint256 _newIndex) = _readStEthIndex();
 841 |     |         (uint256 _feeTaken, , ) = _calcSyncedGlobalAccounting(_newIndex, _oldIndex);
 842 |     | 
 843 |     |         uint256 _systemCollShare = activePool.getSystemCollShares();
 844 |     |         if (_feeTaken > 0) {
 845 |     |             _systemCollShare = _systemCollShare - _feeTaken;
 846 |     |         }
 847 |     |         return _systemCollShare;
 848 |     |     }
 849 |     | 
 850 |     |     /// @notice Calculate the TCR, including pending debt distribution and fee split to be taken
 851 |     |     /// @param _price The ETH:eBTC price to be used in TCR calculation
 852 |     |     /// @return The TCR of the eBTC system including debt distribution and fee split considered
 853 |     |     /// @dev Should always use this as the first(default) choice for TCR query
 854 |     |     function getSyncedTCR(uint256 _price) public view returns (uint256) {
 855 |     |         uint256 _systemCollShare = getSyncedSystemCollShares();
 856 |     |         uint256 _systemDebt = activePool.getSystemDebt();
 857 |     |         return _calculateCR(_systemCollShare, _systemDebt, _price);
 858 |     |     }
 859 |     | 
 860 |     |     /// @notice Get the count of active Cdps in the system
 861 |     |     /// @return The number of current active Cdps (not closed) in the system.
 862 |     |     function getActiveCdpsCount() public view override returns (uint256) {
 863 |     |         return sortedCdps.getSize();
 864 |     |     }
 865 |     | 
 866 |     |     /// @param icr The ICR of a Cdp to check if liquidatable
 867 |     |     /// @param tcr The TCR of the eBTC system used to determine if Recovery Mode is triggered
 868 |     |     /// @return whether the Cdp of specified icr is liquidatable with specified tcr
 869 |     |     /// @dev The flag will only be set to true if enough time has passed since Grace Period starts
 870 |     |     function canLiquidateRecoveryMode(uint256 icr, uint256 tcr) public view returns (bool) {
 871 |     |         return _checkICRAgainstTCR(icr, tcr) && _recoveryModeGracePeriodPassed();
 872 |     |     }
 873 |     | 
 874 |     |     /// @dev Check if enough time has passed for grace period after enabled
 875 |     |     function _recoveryModeGracePeriodPassed() internal view returns (bool) {
 876 |     |         // we have waited enough
 877 |     |         uint128 cachedLastGracePeriodStartTimestamp = lastGracePeriodStartTimestamp;
 878 |     |         return
 879 |     |             cachedLastGracePeriodStartTimestamp != UNSET_TIMESTAMP &&
 880 |     |             block.timestamp > cachedLastGracePeriodStartTimestamp + recoveryModeGracePeriodDuration;
 881 |     |     }
 882 |     | }
 883 |     | 

/mnt/c/Users/Lourens/Documents/Recon-Fuzz/collabs/ebtc/packages/contracts/contracts/CollSurplusPool.sol
   1 |     | // SPDX-License-Identifier: MIT
   2 |     | 
   3 |     | pragma solidity 0.8.17;
   4 |     | 
   5 |     | import "./Interfaces/ICollSurplusPool.sol";
   6 |     | import "./Dependencies/ICollateralToken.sol";
   7 |     | import "./Dependencies/SafeERC20.sol";
   8 |     | import "./Dependencies/ReentrancyGuard.sol";
   9 |     | import "./Dependencies/AuthNoOwner.sol";
  10 |     | import "./Interfaces/IActivePool.sol";
  11 |     | 
  12 |     | /// @notice CollSurplusPool holds stETH collateral for Cdp owner when redemption or liquidation happens
  13 |     | /// @notice only if there is a remaining portion of the closed Cdp for the owner to claim
  14 |     | /// @dev While an owner could have multiple different sized Cdps, the remaining surplus colateral from all of its closed Cdp
  15 |     | /// @dev is consolidated into one balance here
  16 |     | contract CollSurplusPool is ICollSurplusPool, ReentrancyGuard, AuthNoOwner {
  17 |     |     using SafeERC20 for IERC20;
  18 |     | 
  19 |     |     string public constant NAME = "CollSurplusPool";
  20 |     | 
  21 |     |     address public immutable borrowerOperationsAddress;
  22 |     |     address public immutable cdpManagerAddress;
  23 |     |     address public immutable activePoolAddress;
  24 |     |     address public immutable feeRecipientAddress;
  25 |     |     ICollateralToken public immutable collateral;
  26 |     | 
  27 |     |     // deposited ether tracker
  28 |     |     uint256 internal totalSurplusCollShares;
  29 |     |     // Collateral surplus claimable by cdp owners
  30 |     |     mapping(address => uint256) internal balances;
  31 |     | 
  32 |     |     // --- Contract setters ---
  33 |     | 
  34 |     |     /**
  35 |     |      * @notice Sets the addresses of the contracts and renounces ownership
  36 |     |      * @dev One-time initialization function. Can only be called by the owner as a security measure. Ownership is renounced after the function is called.
  37 |     |      * @param _borrowerOperationsAddress The address of the BorrowerOperations
  38 |     |      * @param _cdpManagerAddress The address of the CDPManager
  39 |     |      * @param _activePoolAddress The address of the ActivePool
  40 |     |      * @param _collTokenAddress The address of the CollateralToken
  41 |     |      */
  42 |     |     constructor(
  43 |     |         address _borrowerOperationsAddress,
  44 |     |         address _cdpManagerAddress,
  45 |     |         address _activePoolAddress,
  46 |     |         address _collTokenAddress
  47 |     |     ) {
  48 |     |         borrowerOperationsAddress = _borrowerOperationsAddress;
  49 |     |         cdpManagerAddress = _cdpManagerAddress;
  50 |     |         activePoolAddress = _activePoolAddress;
  51 |     |         collateral = ICollateralToken(_collTokenAddress);
  52 |     |         feeRecipientAddress = IActivePool(activePoolAddress).feeRecipientAddress();
  53 |     | 
  54 |     |         address _authorityAddress = address(AuthNoOwner(cdpManagerAddress).authority());
  55 |     |         if (_authorityAddress != address(0)) {
  56 |     |             _initializeAuthority(_authorityAddress);
  57 |     |         }
  58 |     |     }
  59 |     | 
  60 |     |     /// @return The current total collateral surplus available in this pool
  61 |     |     function getTotalSurplusCollShares() external view override returns (uint256) {
  62 |     |         return totalSurplusCollShares;
  63 |     |     }
  64 |     | 
  65 |     |     /// @return The collateral surplus available for the specified owner _account
  66 |     |     /// @param _account The address of the owner whose surplus balance to be queried
  67 |     |     function getSurplusCollShares(address _account) external view override returns (uint256) {
  68 |     |         return balances[_account];
  69 |     |     }
  70 |     | 
  71 |     |     // --- Pool functionality ---
  72 |     | 
  73 |     |     /// @notice Increases the claimable surplus collateral shares for the specified account.
  74 |     |     /// @notice Internal permissioned system function, can track amounts added from collateral shares and liquidator reward shares separately for accounting purposes.
  75 |     |     /// @dev Only the CdpManager contract can call this function.
  76 |     |     /// @param _cdpId CdpId surplus collateral shares come from, for accounting purposes.
  77 |     |     /// @param _account The account to increase collateral surplus balance for.
  78 |     |     /// @param _collateralShares The number of collateral shares to be added to the owner's surplus balance, from Cdp collateral shares.
  79 |     |     /// @param _liquidatorRewardShares The number of collateral shares to be added to the owner's surplus balance, from liquidator reward shares.
  80 |     |     function increaseSurplusCollShares(
  81 |     |         bytes32 _cdpId,
  82 |     |         address _account,
  83 |     |         uint256 _collateralShares,
  84 |     |         uint256 _liquidatorRewardShares
  85 |     |     ) external override {
  86 |     |         _requireCallerIsCdpManager();
  87 |     | 
  88 |     |         uint256 _totalClaimableSurplusCollShares = balances[_account] +
  89 |     |             _collateralShares +
  90 |     |             _liquidatorRewardShares;
  91 |     |         balances[_account] = _totalClaimableSurplusCollShares;
  92 |     | 
  93 |     |         emit SurplusCollSharesAdded(
  94 |     |             _cdpId,
  95 |     |             _account,
  96 |     |             _totalClaimableSurplusCollShares,
  97 |     |             _collateralShares,
  98 |     |             _liquidatorRewardShares
  99 |     |         );
 100 |     |     }
 101 |     | 
 102 |     |     /// @notice Allow owner to claim all its surplus recorded in this pool
 103 |     |     /// @dev stETH token will be sent to _account address if any surplus exist
 104 |     |     /// @param _account The owner address whose surplus balance is to be claimed
 105 |     |     function claimSurplusCollShares(address _account) external override {
 106 |     |         _requireCallerIsBorrowerOperations();
 107 |     |         uint256 claimableColl = balances[_account];
 108 |     |         require(claimableColl > 0, "CollSurplusPool: No collateral available to claim");
 109 |     | 
 110 |     |         balances[_account] = 0;
 111 |     | 
 112 |     |         uint256 cachedTotalSurplusCollShares = totalSurplusCollShares;
 113 |     | 
 114 |     |         require(cachedTotalSurplusCollShares >= claimableColl, "!CollSurplusPoolBal");
 115 |     |         // Safe per the check above
 116 |     |         unchecked {
 117 |     |             totalSurplusCollShares = cachedTotalSurplusCollShares - claimableColl;
 118 |     |         }
 119 |     |         emit CollSharesTransferred(_account, claimableColl);
 120 |     | 
 121 |     |         // NOTE: No need for safe transfer if the collateral asset is standard. Make sure this is the case!
 122 |     |         collateral.transferShares(_account, claimableColl);
 123 |     |     }
 124 |     | 
 125 |     |     // --- 'require' functions ---
 126 |     | 
 127 |     |     function _requireCallerIsBorrowerOperations() internal view {
 128 |     |         require(
 129 |     |             msg.sender == borrowerOperationsAddress,
 130 |     |             "CollSurplusPool: Caller is not Borrower Operations"
 131 |     |         );
 132 |     |     }
 133 |     | 
 134 |     |     function _requireCallerIsCdpManager() internal view {
 135 |     |         require(msg.sender == cdpManagerAddress, "CollSurplusPool: Caller is not CdpManager");
 136 |     |     }
 137 |     | 
 138 |     |     function _requireCallerIsActivePool() internal view {
 139 |     |         require(msg.sender == activePoolAddress, "CollSurplusPool: Caller is not Active Pool");
 140 |     |     }
 141 |     | 
 142 |     |     /// @notice Increase total collateral surplus balance by _value
 143 |     |     /// @param _value The surplus increase value
 144 |     |     /// @dev only ActivePool is allowed to call this function
 145 |     |     function increaseTotalSurplusCollShares(uint256 _value) external override {
 146 |     |         _requireCallerIsActivePool();
 147 |     |         totalSurplusCollShares = totalSurplusCollShares + _value;
 148 |     |     }
 149 |     | 
 150 |     |     // === Governed Functions === //
 151 |     | 
 152 |     |     /// @dev Function to move unintended dust that are not protected to fee recipient
 153 |     |     /// @notice moves given amount of given token (collateral is NOT allowed)
 154 |     |     /// @notice because recipient are fixed, this function is safe to be called by anyone
 155 |     |     /// @param token The token to be swept
 156 |     |     /// @param amount The token value to be swept
 157 |     |     function sweepToken(address token, uint256 amount) public nonReentrant requiresAuth {
 158 |     |         require(token != address(collateral), "CollSurplusPool: Cannot Sweep Collateral");
 159 |     | 
 160 |     |         uint256 balance = IERC20(token).balanceOf(address(this));
 161 |     |         require(amount <= balance, "CollSurplusPool: Attempt to sweep more than balance");
 162 |     | 
 163 |     |         IERC20(token).safeTransfer(feeRecipientAddress, amount);
 164 |     | 
 165 |     |         emit SweepTokenSuccess(token, amount, feeRecipientAddress);
 166 |     |     }
 167 |     | }
 168 |     | 

/mnt/c/Users/Lourens/Documents/Recon-Fuzz/collabs/ebtc/packages/contracts/contracts/Dependencies/Address.sol
   1 |     | // SPDX-License-Identifier: MIT
   2 |     | // OpenZeppelin Contracts (last updated v4.8.0) (utils/Address.sol)
   3 |     | 
   4 |     | pragma solidity 0.8.17;
   5 |     | 
   6 |     | /**
   7 |     |  * @dev Collection of functions related to the address type
   8 |     |  */
   9 |     | library Address {
  10 |     |     /**
  11 |     |      * @dev Returns true if `account` is a contract.
  12 |     |      *
  13 |     |      * [IMPORTANT]
  14 |     |      * ====
  15 |     |      * It is unsafe to assume that an address for which this function returns
  16 |     |      * false is an externally-owned account (EOA) and not a contract.
  17 |     |      *
  18 |     |      * Among others, `isContract` will return false for the following
  19 |     |      * types of addresses:
  20 |     |      *
  21 |     |      *  - an externally-owned account
  22 |     |      *  - a contract in construction
  23 |     |      *  - an address where a contract will be created
  24 |     |      *  - an address where a contract lived, but was destroyed
  25 |     |      *
  26 |     |      * Furthermore, `isContract` will also return true if the target contract within
  27 |     |      * the same transaction is already scheduled for destruction by `SELFDESTRUCT`,
  28 |     |      * which only has an effect at the end of a transaction.
  29 |     |      * ====
  30 |     |      *
  31 |     |      * [IMPORTANT]
  32 |     |      * ====
  33 |     |      * You shouldn't rely on `isContract` to protect against flash loan attacks!
  34 |     |      *
  35 |     |      * Preventing calls from contracts is highly discouraged. It breaks composability, breaks support for smart wallets
  36 |     |      * like Gnosis Safe, and does not provide security since it can be circumvented by calling from a contract
  37 |     |      * constructor.
  38 |     |      * ====
  39 |     |      */
  40 |     |     function isContract(address account) internal view returns (bool) {
  41 |     |         // This method relies on extcodesize/address.code.length, which returns 0
  42 |     |         // for contracts in construction, since the code is only stored at the end
  43 |     |         // of the constructor execution.
  44 |     | 
  45 |     |         return account.code.length > 0;
  46 |     |     }
  47 |     | 
  48 |     |     /**
  49 |     |      * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`], but with
  50 |     |      * `errorMessage` as a fallback revert reason when `target` reverts.
  51 |     |      *
  52 |     |      * _Available since v3.1._
  53 |     |      */
  54 |     |     function functionCall(
  55 |     |         address target,
  56 |     |         bytes memory data,
  57 |     |         string memory errorMessage
  58 |     |     ) internal returns (bytes memory) {
  59 |     |         return functionCallWithValue(target, data, 0, errorMessage);
  60 |     |     }
  61 |     | 
  62 |     |     /**
  63 |     |      * @dev Same as {xref-Address-functionCallWithValue-address-bytes-uint256-}[`functionCallWithValue`], but
  64 |     |      * with `errorMessage` as a fallback revert reason when `target` reverts.
  65 |     |      *
  66 |     |      * _Available since v3.1._
  67 |     |      */
  68 |     |     function functionCallWithValue(
  69 |     |         address target,
  70 |     |         bytes memory data,
  71 |     |         uint256 value,
  72 |     |         string memory errorMessage
  73 |     |     ) internal returns (bytes memory) {
  74 |     |         require(address(this).balance >= value, "Address: insufficient balance for call");
  75 |     |         (bool success, bytes memory returndata) = target.call{value: value}(data);
  76 |     |         return verifyCallResultFromTarget(target, success, returndata, errorMessage);
  77 |     |     }
  78 |     | 
  79 |     |     /**
  80 |     |      * @dev Tool to verify that a low level call to smart-contract was successful, and revert (either by bubbling
  81 |     |      * the revert reason or using the provided one) in case of unsuccessful call or if target was not a contract.
  82 |     |      *
  83 |     |      * _Available since v4.8._
  84 |     |      */
  85 |     |     function verifyCallResultFromTarget(
  86 |     |         address target,
  87 |     |         bool success,
  88 |     |         bytes memory returndata,
  89 |     |         string memory errorMessage
  90 |     |     ) internal view returns (bytes memory) {
  91 |     |         if (success) {
  92 |     |             if (returndata.length == 0) {
  93 |     |                 // only check isContract if the call was successful and the return data is empty
  94 |     |                 // otherwise we already know that it was a contract
  95 |     |                 require(isContract(target), "Address: call to non-contract");
  96 |     |             }
  97 |     |             return returndata;
  98 |     |         } else {
  99 |     |             _revert(returndata, errorMessage);
 100 |     |         }
 101 |     |     }
 102 |     | 
 103 |     |     function _revert(bytes memory returndata, string memory errorMessage) private pure {
 104 |     |         // Look for revert reason and bubble it up if present
 105 |     |         if (returndata.length > 0) {
 106 |     |             // The easiest way to bubble the revert reason is using memory via assembly
 107 |     |             /// @solidity memory-safe-assembly
 108 |     |             assembly {
 109 |     |                 let returndata_size := mload(returndata)
 110 |     |                 revert(add(32, returndata), returndata_size)
 111 |     |             }
 112 |     |         } else {
 113 |     |             revert(errorMessage);
 114 |     |         }
 115 |     |     }
 116 |     | }
 117 |     | 

/mnt/c/Users/Lourens/Documents/Recon-Fuzz/collabs/ebtc/packages/contracts/contracts/Dependencies/AggregatorV3Interface.sol
  1 |     | // SPDX-License-Identifier: MIT
  2 |     | // Code from https://github.com/smartcontractkit/chainlink/blob/master/evm-contracts/src/v0.6/interfaces/AggregatorV3Interface.sol
  3 |     | 
  4 |     | pragma solidity 0.8.17;
  5 |     | 
  6 |     | interface AggregatorV3Interface {
  7 |     |     function decimals() external view returns (uint8);
  8 |     | 
  9 |     |     function description() external view returns (string memory);
 10 |     | 
 11 |     |     function version() external view returns (uint256);
 12 |     | 
 13 |     |     // getRoundData and latestRoundData should both raise "No data present"
 14 |     |     // if they do not have data to report, instead of returning unset values
 15 |     |     // which could be misinterpreted as actual reported values.
 16 |     |     function getRoundData(
 17 |     |         uint80 _roundId
 18 |     |     )
 19 |     |         external
 20 |     |         view
 21 |     |         returns (
 22 |     |             uint80 roundId,
 23 |     |             int256 answer,
 24 |     |             uint256 startedAt,
 25 |     |             uint256 updatedAt,
 26 |     |             uint80 answeredInRound
 27 |     |         );
 28 |     | 
 29 |     |     function latestRoundData()
 30 |     |         external
 31 |     |         view
 32 |     |         returns (
 33 |     |             uint80 roundId,
 34 |     |             int256 answer,
 35 |     |             uint256 startedAt,
 36 |     |             uint256 updatedAt,
 37 |     |             uint80 answeredInRound
 38 |     |         );
 39 |     | }
 40 |     | 

/mnt/c/Users/Lourens/Documents/Recon-Fuzz/collabs/ebtc/packages/contracts/contracts/Dependencies/Auth.sol
  1 |     | // SPDX-License-Identifier: AGPL-3.0-only
  2 |     | pragma solidity 0.8.17;
  3 |     | 
  4 |     | import {Authority} from "./Authority.sol";
  5 |     | 
  6 |     | /// @notice Provides a flexible and updatable auth pattern which is completely separate from application logic.
  7 |     | /// @author Solmate (https://github.com/transmissions11/solmate/blob/main/src/auth/Auth.sol)
  8 |     | /// @author Modified from Dappsys (https://github.com/dapphub/ds-auth/blob/master/src/auth.sol)
  9 |     | abstract contract Auth {
 10 |     |     event OwnershipTransferred(address indexed user, address indexed newOwner);
 11 |     | 
 12 |     |     event AuthorityUpdated(address indexed user, Authority indexed newAuthority);
 13 |     | 
 14 |     |     address public owner;
 15 |     | 
 16 |     |     Authority public authority;
 17 |     | 
 18 |     |     constructor(address _owner, Authority _authority) {
 19 |     |         owner = _owner;
 20 |     |         authority = _authority;
 21 |     | 
 22 |     |         emit OwnershipTransferred(msg.sender, _owner);
 23 |     |         emit AuthorityUpdated(msg.sender, _authority);
 24 |     |     }
 25 |     | 
 26 |     |     modifier requiresAuth() virtual {
 27 |     |         require(isAuthorized(msg.sender, msg.sig), "Auth: UNAUTHORIZED");
 28 |     | 
 29 |     |         _;
 30 |     |     }
 31 |     | 
 32 |     |     function isAuthorized(address user, bytes4 functionSig) internal view virtual returns (bool) {
 33 |     |         Authority auth = authority; // Memoizing authority saves us a warm SLOAD, around 100 gas.
 34 |     | 
 35 |     |         // Checking if the caller is the owner only after calling the authority saves gas in most cases, but be
 36 |     |         // aware that this makes protected functions uncallable even to the owner if the authority is out of order.
 37 |     |         return
 38 |     |             (address(auth) != address(0) && auth.canCall(user, address(this), functionSig)) ||
 39 |     |             user == owner;
 40 |     |     }
 41 |     | 
 42 |     |     function setAuthority(Authority newAuthority) public virtual {
 43 |     |         // We check if the caller is the owner first because we want to ensure they can
 44 |     |         // always swap out the authority even if it's reverting or using up a lot of gas.
 45 |     |         require(msg.sender == owner || authority.canCall(msg.sender, address(this), msg.sig));
 46 |     | 
 47 |     |         authority = newAuthority;
 48 |     | 
 49 |     |         emit AuthorityUpdated(msg.sender, newAuthority);
 50 |     |     }
 51 |     | 
 52 |     |     function transferOwnership(address newOwner) public virtual requiresAuth {
 53 |     |         owner = newOwner;
 54 |     | 
 55 |     |         emit OwnershipTransferred(msg.sender, newOwner);
 56 |     |     }
 57 |     | }
 58 |     | 

/mnt/c/Users/Lourens/Documents/Recon-Fuzz/collabs/ebtc/packages/contracts/contracts/Dependencies/AuthNoOwner.sol
  1 |     | // SPDX-License-Identifier: AGPL-3.0-only
  2 |     | pragma solidity 0.8.17;
  3 |     | 
  4 |     | import {Authority} from "./Authority.sol";
  5 |     | 
  6 |     | /// @notice Provides a flexible and updatable auth pattern which is completely separate from application logic.
  7 |     | /// @author Modified by BadgerDAO to remove owner
  8 |     | /// @author Solmate (https://github.com/transmissions11/solmate/blob/main/src/auth/Auth.sol)
  9 |     | /// @author Modified from Dappsys (https://github.com/dapphub/ds-auth/blob/master/src/auth.sol)
 10 |     | contract AuthNoOwner {
 11 |     |     event AuthorityUpdated(address indexed user, Authority indexed newAuthority);
 12 |     | 
 13 |     |     Authority private _authority;
 14 |     |     bool private _authorityInitialized;
 15 |     | 
 16 |     |     modifier requiresAuth() virtual {
 17 |     |         require(isAuthorized(msg.sender, msg.sig), "Auth: UNAUTHORIZED");
 18 |     | 
 19 |     |         _;
 20 |     |     }
 21 |     | 
 22 |     |     function authority() public view returns (Authority) {
 23 |     |         return _authority;
 24 |     |     }
 25 |     | 
 26 |     |     function authorityInitialized() public view returns (bool) {
 27 |     |         return _authorityInitialized;
 28 |     |     }
 29 |     | 
 30 |     |     function isAuthorized(address user, bytes4 functionSig) internal view virtual returns (bool) {
 31 |     |         Authority auth = _authority; // Memoizing authority saves us a warm SLOAD, around 100 gas.
 32 |     | 
 33 |     |         // Checking if the caller is the owner only after calling the authority saves gas in most cases, but be
 34 |     |         // aware that this makes protected functions uncallable even to the owner if the authority is out of order.
 35 |     |         return (address(auth) != address(0) && auth.canCall(user, address(this), functionSig));
 36 |     |     }
 37 |     | 
 38 |     |     /// @notice Changed constructor to initialize to allow flexiblity of constructor vs initializer use
 39 |     |     /// @notice sets authorityInitiailzed flag to ensure only one use of
 40 |     |     function _initializeAuthority(address newAuthority) internal {
 41 |     |         require(address(_authority) == address(0), "Auth: authority is non-zero");
 42 |     |         require(!_authorityInitialized, "Auth: authority already initialized");
 43 |     | 
 44 |     |         _authority = Authority(newAuthority);
 45 |     |         _authorityInitialized = true;
 46 |     | 
 47 |     |         emit AuthorityUpdated(address(this), Authority(newAuthority));
 48 |     |     }
 49 |     | }
 50 |     | 

/mnt/c/Users/Lourens/Documents/Recon-Fuzz/collabs/ebtc/packages/contracts/contracts/Dependencies/Authority.sol
  1 |     | // SPDX-License-Identifier: AGPL-3.0-only
  2 |     | pragma solidity 0.8.17;
  3 |     | 
  4 |     | /// @notice A generic interface for a contract which provides authorization data to an Auth instance.
  5 |     | /// @author Solmate (https://github.com/transmissions11/solmate/blob/main/src/auth/Auth.sol)
  6 |     | /// @author Modified from Dappsys (https://github.com/dapphub/ds-auth/blob/master/src/auth.sol)
  7 |     | interface Authority {
  8 |     |     function canCall(address user, address target, bytes4 functionSig) external view returns (bool);
  9 |     | }
 10 |     | 

/mnt/c/Users/Lourens/Documents/Recon-Fuzz/collabs/ebtc/packages/contracts/contracts/Dependencies/BaseMath.sol
 1 |     | // SPDX-License-Identifier: MIT
 2 |     | pragma solidity 0.8.17;
 3 |     | 
 4 |     | contract BaseMath {
 5 |     |     uint256 public constant DECIMAL_PRECISION = 1e18;
 6 |     | }
 7 |     | 

/mnt/c/Users/Lourens/Documents/Recon-Fuzz/collabs/ebtc/packages/contracts/contracts/Dependencies/Context.sol
  1 |     | // SPDX-License-Identifier: MIT
  2 |     | // OpenZeppelin Contracts v4.4.1 (utils/Context.sol)
  3 |     | 
  4 |     | pragma solidity 0.8.17;
  5 |     | 
  6 |     | /**
  7 |     |  * @dev Provides information about the current execution context, including the
  8 |     |  * sender of the transaction and its data. While these are generally available
  9 |     |  * via msg.sender and msg.data, they should not be accessed in such a direct
 10 |     |  * manner, since when dealing with meta-transactions the account sending and
 11 |     |  * paying for execution may not be the actual sender (as far as an application
 12 |     |  * is concerned).
 13 |     |  *
 14 |     |  * This contract is only required for intermediate, library-like contracts.
 15 |     |  */
 16 |     | abstract contract Context {
 17 |     |     function _msgSender() internal view virtual returns (address) {
 18 |     |         return msg.sender;
 19 |     |     }
 20 |     | 
 21 |     |     function _msgData() internal view virtual returns (bytes calldata) {
 22 |     |         return msg.data;
 23 |     |     }
 24 |     | }
 25 |     | 

/mnt/c/Users/Lourens/Documents/Recon-Fuzz/collabs/ebtc/packages/contracts/contracts/Dependencies/Create3.sol
   1 |     | //SPDX-License-Identifier: Unlicense
   2 |     | pragma solidity 0.8.17;
   3 |     | 
   4 |     | /**
   5 |     |   @title A library for deploying contracts EIP-3171 style.
   6 |     |   @author Agustin Aguilar <aa@horizon.io>
   7 |     | */
   8 |     | library Create3 {
   9 |     |     error ErrorCreatingProxy();
  10 |     |     error ErrorCreatingContract();
  11 |     |     error TargetAlreadyExists();
  12 |     | 
  13 |     |     /**
  14 |     |     @notice The bytecode for a contract that proxies the creation of another contract
  15 |     |     @dev If this code is deployed using CREATE2 it can be used to decouple `creationCode` from the child contract address
  16 |     | 
  17 |     |   0x67363d3d37363d34f03d5260086018f3:
  18 |     |       0x00  0x67  0x67XXXXXXXXXXXXXXXX  PUSH8 bytecode  0x363d3d37363d34f0
  19 |     |       0x01  0x3d  0x3d                  RETURNDATASIZE  0 0x363d3d37363d34f0
  20 |     |       0x02  0x52  0x52                  MSTORE
  21 |     |       0x03  0x60  0x6008                PUSH1 08        8
  22 |     |       0x04  0x60  0x6018                PUSH1 18        24 8
  23 |     |       0x05  0xf3  0xf3                  RETURN
  24 |     | 
  25 |     |   0x363d3d37363d34f0:
  26 |     |       0x00  0x36  0x36                  CALLDATASIZE    cds
  27 |     |       0x01  0x3d  0x3d                  RETURNDATASIZE  0 cds
  28 |     |       0x02  0x3d  0x3d                  RETURNDATASIZE  0 0 cds
  29 |     |       0x03  0x37  0x37                  CALLDATACOPY
  30 |     |       0x04  0x36  0x36                  CALLDATASIZE    cds
  31 |     |       0x05  0x3d  0x3d                  RETURNDATASIZE  0 cds
  32 |     |       0x06  0x34  0x34                  CALLVALUE       val 0 cds
  33 |     |       0x07  0xf0  0xf0                  CREATE          addr
  34 |     |   */
  35 |     | 
  36 |     |     bytes internal constant PROXY_CHILD_BYTECODE =
  37 |     |         hex"67_36_3d_3d_37_36_3d_34_f0_3d_52_60_08_60_18_f3";
  38 |     | 
  39 |     |     //                        KECCAK256_PROXY_CHILD_BYTECODE = keccak256(PROXY_CHILD_BYTECODE);
  40 |     |     bytes32 internal constant KECCAK256_PROXY_CHILD_BYTECODE =
  41 |     |         0x21c35dbe1b344a2488cf3321d6ce542f8e9f305544ff09e4993a62319a497c1f;
  42 |     | 
  43 |     |     /**
  44 |     |     @notice Returns the size of the code on a given address
  45 |     |     @param _addr Address that may or may not contain code
  46 |     |     @return size of the code on the given `_addr`
  47 |     |   */
  48 |     |     function codeSize(address _addr) internal view returns (uint256 size) {
  49 |     |         assembly {
  50 |     |             size := extcodesize(_addr)
  51 |     |         }
  52 |     |     }
  53 |     | 
  54 |     |     /**
  55 |     |     @notice Creates a new contract with given `_creationCode` and `_salt`
  56 |     |     @param _salt Salt of the contract creation, resulting address will be derivated from this value only
  57 |     |     @param _creationCode Creation code (constructor) of the contract to be deployed, this value doesn't affect the resulting address
  58 |     |     @return addr of the deployed contract, reverts on error
  59 |     |   */
  60 |     |     function create3(bytes32 _salt, bytes memory _creationCode) internal returns (address addr) {
  61 |     |         return create3(_salt, _creationCode, 0);
  62 |     |     }
  63 |     | 
  64 |     |     /**
  65 |     |     @notice Creates a new contract with given `_creationCode` and `_salt`
  66 |     |     @param _salt Salt of the contract creation, resulting address will be derivated from this value only
  67 |     |     @param _creationCode Creation code (constructor) of the contract to be deployed, this value doesn't affect the resulting address
  68 |     |     @param _value In WEI of ETH to be forwarded to child contract
  69 |     |     @return addr of the deployed contract, reverts on error
  70 |     |   */
  71 |     |     function create3(
  72 |     |         bytes32 _salt,
  73 |     |         bytes memory _creationCode,
  74 |     |         uint256 _value
  75 |     |     ) internal returns (address addr) {
  76 |     |         // Creation code
  77 |     |         bytes memory creationCode = PROXY_CHILD_BYTECODE;
  78 |     | 
  79 |     |         // Get target final address
  80 |     |         addr = addressOf(_salt);
  81 |     |         if (codeSize(addr) != 0) revert TargetAlreadyExists();
  82 |     | 
  83 |     |         // Create CREATE2 proxy
  84 |     |         address proxy;
  85 |     |         assembly {
  86 |     |             proxy := create2(0, add(creationCode, 32), mload(creationCode), _salt)
  87 |     |         }
  88 |     |         if (proxy == address(0)) revert ErrorCreatingProxy();
  89 |     | 
  90 |     |         // Call proxy with final init code
  91 |     |         (bool success, ) = proxy.call{value: _value}(_creationCode);
  92 |     |         if (!success || codeSize(addr) == 0) revert ErrorCreatingContract();
  93 |     |     }
  94 |     | 
  95 |     |     /**
  96 |     |     @notice Computes the resulting address of a contract deployed using address(this) and the given `_salt`
  97 |     |     @param _salt Salt of the contract creation, resulting address will be derivated from this value only
  98 |     |     @return addr of the deployed contract, reverts on error
  99 |     | 
 100 |     |     @dev The address creation formula is: keccak256(rlp([keccak256(0xff ++ address(this) ++ _salt ++ keccak256(childBytecode))[12:], 0x01]))
 101 |     |   */
 102 |     |     function addressOf(bytes32 _salt) internal view returns (address) {
 103 |     |         address proxy = address(
 104 |     |             uint160(
 105 |     |                 uint256(
 106 |     |                     keccak256(
 107 |     |                         abi.encodePacked(
 108 |     |                             hex"ff",
 109 |     |                             address(this),
 110 |     |                             _salt,
 111 |     |                             KECCAK256_PROXY_CHILD_BYTECODE
 112 |     |                         )
 113 |     |                     )
 114 |     |                 )
 115 |     |             )
 116 |     |         );
 117 |     | 
 118 |     |         return address(uint160(uint256(keccak256(abi.encodePacked(hex"d6_94", proxy, hex"01")))));
 119 |     |     }
 120 |     | }
 121 |     | 

/mnt/c/Users/Lourens/Documents/Recon-Fuzz/collabs/ebtc/packages/contracts/contracts/Dependencies/ERC3156FlashLender.sol
  1 |     | // SPDX-License-Identifier: MIT
  2 |     | 
  3 |     | pragma solidity 0.8.17;
  4 |     | 
  5 |     | import "../Interfaces/IERC3156FlashLender.sol";
  6 |     | import "../Interfaces/IWETH.sol";
  7 |     | 
  8 |     | abstract contract ERC3156FlashLender is IERC3156FlashLender {
  9 |     |     uint256 public constant MAX_BPS = 10_000;
 10 |     |     uint256 public constant MAX_FEE_BPS = 1_000; // 10%
 11 |     |     bytes32 public constant FLASH_SUCCESS_VALUE = keccak256("ERC3156FlashBorrower.onFlashLoan");
 12 |     | 
 13 |     |     // Functions to modify these variables must be included in impelemnting contracts if desired
 14 |     |     uint16 public feeBps = 3; // may be subject to future adjustments through protocol governance
 15 |     |     bool public flashLoansPaused;
 16 |     | }
 17 |     | 

/mnt/c/Users/Lourens/Documents/Recon-Fuzz/collabs/ebtc/packages/contracts/contracts/Dependencies/EbtcBase.sol
   1 |     | // SPDX-License-Identifier: MIT
   2 |     | 
   3 |     | pragma solidity 0.8.17;
   4 |     | 
   5 |     | import "./BaseMath.sol";
   6 |     | import "./EbtcMath.sol";
   7 |     | import "../Interfaces/IActivePool.sol";
   8 |     | import "../Interfaces/IPriceFeed.sol";
   9 |     | import "../Interfaces/IEbtcBase.sol";
  10 |     | import "../Dependencies/ICollateralToken.sol";
  11 |     | 
  12 |     | /*
  13 |     |  * Base contract for CdpManager, BorrowerOperations. Contains global system constants and
  14 |     |  * common functions.
  15 |     |  */
  16 |     | contract EbtcBase is BaseMath, IEbtcBase {
  17 |     |     // Collateral Ratio applied for Liquidation Incentive
  18 |     |     // i.e., liquidator repay $1 worth of debt to get back $1.03 worth of collateral
  19 |     |     uint256 public constant LICR = 1030000000000000000; // 103%
  20 |     | 
  21 |     |     // Minimum collateral ratio for individual cdps
  22 | *   |     uint256 public constant MCR = 1100000000000000000; // 110%
  23 |     | 
  24 |     |     // Critical system collateral ratio. If the system's total collateral ratio (TCR) falls below the CCR, Recovery Mode is triggered.
  25 | *   |     uint256 public constant CCR = 1250000000000000000; // 125%
  26 |     | 
  27 |     |     // Amount of stETH collateral to be locked in active pool on opening cdps
  28 |     |     uint256 public constant LIQUIDATOR_REWARD = 2e17;
  29 |     | 
  30 |     |     // Minimum amount of stETH collateral a CDP must have
  31 |     |     uint256 public constant MIN_NET_STETH_BALANCE = 2e18;
  32 |     | 
  33 |     |     uint256 public constant PERCENT_DIVISOR = 200; // dividing by 200 yields 0.5%
  34 |     | 
  35 |     |     uint256 public constant BORROWING_FEE_FLOOR = 0; // 0.5%
  36 |     | 
  37 |     |     uint256 public constant STAKING_REWARD_SPLIT = 5_000; // taking 50% cut from staking reward
  38 |     | 
  39 |     |     uint256 public constant MAX_REWARD_SPLIT = 10_000;
  40 |     | 
  41 |     |     uint256 public constant MIN_CHANGE = 1000;
  42 |     | 
  43 |     |     IActivePool public immutable activePool;
  44 |     | 
  45 |     |     IPriceFeed public immutable override priceFeed;
  46 |     | 
  47 |     |     // the only collateral token allowed in CDP
  48 |     |     ICollateralToken public immutable collateral;
  49 |     | 
  50 |     |     /// @notice Initializes the contract with the provided addresses
  51 |     |     /// @param _activePoolAddress The address of the ActivePool contract
  52 |     |     /// @param _priceFeedAddress The address of the PriceFeed contract
  53 |     |     /// @param _collateralAddress The address of the CollateralToken contract
  54 |     |     constructor(address _activePoolAddress, address _priceFeedAddress, address _collateralAddress) {
  55 |     |         activePool = IActivePool(_activePoolAddress);
  56 |     |         priceFeed = IPriceFeed(_priceFeedAddress);
  57 |     |         collateral = ICollateralToken(_collateralAddress);
  58 |     |     }
  59 |     | 
  60 |     |     // --- Gas compensation functions ---
  61 |     | 
  62 |     |     function _calcNetStEthBalance(uint256 _stEthBalance) internal pure returns (uint256) {
  63 |     |         return _stEthBalance - LIQUIDATOR_REWARD;
  64 |     |     }
  65 |     | 
  66 |     |     /// @notice Get the entire system collateral
  67 |     |     /// @notice Entire system collateral = collateral allocated to system in ActivePool, using it's internal accounting
  68 |     |     /// @dev Collateral tokens stored in ActivePool for liquidator rewards, fees, or coll in CollSurplusPool, are not included
  69 | *   |     function getSystemCollShares() public view returns (uint256 entireSystemColl) {
  70 | *   |         return (activePool.getSystemCollShares());
  71 |     |     }
  72 |     | 
  73 |     |     /**
  74 |     |         @notice Get the entire system debt
  75 |     |         @notice Entire system collateral = collateral stored in ActivePool, using their internal accounting
  76 |     |      */
  77 | *   |     function _getSystemDebt() internal view returns (uint256 entireSystemDebt) {
  78 | *   |         return (activePool.getSystemDebt());
  79 |     |     }
  80 |     | 
  81 |     |     function _getCachedTCR(uint256 _price) internal view returns (uint256 TCR) {
  82 |     |         (TCR, , ) = _getTCRWithSystemDebtAndCollShares(_price);
  83 |     |     }
  84 |     | 
  85 | *   |     function _getTCRWithSystemDebtAndCollShares(
  86 |     |         uint256 _price
  87 | *   |     ) internal view returns (uint256 TCR, uint256 _coll, uint256 _debt) {
  88 | *   |         uint256 systemCollShares = getSystemCollShares();
  89 | *   |         uint256 systemDebt = _getSystemDebt();
  90 |     | 
  91 | *   |         uint256 _systemStEthBalance = collateral.getPooledEthByShares(systemCollShares);
  92 | *   |         TCR = EbtcMath._computeCR(_systemStEthBalance, systemDebt, _price);
  93 |     | 
  94 | *   |         return (TCR, systemCollShares, systemDebt);
  95 |     |     }
  96 |     | 
  97 |     |     function _checkRecoveryMode(uint256 _price) internal view returns (bool) {
  98 |     |         return _checkRecoveryModeForTCR(_getCachedTCR(_price));
  99 |     |     }
 100 |     | 
 101 | *   |     function _checkRecoveryModeForTCR(uint256 _tcr) internal view returns (bool) {
 102 | *   |         return _tcr < CCR;
 103 |     |     }
 104 |     | 
 105 |     |     function _requireUserAcceptsFee(
 106 |     |         uint256 _fee,
 107 |     |         uint256 _amount,
 108 |     |         uint256 _maxFeePercentage
 109 |     |     ) internal pure {
 110 |     |         uint256 feePercentage = (_fee * DECIMAL_PRECISION) / _amount;
 111 |     |         require(feePercentage <= _maxFeePercentage, "Fee exceeded provided maximum");
 112 |     |     }
 113 |     | 
 114 |     |     // Convert debt denominated in ETH to debt denominated in BTC given that _price is ETH/BTC
 115 |     |     // _debt is denominated in ETH
 116 |     |     // _price is ETH/BTC
 117 |     |     function _convertDebtDenominationToBtc(
 118 |     |         uint256 _debt,
 119 |     |         uint256 _price
 120 |     |     ) internal pure returns (uint256) {
 121 |     |         return (_debt * _price) / DECIMAL_PRECISION;
 122 |     |     }
 123 |     | 
 124 |     |     /// @dev return true if given ICR is qualified for liquidation compared to configured threshold
 125 |     |     /// @dev this function ONLY checks numbers not check grace period switch for Recovery Mode
 126 | *   |     function _checkICRAgainstLiqThreshold(uint256 _icr, uint _tcr) internal view returns (bool) {
 127 |     |         // Either undercollateralized
 128 |     |         // OR, it's RM AND they meet the requirement
 129 |     |         // Swapped Requirement && RM to save gas
 130 |     |         return
 131 | *   |             _checkICRAgainstMCR(_icr) ||
 132 | *   |             (_checkICRAgainstTCR(_icr, _tcr) && _checkRecoveryModeForTCR(_tcr));
 133 |     |     }
 134 |     | 
 135 |     |     /// @dev return true if given ICR is qualified for liquidation compared to MCR
 136 | *   |     function _checkICRAgainstMCR(uint256 _icr) internal view returns (bool) {
 137 | *   |         return _icr < MCR;
 138 |     |     }
 139 |     | 
 140 |     |     /// @dev return true if given ICR is qualified for liquidation compared to TCR
 141 |     |     /// @dev typically used in Recovery Mode
 142 |     |     function _checkICRAgainstTCR(uint256 _icr, uint _tcr) internal view returns (bool) {
 143 |     |         /// @audit is _icr <= _tcr more dangerous for overal system safety?
 144 |     |         /// @audit Should we use _icr < CCR to allow any risky CDP being liquidated?
 145 | *   |         return _icr <= _tcr;
 146 |     |     }
 147 |     | }
 148 |     | 

/mnt/c/Users/Lourens/Documents/Recon-Fuzz/collabs/ebtc/packages/contracts/contracts/Dependencies/EbtcMath.sol
   1 |     | // SPDX-License-Identifier: MIT
   2 |     | 
   3 |     | pragma solidity 0.8.17;
   4 |     | 
   5 |     | library EbtcMath {
   6 |     |     uint256 internal constant DECIMAL_PRECISION = 1e18;
   7 |     |     uint256 public constant MAX_TCR = type(uint256).max;
   8 |     | 
   9 |     |     /* Precision for Nominal ICR (independent of price). Rationale for the value:
  10 |     |      *
  11 |     |      * - Making it “too high” could lead to overflows.
  12 |     |      * - Making it “too low” could lead to an ICR equal to zero, due to truncation from Solidity floor division.
  13 |     |      *
  14 |     |      * This value of 1e20 is chosen for safety: the NICR will only overflow for numerator > ~1e39 ETH,
  15 |     |      * and will only truncate to 0 if the denominator is at least 1e20 times greater than the numerator.
  16 |     |      *
  17 |     |      */
  18 |     |     uint256 internal constant NICR_PRECISION = 1e20;
  19 |     | 
  20 |     |     function _min(uint256 _a, uint256 _b) internal pure returns (uint256) {
  21 |     |         return (_a < _b) ? _a : _b;
  22 |     |     }
  23 |     | 
  24 |     |     function _max(uint256 _a, uint256 _b) internal pure returns (uint256) {
  25 |     |         return (_a >= _b) ? _a : _b;
  26 |     |     }
  27 |     | 
  28 |     |     /**
  29 |     |      * credit to OpenZeppelin
  30 |     |      * @dev Returns the downcasted uint128 from uint256, reverting on
  31 |     |      * overflow (when the input is greater than largest uint128).
  32 |     |      *
  33 |     |      * Counterpart to Solidity's `uint128` operator.
  34 |     |      *
  35 |     |      * Requirements:
  36 |     |      *
  37 |     |      * - input must fit into 128 bits
  38 |     |      */
  39 |     |     function toUint128(uint256 value) internal pure returns (uint128) {
  40 |     |         require(value <= type(uint128).max, "EbtcMath: downcast to uint128 will overflow");
  41 |     |         return uint128(value);
  42 |     |     }
  43 |     | 
  44 |     |     /*
  45 |     |      * Multiply two decimal numbers and use normal rounding rules:
  46 |     |      * -round product up if 19'th mantissa digit >= 5
  47 |     |      * -round product down if 19'th mantissa digit < 5
  48 |     |      *
  49 |     |      * Used only inside the exponentiation, _decPow().
  50 |     |      */
  51 |     |     function decMul(uint256 x, uint256 y) internal pure returns (uint256 decProd) {
  52 |     |         uint256 prod_xy = x * y;
  53 |     | 
  54 |     |         decProd = (prod_xy + (DECIMAL_PRECISION / 2)) / DECIMAL_PRECISION;
  55 |     |     }
  56 |     | 
  57 |     |     /*
  58 |     |      * _decPow: Exponentiation function for 18-digit decimal base, and integer exponent n.
  59 |     |      *
  60 |     |      * Uses the efficient "exponentiation by squaring" algorithm. O(log(n)) complexity.
  61 |     |      *
  62 |     |      * Called by two functions that represent time in units of minutes:
  63 |     |      * 1) CdpManager._calcDecayedBaseRate
  64 |     |      * 2) CommunityIssuance._getCumulativeIssuanceFraction
  65 |     |      *
  66 |     |      * The exponent is capped to avoid reverting due to overflow. The cap 525600000 equals
  67 |     |      * "minutes in 1000 years": 60 * 24 * 365 * 1000
  68 |     |      *
  69 |     |      * If a period of > 1000 years is ever used as an exponent in either of the above functions, the result will be
  70 |     |      * negligibly different from just passing the cap, since:
  71 |     |      *
  72 |     |      * In function 1), the decayed base rate will be 0 for 1000 years or > 1000 years
  73 |     |      * In function 2), the difference in tokens issued at 1000 years and any time > 1000 years, will be negligible
  74 |     |      */
  75 |     |     function _decPow(uint256 _base, uint256 _minutes) internal pure returns (uint256) {
  76 |     |         if (_minutes > 525600000) {
  77 |     |             _minutes = 525600000;
  78 |     |         } // cap to avoid overflow
  79 |     | 
  80 |     |         if (_minutes == 0) {
  81 |     |             return DECIMAL_PRECISION;
  82 |     |         }
  83 |     | 
  84 |     |         uint256 y = DECIMAL_PRECISION;
  85 |     |         uint256 x = _base;
  86 |     |         uint256 n = _minutes;
  87 |     | 
  88 |     |         // Exponentiation-by-squaring
  89 |     |         while (n > 1) {
  90 |     |             if (n % 2 == 0) {
  91 |     |                 x = decMul(x, x);
  92 |     |                 n = n / 2;
  93 |     |             } else {
  94 |     |                 // if (n % 2 != 0)
  95 |     |                 y = decMul(x, y);
  96 |     |                 x = decMul(x, x);
  97 |     |                 n = (n - 1) / 2;
  98 |     |             }
  99 |     |         }
 100 |     | 
 101 |     |         return decMul(x, y);
 102 |     |     }
 103 |     | 
 104 |     |     function _getAbsoluteDifference(uint256 _a, uint256 _b) internal pure returns (uint256) {
 105 |     |         return (_a >= _b) ? (_a - _b) : (_b - _a);
 106 |     |     }
 107 |     | 
 108 |     |     function _computeNominalCR(uint256 _collShares, uint256 _debt) internal pure returns (uint256) {
 109 |     |         if (_debt > 0) {
 110 |     |             return (_collShares * NICR_PRECISION) / _debt;
 111 |     |         }
 112 |     |         // Return the maximal value for uint256 if the Cdp has a debt of 0. Represents "infinite" CR.
 113 |     |         else {
 114 |     |             // if (_debt == 0)
 115 |     |             return MAX_TCR;
 116 |     |         }
 117 |     |     }
 118 |     | 
 119 |     |     /// @dev Compute collateralization ratio, given stETH balance, price, and debt balance
 120 | *   |     function _computeCR(
 121 |     |         uint256 _stEthBalance,
 122 |     |         uint256 _debt,
 123 |     |         uint256 _price
 124 | *   |     ) internal pure returns (uint256) {
 125 | *   |         if (_debt > 0) {
 126 | *   |             uint256 newCollRatio = (_stEthBalance * _price) / _debt;
 127 |     | 
 128 | *   |             return newCollRatio;
 129 |     |         }
 130 |     |         // Return the maximal value for uint256 if the Cdp has a debt of 0. Represents "infinite" CR.
 131 |     |         else {
 132 |     |             // if (_debt == 0)
 133 |     |             return MAX_TCR;
 134 |     |         }
 135 |     |     }
 136 |     | }
 137 |     | 

/mnt/c/Users/Lourens/Documents/Recon-Fuzz/collabs/ebtc/packages/contracts/contracts/Dependencies/EnumerableSet.sol
   1 |     | // SPDX-License-Identifier: MIT
   2 |     | // OpenZeppelin Contracts (last updated v4.8.0) (utils/structs/EnumerableSet.sol)
   3 |     | // This file was procedurally generated from scripts/generate/templates/EnumerableSet.js.
   4 |     | 
   5 |     | pragma solidity 0.8.17;
   6 |     | 
   7 |     | /**
   8 |     |  * @dev Library for managing
   9 |     |  * https://en.wikipedia.org/wiki/Set_(abstract_data_type)[sets] of primitive
  10 |     |  * types.
  11 |     |  *
  12 |     |  * Sets have the following properties:
  13 |     |  *
  14 |     |  * - Elements are added, removed, and checked for existence in constant time
  15 |     |  * (O(1)).
  16 |     |  * - Elements are enumerated in O(n). No guarantees are made on the ordering.
  17 |     |  *
  18 |     |  * ```solidity
  19 |     |  * contract Example {
  20 |     |  *     // Add the library methods
  21 |     |  *     using EnumerableSet for EnumerableSet.AddressSet;
  22 |     |  *
  23 |     |  *     // Declare a set state variable
  24 |     |  *     EnumerableSet.AddressSet private mySet;
  25 |     |  * }
  26 |     |  * ```
  27 |     |  *
  28 |     |  * As of v3.3.0, sets of type `bytes32` (`Bytes32Set`), `address` (`AddressSet`)
  29 |     |  * and `uint256` (`UintSet`) are supported.
  30 |     |  *
  31 |     |  * [WARNING]
  32 |     |  * ====
  33 |     |  * Trying to delete such a structure from storage will likely result in data corruption, rendering the structure
  34 |     |  * unusable.
  35 |     |  * See https://github.com/ethereum/solidity/pull/11843[ethereum/solidity#11843] for more info.
  36 |     |  *
  37 |     |  * In order to clean an EnumerableSet, you can either remove all elements one by one or create a fresh instance using an
  38 |     |  * array of EnumerableSet.
  39 |     |  * ====
  40 |     |  */
  41 |     | library EnumerableSet {
  42 |     |     // To implement this library for multiple types with as little code
  43 |     |     // repetition as possible, we write it in terms of a generic Set type with
  44 |     |     // bytes32 values.
  45 |     |     // The Set implementation uses private functions, and user-facing
  46 |     |     // implementations (such as AddressSet) are just wrappers around the
  47 |     |     // underlying Set.
  48 |     |     // This means that we can only create new EnumerableSets for types that fit
  49 |     |     // in bytes32.
  50 |     | 
  51 |     |     struct Set {
  52 |     |         // Storage of set values
  53 |     |         bytes32[] _values;
  54 |     |         // Position of the value in the `values` array, plus 1 because index 0
  55 |     |         // means a value is not in the set.
  56 |     |         mapping(bytes32 => uint256) _indexes;
  57 |     |     }
  58 |     | 
  59 |     |     /**
  60 |     |      * @dev Add a value to a set. O(1).
  61 |     |      *
  62 |     |      * Returns true if the value was added to the set, that is if it was not
  63 |     |      * already present.
  64 |     |      */
  65 |     |     function _add(Set storage set, bytes32 value) private returns (bool) {
  66 |     |         if (!_contains(set, value)) {
  67 |     |             set._values.push(value);
  68 |     |             // The value is stored at length-1, but we add 1 to all indexes
  69 |     |             // and use 0 as a sentinel value
  70 |     |             set._indexes[value] = set._values.length;
  71 |     |             return true;
  72 |     |         } else {
  73 |     |             return false;
  74 |     |         }
  75 |     |     }
  76 |     | 
  77 |     |     /**
  78 |     |      * @dev Removes a value from a set. O(1).
  79 |     |      *
  80 |     |      * Returns true if the value was removed from the set, that is if it was
  81 |     |      * present.
  82 |     |      */
  83 |     |     function _remove(Set storage set, bytes32 value) private returns (bool) {
  84 |     |         // We read and store the value's index to prevent multiple reads from the same storage slot
  85 |     |         uint256 valueIndex = set._indexes[value];
  86 |     | 
  87 |     |         if (valueIndex != 0) {
  88 |     |             // Equivalent to contains(set, value)
  89 |     |             // To delete an element from the _values array in O(1), we swap the element to delete with the last one in
  90 |     |             // the array, and then remove the last element (sometimes called as 'swap and pop').
  91 |     |             // This modifies the order of the array, as noted in {at}.
  92 |     | 
  93 |     |             uint256 toDeleteIndex = valueIndex - 1;
  94 |     |             uint256 lastIndex = set._values.length - 1;
  95 |     | 
  96 |     |             if (lastIndex != toDeleteIndex) {
  97 |     |                 bytes32 lastValue = set._values[lastIndex];
  98 |     | 
  99 |     |                 // Move the last value to the index where the value to delete is
 100 |     |                 set._values[toDeleteIndex] = lastValue;
 101 |     |                 // Update the index for the moved value
 102 |     |                 set._indexes[lastValue] = valueIndex; // Replace lastValue's index to valueIndex
 103 |     |             }
 104 |     | 
 105 |     |             // Delete the slot where the moved value was stored
 106 |     |             set._values.pop();
 107 |     | 
 108 |     |             // Delete the index for the deleted slot
 109 |     |             delete set._indexes[value];
 110 |     | 
 111 |     |             return true;
 112 |     |         } else {
 113 |     |             return false;
 114 |     |         }
 115 |     |     }
 116 |     | 
 117 |     |     /**
 118 |     |      * @dev Returns true if the value is in the set. O(1).
 119 |     |      */
 120 |     |     function _contains(Set storage set, bytes32 value) private view returns (bool) {
 121 |     |         return set._indexes[value] != 0;
 122 |     |     }
 123 |     | 
 124 |     |     /**
 125 |     |      * @dev Returns the number of values on the set. O(1).
 126 |     |      */
 127 |     |     function _length(Set storage set) private view returns (uint256) {
 128 |     |         return set._values.length;
 129 |     |     }
 130 |     | 
 131 |     |     /**
 132 |     |      * @dev Returns the value stored at position `index` in the set. O(1).
 133 |     |      *
 134 |     |      * Note that there are no guarantees on the ordering of values inside the
 135 |     |      * array, and it may change when more values are added or removed.
 136 |     |      *
 137 |     |      * Requirements:
 138 |     |      *
 139 |     |      * - `index` must be strictly less than {length}.
 140 |     |      */
 141 |     |     function _at(Set storage set, uint256 index) private view returns (bytes32) {
 142 |     |         return set._values[index];
 143 |     |     }
 144 |     | 
 145 |     |     /**
 146 |     |      * @dev Return the entire set in an array
 147 |     |      *
 148 |     |      * WARNING: This operation will copy the entire storage to memory, which can be quite expensive. This is designed
 149 |     |      * to mostly be used by view accessors that are queried without any gas fees. Developers should keep in mind that
 150 |     |      * this function has an unbounded cost, and using it as part of a state-changing function may render the function
 151 |     |      * uncallable if the set grows to a point where copying to memory consumes too much gas to fit in a block.
 152 |     |      */
 153 |     |     function _values(Set storage set) private view returns (bytes32[] memory) {
 154 |     |         return set._values;
 155 |     |     }
 156 |     | 
 157 |     |     // Bytes32Set
 158 |     | 
 159 |     |     struct Bytes32Set {
 160 |     |         Set _inner;
 161 |     |     }
 162 |     | 
 163 |     |     /**
 164 |     |      * @dev Add a value to a set. O(1).
 165 |     |      *
 166 |     |      * Returns true if the value was added to the set, that is if it was not
 167 |     |      * already present.
 168 |     |      */
 169 |     |     function add(Bytes32Set storage set, bytes32 value) internal returns (bool) {
 170 |     |         return _add(set._inner, value);
 171 |     |     }
 172 |     | 
 173 |     |     /**
 174 |     |      * @dev Removes a value from a set. O(1).
 175 |     |      *
 176 |     |      * Returns true if the value was removed from the set, that is if it was
 177 |     |      * present.
 178 |     |      */
 179 |     |     function remove(Bytes32Set storage set, bytes32 value) internal returns (bool) {
 180 |     |         return _remove(set._inner, value);
 181 |     |     }
 182 |     | 
 183 |     |     /**
 184 |     |      * @dev Returns true if the value is in the set. O(1).
 185 |     |      */
 186 |     |     function contains(Bytes32Set storage set, bytes32 value) internal view returns (bool) {
 187 |     |         return _contains(set._inner, value);
 188 |     |     }
 189 |     | 
 190 |     |     /**
 191 |     |      * @dev Returns the number of values in the set. O(1).
 192 |     |      */
 193 |     |     function length(Bytes32Set storage set) internal view returns (uint256) {
 194 |     |         return _length(set._inner);
 195 |     |     }
 196 |     | 
 197 |     |     /**
 198 |     |      * @dev Returns the value stored at position `index` in the set. O(1).
 199 |     |      *
 200 |     |      * Note that there are no guarantees on the ordering of values inside the
 201 |     |      * array, and it may change when more values are added or removed.
 202 |     |      *
 203 |     |      * Requirements:
 204 |     |      *
 205 |     |      * - `index` must be strictly less than {length}.
 206 |     |      */
 207 |     |     function at(Bytes32Set storage set, uint256 index) internal view returns (bytes32) {
 208 |     |         return _at(set._inner, index);
 209 |     |     }
 210 |     | 
 211 |     |     /**
 212 |     |      * @dev Return the entire set in an array
 213 |     |      *
 214 |     |      * WARNING: This operation will copy the entire storage to memory, which can be quite expensive. This is designed
 215 |     |      * to mostly be used by view accessors that are queried without any gas fees. Developers should keep in mind that
 216 |     |      * this function has an unbounded cost, and using it as part of a state-changing function may render the function
 217 |     |      * uncallable if the set grows to a point where copying to memory consumes too much gas to fit in a block.
 218 |     |      */
 219 |     |     function values(Bytes32Set storage set) internal view returns (bytes32[] memory) {
 220 |     |         bytes32[] memory store = _values(set._inner);
 221 |     |         bytes32[] memory result;
 222 |     | 
 223 |     |         /// @solidity memory-safe-assembly
 224 |     |         assembly {
 225 |     |             result := store
 226 |     |         }
 227 |     | 
 228 |     |         return result;
 229 |     |     }
 230 |     | 
 231 |     |     // AddressSet
 232 |     | 
 233 |     |     struct AddressSet {
 234 |     |         Set _inner;
 235 |     |     }
 236 |     | 
 237 |     |     /**
 238 |     |      * @dev Add a value to a set. O(1).
 239 |     |      *
 240 |     |      * Returns true if the value was added to the set, that is if it was not
 241 |     |      * already present.
 242 |     |      */
 243 |     |     function add(AddressSet storage set, address value) internal returns (bool) {
 244 |     |         return _add(set._inner, bytes32(uint256(uint160(value))));
 245 |     |     }
 246 |     | 
 247 |     |     /**
 248 |     |      * @dev Removes a value from a set. O(1).
 249 |     |      *
 250 |     |      * Returns true if the value was removed from the set, that is if it was
 251 |     |      * present.
 252 |     |      */
 253 |     |     function remove(AddressSet storage set, address value) internal returns (bool) {
 254 |     |         return _remove(set._inner, bytes32(uint256(uint160(value))));
 255 |     |     }
 256 |     | 
 257 |     |     /**
 258 |     |      * @dev Returns true if the value is in the set. O(1).
 259 |     |      */
 260 |     |     function contains(AddressSet storage set, address value) internal view returns (bool) {
 261 |     |         return _contains(set._inner, bytes32(uint256(uint160(value))));
 262 |     |     }
 263 |     | 
 264 |     |     /**
 265 |     |      * @dev Returns the number of values in the set. O(1).
 266 |     |      */
 267 |     |     function length(AddressSet storage set) internal view returns (uint256) {
 268 |     |         return _length(set._inner);
 269 |     |     }
 270 |     | 
 271 |     |     /**
 272 |     |      * @dev Returns the value stored at position `index` in the set. O(1).
 273 |     |      *
 274 |     |      * Note that there are no guarantees on the ordering of values inside the
 275 |     |      * array, and it may change when more values are added or removed.
 276 |     |      *
 277 |     |      * Requirements:
 278 |     |      *
 279 |     |      * - `index` must be strictly less than {length}.
 280 |     |      */
 281 |     |     function at(AddressSet storage set, uint256 index) internal view returns (address) {
 282 |     |         return address(uint160(uint256(_at(set._inner, index))));
 283 |     |     }
 284 |     | 
 285 |     |     /**
 286 |     |      * @dev Return the entire set in an array
 287 |     |      *
 288 |     |      * WARNING: This operation will copy the entire storage to memory, which can be quite expensive. This is designed
 289 |     |      * to mostly be used by view accessors that are queried without any gas fees. Developers should keep in mind that
 290 |     |      * this function has an unbounded cost, and using it as part of a state-changing function may render the function
 291 |     |      * uncallable if the set grows to a point where copying to memory consumes too much gas to fit in a block.
 292 |     |      */
 293 |     |     function values(AddressSet storage set) internal view returns (address[] memory) {
 294 |     |         bytes32[] memory store = _values(set._inner);
 295 |     |         address[] memory result;
 296 |     | 
 297 |     |         /// @solidity memory-safe-assembly
 298 |     |         assembly {
 299 |     |             result := store
 300 |     |         }
 301 |     | 
 302 |     |         return result;
 303 |     |     }
 304 |     | 
 305 |     |     // UintSet
 306 |     | 
 307 |     |     struct UintSet {
 308 |     |         Set _inner;
 309 |     |     }
 310 |     | 
 311 |     |     /**
 312 |     |      * @dev Add a value to a set. O(1).
 313 |     |      *
 314 |     |      * Returns true if the value was added to the set, that is if it was not
 315 |     |      * already present.
 316 |     |      */
 317 |     |     function add(UintSet storage set, uint256 value) internal returns (bool) {
 318 |     |         return _add(set._inner, bytes32(value));
 319 |     |     }
 320 |     | 
 321 |     |     /**
 322 |     |      * @dev Removes a value from a set. O(1).
 323 |     |      *
 324 |     |      * Returns true if the value was removed from the set, that is if it was
 325 |     |      * present.
 326 |     |      */
 327 |     |     function remove(UintSet storage set, uint256 value) internal returns (bool) {
 328 |     |         return _remove(set._inner, bytes32(value));
 329 |     |     }
 330 |     | 
 331 |     |     /**
 332 |     |      * @dev Returns true if the value is in the set. O(1).
 333 |     |      */
 334 |     |     function contains(UintSet storage set, uint256 value) internal view returns (bool) {
 335 |     |         return _contains(set._inner, bytes32(value));
 336 |     |     }
 337 |     | 
 338 |     |     /**
 339 |     |      * @dev Returns the number of values in the set. O(1).
 340 |     |      */
 341 |     |     function length(UintSet storage set) internal view returns (uint256) {
 342 |     |         return _length(set._inner);
 343 |     |     }
 344 |     | 
 345 |     |     /**
 346 |     |      * @dev Returns the value stored at position `index` in the set. O(1).
 347 |     |      *
 348 |     |      * Note that there are no guarantees on the ordering of values inside the
 349 |     |      * array, and it may change when more values are added or removed.
 350 |     |      *
 351 |     |      * Requirements:
 352 |     |      *
 353 |     |      * - `index` must be strictly less than {length}.
 354 |     |      */
 355 |     |     function at(UintSet storage set, uint256 index) internal view returns (uint256) {
 356 |     |         return uint256(_at(set._inner, index));
 357 |     |     }
 358 |     | 
 359 |     |     /**
 360 |     |      * @dev Return the entire set in an array
 361 |     |      *
 362 |     |      * WARNING: This operation will copy the entire storage to memory, which can be quite expensive. This is designed
 363 |     |      * to mostly be used by view accessors that are queried without any gas fees. Developers should keep in mind that
 364 |     |      * this function has an unbounded cost, and using it as part of a state-changing function may render the function
 365 |     |      * uncallable if the set grows to a point where copying to memory consumes too much gas to fit in a block.
 366 |     |      */
 367 |     |     function values(UintSet storage set) internal view returns (uint256[] memory) {
 368 |     |         bytes32[] memory store = _values(set._inner);
 369 |     |         uint256[] memory result;
 370 |     | 
 371 |     |         /// @solidity memory-safe-assembly
 372 |     |         assembly {
 373 |     |             result := store
 374 |     |         }
 375 |     | 
 376 |     |         return result;
 377 |     |     }
 378 |     | }
 379 |     | 

/mnt/c/Users/Lourens/Documents/Recon-Fuzz/collabs/ebtc/packages/contracts/contracts/Dependencies/ICollateralToken.sol
  1 |     | // SPDX-License-Identifier: MIT
  2 |     | pragma solidity 0.8.17;
  3 |     | 
  4 |     | import "./IERC20.sol";
  5 |     | 
  6 |     | /**
  7 |     |  * Based on the stETH:
  8 |     |  *  -   https://docs.lido.fi/contracts/lido#
  9 |     |  */
 10 |     | interface ICollateralToken is IERC20 {
 11 |     |     // Returns the amount of shares that corresponds to _ethAmount protocol-controlled Ether
 12 |     |     function getSharesByPooledEth(uint256 _ethAmount) external view returns (uint256);
 13 |     | 
 14 |     |     // Returns the amount of Ether that corresponds to _sharesAmount token shares
 15 |     |     function getPooledEthByShares(uint256 _sharesAmount) external view returns (uint256);
 16 |     | 
 17 |     |     // Moves `_sharesAmount` token shares from the caller's account to the `_recipient` account.
 18 |     |     function transferShares(address _recipient, uint256 _sharesAmount) external returns (uint256);
 19 |     | 
 20 |     |     // Returns the amount of shares owned by _account
 21 |     |     function sharesOf(address _account) external view returns (uint256);
 22 |     | 
 23 |     |     // Returns authorized oracle address
 24 |     |     function getOracle() external view returns (address);
 25 |     | }
 26 |     | 

/mnt/c/Users/Lourens/Documents/Recon-Fuzz/collabs/ebtc/packages/contracts/contracts/Dependencies/ICollateralTokenOracle.sol
  1 |     | // SPDX-License-Identifier: MIT
  2 |     | pragma solidity 0.8.17;
  3 |     | 
  4 |     | /**
  5 |     |  * Based on the stETH:
  6 |     |  *  -   https://docs.lido.fi/contracts/lido#
  7 |     |  */
  8 |     | interface ICollateralTokenOracle {
  9 |     |     // Return beacon specification data.
 10 |     |     function getBeaconSpec()
 11 |     |         external
 12 |     |         view
 13 |     |         returns (
 14 |     |             uint64 epochsPerFrame,
 15 |     |             uint64 slotsPerEpoch,
 16 |     |             uint64 secondsPerSlot,
 17 |     |             uint64 genesisTime
 18 |     |         );
 19 |     | }
 20 |     | 

/mnt/c/Users/Lourens/Documents/Recon-Fuzz/collabs/ebtc/packages/contracts/contracts/Dependencies/IERC20.sol
  1 |     | // SPDX-License-Identifier: MIT
  2 |     | 
  3 |     | pragma solidity 0.8.17;
  4 |     | 
  5 |     | /**
  6 |     |  * Based on the OpenZeppelin IER20 interface:
  7 |     |  * https://github.com/OpenZeppelin/openzeppelin-contracts/blob/master/contracts/token/ERC20/IERC20.sol
  8 |     |  *
  9 |     |  * @dev Interface of the ERC20 standard as defined in the EIP.
 10 |     |  */
 11 |     | interface IERC20 {
 12 |     |     /**
 13 |     |      * @dev Returns the amount of tokens in existence.
 14 |     |      */
 15 |     |     function totalSupply() external view returns (uint256);
 16 |     | 
 17 |     |     /**
 18 |     |      * @dev Returns the amount of tokens owned by `account`.
 19 |     |      */
 20 |     |     function balanceOf(address account) external view returns (uint256);
 21 |     | 
 22 |     |     /**
 23 |     |      * @dev Moves `amount` tokens from the caller's account to `recipient`.
 24 |     |      *
 25 |     |      * Returns a boolean value indicating whether the operation succeeded.
 26 |     |      *
 27 |     |      * Emits a {Transfer} event.
 28 |     |      */
 29 |     |     function transfer(address recipient, uint256 amount) external returns (bool);
 30 |     | 
 31 |     |     /**
 32 |     |      * @dev Returns the remaining number of tokens that `spender` will be
 33 |     |      * allowed to spend on behalf of `owner` through {transferFrom}. This is
 34 |     |      * zero by default.
 35 |     |      *
 36 |     |      * This value changes when {approve} or {transferFrom} are called.
 37 |     |      */
 38 |     |     function allowance(address owner, address spender) external view returns (uint256);
 39 |     | 
 40 |     |     function increaseAllowance(address spender, uint256 addedValue) external returns (bool);
 41 |     | 
 42 |     |     function decreaseAllowance(address spender, uint256 subtractedValue) external returns (bool);
 43 |     | 
 44 |     |     /**
 45 |     |      * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.
 46 |     |      *
 47 |     |      * Returns a boolean value indicating whether the operation succeeded.
 48 |     |      *
 49 |     |      * IMPORTANT: Beware that changing an allowance with this method brings the risk
 50 |     |      * that someone may use both the old and the new allowance by unfortunate
 51 |     |      * transaction ordering. One possible solution to mitigate this race
 52 |     |      * condition is to first reduce the spender's allowance to 0 and set the
 53 |     |      * desired value afterwards:
 54 |     |      * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729
 55 |     |      *
 56 |     |      * Emits an {Approval} event.
 57 |     |      */
 58 |     |     function approve(address spender, uint256 amount) external returns (bool);
 59 |     | 
 60 |     |     /**
 61 |     |      * @dev Moves `amount` tokens from `sender` to `recipient` using the
 62 |     |      * allowance mechanism. `amount` is then deducted from the caller's
 63 |     |      * allowance.
 64 |     |      *
 65 |     |      * Returns a boolean value indicating whether the operation succeeded.
 66 |     |      *
 67 |     |      * Emits a {Transfer} event.
 68 |     |      */
 69 |     |     function transferFrom(address sender, address recipient, uint256 amount) external returns (bool);
 70 |     | 
 71 |     |     function name() external view returns (string memory);
 72 |     | 
 73 |     |     function symbol() external view returns (string memory);
 74 |     | 
 75 |     |     function decimals() external view returns (uint8);
 76 |     | 
 77 |     |     /**
 78 |     |      * @dev Emitted when `value` tokens are moved from one account (`from`) to
 79 |     |      * another (`to`).
 80 |     |      *
 81 |     |      * Note that `value` may be zero.
 82 |     |      */
 83 |     |     event Transfer(address indexed from, address indexed to, uint256 value);
 84 |     | 
 85 |     |     /**
 86 |     |      * @dev Emitted when the allowance of a `spender` for an `owner` is set by
 87 |     |      * a call to {approve}. `value` is the new allowance.
 88 |     |      */
 89 |     |     event Approval(address indexed owner, address indexed spender, uint256 value);
 90 |     | }
 91 |     | 

/mnt/c/Users/Lourens/Documents/Recon-Fuzz/collabs/ebtc/packages/contracts/contracts/Dependencies/IERC2612.sol
  1 |     | // SPDX-License-Identifier: MIT
  2 |     | 
  3 |     | pragma solidity 0.8.17;
  4 |     | 
  5 |     | /**
  6 |     |  * @dev Interface of the ERC2612 standard as defined in the EIP.
  7 |     |  *
  8 |     |  * Adds the {permit} method, which can be used to change one's
  9 |     |  * {IERC20-allowance} without having to send a transaction, by signing a
 10 |     |  * message. This allows users to spend tokens without having to hold Ether.
 11 |     |  *
 12 |     |  * See https://eips.ethereum.org/EIPS/eip-2612.
 13 |     |  *
 14 |     |  * Code adapted from https://github.com/OpenZeppelin/openzeppelin-contracts/pull/2237/
 15 |     |  */
 16 |     | interface IERC2612 {
 17 |     |     /**
 18 |     |      * @dev Sets `amount` as the allowance of `spender` over `owner`'s tokens,
 19 |     |      * given `owner`'s signed approval.
 20 |     |      *
 21 |     |      * IMPORTANT: The same issues {IERC20-approve} has related to transaction
 22 |     |      * ordering also apply here.
 23 |     |      *
 24 |     |      * Emits an {Approval} event.
 25 |     |      *
 26 |     |      * Requirements:
 27 |     |      *
 28 |     |      * - `owner` cannot be the zero address.
 29 |     |      * - `spender` cannot be the zero address.
 30 |     |      * - `deadline` must be a timestamp in the future.
 31 |     |      * - `v`, `r` and `s` must be a valid `secp256k1` signature from `owner`
 32 |     |      * over the EIP712-formatted function arguments.
 33 |     |      * - the signature must use ``owner``'s current nonce (see {nonces}).
 34 |     |      *
 35 |     |      * For more information on the signature format, see the
 36 |     |      * https://eips.ethereum.org/EIPS/eip-2612#specification[relevant EIP
 37 |     |      * section].
 38 |     |      */
 39 |     |     function permit(
 40 |     |         address owner,
 41 |     |         address spender,
 42 |     |         uint256 amount,
 43 |     |         uint256 deadline,
 44 |     |         uint8 v,
 45 |     |         bytes32 r,
 46 |     |         bytes32 s
 47 |     |     ) external;
 48 |     | 
 49 |     |     /**
 50 |     |      * @dev Returns the current ERC2612 nonce for `owner`. This value must be
 51 |     |      * included whenever a signature is generated for {permit}.
 52 |     |      *
 53 |     |      * Every successful call to {permit} increases `owner`'s nonce by one. This
 54 |     |      * prevents a signature from being used multiple times.
 55 |     |      *
 56 |     |      * `owner` can limit the time a Permit is valid for by setting `deadline` to
 57 |     |      * a value in the near future. The deadline argument can be set to uint256(-1) to
 58 |     |      * create Permits that effectively never expire.
 59 |     |      */
 60 |     |     function nonces(address owner) external view returns (uint256);
 61 |     | 
 62 |     |     function version() external view returns (string memory);
 63 |     | 
 64 |     |     function permitTypeHash() external view returns (bytes32);
 65 |     | 
 66 |     |     function domainSeparator() external view returns (bytes32);
 67 |     | }
 68 |     | 

/mnt/c/Users/Lourens/Documents/Recon-Fuzz/collabs/ebtc/packages/contracts/contracts/Dependencies/IRolesAuthority.sol
  1 |     | // SPDX-License-Identifier: AGPL-3.0-only
  2 |     | pragma solidity 0.8.17;
  3 |     | 
  4 |     | import "./EnumerableSet.sol";
  5 |     | 
  6 |     | /// @notice Role based Authority that supports up to 256 roles.
  7 |     | /// @author BadgerDAO
  8 |     | /// @author Modified from Solmate (https://github.com/transmissions11/solmate/blob/main/src/auth/authorities/RolesAuthority.sol)
  9 |     | /// @author Modified from Dappsys (https://github.com/dapphub/ds-roles/blob/master/src/roles.sol)
 10 |     | interface IRolesAuthority {
 11 |     |     event UserRoleUpdated(address indexed user, uint8 indexed role, bool enabled);
 12 |     | 
 13 |     |     event PublicCapabilityUpdated(address indexed target, bytes4 indexed functionSig, bool enabled);
 14 |     |     event CapabilityBurned(address indexed target, bytes4 indexed functionSig);
 15 |     | 
 16 |     |     event RoleCapabilityUpdated(
 17 |     |         uint8 indexed role,
 18 |     |         address indexed target,
 19 |     |         bytes4 indexed functionSig,
 20 |     |         bool enabled
 21 |     |     );
 22 |     | 
 23 |     |     enum CapabilityFlag {
 24 |     |         None,
 25 |     |         Public,
 26 |     |         Burned
 27 |     |     }
 28 |     | }
 29 |     | 

/mnt/c/Users/Lourens/Documents/Recon-Fuzz/collabs/ebtc/packages/contracts/contracts/Dependencies/Ownable.sol
  1 |     | // SPDX-License-Identifier: MIT
  2 |     | // OpenZeppelin Contracts (last updated v4.7.0) (access/Ownable.sol)
  3 |     | 
  4 |     | pragma solidity 0.8.17;
  5 |     | 
  6 |     | import "./Context.sol";
  7 |     | 
  8 |     | /**
  9 |     |  * @dev Contract module which provides a basic access control mechanism, where
 10 |     |  * there is an account (an owner) that can be granted exclusive access to
 11 |     |  * specific functions.
 12 |     |  *
 13 |     |  * By default, the owner account will be the one that deploys the contract. This
 14 |     |  * can later be changed with {transferOwnership}.
 15 |     |  *
 16 |     |  * This module is used through inheritance. It will make available the modifier
 17 |     |  * `onlyOwner`, which can be applied to your functions to restrict their use to
 18 |     |  * the owner.
 19 |     |  */
 20 |     | abstract contract Ownable is Context {
 21 |     |     address private _owner;
 22 |     | 
 23 |     |     event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);
 24 |     | 
 25 |     |     /**
 26 |     |      * @dev Initializes the contract setting the deployer as the initial owner.
 27 |     |      */
 28 |     |     constructor() {
 29 |     |         _transferOwnership(_msgSender());
 30 |     |     }
 31 |     | 
 32 |     |     /**
 33 |     |      * @dev Throws if called by any account other than the owner.
 34 |     |      */
 35 |     |     modifier onlyOwner() {
 36 |     |         _checkOwner();
 37 |     |         _;
 38 |     |     }
 39 |     | 
 40 |     |     /**
 41 |     |      * @dev Returns the address of the current owner.
 42 |     |      */
 43 |     |     function owner() public view virtual returns (address) {
 44 |     |         return _owner;
 45 |     |     }
 46 |     | 
 47 |     |     /**
 48 |     |      * @dev Throws if the sender is not the owner.
 49 |     |      */
 50 |     |     function _checkOwner() internal view virtual {
 51 |     |         require(owner() == _msgSender(), "Ownable: caller is not the owner");
 52 |     |     }
 53 |     | 
 54 |     |     /**
 55 |     |      * @dev Leaves the contract without owner. It will not be possible to call
 56 |     |      * `onlyOwner` functions anymore. Can only be called by the current owner.
 57 |     |      *
 58 |     |      * NOTE: Renouncing ownership will leave the contract without an owner,
 59 |     |      * thereby removing any functionality that is only available to the owner.
 60 |     |      */
 61 |     |     function renounceOwnership() public virtual onlyOwner {
 62 |     |         _transferOwnership(address(0));
 63 |     |     }
 64 |     | 
 65 |     |     /**
 66 |     |      * @dev Transfers ownership of the contract to a new account (`newOwner`).
 67 |     |      * Can only be called by the current owner.
 68 |     |      */
 69 |     |     function transferOwnership(address newOwner) public virtual onlyOwner {
 70 |     |         require(newOwner != address(0), "Ownable: new owner is the zero address");
 71 |     |         _transferOwnership(newOwner);
 72 |     |     }
 73 |     | 
 74 |     |     /**
 75 |     |      * @dev Transfers ownership of the contract to a new account (`newOwner`).
 76 |     |      * Internal function without access restriction.
 77 |     |      */
 78 |     |     function _transferOwnership(address newOwner) internal virtual {
 79 |     |         address oldOwner = _owner;
 80 |     |         _owner = newOwner;
 81 |     |         emit OwnershipTransferred(oldOwner, newOwner);
 82 |     |     }
 83 |     | }
 84 |     | 

/mnt/c/Users/Lourens/Documents/Recon-Fuzz/collabs/ebtc/packages/contracts/contracts/Dependencies/PermitNonce.sol
  1 |     | // SPDX-License-Identifier: MIT
  2 |     | 
  3 |     | pragma solidity 0.8.17;
  4 |     | import "../Interfaces/IPermitNonce.sol";
  5 |     | 
  6 |     | /**
  7 |     |  * @dev This abstract contract provides a mapping from address to nonce (uint256) used for permit signature
  8 |     |  */
  9 |     | contract PermitNonce is IPermitNonce {
 10 |     |     mapping(address => uint256) internal _nonces;
 11 |     | 
 12 |     |     /// @dev Increase current nonce for msg.sender by one.
 13 |     |     /// @notice This function could be used to invalidate any signed permit out there
 14 |     |     function increasePermitNonce() external returns (uint256) {
 15 |     |         return ++_nonces[msg.sender];
 16 |     |     }
 17 |     | 
 18 |     |     /// @dev Return current nonce for msg.sender fOR EIP-2612 compatibility
 19 |     |     function nonces(address owner) external view virtual returns (uint256) {
 20 |     |         return _nonces[owner];
 21 |     |     }
 22 |     | }
 23 |     | 

/mnt/c/Users/Lourens/Documents/Recon-Fuzz/collabs/ebtc/packages/contracts/contracts/Dependencies/Proxy.sol
  1 |     | // SPDX-License-Identifier: MIT
  2 |     | // OpenZeppelin Contracts (last updated v4.6.0) (proxy/Proxy.sol)
  3 |     | 
  4 |     | pragma solidity 0.8.17;
  5 |     | 
  6 |     | /**
  7 |     |  * @dev This abstract contract provides a fallback function that delegates all calls to another contract using the EVM
  8 |     |  * instruction `delegatecall`. We refer to the second contract as the _implementation_ behind the proxy, and it has to
  9 |     |  * be specified by overriding the virtual {_implementation} function.
 10 |     |  *
 11 |     |  * Additionally, delegation to the implementation can be triggered manually through the {_fallback} function, or to a
 12 |     |  * different contract through the {_delegate} function.
 13 |     |  *
 14 |     |  * The success and return data of the delegated call will be returned back to the caller of the proxy.
 15 |     |  * @dev BadgerDAO: Simplified to the core delegation functionality, without any additional features.
 16 |     |  */
 17 |     | contract Proxy {
 18 |     |     /**
 19 |     |      * @dev Delegates the current call to `implementation`.
 20 |     |      *
 21 |     |      * This function does not return to its internal call site, it will return directly to the external caller.
 22 |     |      */
 23 |     |     function _delegate(address implementation) internal virtual {
 24 |     |         assembly {
 25 |     |             // Copy msg.data. We take full control of memory in this inline assembly
 26 |     |             // block because it will not return to Solidity code. We overwrite the
 27 |     |             // Solidity scratch pad at memory position 0.
 28 |     |             calldatacopy(0, 0, calldatasize())
 29 |     | 
 30 |     |             // Call the implementation.
 31 |     |             // out and outsize are 0 because we don't know the size yet.
 32 |     |             let result := delegatecall(gas(), implementation, 0, calldatasize(), 0, 0)
 33 |     | 
 34 |     |             // Copy the returned data.
 35 |     |             returndatacopy(0, 0, returndatasize())
 36 |     | 
 37 |     |             switch result
 38 |     |             // delegatecall returns 0 on error.
 39 |     |             case 0 {
 40 |     |                 revert(0, returndatasize())
 41 |     |             }
 42 |     |             default {
 43 |     |                 return(0, returndatasize())
 44 |     |             }
 45 |     |         }
 46 |     |     }
 47 |     | }
 48 |     | 

/mnt/c/Users/Lourens/Documents/Recon-Fuzz/collabs/ebtc/packages/contracts/contracts/Dependencies/ReentrancyGuard.sol
  1 |     | // SPDX-License-Identifier: AGPL-3.0-only
  2 |     | pragma solidity 0.8.17;
  3 |     | 
  4 |     | /// @notice Gas optimized reentrancy protection for smart contracts.
  5 |     | /// @author Solmate (https://github.com/transmissions11/solmate/blob/main/src/utils/ReentrancyGuard.sol)
  6 |     | /// @author Modified from OpenZeppelin (https://github.com/OpenZeppelin/openzeppelin-contracts/blob/master/contracts/security/ReentrancyGuard.sol)
  7 |     | abstract contract ReentrancyGuard {
  8 |     |     uint256 internal constant OPEN = 1;
  9 |     |     uint256 internal constant LOCKED = 2;
 10 |     | 
 11 |     |     uint256 public locked = OPEN;
 12 |     | 
 13 |     |     modifier nonReentrant() virtual {
 14 |     |         require(locked == OPEN, "ReentrancyGuard: Reentrancy in nonReentrant call");
 15 |     | 
 16 |     |         locked = LOCKED;
 17 |     | 
 18 |     |         _;
 19 |     | 
 20 |     |         locked = OPEN;
 21 |     |     }
 22 |     | }
 23 |     | 

/mnt/c/Users/Lourens/Documents/Recon-Fuzz/collabs/ebtc/packages/contracts/contracts/Dependencies/RolesAuthority.sol
   1 |     | // SPDX-License-Identifier: AGPL-3.0-only
   2 |     | pragma solidity 0.8.17;
   3 |     | 
   4 |     | import {IRolesAuthority} from "./IRolesAuthority.sol";
   5 |     | import {Auth, Authority} from "./Auth.sol";
   6 |     | import "./EnumerableSet.sol";
   7 |     | 
   8 |     | /// @notice Role based Authority that supports up to 256 roles.
   9 |     | /// @author BadgerDAO
  10 |     | /// @author Modified from Solmate (https://github.com/transmissions11/solmate/blob/main/src/auth/authorities/RolesAuthority.sol)
  11 |     | /// @author Modified from Dappsys (https://github.com/dapphub/ds-roles/blob/master/src/roles.sol)
  12 |     | contract RolesAuthority is IRolesAuthority, Auth, Authority {
  13 |     |     using EnumerableSet for EnumerableSet.Bytes32Set;
  14 |     |     using EnumerableSet for EnumerableSet.AddressSet;
  15 |     | 
  16 |     |     /*//////////////////////////////////////////////////////////////
  17 |     |                                CONSTRUCTOR
  18 |     |     //////////////////////////////////////////////////////////////*/
  19 |     | 
  20 |     |     constructor(address _owner, Authority _authority) Auth(_owner, _authority) {}
  21 |     | 
  22 |     |     /*//////////////////////////////////////////////////////////////
  23 |     |                             ROLE/USER STORAGE
  24 |     |     //////////////////////////////////////////////////////////////*/
  25 |     | 
  26 |     |     EnumerableSet.AddressSet internal users;
  27 |     |     EnumerableSet.AddressSet internal targets;
  28 |     |     mapping(address => EnumerableSet.Bytes32Set) internal enabledFunctionSigsByTarget;
  29 |     | 
  30 |     |     EnumerableSet.Bytes32Set internal enabledFunctionSigsPublic;
  31 |     | 
  32 | *   |     mapping(address => bytes32) public getUserRoles;
  33 |     | 
  34 |     |     mapping(address => mapping(bytes4 => CapabilityFlag)) public capabilityFlag;
  35 |     | 
  36 |     |     mapping(address => mapping(bytes4 => bytes32)) public getRolesWithCapability;
  37 |     | 
  38 |     |     function doesUserHaveRole(address user, uint8 role) public view virtual returns (bool) {
  39 |     |         return (uint256(getUserRoles[user]) >> role) & 1 != 0;
  40 |     |     }
  41 |     | 
  42 | *   |     function doesRoleHaveCapability(
  43 |     |         uint8 role,
  44 |     |         address target,
  45 |     |         bytes4 functionSig
  46 |     |     ) public view virtual returns (bool) {
  47 |     |         return (uint256(getRolesWithCapability[target][functionSig]) >> role) & 1 != 0;
  48 |     |     }
  49 |     | 
  50 |     |     function isPublicCapability(address target, bytes4 functionSig) public view returns (bool) {
  51 |     |         return capabilityFlag[target][functionSig] == CapabilityFlag.Public;
  52 |     |     }
  53 |     | 
  54 |     |     /*//////////////////////////////////////////////////////////////
  55 |     |                            AUTHORIZATION LOGIC
  56 |     |     //////////////////////////////////////////////////////////////*/
  57 |     | 
  58 |     |     /**
  59 |     |         @notice A user can call a given function signature on a given target address if:
  60 |     |             - The capability has not been burned
  61 |     |             - That capability is public, or the user has a role that has been granted the capability to call the function
  62 |     |      */
  63 | *   |     function canCall(
  64 |     |         address user,
  65 |     |         address target,
  66 |     |         bytes4 functionSig
  67 | *   |     ) public view virtual override returns (bool) {
  68 | *   |         CapabilityFlag flag = capabilityFlag[target][functionSig];
  69 |     | 
  70 | *   |         if (flag == CapabilityFlag.Burned) {
  71 |     |             return false;
  72 | *   |         } else if (flag == CapabilityFlag.Public) {
  73 |     |             return true;
  74 |     |         } else {
  75 | *   |             return bytes32(0) != getUserRoles[user] & getRolesWithCapability[target][functionSig];
  76 |     |         }
  77 |     |     }
  78 |     | 
  79 |     |     /*//////////////////////////////////////////////////////////////
  80 |     |                    ROLE CAPABILITY CONFIGURATION LOGIC
  81 |     |     //////////////////////////////////////////////////////////////*/
  82 |     | 
  83 |     |     /// @notice Set a capability flag as public, meaning any account can call it. Or revoke this capability.
  84 |     |     /// @dev A capability cannot be made public if it has been burned.
  85 |     |     function setPublicCapability(
  86 |     |         address target,
  87 |     |         bytes4 functionSig,
  88 |     |         bool enabled
  89 |     |     ) public virtual requiresAuth {
  90 |     |         require(
  91 |     |             capabilityFlag[target][functionSig] != CapabilityFlag.Burned,
  92 |     |             "RolesAuthority: Capability Burned"
  93 |     |         );
  94 |     | 
  95 |     |         if (enabled) {
  96 |     |             capabilityFlag[target][functionSig] = CapabilityFlag.Public;
  97 |     |         } else {
  98 |     |             capabilityFlag[target][functionSig] = CapabilityFlag.None;
  99 |     |         }
 100 |     | 
 101 |     |         emit PublicCapabilityUpdated(target, functionSig, enabled);
 102 |     |     }
 103 |     | 
 104 |     |     /// @notice Grant a specified role the ability to call a function on a target.
 105 |     |     /// @notice Has no effect
 106 |     |     function setRoleCapability(
 107 |     |         uint8 role,
 108 |     |         address target,
 109 |     |         bytes4 functionSig,
 110 |     |         bool enabled
 111 |     |     ) public virtual requiresAuth {
 112 |     |         if (enabled) {
 113 |     |             getRolesWithCapability[target][functionSig] |= bytes32(1 << role);
 114 |     |             enabledFunctionSigsByTarget[target].add(bytes32(functionSig));
 115 |     | 
 116 |     |             if (!targets.contains(target)) {
 117 |     |                 targets.add(target);
 118 |     |             }
 119 |     |         } else {
 120 |     |             getRolesWithCapability[target][functionSig] &= ~bytes32(1 << role);
 121 |     | 
 122 |     |             // If no role exist for this target & functionSig, mark it as disabled
 123 |     |             if (getRolesWithCapability[target][functionSig] == bytes32(0)) {
 124 |     |                 enabledFunctionSigsByTarget[target].remove(bytes32(functionSig));
 125 |     |             }
 126 |     | 
 127 |     |             // If no enabled function signatures exist for this target, remove target
 128 |     |             if (enabledFunctionSigsByTarget[target].length() == 0) {
 129 |     |                 targets.remove(target);
 130 |     |             }
 131 |     |         }
 132 |     | 
 133 |     |         emit RoleCapabilityUpdated(role, target, functionSig, enabled);
 134 |     |     }
 135 |     | 
 136 |     |     /// @notice Permanently burns a capability for a target.
 137 |     |     function burnCapability(address target, bytes4 functionSig) public virtual requiresAuth {
 138 |     |         require(
 139 |     |             capabilityFlag[target][functionSig] != CapabilityFlag.Burned,
 140 |     |             "RolesAuthority: Capability Burned"
 141 |     |         );
 142 |     |         capabilityFlag[target][functionSig] = CapabilityFlag.Burned;
 143 |     | 
 144 |     |         emit CapabilityBurned(target, functionSig);
 145 |     |     }
 146 |     | 
 147 |     |     /*//////////////////////////////////////////////////////////////
 148 |     |                        USER ROLE ASSIGNMENT LOGIC
 149 |     |     //////////////////////////////////////////////////////////////*/
 150 |     | 
 151 |     |     function setUserRole(address user, uint8 role, bool enabled) public virtual requiresAuth {
 152 |     |         if (enabled) {
 153 |     |             getUserRoles[user] |= bytes32(1 << role);
 154 |     | 
 155 |     |             if (!users.contains(user)) {
 156 |     |                 users.add(user);
 157 |     |             }
 158 |     |         } else {
 159 |     |             getUserRoles[user] &= ~bytes32(1 << role);
 160 |     | 
 161 |     |             // Remove user if no more roles
 162 |     |             if (getUserRoles[user] == bytes32(0)) {
 163 |     |                 users.remove(user);
 164 |     |             }
 165 |     |         }
 166 |     | 
 167 |     |         emit UserRoleUpdated(user, role, enabled);
 168 |     |     }
 169 |     | }
 170 |     | 

/mnt/c/Users/Lourens/Documents/Recon-Fuzz/collabs/ebtc/packages/contracts/contracts/Dependencies/SafeERC20.sol
  1 |     | // SPDX-License-Identifier: MIT
  2 |     | // OpenZeppelin Contracts (last updated v4.8.0) (token/ERC20/utils/SafeERC20.sol)
  3 |     | 
  4 |     | pragma solidity 0.8.17;
  5 |     | 
  6 |     | import "./IERC20.sol";
  7 |     | import "./Address.sol";
  8 |     | 
  9 |     | /**
 10 |     |  * @title SafeERC20
 11 |     |  * @dev Wrappers around ERC20 operations that throw on failure (when the token
 12 |     |  * contract returns false). Tokens that return no value (and instead revert or
 13 |     |  * throw on failure) are also supported, non-reverting calls are assumed to be
 14 |     |  * successful.
 15 |     |  * To use this library you can add a `using SafeERC20 for IERC20;` statement to your contract,
 16 |     |  * which allows you to call the safe operations as `token.safeTransfer(...)`, etc.
 17 |     |  */
 18 |     | library SafeERC20 {
 19 |     |     using Address for address;
 20 |     | 
 21 |     |     /**
 22 |     |      * @dev Transfer `value` amount of `token` from the calling contract to `to`. If `token` returns no value,
 23 |     |      * non-reverting calls are assumed to be successful.
 24 |     |      */
 25 |     |     function safeTransfer(IERC20 token, address to, uint256 value) internal {
 26 |     |         _callOptionalReturn(token, abi.encodeWithSelector(token.transfer.selector, to, value));
 27 |     |     }
 28 |     | 
 29 |     |     /// @dev Calls approve while checking bool return value, handles no-return tokens
 30 |     |     function safeApprove(IERC20 token, address spender, uint256 amount) internal {
 31 |     |         _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, amount));
 32 |     |     }
 33 |     | 
 34 |     |     function safeTransferFrom(IERC20 token, address from, address to, uint256 value) internal {
 35 |     |         _callOptionalReturn(
 36 |     |             token,
 37 |     |             abi.encodeWithSelector(token.transferFrom.selector, from, to, value)
 38 |     |         );
 39 |     |     }
 40 |     | 
 41 |     |     /**
 42 |     |      * @dev Imitates a Solidity high-level call (i.e. a regular function call to a contract), relaxing the requirement
 43 |     |      * on the return value: the return value is optional (but if data is returned, it must not be false).
 44 |     |      * @param token The token targeted by the call.
 45 |     |      * @param data The call data (encoded using abi.encode or one of its variants).
 46 |     |      */
 47 |     |     function _callOptionalReturn(IERC20 token, bytes memory data) private {
 48 |     |         // We need to perform a low level call here, to bypass Solidity's return data size checking mechanism, since
 49 |     |         // we're implementing it ourselves. We use {Address-functionCall} to perform this call, which verifies that
 50 |     |         // the target address contains contract code and also asserts for success in the low-level call.
 51 |     | 
 52 |     |         bytes memory returndata = address(token).functionCall(
 53 |     |             data,
 54 |     |             "SafeERC20: low-level call failed"
 55 |     |         );
 56 |     |         require(
 57 |     |             returndata.length == 0 || abi.decode(returndata, (bool)),
 58 |     |             "SafeERC20: ERC20 operation did not succeed"
 59 |     |         );
 60 |     |     }
 61 |     | }
 62 |     | 

/mnt/c/Users/Lourens/Documents/Recon-Fuzz/collabs/ebtc/packages/contracts/contracts/Dependencies/SafeMath.sol
   1 |     | // SPDX-License-Identifier: MIT
   2 |     | 
   3 |     | pragma solidity 0.8.17;
   4 |     | 
   5 |     | /**
   6 |     |  * Based on OpenZeppelin's SafeMath:
   7 |     |  * https://github.com/OpenZeppelin/openzeppelin-contracts/blob/master/contracts/math/SafeMath.sol
   8 |     |  *
   9 |     |  * @dev Wrappers over Solidity's arithmetic operations with added overflow
  10 |     |  * checks.
  11 |     |  *
  12 |     |  * Arithmetic operations in Solidity wrap on overflow. This can easily result
  13 |     |  * in bugs, because programmers usually assume that an overflow raises an
  14 |     |  * error, which is the standard behavior in high level programming languages.
  15 |     |  * `SafeMath` restores this intuition by reverting the transaction when an
  16 |     |  * operation overflows.
  17 |     |  *
  18 |     |  * Using this library instead of the unchecked operations eliminates an entire
  19 |     |  * class of bugs, so it's recommended to use it always.
  20 |     |  */
  21 |     | library SafeMath {
  22 |     |     /**
  23 |     |      * @dev Returns the addition of two unsigned integers, reverting on
  24 |     |      * overflow.
  25 |     |      *
  26 |     |      * Counterpart to Solidity's `+` operator.
  27 |     |      *
  28 |     |      * Requirements:
  29 |     |      * - Addition cannot overflow.
  30 |     |      */
  31 |     |     function add(uint256 a, uint256 b) internal pure returns (uint256) {
  32 |     |         uint256 c = a + b;
  33 |     |         require(c >= a, "SafeMath: addition overflow");
  34 |     | 
  35 |     |         return c;
  36 |     |     }
  37 |     | 
  38 |     |     /**
  39 |     |      * @dev Returns the subtraction of two unsigned integers, reverting on
  40 |     |      * overflow (when the result is negative).
  41 |     |      *
  42 |     |      * Counterpart to Solidity's `-` operator.
  43 |     |      *
  44 |     |      * Requirements:
  45 |     |      * - Subtraction cannot overflow.
  46 |     |      */
  47 |     |     function sub(uint256 a, uint256 b) internal pure returns (uint256) {
  48 |     |         return sub(a, b, "SafeMath: subtraction overflow");
  49 |     |     }
  50 |     | 
  51 |     |     /**
  52 |     |      * @dev Returns the subtraction of two unsigned integers, reverting with custom message on
  53 |     |      * overflow (when the result is negative).
  54 |     |      *
  55 |     |      * Counterpart to Solidity's `-` operator.
  56 |     |      *
  57 |     |      * Requirements:
  58 |     |      * - Subtraction cannot overflow.
  59 |     |      *
  60 |     |      * _Available since v2.4.0._
  61 |     |      */
  62 |     |     function sub(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {
  63 |     |         require(b <= a, errorMessage);
  64 |     |         uint256 c = a - b;
  65 |     | 
  66 |     |         return c;
  67 |     |     }
  68 |     | 
  69 |     |     /**
  70 |     |      * @dev Returns the multiplication of two unsigned integers, reverting on
  71 |     |      * overflow.
  72 |     |      *
  73 |     |      * Counterpart to Solidity's `*` operator.
  74 |     |      *
  75 |     |      * Requirements:
  76 |     |      * - Multiplication cannot overflow.
  77 |     |      */
  78 |     |     function mul(uint256 a, uint256 b) internal pure returns (uint256) {
  79 |     |         // Gas optimization: this is cheaper than requiring 'a' not being zero, but the
  80 |     |         // benefit is lost if 'b' is also tested.
  81 |     |         // See: https://github.com/OpenZeppelin/openzeppelin-contracts/pull/522
  82 |     |         if (a == 0) {
  83 |     |             return 0;
  84 |     |         }
  85 |     | 
  86 |     |         uint256 c = a * b;
  87 |     |         require(c / a == b, "SafeMath: multiplication overflow");
  88 |     | 
  89 |     |         return c;
  90 |     |     }
  91 |     | 
  92 |     |     /**
  93 |     |      * @dev Returns the integer division of two unsigned integers. Reverts on
  94 |     |      * division by zero. The result is rounded towards zero.
  95 |     |      *
  96 |     |      * Counterpart to Solidity's `/` operator. Note: this function uses a
  97 |     |      * `revert` opcode (which leaves remaining gas untouched) while Solidity
  98 |     |      * uses an invalid opcode to revert (consuming all remaining gas).
  99 |     |      *
 100 |     |      * Requirements:
 101 |     |      * - The divisor cannot be zero.
 102 |     |      */
 103 |     |     function div(uint256 a, uint256 b) internal pure returns (uint256) {
 104 |     |         return div(a, b, "SafeMath: division by zero");
 105 |     |     }
 106 |     | 
 107 |     |     /**
 108 |     |      * @dev Returns the integer division of two unsigned integers. Reverts with custom message on
 109 |     |      * division by zero. The result is rounded towards zero.
 110 |     |      *
 111 |     |      * Counterpart to Solidity's `/` operator. Note: this function uses a
 112 |     |      * `revert` opcode (which leaves remaining gas untouched) while Solidity
 113 |     |      * uses an invalid opcode to revert (consuming all remaining gas).
 114 |     |      *
 115 |     |      * Requirements:
 116 |     |      * - The divisor cannot be zero.
 117 |     |      *
 118 |     |      * _Available since v2.4.0._
 119 |     |      */
 120 |     |     function div(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {
 121 |     |         // Solidity only automatically asserts when dividing by 0
 122 |     |         require(b > 0, errorMessage);
 123 |     |         uint256 c = a / b;
 124 |     |         // assert(a == b * c + a % b); // There is no case in which this doesn't hold
 125 |     | 
 126 |     |         return c;
 127 |     |     }
 128 |     | 
 129 |     |     /**
 130 |     |      * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),
 131 |     |      * Reverts when dividing by zero.
 132 |     |      *
 133 |     |      * Counterpart to Solidity's `%` operator. This function uses a `revert`
 134 |     |      * opcode (which leaves remaining gas untouched) while Solidity uses an
 135 |     |      * invalid opcode to revert (consuming all remaining gas).
 136 |     |      *
 137 |     |      * Requirements:
 138 |     |      * - The divisor cannot be zero.
 139 |     |      */
 140 |     |     function mod(uint256 a, uint256 b) internal pure returns (uint256) {
 141 |     |         return mod(a, b, "SafeMath: modulo by zero");
 142 |     |     }
 143 |     | 
 144 |     |     /**
 145 |     |      * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),
 146 |     |      * Reverts with custom message when dividing by zero.
 147 |     |      *
 148 |     |      * Counterpart to Solidity's `%` operator. This function uses a `revert`
 149 |     |      * opcode (which leaves remaining gas untouched) while Solidity uses an
 150 |     |      * invalid opcode to revert (consuming all remaining gas).
 151 |     |      *
 152 |     |      * Requirements:
 153 |     |      * - The divisor cannot be zero.
 154 |     |      *
 155 |     |      * _Available since v2.4.0._
 156 |     |      */
 157 |     |     function mod(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {
 158 |     |         require(b != 0, errorMessage);
 159 |     |         return a % b;
 160 |     |     }
 161 |     | }
 162 |     | 

/mnt/c/Users/Lourens/Documents/Recon-Fuzz/collabs/ebtc/packages/contracts/contracts/Dependencies/TwapWeightedObserver.sol
   1 |     | // SPDX-License Identifier: MIT
   2 |     | pragma solidity 0.8.17;
   3 |     | import {ITwapWeightedObserver} from "../Interfaces/ITwapWeightedObserver.sol";
   4 |     | 
   5 |     | /// @title TwapWeightedObserver
   6 |     | /// @notice Given a value, applies a time-weighted TWAP that smooths out changes over a 7 days period
   7 |     | /// @dev Used to get the lowest value of total supply to prevent underpaying redemptions
   8 |     | contract TwapWeightedObserver is ITwapWeightedObserver {
   9 |     |     PackedData public data;
  10 |     |     uint128 public valueToTrack;
  11 |     |     bool public twapDisabled;
  12 |     | 
  13 |     |     constructor(uint128 initialValue) {
  14 |     |         PackedData memory cachedData = PackedData({
  15 |     |             observerCumuVal: initialValue,
  16 |     |             accumulator: initialValue,
  17 |     |             lastObserved: uint64(block.timestamp),
  18 |     |             lastAccrued: uint64(block.timestamp),
  19 |     |             lastObservedAverage: initialValue
  20 |     |         });
  21 |     | 
  22 |     |         valueToTrack = initialValue;
  23 |     |         data = cachedData;
  24 |     |     }
  25 |     | 
  26 |     |     /// TWAP ///
  27 |     |     event NewTrackValue(uint256 _oldValue, uint256 _newValue, uint256 _ts, uint256 _newAcc);
  28 |     | 
  29 |     |     // Set to new value, sync accumulator to now with old value
  30 |     |     // Changes in same block have no impact, as no time has expired
  31 |     |     // Effectively we use the previous block value, and we magnify it by weight
  32 |     |     function _setValue(uint128 newValue) internal {
  33 |     |         uint128 _newAcc = _updateAcc(valueToTrack);
  34 |     | 
  35 |     |         data.lastAccrued = uint64(block.timestamp);
  36 |     |         emit NewTrackValue(valueToTrack, newValue, block.timestamp, _newAcc);
  37 |     |         valueToTrack = newValue;
  38 |     |     }
  39 |     | 
  40 |     |     // Update the accumulator based on time passed
  41 |     |     function _updateAcc(uint128 oldValue) internal returns (uint128) {
  42 |     |         uint128 _newAcc = data.accumulator + oldValue * (timeToAccrue());
  43 |     |         data.accumulator = _newAcc;
  44 |     |         return _newAcc;
  45 |     |     }
  46 |     | 
  47 |     |     /// @notice Returns the time since the last update
  48 |     |     /// @return Duration since last update
  49 |     |     /// @dev Safe from overflow for tens of thousands of years
  50 |     |     function timeToAccrue() public view returns (uint64) {
  51 |     |         return uint64(block.timestamp) - data.lastAccrued;
  52 |     |     }
  53 |     | 
  54 |     |     /// @notice Returns the accumulator value, adjusted according to the current value and block timestamp
  55 |     |     // Return the update value to now
  56 |     |     function _syncToNow() internal view returns (uint128) {
  57 |     |         return data.accumulator + (valueToTrack * (timeToAccrue()));
  58 |     |     }
  59 |     | 
  60 |     |     // == Getters == //
  61 |     | 
  62 |     |     /// @notice Returns the accumulator value, adjusted according to the current value and block timestamp
  63 |     |     function getLatestAccumulator() public view returns (uint128) {
  64 |     |         return _syncToNow();
  65 |     |     }
  66 |     | 
  67 |     |     /// END TWAP ///
  68 |     | 
  69 |     |     /// TWAP WEIGHTED OBSERVER ///
  70 |     | 
  71 |     |     // Hardcoded TWAP Period of 7 days
  72 |     |     uint256 public constant PERIOD = 7 days;
  73 |     | 
  74 |     |     // Look at last
  75 |     |     // Linear interpolate (or prob TWAP already does that for you)
  76 |     | 
  77 |     |     /// @notice Returns the current value, adjusted according to the current value and block timestamp
  78 |     |     function observe() external returns (uint256) {
  79 |     |         // Here, we need to apply the new accumulator to skew the price in some way
  80 |     |         // The weight of the skew should be proportional to the time passed
  81 |     |         uint256 futureWeight = block.timestamp - data.lastObserved;
  82 |     | 
  83 |     |         if (futureWeight == 0) {
  84 |     |             return data.lastObservedAverage;
  85 |     |         }
  86 |     | 
  87 |     |         // A reference period is 7 days
  88 |     |         // For each second passed after update
  89 |     |         // Let's virtally sync TWAP
  90 |     |         // With a weight, that is higher, the more time has passed
  91 |     |         (uint128 virtualAvgValue, uint128 obsAcc) = _calcUpdatedAvg();
  92 |     | 
  93 |     |         if (_checkUpdatePeriod()) {
  94 |     |             _update(virtualAvgValue, obsAcc); // May as well update
  95 |     |             // Return virtual
  96 |     |             return virtualAvgValue;
  97 |     |         }
  98 |     | 
  99 |     |         uint256 weightedAvg = uint256(data.lastObservedAverage) *
 100 |     |             (uint256(PERIOD) - uint256(futureWeight));
 101 |     |         uint256 weightedVirtual = uint256(virtualAvgValue) * (uint256(futureWeight));
 102 |     | 
 103 |     |         uint256 weightedMean = (weightedAvg + weightedVirtual) / PERIOD;
 104 |     | 
 105 |     |         return weightedMean;
 106 |     |     }
 107 |     | 
 108 |     |     /// @dev Usual Accumulator Math, (newAcc - acc0) / (now - t0)
 109 |     |     function _calcUpdatedAvg() internal view returns (uint128, uint128) {
 110 |     |         uint128 latestAcc = getLatestAccumulator();
 111 |     |         uint128 avgValue = (latestAcc - data.observerCumuVal) /
 112 |     |             (uint64(block.timestamp) - data.lastObserved);
 113 |     |         return (avgValue, latestAcc);
 114 |     |     }
 115 |     | 
 116 |     |     /// @dev Utility to update internal data
 117 |     |     function _update(uint128 avgValue, uint128 obsAcc) internal {
 118 |     |         data.lastObservedAverage = avgValue;
 119 |     |         data.observerCumuVal = obsAcc;
 120 |     |         data.lastObserved = uint64(block.timestamp);
 121 |     |     }
 122 |     | 
 123 |     |     /// @dev Should we update in observe?
 124 |     |     function _checkUpdatePeriod() internal returns (bool) {
 125 |     |         return block.timestamp >= (data.lastObserved + PERIOD);
 126 |     |     }
 127 |     | 
 128 |     |     /// @dev update time-weighted Observer
 129 |     |     function update() public {
 130 |     |         if (_checkUpdatePeriod()) {
 131 |     |             (uint128 avgValue, uint128 latestAcc) = _calcUpdatedAvg();
 132 |     |             _update(avgValue, latestAcc);
 133 |     |         }
 134 |     |     }
 135 |     | 
 136 |     |     function setValueAndUpdate(uint128 value) external {
 137 |     |         require(msg.sender == address(this), "TwapWeightedObserver: Only self call");
 138 |     |         _setValue(value);
 139 |     |         update();
 140 |     |     }
 141 |     | 
 142 |     |     function getData() external view returns (PackedData memory) {
 143 |     |         return data;
 144 |     |     }
 145 |     | 
 146 |     |     /// END TWAP WEIGHTED OBSERVER ///
 147 |     | }
 148 |     | 

/mnt/c/Users/Lourens/Documents/Recon-Fuzz/collabs/ebtc/packages/contracts/contracts/EBTCDeployer.sol
   1 |     | // SPDX-License-Identifier: MIT
   2 |     | 
   3 |     | pragma solidity 0.8.17;
   4 |     | 
   5 |     | import "./Dependencies/Create3.sol";
   6 |     | import "./Dependencies/Ownable.sol";
   7 |     | 
   8 |     | contract EBTCDeployer is Ownable {
   9 |     |     string public constant name = "eBTC Deployer";
  10 |     | 
  11 |     |     string public constant AUTHORITY = "ebtc.v1.authority";
  12 |     |     string public constant LIQUIDATION_LIBRARY = "ebtc.v1.liquidationLibrary";
  13 |     |     string public constant CDP_MANAGER = "ebtc.v1.cdpManager";
  14 |     |     string public constant BORROWER_OPERATIONS = "ebtc.v1.borrowerOperations";
  15 |     | 
  16 |     |     string public constant PRICE_FEED = "ebtc.v1.priceFeed";
  17 |     |     string public constant EBTC_FEED = "ebtc.v1.ebtcFeed";
  18 |     |     string public constant SORTED_CDPS = "ebtc.v1.sortedCdps";
  19 |     | 
  20 |     |     string public constant ACTIVE_POOL = "ebtc.v1.activePool";
  21 |     |     string public constant COLL_SURPLUS_POOL = "ebtc.v1.collSurplusPool";
  22 |     | 
  23 |     |     string public constant HINT_HELPERS = "ebtc.v1.hintHelpers";
  24 |     |     string public constant EBTC_TOKEN = "ebtc.v1.eBTCToken";
  25 |     |     string public constant FEE_RECIPIENT = "ebtc.v1.feeRecipient";
  26 |     |     string public constant MULTI_CDP_GETTER = "ebtc.v1.multiCdpGetter";
  27 |     | 
  28 |     |     event ContractDeployed(address indexed contractAddress, string contractName, bytes32 salt);
  29 |     | 
  30 |     |     struct EbtcAddresses {
  31 |     |         address authorityAddress;
  32 |     |         address liquidationLibraryAddress;
  33 |     |         address cdpManagerAddress;
  34 |     |         address borrowerOperationsAddress;
  35 |     |         address priceFeedAddress;
  36 |     |         address sortedCdpsAddress;
  37 |     |         address activePoolAddress;
  38 |     |         address collSurplusPoolAddress;
  39 |     |         address hintHelpersAddress;
  40 |     |         address ebtcTokenAddress;
  41 |     |         address feeRecipientAddress;
  42 |     |         address multiCdpGetterAddress;
  43 |     |         address ebtcFeedAddress;
  44 |     |     }
  45 |     | 
  46 |     |     /**
  47 |     |     @notice Helper method to return a set of future addresses for eBTC. Intended to be used in the order specified.
  48 |     |     
  49 |     |     @dev The order is as follows:
  50 |     |     0: authority
  51 |     |     1: liquidationLibrary
  52 |     |     2: cdpManager
  53 |     |     3: borrowerOperations
  54 |     |     4: priceFeed
  55 |     |     5; sortedCdps
  56 |     |     6: activePool
  57 |     |     7: collSurplusPool
  58 |     |     8: hintHelpers
  59 |     |     9: eBTCToken
  60 |     |     10: feeRecipient
  61 |     |     11: multiCdpGetter
  62 |     |     12: ebtcFeed
  63 |     | 
  64 |     | 
  65 |     |      */
  66 |     |     function getFutureEbtcAddresses() public view returns (EbtcAddresses memory) {
  67 |     |         EbtcAddresses memory addresses = EbtcAddresses(
  68 |     |             Create3.addressOf(keccak256(abi.encodePacked(AUTHORITY))),
  69 |     |             Create3.addressOf(keccak256(abi.encodePacked(LIQUIDATION_LIBRARY))),
  70 |     |             Create3.addressOf(keccak256(abi.encodePacked(CDP_MANAGER))),
  71 |     |             Create3.addressOf(keccak256(abi.encodePacked(BORROWER_OPERATIONS))),
  72 |     |             Create3.addressOf(keccak256(abi.encodePacked(PRICE_FEED))),
  73 |     |             Create3.addressOf(keccak256(abi.encodePacked(SORTED_CDPS))),
  74 |     |             Create3.addressOf(keccak256(abi.encodePacked(ACTIVE_POOL))),
  75 |     |             Create3.addressOf(keccak256(abi.encodePacked(COLL_SURPLUS_POOL))),
  76 |     |             Create3.addressOf(keccak256(abi.encodePacked(HINT_HELPERS))),
  77 |     |             Create3.addressOf(keccak256(abi.encodePacked(EBTC_TOKEN))),
  78 |     |             Create3.addressOf(keccak256(abi.encodePacked(FEE_RECIPIENT))),
  79 |     |             Create3.addressOf(keccak256(abi.encodePacked(MULTI_CDP_GETTER))),
  80 |     |             Create3.addressOf(keccak256(abi.encodePacked(EBTC_FEED)))
  81 |     |         );
  82 |     | 
  83 |     |         return addresses;
  84 |     |     }
  85 |     | 
  86 |     |     /**
  87 |     |         @notice Deploy a contract using salt in string format and arbitrary runtime code.
  88 |     |         @dev Intended use is: get the future eBTC addresses, then deploy the appropriate contract to each address via this method, building the constructor using the mapped addresses
  89 |     |         @dev no enforcment of bytecode at address as we can't know the runtime code in this contract due to space constraints
  90 |     |         @dev gated to given deployer EOA to ensure no interference with process, given proper actions by deployer
  91 |     |      */
  92 |     |     function deploy(
  93 |     |         string memory _saltString,
  94 |     |         bytes memory _creationCode
  95 |     |     ) public returns (address deployedAddress) {
  96 |     |         bytes32 _salt = keccak256(abi.encodePacked(_saltString));
  97 |     |         deployedAddress = Create3.create3(_salt, _creationCode);
  98 |     |         emit ContractDeployed(deployedAddress, _saltString, _salt);
  99 |     |     }
 100 |     | 
 101 |     |     function deployWithCreationCodeAndConstructorArgs(
 102 |     |         string memory _saltString,
 103 |     |         bytes memory creationCode,
 104 |     |         bytes memory constructionArgs
 105 |     |     ) external returns (address) {
 106 |     |         bytes memory _data = abi.encodePacked(creationCode, constructionArgs);
 107 |     |         return deploy(_saltString, _data);
 108 |     |     }
 109 |     | 
 110 |     |     function deployWithCreationCode(
 111 |     |         string memory _saltString,
 112 |     |         bytes memory creationCode
 113 |     |     ) external returns (address) {
 114 |     |         return deploy(_saltString, creationCode);
 115 |     |     }
 116 |     | 
 117 |     |     function addressOf(string memory _saltString) external view returns (address) {
 118 |     |         bytes32 _salt = keccak256(abi.encodePacked(_saltString));
 119 |     |         return Create3.addressOf(_salt);
 120 |     |     }
 121 |     | 
 122 |     |     function addressOfSalt(bytes32 _salt) external view returns (address) {
 123 |     |         return Create3.addressOf(_salt);
 124 |     |     }
 125 |     | 
 126 |     |     /**
 127 |     |         @notice Create the creation code for a contract with the given runtime code.
 128 |     |         @dev credit: https://github.com/0xsequence/create3/blob/master/contracts/test_utils/Create3Imp.sol
 129 |     |      */
 130 |     |     function creationCodeFor(bytes memory _code) internal pure returns (bytes memory) {
 131 |     |         /*
 132 |     |       0x00    0x63         0x63XXXXXX  PUSH4 _code.length  size
 133 |     |       0x01    0x80         0x80        DUP1                size size
 134 |     |       0x02    0x60         0x600e      PUSH1 14            14 size size
 135 |     |       0x03    0x60         0x6000      PUSH1 00            0 14 size size
 136 |     |       0x04    0x39         0x39        CODECOPY            size
 137 |     |       0x05    0x60         0x6000      PUSH1 00            0 size
 138 |     |       0x06    0xf3         0xf3        RETURN
 139 |     |       <CODE>
 140 |     |     */
 141 |     | 
 142 |     |         return
 143 |     |             abi.encodePacked(hex"63", uint32(_code.length), hex"80_60_0E_60_00_39_60_00_F3", _code);
 144 |     |     }
 145 |     | }
 146 |     | 

/mnt/c/Users/Lourens/Documents/Recon-Fuzz/collabs/ebtc/packages/contracts/contracts/EBTCToken.sol
   1 |     | // SPDX-License-Identifier: MIT
   2 |     | 
   3 |     | pragma solidity 0.8.17;
   4 |     | 
   5 |     | import "./Interfaces/IEBTCToken.sol";
   6 |     | 
   7 |     | import "./Dependencies/AuthNoOwner.sol";
   8 |     | import "./Dependencies/PermitNonce.sol";
   9 |     | 
  10 |     | /*
  11 |     |  *
  12 |     |  * Based upon OpenZeppelin's ERC20 contract:
  13 |     |  * https://github.com/OpenZeppelin/openzeppelin-contracts/blob/master/contracts/token/ERC20/ERC20.sol
  14 |     |  *
  15 |     |  * and their EIP2612 (ERC20Permit / ERC712) functionality:
  16 |     |  * https://github.com/OpenZeppelin/openzeppelin-contracts/blob/53516bc555a454862470e7860a9b5254db4d00f5/contracts/token/ERC20/ERC20Permit.sol
  17 |     |  *
  18 |     |  *
  19 |     |  * --- Functionality added specific to the EBTCToken ---
  20 |     |  *
  21 |     |  * 1) Transfer protection: blocklist of addresses that are invalid recipients (i.e. core Ebtc contracts) in external transfer() and transferFrom() calls.
  22 |     |  * The purpose is to protect users from losing tokens by mistakenly sending EBTC directly to a Liquity.
  23 |     |  * core contract, when they should rather call the right function.
  24 |     |  */
  25 |     | 
  26 |     | contract EBTCToken is IEBTCToken, AuthNoOwner, PermitNonce {
  27 |     |     uint256 private _totalSupply;
  28 |     |     string internal constant _NAME = "EBTC Stablecoin";
  29 |     |     string internal constant _SYMBOL = "EBTC";
  30 |     |     string internal constant _VERSION = "1";
  31 |     |     uint8 internal constant _DECIMALS = 18;
  32 |     | 
  33 |     |     // --- Data for EIP2612 ---
  34 |     | 
  35 |     |     // keccak256("Permit(address owner,address spender,uint256 value,uint256 nonce,uint256 deadline)");
  36 |     |     bytes32 private constant _PERMIT_TYPEHASH =
  37 |     |         0x6e71edae12b1b97f4d1f60370fef10105fa2faae0126114a169c64845d6126c9;
  38 |     |     // keccak256("EIP712Domain(string name,string version,uint256 chainId,address verifyingContract)");
  39 |     |     bytes32 private constant _TYPE_HASH =
  40 |     |         0x8b73c3c69bb8fe3d512ecc4cf759cc79239f7b179b0ffacaa9a75d522b39400f;
  41 |     | 
  42 |     |     // Cache the domain separator as an immutable value, but also store the chain id that it corresponds to, in order to
  43 |     |     // invalidate the cached domain separator if the chain id changes.
  44 |     |     bytes32 private immutable _CACHED_DOMAIN_SEPARATOR;
  45 |     |     uint256 private immutable _CACHED_CHAIN_ID;
  46 |     | 
  47 |     |     bytes32 private immutable _HASHED_NAME;
  48 |     |     bytes32 private immutable _HASHED_VERSION;
  49 |     | 
  50 |     |     // User data for EBTC token
  51 |     |     mapping(address => uint256) private _balances;
  52 |     |     mapping(address => mapping(address => uint256)) private _allowances;
  53 |     | 
  54 |     |     // --- Addresses ---
  55 |     |     address public immutable cdpManagerAddress;
  56 |     |     address public immutable borrowerOperationsAddress;
  57 |     | 
  58 |     |     /// @param _cdpManagerAddress Address of the CDP Manager
  59 |     |     /// @param _borrowerOperationsAddress Address of the Borrower Operations
  60 |     |     /// @param _authorityAddress Address of the authority for the contract
  61 |     |     constructor(
  62 |     |         address _cdpManagerAddress,
  63 |     |         address _borrowerOperationsAddress,
  64 |     |         address _authorityAddress
  65 |     |     ) {
  66 |     |         _initializeAuthority(_authorityAddress);
  67 |     | 
  68 |     |         cdpManagerAddress = _cdpManagerAddress;
  69 |     |         borrowerOperationsAddress = _borrowerOperationsAddress;
  70 |     | 
  71 |     |         bytes32 hashedName = keccak256(bytes(_NAME));
  72 |     |         bytes32 hashedVersion = keccak256(bytes(_VERSION));
  73 |     | 
  74 |     |         _HASHED_NAME = hashedName;
  75 |     |         _HASHED_VERSION = hashedVersion;
  76 |     |         _CACHED_CHAIN_ID = _chainID();
  77 |     |         _CACHED_DOMAIN_SEPARATOR = _buildDomainSeparator(_TYPE_HASH, hashedName, hashedVersion);
  78 |     |     }
  79 |     | 
  80 |     |     /// @notice Mint new tokens
  81 |     |     /// @dev Internal system function - only callable by BorrowerOperations or CDPManager
  82 |     |     /// @dev Governance can also expand the list of approved minters to enable other systems to mint tokens
  83 |     |     /// @param _account The address to receive the newly minted tokens
  84 |     |     /// @param _amount The amount of tokens to mint
  85 |     |     function mint(address _account, uint256 _amount) external override {
  86 |     |         _requireCallerIsBOorCdpMOrAuth();
  87 |     |         _mint(_account, _amount);
  88 |     |     }
  89 |     | 
  90 |     |     /// @notice Burn existing tokens
  91 |     |     /// @dev Internal system function - only callable by BorrowerOperations or CDPManager
  92 |     |     /// @dev Governance can also expand the list of approved burners to enable other systems to burn tokens
  93 |     |     /// @param _account The address to burn tokens from
  94 |     |     /// @param _amount The amount of tokens to burn
  95 |     |     function burn(address _account, uint256 _amount) external override {
  96 |     |         _requireCallerIsBOorCdpMOrAuth();
  97 |     |         _burn(_account, _amount);
  98 |     |     }
  99 |     | 
 100 |     |     /// @notice Burn existing tokens from caller
 101 |     |     /// @dev Internal system function - only callable by BorrowerOperations or CDPManager
 102 |     |     /// @dev Governance can also expand the list of approved burners to enable other systems to burn tokens
 103 |     |     /// @param _amount The amount of tokens to burn
 104 |     |     function burn(uint256 _amount) external {
 105 |     |         _requireCallerIsBOorCdpMOrAuth();
 106 |     |         _burn(msg.sender, _amount);
 107 |     |     }
 108 |     | 
 109 |     |     // --- External functions ---
 110 |     | 
 111 |     |     function totalSupply() external view override returns (uint256) {
 112 |     |         return _totalSupply;
 113 |     |     }
 114 |     | 
 115 |     |     function balanceOf(address account) external view override returns (uint256) {
 116 |     |         return _balances[account];
 117 |     |     }
 118 |     | 
 119 |     |     function transfer(address recipient, uint256 amount) external override returns (bool) {
 120 |     |         _requireValidRecipient(recipient);
 121 |     |         _transfer(msg.sender, recipient, amount);
 122 |     |         return true;
 123 |     |     }
 124 |     | 
 125 |     |     function allowance(address owner, address spender) external view override returns (uint256) {
 126 |     |         return _allowances[owner][spender];
 127 |     |     }
 128 |     | 
 129 |     |     function approve(address spender, uint256 amount) external override returns (bool) {
 130 |     |         _approve(msg.sender, spender, amount);
 131 |     |         return true;
 132 |     |     }
 133 |     | 
 134 |     |     function transferFrom(
 135 |     |         address sender,
 136 |     |         address recipient,
 137 |     |         uint256 amount
 138 |     |     ) external override returns (bool) {
 139 |     |         _requireValidRecipient(recipient);
 140 |     |         _transfer(sender, recipient, amount);
 141 |     | 
 142 |     |         uint256 cachedAllowance = _allowances[sender][msg.sender];
 143 |     |         if (cachedAllowance != type(uint256).max) {
 144 |     |             require(cachedAllowance >= amount, "ERC20: transfer amount exceeds allowance");
 145 |     |             unchecked {
 146 |     |                 _approve(sender, msg.sender, cachedAllowance - amount);
 147 |     |             }
 148 |     |         }
 149 |     |         return true;
 150 |     |     }
 151 |     | 
 152 |     |     function increaseAllowance(
 153 |     |         address spender,
 154 |     |         uint256 addedValue
 155 |     |     ) external override returns (bool) {
 156 |     |         _approve(msg.sender, spender, _allowances[msg.sender][spender] + addedValue);
 157 |     |         return true;
 158 |     |     }
 159 |     | 
 160 |     |     function decreaseAllowance(
 161 |     |         address spender,
 162 |     |         uint256 subtractedValue
 163 |     |     ) external override returns (bool) {
 164 |     |         uint256 cachedAllowances = _allowances[msg.sender][spender];
 165 |     |         require(cachedAllowances >= subtractedValue, "ERC20: decreased allowance below zero");
 166 |     |         unchecked {
 167 |     |             _approve(msg.sender, spender, cachedAllowances - subtractedValue);
 168 |     |         }
 169 |     |         return true;
 170 |     |     }
 171 |     | 
 172 |     |     // --- EIP 2612 Functionality (https://eips.ethereum.org/EIPS/eip-2612) ---
 173 |     | 
 174 |     |     /// @notice This function returns the domain separator for current chain
 175 |     |     /// @return EIP712 compatible Domain definition
 176 |     |     function DOMAIN_SEPARATOR() external view returns (bytes32) {
 177 |     |         return domainSeparator();
 178 |     |     }
 179 |     | 
 180 |     |     /// @notice This function returns the domain separator for current chain
 181 |     |     /// @return EIP712 compatible Domain definition
 182 |     |     function domainSeparator() public view override returns (bytes32) {
 183 |     |         if (_chainID() == _CACHED_CHAIN_ID) {
 184 |     |             return _CACHED_DOMAIN_SEPARATOR;
 185 |     |         } else {
 186 |     |             return _buildDomainSeparator(_TYPE_HASH, _HASHED_NAME, _HASHED_VERSION);
 187 |     |         }
 188 |     |     }
 189 |     | 
 190 |     |     /// @notice This function approve given amount for specified owner and spender
 191 |     |     /// @notice by verifying the validity of given deadline and signature parameters (v, r, s).
 192 |     |     /// @param owner The token owner
 193 |     |     /// @param spender The consumer to which owner want to grant approval
 194 |     |     /// @param amount The token expenditure budget to be set
 195 |     |     /// @param deadline The permit valid deadline
 196 |     |     /// @param v The v part of signature from owner
 197 |     |     /// @param r The r part of signature from owner
 198 |     |     /// @param s The s part of signature from owner
 199 |     |     function permit(
 200 |     |         address owner,
 201 |     |         address spender,
 202 |     |         uint256 amount,
 203 |     |         uint256 deadline,
 204 |     |         uint8 v,
 205 |     |         bytes32 r,
 206 |     |         bytes32 s
 207 |     |     ) external override {
 208 |     |         require(deadline >= block.timestamp, "EBTC: expired deadline");
 209 |     |         bytes32 digest = keccak256(
 210 |     |             abi.encodePacked(
 211 |     |                 "\x19\x01",
 212 |     |                 domainSeparator(),
 213 |     |                 keccak256(
 214 |     |                     abi.encode(_PERMIT_TYPEHASH, owner, spender, amount, _nonces[owner]++, deadline)
 215 |     |                 )
 216 |     |             )
 217 |     |         );
 218 |     |         address recoveredAddress = ecrecover(digest, v, r, s);
 219 |     |         require(recoveredAddress == owner, "EBTC: invalid signature");
 220 |     |         _approve(owner, spender, amount);
 221 |     |     }
 222 |     | 
 223 |     |     /// @dev Return current nonce for specified owner fOR EIP-2612 compatibility
 224 |     |     /// @param owner The address whose nonce to be queried
 225 |     |     function nonces(address owner) external view override(IERC2612, PermitNonce) returns (uint256) {
 226 |     |         return _nonces[owner];
 227 |     |     }
 228 |     | 
 229 |     |     // --- Internal operations ---
 230 |     | 
 231 |     |     function _chainID() private view returns (uint256) {
 232 |     |         return block.chainid;
 233 |     |     }
 234 |     | 
 235 |     |     function _buildDomainSeparator(
 236 |     |         bytes32 typeHash,
 237 |     |         bytes32 name,
 238 |     |         bytes32 version
 239 |     |     ) private view returns (bytes32) {
 240 |     |         return keccak256(abi.encode(typeHash, name, version, _chainID(), address(this)));
 241 |     |     }
 242 |     | 
 243 |     |     // --- Internal operations ---
 244 |     |     // Warning: sanity checks (for sender and recipient) should have been done before calling these internal functions
 245 |     | 
 246 |     |     function _transfer(address sender, address recipient, uint256 amount) internal {
 247 |     |         require(sender != address(0), "EBTCToken: zero sender!");
 248 |     |         require(recipient != address(0), "EBTCToken: zero recipient!");
 249 |     | 
 250 |     |         uint256 cachedSenderBalances = _balances[sender];
 251 |     |         require(cachedSenderBalances >= amount, "ERC20: transfer amount exceeds balance");
 252 |     | 
 253 |     |         unchecked {
 254 |     |             // Safe because of the check above
 255 |     |             _balances[sender] = cachedSenderBalances - amount;
 256 |     |         }
 257 |     | 
 258 |     |         _balances[recipient] = _balances[recipient] + amount;
 259 |     |         emit Transfer(sender, recipient, amount);
 260 |     |     }
 261 |     | 
 262 |     |     function _mint(address account, uint256 amount) internal {
 263 |     |         require(account != address(0), "EBTCToken: mint to zero recipient!");
 264 |     | 
 265 |     |         _totalSupply = _totalSupply + amount;
 266 |     |         _balances[account] = _balances[account] + amount;
 267 |     |         emit Transfer(address(0), account, amount);
 268 |     |     }
 269 |     | 
 270 |     |     function _burn(address account, uint256 amount) internal {
 271 |     |         require(account != address(0), "EBTCToken: burn from zero account!");
 272 |     | 
 273 |     |         uint256 cachedBalance = _balances[account];
 274 |     |         require(cachedBalance >= amount, "ERC20: burn amount exceeds balance");
 275 |     | 
 276 |     |         unchecked {
 277 |     |             // Safe because of the check above
 278 |     |             _balances[account] = cachedBalance - amount;
 279 |     |         }
 280 |     | 
 281 |     |         _totalSupply = _totalSupply - amount;
 282 |     |         emit Transfer(account, address(0), amount);
 283 |     |     }
 284 |     | 
 285 |     |     function _approve(address owner, address spender, uint256 amount) internal {
 286 |     |         require(owner != address(0), "EBTCToken: zero approve owner!");
 287 |     |         require(spender != address(0), "EBTCToken: zero approve spender!");
 288 |     | 
 289 |     |         _allowances[owner][spender] = amount;
 290 |     |         emit Approval(owner, spender, amount);
 291 |     |     }
 292 |     | 
 293 |     |     // --- 'require' functions ---
 294 |     | 
 295 |     |     function _requireValidRecipient(address _recipient) internal view {
 296 |     |         require(
 297 |     |             _recipient != address(0) && _recipient != address(this),
 298 |     |             "EBTC: Cannot transfer tokens directly to the EBTC token contract or the zero address"
 299 |     |         );
 300 |     |         require(
 301 |     |             _recipient != cdpManagerAddress && _recipient != borrowerOperationsAddress,
 302 |     |             "EBTC: Cannot transfer tokens directly to the CdpManager or BorrowerOps"
 303 |     |         );
 304 |     |     }
 305 |     | 
 306 |     |     function _requireCallerIsBorrowerOperations() internal view {
 307 |     |         require(
 308 |     |             msg.sender == borrowerOperationsAddress,
 309 |     |             "EBTCToken: Caller is not BorrowerOperations"
 310 |     |         );
 311 |     |     }
 312 |     | 
 313 |     |     /// @dev authority check last to short-circuit in the case of use by usual immutable addresses
 314 |     |     function _requireCallerIsBOorCdpMOrAuth() internal view {
 315 |     |         require(
 316 |     |             msg.sender == borrowerOperationsAddress ||
 317 |     |                 msg.sender == cdpManagerAddress ||
 318 |     |                 isAuthorized(msg.sender, msg.sig),
 319 |     |             "EBTC: Caller is neither BorrowerOperations nor CdpManager nor authorized"
 320 |     |         );
 321 |     |     }
 322 |     | 
 323 |     |     function _requireCallerIsCdpM() internal view {
 324 |     |         require(msg.sender == cdpManagerAddress, "EBTC: Caller is not CdpManager");
 325 |     |     }
 326 |     | 
 327 |     |     // --- Optional functions ---
 328 |     | 
 329 |     |     /// @notice Returns the name of the token
 330 |     |     /// @return Name of the token
 331 |     |     function name() external pure override returns (string memory) {
 332 |     |         return _NAME;
 333 |     |     }
 334 |     | 
 335 |     |     /// @notice Returns the symbol of the token
 336 |     |     /// @return Symbol of the token
 337 |     |     function symbol() external pure override returns (string memory) {
 338 |     |         return _SYMBOL;
 339 |     |     }
 340 |     | 
 341 |     |     /// @notice Returns the number of decimals used to represent token amounts
 342 |     |     /// @return Number of decimals used by the token
 343 |     |     function decimals() external pure override returns (uint8) {
 344 |     |         return _DECIMALS;
 345 |     |     }
 346 |     | 
 347 |     |     /// @notice Returns the version of the token
 348 |     |     /// @return Version of the token
 349 |     |     function version() external pure override returns (string memory) {
 350 |     |         return _VERSION;
 351 |     |     }
 352 |     | 
 353 |     |     /// @notice Returns the type hash used for permit() function as per EIP-2612
 354 |     |     /// @return EIP-2612 permit type hash
 355 |     |     function permitTypeHash() external pure override returns (bytes32) {
 356 |     |         return _PERMIT_TYPEHASH;
 357 |     |     }
 358 |     | }
 359 |     | 

/mnt/c/Users/Lourens/Documents/Recon-Fuzz/collabs/ebtc/packages/contracts/contracts/EbtcFeed.sol
   1 |     | // SPDX-License-Identifier: MIT
   2 |     | 
   3 |     | pragma solidity 0.8.17;
   4 |     | 
   5 |     | import "./Interfaces/IPriceFeed.sol";
   6 |     | import {IPriceFetcher} from "./Interfaces/IOracleCaller.sol";
   7 |     | import "./Dependencies/AuthNoOwner.sol";
   8 |     | 
   9 |     | /*
  10 |     |  * PriceFeed for mainnet deployment, it connects to two Chainlink's live feeds, ETH:BTC and
  11 |     |  * stETH:ETH, which are used to aggregate the price feed of stETH:BTC in conjuction.
  12 |     |  * It also allows for a fallback oracle to intervene in case that the primary Chainlink oracle fails.
  13 |     |  *
  14 |     |  * The PriceFeed uses Chainlink as primary oracle and allows for an optional fallback source. It contains logic for
  15 |     |  * switching oracles based on oracle failures, timeouts, and conditions for returning to the primary
  16 |     |  * Chainlink oracle. In addition, it contains the mechanism to add or remove the fallback oracle through governance.
  17 |     |  */
  18 | *   | contract EbtcFeed is IPriceFeed, AuthNoOwner {
  19 |     |     string public constant NAME = "EbtcFeed";
  20 |     | 
  21 |     |     // The last good price seen from an oracle by Liquity
  22 | *   |     uint256 public lastGoodPrice;
  23 |     | 
  24 |     |     address public primaryOracle;
  25 |     |     address public secondaryOracle;
  26 |     | 
  27 |     |     uint256 constant INVALID_PRICE = 0;
  28 |     |     address constant UNSET_ADDRESS = address(0);
  29 | *   |     uint256 constant GAS_LIMIT = 2_000_000;
  30 |     | 
  31 |     |     // --- Events ---
  32 |     | 
  33 |     |     event PrimaryOracleUpdated(address indexed _oldOracle, address indexed _newOracle);
  34 |     |     event SecondaryOracleUpdated(address indexed _oldOracle, address indexed _newOracle);
  35 |     | 
  36 |     |     // NOTE: Could still use Status to signal current FSM
  37 |     | 
  38 |     |     // --- Dependency setters ---
  39 |     | 
  40 |     |     /// @notice Sets the addresses of the contracts and initializes the system
  41 |     |     constructor(address _authorityAddress, address _primaryOracle, address _secondaryOracle) {
  42 |     |         _initializeAuthority(_authorityAddress);
  43 |     | 
  44 |     |         uint256 firstPrice = IPriceFetcher(_primaryOracle).fetchPrice();
  45 |     |         require(firstPrice != INVALID_PRICE, "EbtcFeed: Primary Oracle Must Work");
  46 |     | 
  47 |     |         _storePrice(firstPrice);
  48 |     | 
  49 |     |         primaryOracle = _primaryOracle;
  50 |     | 
  51 |     |         // If secondaryOracle is known at deployment let's add it
  52 |     |         if (_secondaryOracle != UNSET_ADDRESS) {
  53 |     |             uint256 secondaryOraclePrice = IPriceFetcher(_secondaryOracle).fetchPrice();
  54 |     | 
  55 |     |             if (secondaryOraclePrice != INVALID_PRICE) {
  56 |     |                 secondaryOracle = _secondaryOracle;
  57 |     |             }
  58 |     |         }
  59 |     |     }
  60 |     | 
  61 |     |     /// @notice Allows the owner to replace the primary oracle
  62 |     |     ///     The oracle must work (return non-zero value)
  63 |     |     function setPrimaryOracle(address _newPrimary) external requiresAuth {
  64 |     |         uint256 currentPrice = IPriceFetcher(_newPrimary).fetchPrice();
  65 |     |         require(currentPrice != INVALID_PRICE, "EbtcFeed: Primary Oracle Must Work");
  66 |     | 
  67 |     |         emit PrimaryOracleUpdated(primaryOracle, _newPrimary);
  68 |     |         primaryOracle = _newPrimary;
  69 |     |     }
  70 |     | 
  71 |     |     /// @notice Allows the owner to replace the secondary oracle
  72 |     |     ///     The oracle must work (return non-zero value), unless removed
  73 |     |     function setSecondaryOracle(address _newSecondary) external requiresAuth {
  74 |     |         // Allow governance to remove the secondary oracle
  75 |     |         if (_newSecondary != UNSET_ADDRESS) {
  76 |     |             uint256 currentPrice = IPriceFetcher(_newSecondary).fetchPrice();
  77 |     |             require(currentPrice != INVALID_PRICE, "EbtcFeed: Secondary Oracle Must Work");
  78 |     |         }
  79 |     | 
  80 |     |         emit SecondaryOracleUpdated(secondaryOracle, _newSecondary);
  81 |     |         secondaryOracle = _newSecondary;
  82 |     |     }
  83 |     | 
  84 |     |     /// @notice Fetch the Latest Valid Price
  85 |     |     ///     Assumes the oracle call will return 0 if the data is invalid
  86 |     |     ///     Any non-zero value will be interpreted as valid
  87 |     |     ///     The security checks must be performed by the OracleCallers
  88 |     |     ///
  89 |     |     ///     Logic Breakdown:
  90 |     |     ///
  91 |     |     ///     If primary works, use that and store it as last good price
  92 |     |     ///
  93 |     |     ///     If not, try using secondary, if secondary works, use that and store it as last good price
  94 |     |     ///
  95 |     |     ///     If neither work, use the last good price
  96 |     |     ///
  97 |     |     ///     @dev All calls are done via `tinfoilCall` to allow the maximum resiliency we are able to provide
  98 |     |     ///     Due to this, a OracleCaller has to be written, which will be responsible for calling the real oracle
  99 |     |     ///     this ensures all interfaces are the same and that the logic here is to handle:
 100 |     |     ///     - Functioning Case
 101 |     |     ///     - All types of DOSes by the Oracles
 102 | *   |     function fetchPrice() external override returns (uint256) {
 103 |     |         // Tinfoil Call
 104 | *   |         uint256 primaryResponse = tinfoilCall(
 105 | *   |             primaryOracle,
 106 | *   |             abi.encodeCall(IPriceFetcher.fetchPrice, ())
 107 |     |         );
 108 |     | 
 109 | *   |         if (primaryResponse != INVALID_PRICE) {
 110 | *   |             _storePrice(primaryResponse);
 111 | *   |             return primaryResponse;
 112 |     |         }
 113 |     | 
 114 | *   |         if (secondaryOracle == UNSET_ADDRESS) {
 115 | *   |             return lastGoodPrice; // No fallback, just return latest
 116 |     |         }
 117 |     | 
 118 |     |         // Let's try secondary
 119 |     |         uint256 secondaryResponse = tinfoilCall(
 120 |     |             secondaryOracle,
 121 |     |             abi.encodeCall(IPriceFetcher.fetchPrice, ())
 122 |     |         );
 123 |     | 
 124 |     |         if (secondaryResponse != INVALID_PRICE) {
 125 | *   |             _storePrice(secondaryResponse);
 126 | *   |             return secondaryResponse;
 127 |     |         }
 128 |     | 
 129 |     |         // No valid price, return last
 130 |     |         // NOTE: We could emit something here as this means both oracles are dead
 131 |     |         return lastGoodPrice;
 132 |     |     }
 133 |     | 
 134 |     |     /// @notice Stores the latest valid price.
 135 |     |     /// @param _currentPrice The price to be stored.
 136 | *   |     function _storePrice(uint256 _currentPrice) internal {
 137 | *   |         lastGoodPrice = _currentPrice;
 138 | *   |         emit LastGoodPriceUpdated(_currentPrice);
 139 |     |     }
 140 |     | 
 141 |     |     /// @dev Performs a TinfoilCall, with all known protections
 142 |     |     ///     Against:
 143 |     |     ///     GasGriefing (burning all the gas)
 144 |     |     ///     Return and Revert Bombing (sending insane amounts of data to trigger memory expansion)
 145 |     |     ///     Self-Destruction of contract
 146 |     |     ///
 147 |     |     ///     Also attempts to protect against returning incorrect data
 148 |     |     ///    `excessivelySafeCall` is modified to only load data if the length is the expected one
 149 |     |     ///     This would avoid against receiving gibberish data, most often arrays
 150 | *   |     function tinfoilCall(address _target, bytes memory _calldata) public returns (uint256) {
 151 |     |         // Cap gas at 2 MLN, we don't care about 1/64 cause we expect oracles to consume way less than 200k gas
 152 | *   |         uint256 gasLeft = gasleft();
 153 | *   |         uint256 cappedGas = gasLeft > GAS_LIMIT ? GAS_LIMIT : gasLeft;
 154 |     | 
 155 |     |         // NOTE: We could also just check for contract existence here to avoid more issues later
 156 |     | 
 157 | *   |         (bool success, bytes memory res) = excessivelySafeCall(_target, cappedGas, 0, 32, _calldata);
 158 |     | 
 159 |     |         // Check of success and length allows to ignore checking for contract existence
 160 |     |         //  since non-existent contract cannot return value
 161 | *   |         if (success && res.length == 32) {
 162 |     |             // Parse return value as uint256
 163 | *   |             return abi.decode(res, (uint256));
 164 |     |         }
 165 |     | 
 166 |     |         return INVALID_PRICE;
 167 |     |     }
 168 |     | 
 169 |     |     /// @dev MODIFIED excessivelySafeCall to perform generic calls without getting gas bombed
 170 |     |     ///     Modified to only load the response if it has the intended length
 171 |     |     /// @custom:credits to: https://github.com/nomad-xyz/ExcessivelySafeCall/blob/main/src/ExcessivelySafeCall.sol
 172 | *   |     function excessivelySafeCall(
 173 |     |         address _target,
 174 |     |         uint256 _gas,
 175 |     |         uint256 _value,
 176 |     |         uint16 _expectedLength,
 177 |     |         bytes memory _calldata
 178 | *   |     ) internal returns (bool, bytes memory) {
 179 |     |         // set up for assembly call
 180 | *   |         uint256 _receivedLength; // Length of data we receive
 181 | *   |         bool _success;
 182 | *   |         bytes memory _returnData = new bytes(_expectedLength);
 183 |     |         // dispatch message to recipient
 184 |     |         // by assembly calling "handle" function
 185 |     |         // we call via assembly to avoid memcopying a very large returndata
 186 |     |         // returned by a malicious contract
 187 |     |         assembly {
 188 | *   |             _success := call(
 189 | *   |                 _gas, // gas
 190 | *   |                 _target, // recipient
 191 | *   |                 _value, // ether value
 192 | *   |                 add(_calldata, 0x20), // inloc
 193 | *   |                 mload(_calldata), // inlen
 194 | *   |                 0, // outloc
 195 | *   |                 0 // outlen
 196 |     |             )
 197 |     |             // limit our copy to 256 bytes
 198 | *   |             _receivedLength := returndatasize()
 199 |     |             // NOTE: Read the data only if it's the expected length, else it must be some weird stuff
 200 | *   |             if eq(_receivedLength, _expectedLength) {
 201 |     |                 // Store the length of the copied bytes
 202 | *   |                 mstore(_returnData, _receivedLength)
 203 |     |                 // copy the bytes from returndata[0:_receivedLength]
 204 | *   |                 returndatacopy(add(_returnData, 0x20), 0, _receivedLength)
 205 |     |             }
 206 |     |         }
 207 | *   |         return (_success, _returnData);
 208 |     |     }
 209 |     | }
 210 |     | 

/mnt/c/Users/Lourens/Documents/Recon-Fuzz/collabs/ebtc/packages/contracts/contracts/FeeRecipient.sol
  1 |     | // SPDX-License-Identifier: MIT
  2 |     | 
  3 |     | pragma solidity 0.8.17;
  4 |     | 
  5 |     | import "./Dependencies/Ownable.sol";
  6 |     | import "./Dependencies/AuthNoOwner.sol";
  7 |     | import "./Dependencies/IERC20.sol";
  8 |     | import "./Dependencies/SafeERC20.sol";
  9 |     | 
 10 |     | /// @notice Minimal fee recipient
 11 |     | /// @notice Tokens can be swept to owner address by authorized user
 12 |     | contract FeeRecipient is Ownable, AuthNoOwner {
 13 |     |     using SafeERC20 for IERC20;
 14 |     | 
 15 |     |     event SweepTokenSuccess(address indexed _token, uint256 _amount, address indexed _recipient);
 16 |     | 
 17 |     |     string public constant NAME = "FeeRecipient";
 18 |     | 
 19 |     |     /// @dev Contract constructor that sets the owner and authority of the contract.
 20 |     |     /// @param _ownerAddress Address of the contract owner.
 21 |     |     /// @param _authorityAddress Address of the authority.
 22 |     |     constructor(address _ownerAddress, address _authorityAddress) {
 23 |     |         _transferOwnership(_ownerAddress);
 24 |     |         _initializeAuthority(_authorityAddress);
 25 |     |     }
 26 |     | 
 27 |     |     // === Governed Functions === //
 28 |     | 
 29 |     |     /// @dev Function to move unintended dust that are not protected
 30 |     |     /// @notice moves given amount of given token (collateral is NOT allowed)
 31 |     |     /// @notice because recipient are fixed, this function is safe to be called by anyone
 32 |     |     function sweepToken(address token, uint256 amount) public requiresAuth {
 33 |     |         uint256 balance = IERC20(token).balanceOf(address(this));
 34 |     |         require(amount <= balance, "FeeRecipient: Attempt to sweep more than balance");
 35 |     | 
 36 |     |         address _owner = owner();
 37 |     |         IERC20(token).safeTransfer(_owner, amount);
 38 |     | 
 39 |     |         emit SweepTokenSuccess(token, amount, _owner);
 40 |     |     }
 41 |     | }
 42 |     | 

/mnt/c/Users/Lourens/Documents/Recon-Fuzz/collabs/ebtc/packages/contracts/contracts/FixedAdapter.sol
  1 |     | // SPDX-License-Identifier: MIT
  2 |     | pragma solidity 0.8.17;
  3 |     | 
  4 |     | import {AggregatorV3Interface} from "./Dependencies/AggregatorV3Interface.sol";
  5 |     | 
  6 | *   | contract FixedAdapter is AggregatorV3Interface {
  7 | *   |     uint8 public constant override decimals = 18;
  8 |     |     uint256 public constant override version = 1;
  9 |     | 
 10 |     |     /// @notice PriceFeed always fetches current and previous rounds. It's ok to
 11 |     |     /// hardcode round IDs as long as they are greater than 0.
 12 | *   |     uint80 public constant CURRENT_ROUND = 2;
 13 | *   |     uint80 public constant PREVIOUS_ROUND = 1;
 14 | *   |     int256 internal constant ADAPTER_PRECISION = int256(10 ** decimals);
 15 |     | 
 16 |     |     function description() external view returns (string memory) {
 17 |     |         return "stETH/ETH Fixed Adapter";
 18 |     |     }
 19 |     | 
 20 |     |     // getRoundData and latestRoundData should both raise "No data present"
 21 |     |     // if they do not have data to report, instead of returning unset values
 22 |     |     // which could be misinterpreted as actual reported values.
 23 | *   |     function getRoundData(
 24 |     |         uint80 _roundId
 25 |     |     )
 26 |     |         external
 27 |     |         view
 28 |     |         returns (
 29 | *   |             uint80 roundId,
 30 |     |             int256 answer,
 31 |     |             uint256 startedAt,
 32 |     |             uint256 updatedAt,
 33 |     |             uint80 answeredInRound
 34 |     |         )
 35 |     |     {
 36 | *   |         require(_roundId == CURRENT_ROUND || _roundId == PREVIOUS_ROUND);
 37 |     | 
 38 | *   |         roundId = _roundId;
 39 | *   |         updatedAt = _roundId == CURRENT_ROUND ? block.timestamp : block.timestamp - 1;
 40 | *   |         answer = ADAPTER_PRECISION;
 41 |     |     }
 42 |     | 
 43 | *   |     function latestRoundData()
 44 |     |         external
 45 |     |         view
 46 |     |         returns (
 47 | *   |             uint80 roundId,
 48 |     |             int256 answer,
 49 |     |             uint256 startedAt,
 50 |     |             uint256 updatedAt,
 51 |     |             uint80 answeredInRound
 52 |     |         )
 53 |     |     {
 54 |     |         roundId = CURRENT_ROUND;
 55 | *   |         updatedAt = block.timestamp;
 56 | *   |         answer = ADAPTER_PRECISION;
 57 |     |     }
 58 |     | }
 59 |     | 

/mnt/c/Users/Lourens/Documents/Recon-Fuzz/collabs/ebtc/packages/contracts/contracts/Governor.sol
   1 |     | // SPDX-License-Identifier: AGPL-3.0-only
   2 |     | pragma solidity 0.8.17;
   3 |     | 
   4 |     | import {EnumerableSet} from "./Dependencies/EnumerableSet.sol";
   5 |     | import {Authority} from "./Dependencies/Auth.sol";
   6 |     | import {RolesAuthority} from "./Dependencies/RolesAuthority.sol";
   7 |     | 
   8 |     | /// @notice Role based Authority that supports up to 256 roles.
   9 |     | /// @notice We have taken the tradeoff of additional storage usage for easier readabiliy without using off-chain / indexing services.
  10 |     | /// @author BadgerDAO Expanded from Solmate RolesAuthority
  11 |     | /// @author Modified from Solmate (https://github.com/transmissions11/solmate/blob/main/src/auth/authorities/RolesAuthority.sol)
  12 |     | /// @author Modified from Dappsys (https://github.com/dapphub/ds-roles/blob/master/src/roles.sol)
  13 | *   | contract Governor is RolesAuthority {
  14 |     |     using EnumerableSet for EnumerableSet.Bytes32Set;
  15 |     |     using EnumerableSet for EnumerableSet.AddressSet;
  16 |     | 
  17 |     |     bytes32 NO_ROLES = bytes32(0);
  18 |     | 
  19 |     |     struct Role {
  20 |     |         uint8 roleId;
  21 |     |         string roleName;
  22 |     |     }
  23 |     | 
  24 |     |     struct Capability {
  25 |     |         address target;
  26 |     |         bytes4 functionSig;
  27 |     |         uint8[] roles;
  28 |     |     }
  29 |     | 
  30 |     |     mapping(uint8 => string) internal roleNames;
  31 |     | 
  32 |     |     event RoleNameSet(uint8 indexed role, string indexed name);
  33 |     | 
  34 |     |     /// @notice The contract constructor initializes RolesAuthority with the given owner.
  35 |     |     /// @param _owner The address of the owner, who gains all permissions by default.
  36 |     |     constructor(address _owner) RolesAuthority(_owner, Authority(address(this))) {}
  37 |     | 
  38 |     |     /// @notice Returns a list of users that are assigned a specific role.
  39 |     |     /// @dev This function searches all users and checks if they are assigned the given role.
  40 |     |     /// @dev Intended for off-chain utility only due to inefficiency.
  41 |     |     /// @param role The role ID to find users for.
  42 |     |     /// @return usersWithRole An array of addresses that are assigned the given role.
  43 |     |     function getUsersByRole(uint8 role) external view returns (address[] memory usersWithRole) {
  44 |     |         // Search over all users: O(n) * 2
  45 |     |         uint256 count;
  46 |     |         for (uint256 i = 0; i < users.length(); i++) {
  47 |     |             address user = users.at(i);
  48 |     |             bool _canCall = doesUserHaveRole(user, role);
  49 |     |             if (_canCall) {
  50 |     |                 count += 1;
  51 |     |             }
  52 |     |         }
  53 |     |         if (count > 0) {
  54 |     |             uint256 j = 0;
  55 |     |             usersWithRole = new address[](count);
  56 |     |             address[] memory _usrs = users.values();
  57 |     |             for (uint256 i = 0; i < _usrs.length; i++) {
  58 |     |                 address user = _usrs[i];
  59 |     |                 bool _canCall = doesUserHaveRole(user, role);
  60 |     |                 if (_canCall) {
  61 |     |                     usersWithRole[j] = user;
  62 |     |                     j++;
  63 |     |                 }
  64 |     |             }
  65 |     |         }
  66 |     |     }
  67 |     | 
  68 |     |     /// @notice Returns a list of roles that an address has.
  69 |     |     /// @dev This function searches all roles and checks if they are assigned to the given user.
  70 |     |     /// @dev Intended for off-chain utility only due to inefficiency.
  71 |     |     /// @param user The address of the user.
  72 |     |     /// @return rolesForUser An array of role IDs that the user has.
  73 |     |     function getRolesForUser(address user) external view returns (uint8[] memory rolesForUser) {
  74 |     |         // Enumerate over all possible roles and check if enabled
  75 |     |         uint256 count;
  76 |     |         for (uint8 i = 0; i <= type(uint8).max; ) {
  77 |     |             if (doesUserHaveRole(user, i)) {
  78 |     |                 count += 1;
  79 |     |             }
  80 |     |             if (i < type(uint8).max) {
  81 |     |                 i = i + 1;
  82 |     |             } else {
  83 |     |                 break;
  84 |     |             }
  85 |     |         }
  86 |     |         if (count > 0) {
  87 |     |             uint256 j = 0;
  88 |     |             rolesForUser = new uint8[](count);
  89 |     |             for (uint8 i = 0; i <= type(uint8).max; ) {
  90 |     |                 if (doesUserHaveRole(user, i)) {
  91 |     |                     rolesForUser[j] = i;
  92 |     |                     j++;
  93 |     |                 }
  94 |     |                 if (i < type(uint8).max) {
  95 |     |                     i = i + 1;
  96 |     |                 } else {
  97 |     |                     break;
  98 |     |                 }
  99 |     |             }
 100 |     |         }
 101 |     |     }
 102 |     | 
 103 |     |     /// @notice Converts a byte map representation to an array of role IDs.
 104 |     |     /// @param byteMap The bytes32 value encoding the roles.
 105 |     |     /// @return roleIds An array of role IDs extracted from the byte map.
 106 |     |     function getRolesFromByteMap(bytes32 byteMap) public pure returns (uint8[] memory roleIds) {
 107 |     |         uint256 count;
 108 |     |         for (uint8 i = 0; i <= type(uint8).max; ) {
 109 |     |             bool roleEnabled = (uint256(byteMap >> i) & 1) != 0;
 110 |     |             if (roleEnabled) {
 111 |     |                 count += 1;
 112 |     |             }
 113 |     |             if (i < type(uint8).max) {
 114 |     |                 i = i + 1;
 115 |     |             } else {
 116 |     |                 break;
 117 |     |             }
 118 |     |         }
 119 |     |         if (count > 0) {
 120 |     |             uint256 j = 0;
 121 |     |             roleIds = new uint8[](count);
 122 |     |             for (uint8 i = 0; i <= type(uint8).max; ) {
 123 |     |                 bool roleEnabled = (uint256(byteMap >> i) & 1) != 0;
 124 |     |                 if (roleEnabled) {
 125 |     |                     roleIds[j] = i;
 126 |     |                     j++;
 127 |     |                 }
 128 |     |                 if (i < type(uint8).max) {
 129 |     |                     i = i + 1;
 130 |     |                 } else {
 131 |     |                     break;
 132 |     |                 }
 133 |     |             }
 134 |     |         }
 135 |     |     }
 136 |     | 
 137 |     |     /// @notice Converts an array of role IDs to a byte map representation.
 138 |     |     /// @param roleIds An array of role IDs.
 139 |     |     /// @return A bytes32 value encoding the roles.
 140 |     |     function getByteMapFromRoles(uint8[] memory roleIds) public pure returns (bytes32) {
 141 |     |         bytes32 _data;
 142 |     |         for (uint256 i = 0; i < roleIds.length; i++) {
 143 |     |             _data |= bytes32(1 << uint256(roleIds[i]));
 144 |     |         }
 145 |     |         return _data;
 146 |     |     }
 147 |     | 
 148 |     |     /// @notice Retrieves all function signatures enabled for a target address.
 149 |     |     /// @param _target The target contract address.
 150 |     |     /// @return _funcs An array of function signatures enabled for the target.
 151 |     |     function getEnabledFunctionsInTarget(
 152 |     |         address _target
 153 |     |     ) public view returns (bytes4[] memory _funcs) {
 154 |     |         bytes32[] memory _sigs = enabledFunctionSigsByTarget[_target].values();
 155 |     |         if (_sigs.length > 0) {
 156 |     |             _funcs = new bytes4[](_sigs.length);
 157 |     |             for (uint256 i = 0; i < _sigs.length; ++i) {
 158 |     |                 _funcs[i] = bytes4(_sigs[i]);
 159 |     |             }
 160 |     |         }
 161 |     |     }
 162 |     | 
 163 |     |     /// @notice Retrieves the name associated with a role ID
 164 |     |     /// @param role The role ID
 165 |     |     /// @return roleName The name of the role
 166 |     |     function getRoleName(uint8 role) external view returns (string memory roleName) {
 167 |     |         return roleNames[role];
 168 |     |     }
 169 |     | 
 170 |     |     /// @notice Sets the name for a specific role ID for better readability
 171 |     |     /// @dev This function requires authorization
 172 |     |     /// @param role The role ID
 173 |     |     /// @param roleName The name to assign to the role
 174 |     |     function setRoleName(uint8 role, string memory roleName) external requiresAuth {
 175 |     |         roleNames[role] = roleName;
 176 |     | 
 177 |     |         emit RoleNameSet(role, roleName);
 178 |     |     }
 179 |     | }
 180 |     | 

/mnt/c/Users/Lourens/Documents/Recon-Fuzz/collabs/ebtc/packages/contracts/contracts/HintHelpers.sol
   1 |     | // SPDX-License-Identifier: MIT
   2 |     | 
   3 |     | pragma solidity 0.8.17;
   4 |     | 
   5 |     | import "./Interfaces/ICdpManager.sol";
   6 |     | import "./Interfaces/ISortedCdps.sol";
   7 |     | import "./Dependencies/EbtcBase.sol";
   8 |     | 
   9 |     | /// @title HintHelpers mainly serves to provide handy information to facilitate offchain integration like redemption bots.
  10 |     | /// @dev It is strongly recommended to use HintHelper for redemption purpose
  11 |     | contract HintHelpers is EbtcBase {
  12 |     |     string public constant NAME = "HintHelpers";
  13 |     | 
  14 |     |     ISortedCdps public immutable sortedCdps;
  15 |     |     ICdpManager public immutable cdpManager;
  16 |     | 
  17 |     |     // --- Events ---
  18 |     | 
  19 |     |     struct LocalVariables_getRedemptionHints {
  20 |     |         uint256 remainingEbtcToRedeem;
  21 |     |         uint256 minNetDebtInBTC;
  22 |     |         bytes32 currentCdpId;
  23 |     |         address currentCdpUser;
  24 |     |     }
  25 |     | 
  26 |     |     // --- Dependency setters ---
  27 |     |     constructor(
  28 |     |         address _sortedCdpsAddress,
  29 |     |         address _cdpManagerAddress,
  30 |     |         address _collateralAddress,
  31 |     |         address _activePoolAddress,
  32 |     |         address _priceFeedAddress
  33 |     |     ) EbtcBase(_activePoolAddress, _priceFeedAddress, _collateralAddress) {
  34 |     |         sortedCdps = ISortedCdps(_sortedCdpsAddress);
  35 |     |         cdpManager = ICdpManager(_cdpManagerAddress);
  36 |     |     }
  37 |     | 
  38 |     |     // --- Functions ---
  39 |     | 
  40 |     |     /// @notice Get the redemption hints for the specified amount of eBTC, price and maximum number of iterations.
  41 |     |     /// @param _EBTCamount The amount of eBTC to be redeemed.
  42 |     |     /// @param _price The current price of the stETH:eBTC.
  43 |     |     /// @param _maxIterations The maximum number of iterations to be performed.
  44 |     |     /// @return firstRedemptionHint The identifier of the first CDP to be considered for redemption.
  45 |     |     /// @return partialRedemptionHintNICR The new Nominal Collateral Ratio (NICR) of the CDP after partial redemption.
  46 |     |     /// @return truncatedEBTCamount The actual amount of eBTC that can be redeemed.
  47 |     |     /// @return partialRedemptionNewColl The new collateral amount after partial redemption.
  48 |     |     function getRedemptionHints(
  49 |     |         uint256 _EBTCamount,
  50 |     |         uint256 _price,
  51 |     |         uint256 _maxIterations
  52 |     |     )
  53 |     |         external
  54 |     |         view
  55 |     |         returns (
  56 |     |             bytes32 firstRedemptionHint,
  57 |     |             uint256 partialRedemptionHintNICR,
  58 |     |             uint256 truncatedEBTCamount,
  59 |     |             uint256 partialRedemptionNewColl
  60 |     |         )
  61 |     |     {
  62 |     |         LocalVariables_getRedemptionHints memory vars;
  63 |     |         {
  64 |     |             vars.remainingEbtcToRedeem = _EBTCamount;
  65 |     |             vars.currentCdpId = sortedCdps.getLast();
  66 |     |             vars.currentCdpUser = sortedCdps.getOwnerAddress(vars.currentCdpId);
  67 |     | 
  68 |     |             while (
  69 |     |                 vars.currentCdpUser != address(0) &&
  70 |     |                 cdpManager.getSyncedICR(vars.currentCdpId, _price) < MCR
  71 |     |             ) {
  72 |     |                 vars.currentCdpId = sortedCdps.getPrev(vars.currentCdpId);
  73 |     |                 vars.currentCdpUser = sortedCdps.getOwnerAddress(vars.currentCdpId);
  74 |     |             }
  75 |     |             firstRedemptionHint = vars.currentCdpId;
  76 |     |         }
  77 |     | 
  78 |     |         if (_maxIterations == 0) {
  79 |     |             _maxIterations = type(uint256).max;
  80 |     |         }
  81 |     | 
  82 |     |         // Underflow is intentionally used in _maxIterations-- > 0
  83 |     |         unchecked {
  84 |     |             while (
  85 |     |                 vars.currentCdpUser != address(0) &&
  86 |     |                 vars.remainingEbtcToRedeem > 0 &&
  87 |     |                 _maxIterations-- > 0
  88 |     |             ) {
  89 |     |                 // Apply pending debt
  90 |     |                 uint256 currentCdpDebt = cdpManager.getSyncedCdpDebt(vars.currentCdpId);
  91 |     | 
  92 |     |                 // If this CDP has more debt than the remaining to redeem, attempt a partial redemption
  93 |     |                 if (currentCdpDebt > vars.remainingEbtcToRedeem) {
  94 |     |                     uint256 _cachedEbtcToRedeem = vars.remainingEbtcToRedeem;
  95 |     |                     (
  96 |     |                         partialRedemptionNewColl,
  97 |     |                         partialRedemptionHintNICR
  98 |     |                     ) = _calculateCdpStateAfterPartialRedemption(vars, currentCdpDebt, _price);
  99 |     | 
 100 |     |                     // If the partial redemption would leave the CDP with less than the minimum allowed coll, bail out of partial redemption and return only the fully redeemable
 101 |     |                     if (
 102 |     |                         collateral.getPooledEthByShares(partialRedemptionNewColl) <
 103 |     |                         MIN_NET_STETH_BALANCE
 104 |     |                     ) {
 105 |     |                         partialRedemptionHintNICR = 0; //reset to 0 as there is no partial redemption in this case
 106 |     |                         partialRedemptionNewColl = 0;
 107 |     |                         vars.remainingEbtcToRedeem = _cachedEbtcToRedeem;
 108 |     |                     } else {
 109 |     |                         vars.remainingEbtcToRedeem = 0;
 110 |     |                     }
 111 |     |                     break;
 112 |     |                 } else {
 113 |     |                     vars.remainingEbtcToRedeem = vars.remainingEbtcToRedeem - currentCdpDebt;
 114 |     |                 }
 115 |     | 
 116 |     |                 vars.currentCdpId = sortedCdps.getPrev(vars.currentCdpId);
 117 |     |                 vars.currentCdpUser = sortedCdps.getOwnerAddress(vars.currentCdpId);
 118 |     |             }
 119 |     |         }
 120 |     | 
 121 |     |         truncatedEBTCamount = _EBTCamount - vars.remainingEbtcToRedeem;
 122 |     |     }
 123 |     | 
 124 |     |     /**
 125 |     |      * @notice Calculate the partial redemption information.
 126 |     |      * @dev This is an internal function used by getRedemptionHints.
 127 |     |      * @param vars The local variables of the getRedemptionHints function.
 128 |     |      * @param currentCdpDebt The net eBTC debt of the CDP.
 129 |     |      * @param _price The current price of the asset.
 130 |     |      * @return newCollShare The new collateral share amount after partial redemption.
 131 |     |      * @return newNICR The new Nominal Collateral Ratio (NICR) of the CDP after partial redemption.
 132 |     |      */
 133 |     |     function _calculateCdpStateAfterPartialRedemption(
 134 |     |         LocalVariables_getRedemptionHints memory vars,
 135 |     |         uint256 currentCdpDebt,
 136 |     |         uint256 _price
 137 |     |     ) internal view returns (uint256, uint256) {
 138 |     |         // maxReemable = min(remainingToRedeem, currentDebt)
 139 |     |         uint256 maxRedeemableEBTC = EbtcMath._min(vars.remainingEbtcToRedeem, currentCdpDebt);
 140 |     | 
 141 |     |         uint256 newCollShare = cdpManager.getSyncedCdpCollShares(vars.currentCdpId);
 142 |     | 
 143 |     |         vars.remainingEbtcToRedeem = vars.remainingEbtcToRedeem - maxRedeemableEBTC;
 144 |     |         uint256 collShareToReceive = collateral.getSharesByPooledEth(
 145 |     |             (maxRedeemableEBTC * DECIMAL_PRECISION) / _price
 146 |     |         );
 147 |     | 
 148 |     |         uint256 _newCollShareAfter = newCollShare - collShareToReceive;
 149 |     |         return (
 150 |     |             _newCollShareAfter,
 151 |     |             EbtcMath._computeNominalCR(_newCollShareAfter, currentCdpDebt - maxRedeemableEBTC)
 152 |     |         );
 153 |     |     }
 154 |     | 
 155 |     |     /* getApproxHint() - return address of a Cdp that is, on average, (length / numTrials) positions away in the 
 156 |     |     sortedCdps list from the correct insert position of the Cdp to be inserted. 
 157 |     |     
 158 |     |     Note: The output address is worst-case O(n) positions away from the correct insert position, however, the function 
 159 |     |     is probabilistic. Input can be tuned to guarantee results to a high degree of confidence, e.g:
 160 |     | 
 161 |     |     Submitting numTrials = k * sqrt(length), with k = 15 makes it very, very likely that the ouput address will 
 162 |     |     be <= sqrt(length) positions away from the correct insert position.
 163 |     |     */
 164 |     |     function getApproxHint(
 165 |     |         uint256 _CR,
 166 |     |         uint256 _numTrials,
 167 |     |         uint256 _inputRandomSeed
 168 |     |     ) external view returns (bytes32 hint, uint256 diff, uint256 latestRandomSeed) {
 169 |     |         uint256 arrayLength = cdpManager.getActiveCdpsCount();
 170 |     | 
 171 |     |         if (arrayLength == 0) {
 172 |     |             return (sortedCdps.nonExistId(), 0, _inputRandomSeed);
 173 |     |         }
 174 |     | 
 175 |     |         hint = sortedCdps.getLast();
 176 |     |         diff = EbtcMath._getAbsoluteDifference(_CR, cdpManager.getSyncedNominalICR(hint));
 177 |     |         latestRandomSeed = _inputRandomSeed;
 178 |     | 
 179 |     |         uint256 i = 1;
 180 |     |         bytes32[] memory cdpIds = sortedCdpsToArray();
 181 |     | 
 182 |     |         while (i < _numTrials) {
 183 |     |             latestRandomSeed = uint256(keccak256(abi.encodePacked(latestRandomSeed)));
 184 |     | 
 185 |     |             uint256 arrayIndex = latestRandomSeed % arrayLength;
 186 |     |             bytes32 _cId = cdpIds[arrayIndex];
 187 |     | 
 188 |     |             uint256 currentNICR = cdpManager.getSyncedNominalICR(_cId);
 189 |     | 
 190 |     |             // check if abs(current - CR) > abs(closest - CR), and update closest if current is closer
 191 |     |             uint256 currentDiff = EbtcMath._getAbsoluteDifference(currentNICR, _CR);
 192 |     | 
 193 |     |             if (currentDiff < diff) {
 194 |     |                 diff = currentDiff;
 195 |     |                 hint = _cId;
 196 |     |             }
 197 |     |             i++;
 198 |     |         }
 199 |     |     }
 200 |     | 
 201 |     |     function sortedCdpsToArray() public view returns (bytes32[] memory cdpIdArray) {
 202 |     |         uint256 size = sortedCdps.getSize();
 203 |     |         cdpIdArray = new bytes32[](size);
 204 |     | 
 205 |     |         if (size == 0) {
 206 |     |             // If the list is empty, return an empty array
 207 |     |             return cdpIdArray;
 208 |     |         }
 209 |     | 
 210 |     |         // Initialize the first CDP in the list
 211 |     |         bytes32 currentCdpId = sortedCdps.getFirst();
 212 |     | 
 213 |     |         for (uint256 i = 0; i < size; ++i) {
 214 |     |             // Add the current CDP to the array
 215 |     |             cdpIdArray[i] = currentCdpId;
 216 |     | 
 217 |     |             // Move to the next CDP in the list
 218 |     |             currentCdpId = sortedCdps.getNext(currentCdpId);
 219 |     |         }
 220 |     | 
 221 |     |         return cdpIdArray;
 222 |     |     }
 223 |     | 
 224 |     |     /// @notice Compute nominal CR for a specified collateral and debt amount
 225 |     |     /// @param _coll The collateral amount, in shares
 226 |     |     /// @param _debt The debt amount
 227 |     |     /// @return The computed nominal CR for the given collateral and debt
 228 |     |     function computeNominalCR(uint256 _coll, uint256 _debt) external pure returns (uint256) {
 229 |     |         return EbtcMath._computeNominalCR(_coll, _debt);
 230 |     |     }
 231 |     | 
 232 |     |     /// @notice Compute CR for a specified collateral, debt amount, and price
 233 |     |     /// @param _coll The collateral amount, in shares
 234 |     |     /// @param _debt The debt amount
 235 |     |     /// @param _price The current price
 236 |     |     /// @return The computed CR for the given parameters
 237 |     |     function computeCR(
 238 |     |         uint256 _coll,
 239 |     |         uint256 _debt,
 240 |     |         uint256 _price
 241 |     |     ) external pure returns (uint256) {
 242 |     |         return EbtcMath._computeCR(_coll, _debt, _price);
 243 |     |     }
 244 |     | }
 245 |     | 

/mnt/c/Users/Lourens/Documents/Recon-Fuzz/collabs/ebtc/packages/contracts/contracts/Interfaces/IActivePool.sol
  1 |     | // SPDX-License-Identifier: MIT
  2 |     | 
  3 |     | pragma solidity 0.8.17;
  4 |     | 
  5 |     | import "./IPool.sol";
  6 |     | import "./ITwapWeightedObserver.sol";
  7 |     | 
  8 |     | interface IActivePool is IPool, ITwapWeightedObserver {
  9 |     |     // --- Events ---
 10 |     |     event ActivePoolEBTCDebtUpdated(uint256 _EBTCDebt);
 11 |     |     event SystemCollSharesUpdated(uint256 _coll);
 12 |     |     event FeeRecipientClaimableCollSharesIncreased(uint256 _coll, uint256 _fee);
 13 |     |     event FeeRecipientClaimableCollSharesDecreased(uint256 _coll, uint256 _fee);
 14 |     |     event FlashLoanSuccess(
 15 |     |         address indexed _receiver,
 16 |     |         address indexed _token,
 17 |     |         uint256 _amount,
 18 |     |         uint256 _fee
 19 |     |     );
 20 |     |     event SweepTokenSuccess(address indexed _token, uint256 _amount, address indexed _recipient);
 21 |     | 
 22 |     |     // --- Functions ---
 23 |     |     function transferSystemCollShares(address _account, uint256 _amount) external;
 24 |     | 
 25 |     |     function increaseSystemCollShares(uint256 _value) external;
 26 |     | 
 27 |     |     function transferSystemCollSharesAndLiquidatorReward(
 28 |     |         address _account,
 29 |     |         uint256 _shares,
 30 |     |         uint256 _liquidatorRewardShares
 31 |     |     ) external;
 32 |     | 
 33 |     |     function allocateSystemCollSharesToFeeRecipient(uint256 _shares) external;
 34 |     | 
 35 |     |     function claimFeeRecipientCollShares(uint256 _shares) external;
 36 |     | 
 37 |     |     function feeRecipientAddress() external view returns (address);
 38 |     | 
 39 |     |     function getFeeRecipientClaimableCollShares() external view returns (uint256);
 40 |     | }
 41 |     | 

/mnt/c/Users/Lourens/Documents/Recon-Fuzz/collabs/ebtc/packages/contracts/contracts/Interfaces/IBaseTwapWeightedObserver.sol
  1 |     | // SPDX-License Identifier: MIT
  2 |     | pragma solidity 0.8.17;
  3 |     | 
  4 |     | interface IBaseTwapWeightedObserver {
  5 |     |     // NOTE: Packing manually is cheaper, but this is simpler to understand and follow
  6 |     |     struct PackedData {
  7 |     |         // Slot 0
  8 |     |         // Seconds in a year: 3.154e+7
  9 |     |         /// @dev Accumulator value recorded for TWAP Observer until last update
 10 |     |         uint128 observerCumuVal; // 3.154e+7 * 80 * 100e27 = 2.5232e+38 | log_2(100e27 * 3.154e+7 * 80) = 127.568522171
 11 |     |         /// @dev Accumulator for TWAP globally
 12 |     |         uint128 accumulator; // 3.154e+7 * 80 * 100e27 = 2.5232e+38 | log_2(100e27 * 3.154e+7 * 80) = 127.568522171
 13 |     |         // NOTE: We can further compress this slot but we will not be able to use only one (see u72 impl)
 14 |     |         /// So what's the point of making the code more complex?
 15 |     | 
 16 |     |         // Slot 1
 17 |     |         /// @dev last update timestamp for TWAP Observer
 18 |     |         uint64 lastObserved; // Thousands of Years, if we use relative time we can use u32 | Relative to deploy time (as immutable)
 19 |     |         /// @dev last update timestamp for TWAP global track(spot) value
 20 |     |         uint64 lastAccrued; // Thousands of years
 21 |     |         // Expect eBTC debt to never surpass 100e27, which is 100 BILLION eBTC
 22 |     |         // log_2(100e27) = 96.3359147517 | log_2(100e27 / 1e18) = 36.5412090438
 23 |     |         // We could use a u64
 24 |     |         /// @dev average value since last observe
 25 |     |         uint128 lastObservedAverage;
 26 |     |     }
 27 |     | }
 28 |     | 

/mnt/c/Users/Lourens/Documents/Recon-Fuzz/collabs/ebtc/packages/contracts/contracts/Interfaces/IBorrowerOperations.sol
  1 |     | // SPDX-License-Identifier: MIT
  2 |     | 
  3 |     | pragma solidity 0.8.17;
  4 |     | import "./IPositionManagers.sol";
  5 |     | 
  6 |     | // Common interface for the Cdp Manager.
  7 |     | interface IBorrowerOperations is IPositionManagers {
  8 |     |     // --- Events ---
  9 |     | 
 10 |     |     event FeeRecipientAddressChanged(address indexed _feeRecipientAddress);
 11 |     |     event FlashLoanSuccess(
 12 |     |         address indexed _receiver,
 13 |     |         address indexed _token,
 14 |     |         uint256 _amount,
 15 |     |         uint256 _fee
 16 |     |     );
 17 |     | 
 18 |     |     // --- Functions ---
 19 |     | 
 20 |     |     function openCdp(
 21 |     |         uint256 _EBTCAmount,
 22 |     |         bytes32 _upperHint,
 23 |     |         bytes32 _lowerHint,
 24 |     |         uint256 _stEthBalance
 25 |     |     ) external returns (bytes32);
 26 |     | 
 27 |     |     function openCdpFor(
 28 |     |         uint _EBTCAmount,
 29 |     |         bytes32 _upperHint,
 30 |     |         bytes32 _lowerHint,
 31 |     |         uint _collAmount,
 32 |     |         address _borrower
 33 |     |     ) external returns (bytes32);
 34 |     | 
 35 |     |     function addColl(
 36 |     |         bytes32 _cdpId,
 37 |     |         bytes32 _upperHint,
 38 |     |         bytes32 _lowerHint,
 39 |     |         uint256 _stEthBalanceIncrease
 40 |     |     ) external;
 41 |     | 
 42 |     |     function withdrawColl(
 43 |     |         bytes32 _cdpId,
 44 |     |         uint256 _stEthBalanceDecrease,
 45 |     |         bytes32 _upperHint,
 46 |     |         bytes32 _lowerHint
 47 |     |     ) external;
 48 |     | 
 49 |     |     function withdrawDebt(
 50 |     |         bytes32 _cdpId,
 51 |     |         uint256 _amount,
 52 |     |         bytes32 _upperHint,
 53 |     |         bytes32 _lowerHint
 54 |     |     ) external;
 55 |     | 
 56 |     |     function repayDebt(
 57 |     |         bytes32 _cdpId,
 58 |     |         uint256 _amount,
 59 |     |         bytes32 _upperHint,
 60 |     |         bytes32 _lowerHint
 61 |     |     ) external;
 62 |     | 
 63 |     |     function closeCdp(bytes32 _cdpId) external;
 64 |     | 
 65 |     |     function adjustCdp(
 66 |     |         bytes32 _cdpId,
 67 |     |         uint256 _stEthBalanceDecrease,
 68 |     |         uint256 _debtChange,
 69 |     |         bool isDebtIncrease,
 70 |     |         bytes32 _upperHint,
 71 |     |         bytes32 _lowerHint
 72 |     |     ) external;
 73 |     | 
 74 |     |     function adjustCdpWithColl(
 75 |     |         bytes32 _cdpId,
 76 |     |         uint256 _stEthBalanceDecrease,
 77 |     |         uint256 _debtChange,
 78 |     |         bool isDebtIncrease,
 79 |     |         bytes32 _upperHint,
 80 |     |         bytes32 _lowerHint,
 81 |     |         uint256 _stEthBalanceIncrease
 82 |     |     ) external;
 83 |     | 
 84 |     |     function claimSurplusCollShares() external;
 85 |     | 
 86 |     |     function feeRecipientAddress() external view returns (address);
 87 |     | }
 88 |     | 

/mnt/c/Users/Lourens/Documents/Recon-Fuzz/collabs/ebtc/packages/contracts/contracts/Interfaces/ICdpManager.sol
  1 |     | // SPDX-License-Identifier: MIT
  2 |     | 
  3 |     | pragma solidity 0.8.17;
  4 |     | 
  5 |     | import "./IEbtcBase.sol";
  6 |     | import "./ICdpManagerData.sol";
  7 |     | 
  8 |     | // Common interface for the Cdp Manager.
  9 |     | interface ICdpManager is IEbtcBase, ICdpManagerData {
 10 |     |     // --- Functions ---
 11 |     |     function liquidate(bytes32 _cdpId) external;
 12 |     | 
 13 |     |     function partiallyLiquidate(
 14 |     |         bytes32 _cdpId,
 15 |     |         uint256 _partialAmount,
 16 |     |         bytes32 _upperPartialHint,
 17 |     |         bytes32 _lowerPartialHint
 18 |     |     ) external;
 19 |     | 
 20 |     |     function batchLiquidateCdps(bytes32[] calldata _cdpArray) external;
 21 |     | 
 22 |     |     function redeemCollateral(
 23 |     |         uint256 _EBTCAmount,
 24 |     |         bytes32 _firstRedemptionHint,
 25 |     |         bytes32 _upperPartialRedemptionHint,
 26 |     |         bytes32 _lowerPartialRedemptionHint,
 27 |     |         uint256 _partialRedemptionHintNICR,
 28 |     |         uint256 _maxIterations,
 29 |     |         uint256 _maxFee
 30 |     |     ) external;
 31 |     | 
 32 |     |     function updateStakeAndTotalStakes(bytes32 _cdpId) external returns (uint256);
 33 |     | 
 34 |     |     function syncAccounting(bytes32 _cdpId) external;
 35 |     | 
 36 |     |     function closeCdp(bytes32 _cdpId, address _borrower, uint256 _debt, uint256 _coll) external;
 37 |     | 
 38 |     |     function getRedemptionRate() external view returns (uint256);
 39 |     | 
 40 |     |     function getRedemptionRateWithDecay() external view returns (uint256);
 41 |     | 
 42 |     |     function getRedemptionFeeWithDecay(uint256 _stETHToRedeem) external view returns (uint256);
 43 |     | 
 44 |     |     function getCdpStatus(bytes32 _cdpId) external view returns (uint256);
 45 |     | 
 46 |     |     function getCdpStake(bytes32 _cdpId) external view returns (uint256);
 47 |     | 
 48 |     |     function getCdpDebt(bytes32 _cdpId) external view returns (uint256);
 49 |     | 
 50 |     |     function getCdpCollShares(bytes32 _cdpId) external view returns (uint256);
 51 |     | 
 52 |     |     function getCdpLiquidatorRewardShares(bytes32 _cdpId) external view returns (uint);
 53 |     | 
 54 |     |     function initializeCdp(
 55 |     |         bytes32 _cdpId,
 56 |     |         uint256 _debt,
 57 |     |         uint256 _coll,
 58 |     |         uint256 _liquidatorRewardShares,
 59 |     |         address _borrower
 60 |     |     ) external;
 61 |     | 
 62 |     |     function updateCdp(
 63 |     |         bytes32 _cdpId,
 64 |     |         address _borrower,
 65 |     |         uint256 _coll,
 66 |     |         uint256 _debt,
 67 |     |         uint256 _newColl,
 68 |     |         uint256 _newDebt
 69 |     |     ) external;
 70 |     | 
 71 |     |     function getCachedTCR(uint256 _price) external view returns (uint256);
 72 |     | 
 73 |     |     function checkRecoveryMode(uint256 _price) external view returns (bool);
 74 |     | }
 75 |     | 

/mnt/c/Users/Lourens/Documents/Recon-Fuzz/collabs/ebtc/packages/contracts/contracts/Interfaces/ICdpManagerData.sol
   1 |     | // SPDX-License-Identifier: MIT
   2 |     | 
   3 |     | pragma solidity 0.8.17;
   4 |     | 
   5 |     | import "./ICollSurplusPool.sol";
   6 |     | import "./IEBTCToken.sol";
   7 |     | import "./ISortedCdps.sol";
   8 |     | import "./IActivePool.sol";
   9 |     | import "./IRecoveryModeGracePeriod.sol";
  10 |     | import "../Dependencies/ICollateralTokenOracle.sol";
  11 |     | 
  12 |     | // Common interface for the Cdp Manager.
  13 |     | interface ICdpManagerData is IRecoveryModeGracePeriod {
  14 |     |     // --- Events ---
  15 |     | 
  16 |     |     event StakingRewardSplitSet(uint256 _stakingRewardSplit);
  17 |     |     event RedemptionFeeFloorSet(uint256 _redemptionFeeFloor);
  18 |     |     event MinuteDecayFactorSet(uint256 _minuteDecayFactor);
  19 |     |     event BetaSet(uint256 _beta);
  20 |     |     event RedemptionsPaused(bool _paused);
  21 |     | 
  22 |     |     event Liquidation(uint256 _liquidatedDebt, uint256 _liquidatedColl, uint256 _liqReward);
  23 |     |     event Redemption(
  24 |     |         uint256 _debtToRedeemExpected,
  25 |     |         uint256 _debtToRedeemActual,
  26 |     |         uint256 _collSharesSent,
  27 |     |         uint256 _feeCollShares,
  28 |     |         address indexed _redeemer
  29 |     |     );
  30 |     |     event CdpUpdated(
  31 |     |         bytes32 indexed _cdpId,
  32 |     |         address indexed _borrower,
  33 |     |         address indexed _executor,
  34 |     |         uint256 _oldDebt,
  35 |     |         uint256 _oldCollShares,
  36 |     |         uint256 _debt,
  37 |     |         uint256 _collShares,
  38 |     |         uint256 _stake,
  39 |     |         CdpOperation _operation
  40 |     |     );
  41 |     |     event CdpLiquidated(
  42 |     |         bytes32 indexed _cdpId,
  43 |     |         address indexed _borrower,
  44 |     |         uint _debt,
  45 |     |         uint _collShares,
  46 |     |         CdpOperation _operation,
  47 |     |         address indexed _liquidator,
  48 |     |         uint _premiumToLiquidator
  49 |     |     );
  50 |     |     event CdpPartiallyLiquidated(
  51 |     |         bytes32 indexed _cdpId,
  52 |     |         address indexed _borrower,
  53 |     |         uint256 _debt,
  54 |     |         uint256 _collShares,
  55 |     |         CdpOperation operation,
  56 |     |         address indexed _liquidator,
  57 |     |         uint _premiumToLiquidator
  58 |     |     );
  59 |     |     event BaseRateUpdated(uint256 _baseRate);
  60 |     |     event LastRedemptionTimestampUpdated(uint256 _lastFeeOpTime);
  61 |     |     event TotalStakesUpdated(uint256 _newTotalStakes);
  62 |     |     event SystemSnapshotsUpdated(uint256 _totalStakesSnapshot, uint256 _totalCollateralSnapshot);
  63 |     |     event SystemDebtRedistributionIndexUpdated(uint256 _systemDebtRedistributionIndex);
  64 |     |     event CdpDebtRedistributionIndexUpdated(bytes32 _cdpId, uint256 _cdpDebtRedistributionIndex);
  65 |     |     event CdpArrayIndexUpdated(bytes32 _cdpId, uint256 _newIndex);
  66 |     |     event StEthIndexUpdated(uint256 _oldIndex, uint256 _newIndex, uint256 _updTimestamp);
  67 |     |     event CollateralFeePerUnitUpdated(uint256 _oldPerUnit, uint256 _newPerUnit, uint256 _feeTaken);
  68 |     |     event CdpFeeSplitApplied(
  69 |     |         bytes32 _cdpId,
  70 |     |         uint256 _oldPerUnitCdp,
  71 |     |         uint256 _newPerUnitCdp,
  72 |     |         uint256 _collReduced,
  73 |     |         uint256 _collLeft
  74 |     |     );
  75 |     | 
  76 |     |     enum CdpOperation {
  77 |     |         openCdp,
  78 |     |         closeCdp,
  79 |     |         adjustCdp,
  80 |     |         syncAccounting,
  81 |     |         liquidateInNormalMode,
  82 |     |         liquidateInRecoveryMode,
  83 |     |         redeemCollateral,
  84 |     |         partiallyLiquidate,
  85 |     |         failedPartialRedemption
  86 |     |     }
  87 |     | 
  88 |     |     enum Status {
  89 |     |         nonExistent,
  90 |     |         active,
  91 |     |         closedByOwner,
  92 |     |         closedByLiquidation,
  93 |     |         closedByRedemption
  94 |     |     }
  95 |     | 
  96 |     |     // Store the necessary data for a cdp
  97 |     |     struct Cdp {
  98 |     |         uint256 debt;
  99 |     |         uint256 coll;
 100 |     |         uint256 stake;
 101 |     |         uint128 liquidatorRewardShares;
 102 |     |         Status status;
 103 |     |     }
 104 |     | 
 105 |     |     /*
 106 |     |      * --- Variable container structs for liquidations ---
 107 |     |      *
 108 |     |      * These structs are used to hold, return and assign variables inside the liquidation functions,
 109 |     |      * in order to avoid the error: "CompilerError: Stack too deep".
 110 |     |      **/
 111 |     | 
 112 |     |     struct CdpDebtAndCollShares {
 113 |     |         uint256 debt;
 114 |     |         uint256 collShares;
 115 |     |     }
 116 |     | 
 117 |     |     struct LiquidationLocals {
 118 |     |         bytes32 cdpId;
 119 |     |         uint256 partialAmount; // used only for partial liquidation, default 0 means full liquidation
 120 |     |         uint256 price;
 121 |     |         uint256 ICR;
 122 |     |         bytes32 upperPartialHint;
 123 |     |         bytes32 lowerPartialHint;
 124 |     |         bool recoveryModeAtStart;
 125 |     |         uint256 TCR;
 126 |     |         uint256 totalSurplusCollShares;
 127 |     |         uint256 totalCollSharesToSend;
 128 |     |         uint256 totalDebtToBurn;
 129 |     |         uint256 totalDebtToRedistribute;
 130 |     |         uint256 totalLiquidatorRewardCollShares;
 131 |     |     }
 132 |     | 
 133 |     |     struct LiquidationRecoveryModeLocals {
 134 |     |         uint256 entireSystemDebt;
 135 |     |         uint256 entireSystemColl;
 136 |     |         uint256 totalDebtToBurn;
 137 |     |         uint256 totalCollSharesToSend;
 138 |     |         uint256 totalSurplusCollShares;
 139 |     |         bytes32 cdpId;
 140 |     |         uint256 price;
 141 |     |         uint256 ICR;
 142 |     |         uint256 totalDebtToRedistribute;
 143 |     |         uint256 totalLiquidatorRewardCollShares;
 144 |     |     }
 145 |     | 
 146 |     |     struct LocalVariables_OuterLiquidationFunction {
 147 |     |         uint256 price;
 148 |     |         bool recoveryModeAtStart;
 149 |     |         uint256 liquidatedDebt;
 150 |     |         uint256 liquidatedColl;
 151 |     |     }
 152 |     | 
 153 |     |     struct LocalVariables_LiquidationSequence {
 154 |     |         uint256 i;
 155 |     |         uint256 ICR;
 156 |     |         bytes32 cdpId;
 157 |     |         bool backToNormalMode;
 158 |     |         uint256 entireSystemDebt;
 159 |     |         uint256 entireSystemColl;
 160 |     |         uint256 price;
 161 |     |         uint256 TCR;
 162 |     |     }
 163 |     | 
 164 |     |     struct SingleRedemptionInputs {
 165 |     |         bytes32 cdpId;
 166 |     |         uint256 maxEBTCamount;
 167 |     |         uint256 price;
 168 |     |         bytes32 upperPartialRedemptionHint;
 169 |     |         bytes32 lowerPartialRedemptionHint;
 170 |     |         uint256 partialRedemptionHintNICR;
 171 |     |     }
 172 |     | 
 173 |     |     struct LiquidationValues {
 174 |     |         uint256 entireCdpDebt;
 175 |     |         uint256 debtToBurn;
 176 |     |         uint256 totalCollToSendToLiquidator;
 177 |     |         uint256 debtToRedistribute;
 178 |     |         uint256 collSurplus;
 179 |     |         uint256 liquidatorCollSharesReward;
 180 |     |     }
 181 |     | 
 182 |     |     struct LiquidationTotals {
 183 |     |         uint256 totalDebtInSequence;
 184 |     |         uint256 totalDebtToBurn;
 185 |     |         uint256 totalCollToSendToLiquidator;
 186 |     |         uint256 totalDebtToRedistribute;
 187 |     |         uint256 totalCollSurplus;
 188 |     |         uint256 totalCollReward;
 189 |     |     }
 190 |     | 
 191 |     |     // --- Variable container structs for redemptions ---
 192 |     | 
 193 |     |     struct RedemptionTotals {
 194 |     |         uint256 remainingDebtToRedeem;
 195 |     |         uint256 debtToRedeem;
 196 |     |         uint256 collSharesDrawn;
 197 |     |         uint256 totalCollSharesSurplus;
 198 |     |         uint256 feeCollShares;
 199 |     |         uint256 collSharesToRedeemer;
 200 |     |         uint256 decayedBaseRate;
 201 |     |         uint256 price;
 202 |     |         uint256 systemDebtAtStart;
 203 |     |         uint256 twapSystemDebtAtStart;
 204 |     |         uint256 systemCollSharesAtStart;
 205 |     |         uint256 tcrAtStart;
 206 |     |     }
 207 |     | 
 208 |     |     struct SingleRedemptionValues {
 209 |     |         uint256 debtToRedeem;
 210 |     |         uint256 collSharesDrawn;
 211 |     |         uint256 collSurplus;
 212 |     |         uint256 liquidatorRewardShares;
 213 |     |         bool cancelledPartial;
 214 |     |         bool fullRedemption;
 215 |     |         uint256 newPartialNICR;
 216 |     |     }
 217 |     | 
 218 |     |     function getActiveCdpsCount() external view returns (uint256);
 219 |     | 
 220 |     |     function totalStakes() external view returns (uint256);
 221 |     | 
 222 |     |     function ebtcToken() external view returns (IEBTCToken);
 223 |     | 
 224 |     |     function systemStEthFeePerUnitIndex() external view returns (uint256);
 225 |     | 
 226 |     |     function systemStEthFeePerUnitIndexError() external view returns (uint256);
 227 |     | 
 228 |     |     function stEthIndex() external view returns (uint256);
 229 |     | 
 230 |     |     function calcFeeUponStakingReward(
 231 |     |         uint256 _newIndex,
 232 |     |         uint256 _prevIndex
 233 |     |     ) external view returns (uint256, uint256, uint256);
 234 |     | 
 235 |     |     function syncGlobalAccounting() external; // Accrues StEthFeeSplit without influencing Grace Period
 236 |     | 
 237 |     |     function syncGlobalAccountingAndGracePeriod() external; // Accrues StEthFeeSplit and influences Grace Period
 238 |     | 
 239 |     |     function getAccumulatedFeeSplitApplied(
 240 |     |         bytes32 _cdpId,
 241 |     |         uint256 _systemStEthFeePerUnitIndex
 242 |     |     ) external view returns (uint256, uint256);
 243 |     | 
 244 |     |     function getCachedNominalICR(bytes32 _cdpId) external view returns (uint256);
 245 |     | 
 246 |     |     function getCachedICR(bytes32 _cdpId, uint256 _price) external view returns (uint256);
 247 |     | 
 248 |     |     function getSyncedCdpDebt(bytes32 _cdpId) external view returns (uint256);
 249 |     | 
 250 |     |     function getSyncedCdpCollShares(bytes32 _cdpId) external view returns (uint256);
 251 |     | 
 252 |     |     function getSyncedICR(bytes32 _cdpId, uint256 _price) external view returns (uint256);
 253 |     | 
 254 |     |     function getSyncedTCR(uint256 _price) external view returns (uint256);
 255 |     | 
 256 |     |     function getSyncedSystemCollShares() external view returns (uint256);
 257 |     | 
 258 |     |     function getSyncedNominalICR(bytes32 _cdpId) external view returns (uint256);
 259 |     | 
 260 |     |     function getPendingRedistributedDebt(bytes32 _cdpId) external view returns (uint256);
 261 |     | 
 262 |     |     function hasPendingRedistributedDebt(bytes32 _cdpId) external view returns (bool);
 263 |     | 
 264 |     |     function getSyncedDebtAndCollShares(
 265 |     |         bytes32 _cdpId
 266 |     |     ) external view returns (uint256 debt, uint256 collShares);
 267 |     | 
 268 |     |     function canLiquidateRecoveryMode(uint256 icr, uint256 tcr) external view returns (bool);
 269 |     | 
 270 |     |     function totalCollateralSnapshot() external view returns (uint256);
 271 |     | 
 272 |     |     function totalStakesSnapshot() external view returns (uint256);
 273 |     | }
 274 |     | 

/mnt/c/Users/Lourens/Documents/Recon-Fuzz/collabs/ebtc/packages/contracts/contracts/Interfaces/ICollSurplusPool.sol
  1 |     | // SPDX-License-Identifier: MIT
  2 |     | 
  3 |     | pragma solidity 0.8.17;
  4 |     | 
  5 |     | interface ICollSurplusPool {
  6 |     |     // --- Events ---
  7 |     | 
  8 |     |     event SurplusCollSharesAdded(
  9 |     |         bytes32 indexed _cdpId,
 10 |     |         address indexed _account,
 11 |     |         uint256 _claimableSurplusCollShares,
 12 |     |         uint256 _surplusCollSharesAddedFromCollateral,
 13 |     |         uint256 _surplusCollSharesAddedFromLiquidatorReward
 14 |     |     );
 15 |     |     event CollSharesTransferred(address indexed _to, uint256 _amount);
 16 |     | 
 17 |     |     event SweepTokenSuccess(address indexed _token, uint256 _amount, address indexed _recipient);
 18 |     | 
 19 |     |     // --- Contract setters ---
 20 |     | 
 21 |     |     function getTotalSurplusCollShares() external view returns (uint256);
 22 |     | 
 23 |     |     function getSurplusCollShares(address _account) external view returns (uint256);
 24 |     | 
 25 |     |     function increaseSurplusCollShares(
 26 |     |         bytes32 _cdpId,
 27 |     |         address _account,
 28 |     |         uint256 _collateralShares,
 29 |     |         uint256 _liquidatorRewardShares
 30 |     |     ) external;
 31 |     | 
 32 |     |     function claimSurplusCollShares(address _account) external;
 33 |     | 
 34 |     |     function increaseTotalSurplusCollShares(uint256 _value) external;
 35 |     | }
 36 |     | 

/mnt/c/Users/Lourens/Documents/Recon-Fuzz/collabs/ebtc/packages/contracts/contracts/Interfaces/IEBTCToken.sol
  1 |     | // SPDX-License-Identifier: MIT
  2 |     | 
  3 |     | pragma solidity 0.8.17;
  4 |     | 
  5 |     | import "../Dependencies/IERC20.sol";
  6 |     | import "../Dependencies/IERC2612.sol";
  7 |     | 
  8 |     | interface IEBTCToken is IERC20, IERC2612 {
  9 |     |     // --- Functions ---
 10 |     | 
 11 |     |     function mint(address _account, uint256 _amount) external;
 12 |     | 
 13 |     |     function burn(address _account, uint256 _amount) external;
 14 |     | }
 15 |     | 

/mnt/c/Users/Lourens/Documents/Recon-Fuzz/collabs/ebtc/packages/contracts/contracts/Interfaces/IERC3156FlashBorrower.sol
  1 |     | // SPDX-License-Identifier: MIT
  2 |     | 
  3 |     | pragma solidity 0.8.17;
  4 |     | 
  5 |     | interface IERC3156FlashBorrower {
  6 |     |     /**
  7 |     |      * @dev Receive a flash loan.
  8 |     |      * @param initiator The initiator of the loan.
  9 |     |      * @param token The loan currency.
 10 |     |      * @param amount The amount of tokens lent.
 11 |     |      * @param fee The additional amount of tokens to repay.
 12 |     |      * @param data Arbitrary data structure, intended to contain user-defined parameters.
 13 |     |      * @return The keccak256 hash of "ERC3156FlashBorrower.onFlashLoan"
 14 |     |      */
 15 |     |     function onFlashLoan(
 16 |     |         address initiator,
 17 |     |         address token,
 18 |     |         uint256 amount,
 19 |     |         uint256 fee,
 20 |     |         bytes calldata data
 21 |     |     ) external returns (bytes32);
 22 |     | }
 23 |     | 

/mnt/c/Users/Lourens/Documents/Recon-Fuzz/collabs/ebtc/packages/contracts/contracts/Interfaces/IERC3156FlashLender.sol
  1 |     | // SPDX-License-Identifier: MIT
  2 |     | 
  3 |     | pragma solidity 0.8.17;
  4 |     | 
  5 |     | import "./IERC3156FlashBorrower.sol";
  6 |     | 
  7 |     | interface IERC3156FlashLender {
  8 |     |     event FlashFeeSet(address indexed _setter, uint256 _oldFee, uint256 _newFee);
  9 |     |     event MaxFlashFeeSet(address indexed _setter, uint256 _oldMaxFee, uint256 _newMaxFee);
 10 |     |     event FlashLoansPaused(address indexed _setter, bool _paused);
 11 |     | 
 12 |     |     /// @dev The amount of currency available to be lent.
 13 |     |     /// @param token The loan currency.
 14 |     |     /// @return The amount of `token` that can be borrowed.
 15 |     |     function maxFlashLoan(address token) external view returns (uint256);
 16 |     | 
 17 |     |     /// @dev The fee to be charged for a given loan.
 18 |     |     /// @param token The loan currency.
 19 |     |     /// @param amount The amount of tokens lent.
 20 |     |     /// @return The amount of `token` to be charged for the loan, on top of the returned principal.
 21 |     |     function flashFee(address token, uint256 amount) external view returns (uint256);
 22 |     | 
 23 |     |     /// @dev Initiate a flash loan.
 24 |     |     /// @param receiver The receiver of the tokens in the loan, and the receiver of the callback.
 25 |     |     /// @param token The loan currency.
 26 |     |     /// @param amount The amount of tokens lent.
 27 |     |     /// @param data Arbitrary data structure, intended to contain user-defined parameters.
 28 |     |     function flashLoan(
 29 |     |         IERC3156FlashBorrower receiver,
 30 |     |         address token,
 31 |     |         uint256 amount,
 32 |     |         bytes calldata data
 33 |     |     ) external returns (bool);
 34 |     | }
 35 |     | 

/mnt/c/Users/Lourens/Documents/Recon-Fuzz/collabs/ebtc/packages/contracts/contracts/Interfaces/IEbtcBase.sol
  1 |     | // SPDX-License-Identifier: MIT
  2 |     | 
  3 |     | pragma solidity 0.8.17;
  4 |     | 
  5 |     | import "./IPriceFeed.sol";
  6 |     | 
  7 |     | interface IEbtcBase {
  8 |     |     function priceFeed() external view returns (IPriceFeed);
  9 |     | }
 10 |     | 

/mnt/c/Users/Lourens/Documents/Recon-Fuzz/collabs/ebtc/packages/contracts/contracts/Interfaces/IFallbackCaller.sol
  1 |     | // SPDX-License-Identifier: MIT
  2 |     | 
  3 |     | pragma solidity 0.8.17;
  4 |     | 
  5 |     | interface IFallbackCaller {
  6 |     |     // --- Events ---
  7 |     |     event FallbackTimeOutChanged(uint256 _oldTimeOut, uint256 _newTimeOut);
  8 |     | 
  9 |     |     // --- Function External View ---
 10 |     | 
 11 |     |     // NOTE: The fallback oracle must always return its answer scaled to 18 decimals where applicable
 12 |     |     //       The system will assume an 18 decimal response for efficiency.
 13 |     |     function getFallbackResponse() external view returns (uint256, uint256, bool);
 14 |     | 
 15 |     |     // NOTE: this returns the timeout window interval for the fallback oracle instead
 16 |     |     // of storing in the `PriceFeed` contract is retrieve for the `FallbackCaller`
 17 |     |     function fallbackTimeout() external view returns (uint256);
 18 |     | 
 19 |     |     // --- Function External Setter ---
 20 |     | 
 21 |     |     function setFallbackTimeout(uint256 newFallbackTimeout) external;
 22 |     | }
 23 |     | 

/mnt/c/Users/Lourens/Documents/Recon-Fuzz/collabs/ebtc/packages/contracts/contracts/Interfaces/IOracleCaller.sol
  1 |     | // SPDX-License-Identifier: MIT
  2 |     | 
  3 |     | pragma solidity 0.8.17;
  4 |     | 
  5 |     | import "./IPool.sol";
  6 |     | 
  7 |     | interface IOracleCaller {
  8 |     |     function getLatestPrice() external view returns (uint256);
  9 |     | }
 10 |     | 
 11 |     | interface IPriceFetcher {
 12 |     |     function fetchPrice() external returns (uint256);
 13 |     | }
 14 |     | 

/mnt/c/Users/Lourens/Documents/Recon-Fuzz/collabs/ebtc/packages/contracts/contracts/Interfaces/IPermitNonce.sol
  1 |     | // SPDX-License-Identifier: MIT
  2 |     | 
  3 |     | pragma solidity 0.8.17;
  4 |     | 
  5 |     | interface IPermitNonce {
  6 |     |     // --- Functions ---
  7 |     |     function increasePermitNonce() external returns (uint256);
  8 |     | 
  9 |     |     function nonces(address owner) external view returns (uint256);
 10 |     | }
 11 |     | 

/mnt/c/Users/Lourens/Documents/Recon-Fuzz/collabs/ebtc/packages/contracts/contracts/Interfaces/IPool.sol
  1 |     | // SPDX-License-Identifier: MIT
  2 |     | 
  3 |     | pragma solidity 0.8.17;
  4 |     | 
  5 |     | // Common interface for the Pools.
  6 |     | interface IPool {
  7 |     |     // --- Events ---
  8 |     | 
  9 |     |     event ETHBalanceUpdated(uint256 _newBalance);
 10 |     |     event EBTCBalanceUpdated(uint256 _newBalance);
 11 |     |     event CollSharesTransferred(address indexed _to, uint256 _amount);
 12 |     | 
 13 |     |     // --- Functions ---
 14 |     | 
 15 |     |     function getSystemCollShares() external view returns (uint256);
 16 |     | 
 17 |     |     function getSystemDebt() external view returns (uint256);
 18 |     | 
 19 |     |     function increaseSystemDebt(uint256 _amount) external;
 20 |     | 
 21 |     |     function decreaseSystemDebt(uint256 _amount) external;
 22 |     | }
 23 |     | 

/mnt/c/Users/Lourens/Documents/Recon-Fuzz/collabs/ebtc/packages/contracts/contracts/Interfaces/IPositionManagers.sol
  1 |     | // SPDX-License-Identifier: MIT
  2 |     | 
  3 |     | pragma solidity 0.8.17;
  4 |     | 
  5 |     | interface IPositionManagers {
  6 |     |     enum PositionManagerApproval {
  7 |     |         None,
  8 |     |         OneTime,
  9 |     |         Persistent
 10 |     |     }
 11 |     | 
 12 |     |     event PositionManagerApprovalSet(
 13 |     |         address indexed _borrower,
 14 |     |         address indexed _positionManager,
 15 |     |         PositionManagerApproval _approval
 16 |     |     );
 17 |     | 
 18 |     |     function getPositionManagerApproval(
 19 |     |         address _borrower,
 20 |     |         address _positionManager
 21 |     |     ) external view returns (PositionManagerApproval);
 22 |     | 
 23 |     |     function setPositionManagerApproval(
 24 |     |         address _positionManager,
 25 |     |         PositionManagerApproval _approval
 26 |     |     ) external;
 27 |     | 
 28 |     |     function revokePositionManagerApproval(address _positionManager) external;
 29 |     | 
 30 |     |     function renouncePositionManagerApproval(address _borrower) external;
 31 |     | 
 32 |     |     function permitPositionManagerApproval(
 33 |     |         address _borrower,
 34 |     |         address _positionManager,
 35 |     |         PositionManagerApproval _approval,
 36 |     |         uint _deadline,
 37 |     |         uint8 v,
 38 |     |         bytes32 r,
 39 |     |         bytes32 s
 40 |     |     ) external;
 41 |     | 
 42 |     |     function version() external view returns (string memory);
 43 |     | 
 44 |     |     function permitTypeHash() external view returns (bytes32);
 45 |     | 
 46 |     |     function domainSeparator() external view returns (bytes32);
 47 |     | }
 48 |     | 

/mnt/c/Users/Lourens/Documents/Recon-Fuzz/collabs/ebtc/packages/contracts/contracts/Interfaces/IPriceFeed.sol
  1 |     | // SPDX-License-Identifier: MIT
  2 |     | 
  3 |     | pragma solidity 0.8.17;
  4 |     | 
  5 |     | interface IPriceFeed {
  6 |     |     // --- Events ---
  7 |     |     event LastGoodPriceUpdated(uint256 _lastGoodPrice);
  8 |     |     event PriceFeedStatusChanged(Status newStatus);
  9 |     |     event FallbackCallerChanged(
 10 |     |         address indexed _oldFallbackCaller,
 11 |     |         address indexed _newFallbackCaller
 12 |     |     );
 13 |     |     event UnhealthyFallbackCaller(address indexed _fallbackCaller, uint256 timestamp);
 14 |     |     event CollateralFeedSourceUpdated(address indexed stEthFeed);
 15 |     | 
 16 |     |     // --- Structs ---
 17 |     | 
 18 |     |     struct ChainlinkResponse {
 19 |     |         uint80 roundEthBtcId;
 20 |     |         uint80 roundStEthEthId;
 21 |     |         uint256 answer;
 22 |     |         uint256 timestampEthBtc;
 23 |     |         uint256 timestampStEthEth;
 24 |     |         bool success;
 25 |     |     }
 26 |     | 
 27 |     |     struct FallbackResponse {
 28 |     |         uint256 answer;
 29 |     |         uint256 timestamp;
 30 |     |         bool success;
 31 |     |     }
 32 |     | 
 33 |     |     // --- Enum ---
 34 |     | 
 35 |     |     enum Status {
 36 |     |         chainlinkWorking,
 37 |     |         usingFallbackChainlinkUntrusted,
 38 |     |         bothOraclesUntrusted,
 39 |     |         usingFallbackChainlinkFrozen,
 40 |     |         usingChainlinkFallbackUntrusted
 41 |     |     }
 42 |     | 
 43 |     |     // --- Function ---
 44 |     |     function fetchPrice() external returns (uint256);
 45 |     | }
 46 |     | 

/mnt/c/Users/Lourens/Documents/Recon-Fuzz/collabs/ebtc/packages/contracts/contracts/Interfaces/IRecoveryModeGracePeriod.sol
  1 |     | // SPDX-License-Identifier: MIT
  2 |     | pragma solidity 0.8.17;
  3 |     | 
  4 |     | // Interface for State Updates that can trigger RM Liquidations
  5 |     | interface IRecoveryModeGracePeriod {
  6 |     |     event TCRNotified(uint256 TCR); /// NOTE: Mostly for debugging to ensure synch
  7 |     | 
  8 |     |     // NOTE: Ts is implicit in events (it's added by GETH)
  9 |     |     event GracePeriodStart();
 10 |     |     event GracePeriodEnd();
 11 |     |     event GracePeriodDurationSet(uint256 _recoveryModeGracePeriodDuration);
 12 |     | 
 13 |     |     function notifyStartGracePeriod(uint256 tcr) external;
 14 |     | 
 15 |     |     function notifyEndGracePeriod(uint256 tcr) external;
 16 |     | }
 17 |     | 

/mnt/c/Users/Lourens/Documents/Recon-Fuzz/collabs/ebtc/packages/contracts/contracts/Interfaces/ISortedCdps.sol
  1 |     | // SPDX-License-Identifier: MIT
  2 |     | 
  3 |     | pragma solidity 0.8.17;
  4 |     | 
  5 |     | // Common interface for the SortedCdps Doubly Linked List.
  6 |     | interface ISortedCdps {
  7 |     |     // --- Events ---
  8 |     | 
  9 |     |     event NodeAdded(bytes32 _id, uint _NICR);
 10 |     |     event NodeRemoved(bytes32 _id);
 11 |     | 
 12 |     |     // --- Functions ---
 13 |     | 
 14 |     |     function remove(bytes32 _id) external;
 15 |     | 
 16 |     |     function batchRemove(bytes32[] memory _ids) external;
 17 |     | 
 18 |     |     function reInsert(bytes32 _id, uint256 _newICR, bytes32 _prevId, bytes32 _nextId) external;
 19 |     | 
 20 |     |     function contains(bytes32 _id) external view returns (bool);
 21 |     | 
 22 |     |     function isFull() external view returns (bool);
 23 |     | 
 24 |     |     function isEmpty() external view returns (bool);
 25 |     | 
 26 |     |     function getSize() external view returns (uint256);
 27 |     | 
 28 |     |     function getMaxSize() external view returns (uint256);
 29 |     | 
 30 |     |     function getFirst() external view returns (bytes32);
 31 |     | 
 32 |     |     function getLast() external view returns (bytes32);
 33 |     | 
 34 |     |     function getNext(bytes32 _id) external view returns (bytes32);
 35 |     | 
 36 |     |     function getPrev(bytes32 _id) external view returns (bytes32);
 37 |     | 
 38 |     |     function validInsertPosition(
 39 |     |         uint256 _ICR,
 40 |     |         bytes32 _prevId,
 41 |     |         bytes32 _nextId
 42 |     |     ) external view returns (bool);
 43 |     | 
 44 |     |     function findInsertPosition(
 45 |     |         uint256 _ICR,
 46 |     |         bytes32 _prevId,
 47 |     |         bytes32 _nextId
 48 |     |     ) external view returns (bytes32, bytes32);
 49 |     | 
 50 |     |     function insert(
 51 |     |         address owner,
 52 |     |         uint256 _ICR,
 53 |     |         bytes32 _prevId,
 54 |     |         bytes32 _nextId
 55 |     |     ) external returns (bytes32);
 56 |     | 
 57 |     |     function getOwnerAddress(bytes32 _id) external pure returns (address);
 58 |     | 
 59 |     |     function nonExistId() external view returns (bytes32);
 60 |     | 
 61 |     |     function cdpCountOf(address owner) external view returns (uint256);
 62 |     | 
 63 |     |     function getCdpCountOf(
 64 |     |         address owner,
 65 |     |         bytes32 startNodeId,
 66 |     |         uint maxNodes
 67 |     |     ) external view returns (uint256, bytes32);
 68 |     | 
 69 |     |     function getCdpsOf(address owner) external view returns (bytes32[] memory);
 70 |     | 
 71 |     |     function getAllCdpsOf(
 72 |     |         address owner,
 73 |     |         bytes32 startNodeId,
 74 |     |         uint maxNodes
 75 |     |     ) external view returns (bytes32[] memory, uint256, bytes32);
 76 |     | 
 77 |     |     function cdpOfOwnerByIndex(address owner, uint256 index) external view returns (bytes32);
 78 |     | 
 79 |     |     function cdpOfOwnerByIdx(
 80 |     |         address owner,
 81 |     |         uint256 index,
 82 |     |         bytes32 startNodeId,
 83 |     |         uint maxNodes
 84 |     |     ) external view returns (bytes32, bool);
 85 |     | 
 86 |     |     function toCdpId(
 87 |     |         address owner,
 88 |     |         uint256 blockHeight,
 89 |     |         uint256 nonce
 90 |     |     ) external pure returns (bytes32);
 91 |     | 
 92 |     |     function nextCdpNonce() external view returns (uint256);
 93 |     | }
 94 |     | 

/mnt/c/Users/Lourens/Documents/Recon-Fuzz/collabs/ebtc/packages/contracts/contracts/Interfaces/ITwapWeightedObserver.sol
  1 |     | // SPDX-License Identifier: MIT
  2 |     | pragma solidity 0.8.17;
  3 |     | import {IBaseTwapWeightedObserver} from "./IBaseTwapWeightedObserver.sol";
  4 |     | 
  5 |     | interface ITwapWeightedObserver is IBaseTwapWeightedObserver {
  6 |     |     event TwapDisabled();
  7 |     | 
  8 |     |     function PERIOD() external view returns (uint256);
  9 |     | 
 10 |     |     function valueToTrack() external view returns (uint128);
 11 |     | 
 12 |     |     function timeToAccrue() external view returns (uint64);
 13 |     | 
 14 |     |     function getLatestAccumulator() external view returns (uint128);
 15 |     | 
 16 |     |     function observe() external returns (uint256);
 17 |     | 
 18 |     |     function update() external;
 19 |     | 
 20 |     |     function twapDisabled() external view returns (bool);
 21 |     | }
 22 |     | 

/mnt/c/Users/Lourens/Documents/Recon-Fuzz/collabs/ebtc/packages/contracts/contracts/Interfaces/IWETH.sol
  1 |     | // SPDX-License-Identifier: MIT
  2 |     | 
  3 |     | pragma solidity 0.8.17;
  4 |     | 
  5 |     | interface IWETH {
  6 |     |     function deposit() external payable;
  7 |     | 
  8 |     |     function withdraw(uint256) external;
  9 |     | 
 10 |     |     function transfer(address to, uint256 amount) external returns (bool);
 11 |     | 
 12 |     |     function transferFrom(address from, address to, uint256 amount) external returns (bool);
 13 |     | }
 14 |     | 

/mnt/c/Users/Lourens/Documents/Recon-Fuzz/collabs/ebtc/packages/contracts/contracts/LiquidationLibrary.sol
   1 |     | // SPDX-License-Identifier: MIT
   2 |     | 
   3 |     | pragma solidity 0.8.17;
   4 |     | import "./Interfaces/ICdpManagerData.sol";
   5 |     | import "./Interfaces/ICollSurplusPool.sol";
   6 |     | import "./Interfaces/IEBTCToken.sol";
   7 |     | import "./Interfaces/ISortedCdps.sol";
   8 |     | import "./Dependencies/ICollateralTokenOracle.sol";
   9 |     | import "./CdpManagerStorage.sol";
  10 |     | 
  11 |     | /// @title LiquidationLibrary mainly provide necessary logic to fulfill liquidation for eBTC Cdps.
  12 |     | /// @dev This contract shares same base and storage layout with CdpManager and is the delegatecall destination from CdpManager
  13 |     | contract LiquidationLibrary is CdpManagerStorage {
  14 |     |     constructor(
  15 |     |         address _borrowerOperationsAddress,
  16 |     |         address _collSurplusPool,
  17 |     |         address _ebtcToken,
  18 |     |         address _sortedCdps,
  19 |     |         address _activePool,
  20 |     |         address _priceFeed,
  21 |     |         address _collateral
  22 |     |     )
  23 |     |         CdpManagerStorage(
  24 |     |             address(0),
  25 |     |             address(0),
  26 |     |             _borrowerOperationsAddress,
  27 |     |             _collSurplusPool,
  28 |     |             _ebtcToken,
  29 |     |             _sortedCdps,
  30 |     |             _activePool,
  31 |     |             _priceFeed,
  32 |     |             _collateral
  33 |     |         )
  34 |     |     {}
  35 |     | 
  36 |     |     /// @notice Fully liquidate a single Cdp by ID. Cdp must meet the criteria for liquidation at the time of execution.
  37 |     |     /// @notice callable by anyone, attempts to liquidate the CdpId. Executes successfully if Cdp meets the conditions for liquidation (e.g. in Normal Mode, it liquidates if the Cdp's ICR < the system MCR).
  38 |     |     /// @dev forwards msg.data directly to the liquidation library using OZ proxy core delegation function
  39 |     |     /// @param _cdpId ID of the Cdp to liquidate.
  40 |     |     function liquidate(bytes32 _cdpId) external nonReentrantSelfAndBOps {
  41 |     |         _liquidateIndividualCdpSetup(_cdpId, 0, _cdpId, _cdpId);
  42 |     |     }
  43 |     | 
  44 |     |     /// @notice Partially liquidate a single Cdp.
  45 |     |     /// @dev forwards msg.data directly to the liquidation library using OZ proxy core delegation function
  46 |     |     /// @param _cdpId ID of the Cdp to partially liquidate.
  47 |     |     /// @param _partialAmount Amount to partially liquidate.
  48 |     |     /// @param _upperPartialHint Upper hint for reinsertion of the Cdp into the linked list.
  49 |     |     /// @param _lowerPartialHint Lower hint for reinsertion of the Cdp into the linked list.
  50 |     |     function partiallyLiquidate(
  51 |     |         bytes32 _cdpId,
  52 |     |         uint256 _partialAmount,
  53 |     |         bytes32 _upperPartialHint,
  54 |     |         bytes32 _lowerPartialHint
  55 |     |     ) external nonReentrantSelfAndBOps {
  56 |     |         require(_partialAmount != 0, "LiquidationLibrary: use `liquidate` for 100%");
  57 |     |         _liquidateIndividualCdpSetup(_cdpId, _partialAmount, _upperPartialHint, _lowerPartialHint);
  58 |     |     }
  59 |     | 
  60 |     |     // Single CDP liquidation function.
  61 |     |     function _liquidateIndividualCdpSetup(
  62 |     |         bytes32 _cdpId,
  63 |     |         uint256 _partialAmount,
  64 |     |         bytes32 _upperPartialHint,
  65 |     |         bytes32 _lowerPartialHint
  66 |     |     ) internal {
  67 |     |         _requireCdpIsActive(_cdpId);
  68 |     | 
  69 |     |         _syncAccounting(_cdpId);
  70 |     | 
  71 |     |         uint256 _price = priceFeed.fetchPrice();
  72 |     | 
  73 |     |         // prepare local variables
  74 |     |         uint256 _ICR = getCachedICR(_cdpId, _price); // @audit syncAccounting already called, guarenteed to be synced
  75 |     |         (uint256 _TCR, uint256 systemColl, uint256 systemDebt) = _getTCRWithSystemDebtAndCollShares(
  76 |     |             _price
  77 |     |         );
  78 |     | 
  79 |     |         // If CDP is above MCR
  80 |     |         if (_ICR >= MCR) {
  81 |     |             // We must be in RM
  82 |     |             require(
  83 |     |                 _checkICRAgainstLiqThreshold(_ICR, _TCR),
  84 |     |                 "LiquidationLibrary: ICR is not below liquidation threshold in current mode"
  85 |     |             );
  86 |     | 
  87 |     |             // == Grace Period == //
  88 |     |             uint128 cachedLastGracePeriodStartTimestamp = lastGracePeriodStartTimestamp;
  89 |     |             require(
  90 |     |                 cachedLastGracePeriodStartTimestamp != UNSET_TIMESTAMP,
  91 |     |                 "LiquidationLibrary: Recovery Mode grace period not started"
  92 |     |             );
  93 |     |             require(
  94 |     |                 block.timestamp >
  95 |     |                     cachedLastGracePeriodStartTimestamp + recoveryModeGracePeriodDuration,
  96 |     |                 "LiquidationLibrary: Recovery mode grace period still in effect"
  97 |     |             );
  98 |     |         } // Implicit Else Case, Implies ICR < MRC, meaning the CDP is liquidatable
  99 |     | 
 100 |     |         bool _recoveryModeAtStart = _TCR < CCR ? true : false;
 101 |     |         LiquidationLocals memory _liqState = LiquidationLocals(
 102 |     |             _cdpId,
 103 |     |             _partialAmount,
 104 |     |             _price,
 105 |     |             _ICR,
 106 |     |             _upperPartialHint,
 107 |     |             _lowerPartialHint,
 108 |     |             (_recoveryModeAtStart),
 109 |     |             _TCR,
 110 |     |             0,
 111 |     |             0,
 112 |     |             0,
 113 |     |             0,
 114 |     |             0
 115 |     |         );
 116 |     | 
 117 |     |         LiquidationRecoveryModeLocals memory _rs = LiquidationRecoveryModeLocals(
 118 |     |             systemDebt,
 119 |     |             systemColl,
 120 |     |             0,
 121 |     |             0,
 122 |     |             0,
 123 |     |             _cdpId,
 124 |     |             _price,
 125 |     |             _ICR,
 126 |     |             0,
 127 |     |             0
 128 |     |         );
 129 |     | 
 130 |     |         _liquidateIndividualCdpSetupCDP(_liqState, _rs);
 131 |     |     }
 132 |     | 
 133 |     |     // liquidate given CDP by repaying debt in full or partially if its ICR is below MCR or TCR in recovery mode.
 134 |     |     // For partial liquidation, caller should use HintHelper smart contract to get correct hints for reinsertion into sorted CDP list
 135 |     |     function _liquidateIndividualCdpSetupCDP(
 136 |     |         LiquidationLocals memory _liqState,
 137 |     |         LiquidationRecoveryModeLocals memory _recoveryState
 138 |     |     ) internal {
 139 |     |         LiquidationValues memory liquidationValues;
 140 |     | 
 141 |     |         uint256 startingSystemDebt = _recoveryState.entireSystemDebt;
 142 |     |         uint256 startingSystemColl = _recoveryState.entireSystemColl;
 143 |     | 
 144 |     |         if (_liqState.partialAmount == 0) {
 145 |     |             (
 146 |     |                 liquidationValues.debtToBurn,
 147 |     |                 liquidationValues.totalCollToSendToLiquidator,
 148 |     |                 liquidationValues.debtToRedistribute,
 149 |     |                 liquidationValues.liquidatorCollSharesReward,
 150 |     |                 liquidationValues.collSurplus
 151 |     |             ) = _liquidateCdpInGivenMode(_liqState, _recoveryState);
 152 |     |         } else {
 153 |     |             (
 154 |     |                 liquidationValues.debtToBurn,
 155 |     |                 liquidationValues.totalCollToSendToLiquidator
 156 |     |             ) = _liquidateCDPPartially(_liqState);
 157 |     |             if (
 158 |     |                 liquidationValues.totalCollToSendToLiquidator == 0 &&
 159 |     |                 liquidationValues.debtToBurn == 0
 160 |     |             ) {
 161 |     |                 // retry with fully liquidation
 162 |     |                 (
 163 |     |                     liquidationValues.debtToBurn,
 164 |     |                     liquidationValues.totalCollToSendToLiquidator,
 165 |     |                     liquidationValues.debtToRedistribute,
 166 |     |                     liquidationValues.liquidatorCollSharesReward,
 167 |     |                     liquidationValues.collSurplus
 168 |     |                 ) = _liquidateCdpInGivenMode(_liqState, _recoveryState);
 169 |     |             }
 170 |     |         }
 171 |     | 
 172 |     |         _finalizeLiquidation(
 173 |     |             liquidationValues.debtToBurn,
 174 |     |             liquidationValues.totalCollToSendToLiquidator,
 175 |     |             liquidationValues.debtToRedistribute,
 176 |     |             liquidationValues.liquidatorCollSharesReward,
 177 |     |             liquidationValues.collSurplus,
 178 |     |             startingSystemColl,
 179 |     |             startingSystemDebt,
 180 |     |             _liqState.price
 181 |     |         );
 182 |     |     }
 183 |     | 
 184 |     |     // liquidate (and close) the CDP from an external liquidator
 185 |     |     // this function would return the liquidated debt and collateral of the given CDP
 186 |     |     function _liquidateCdpInGivenMode(
 187 |     |         LiquidationLocals memory _liqState,
 188 |     |         LiquidationRecoveryModeLocals memory _recoveryState
 189 |     |     ) private returns (uint256, uint256, uint256, uint256, uint256) {
 190 |     |         if (_liqState.recoveryModeAtStart) {
 191 |     |             LiquidationRecoveryModeLocals
 192 |     |                 memory _outputState = _liquidateIndividualCdpSetupCDPInRecoveryMode(_recoveryState);
 193 |     | 
 194 |     |             // housekeeping leftover collateral for liquidated CDP
 195 |     |             if (_outputState.totalSurplusCollShares > 0) {
 196 |     |                 activePool.transferSystemCollShares(
 197 |     |                     address(collSurplusPool),
 198 |     |                     _outputState.totalSurplusCollShares
 199 |     |                 );
 200 |     |             }
 201 |     | 
 202 |     |             return (
 203 |     |                 _outputState.totalDebtToBurn,
 204 |     |                 _outputState.totalCollSharesToSend,
 205 |     |                 _outputState.totalDebtToRedistribute,
 206 |     |                 _outputState.totalLiquidatorRewardCollShares,
 207 |     |                 _outputState.totalSurplusCollShares
 208 |     |             );
 209 |     |         } else {
 210 |     |             LiquidationLocals memory _outputState = _liquidateIndividualCdpSetupCDPInNormalMode(
 211 |     |                 _liqState
 212 |     |             );
 213 |     |             return (
 214 |     |                 _outputState.totalDebtToBurn,
 215 |     |                 _outputState.totalCollSharesToSend,
 216 |     |                 _outputState.totalDebtToRedistribute,
 217 |     |                 _outputState.totalLiquidatorRewardCollShares,
 218 |     |                 _outputState.totalSurplusCollShares
 219 |     |             );
 220 |     |         }
 221 |     |     }
 222 |     | 
 223 |     |     function _liquidateIndividualCdpSetupCDPInNormalMode(
 224 |     |         LiquidationLocals memory _liqState
 225 |     |     ) private returns (LiquidationLocals memory) {
 226 |     |         // liquidate entire debt
 227 |     |         (
 228 |     |             uint256 _totalDebtToBurn,
 229 |     |             uint256 _totalColToSend,
 230 |     |             uint256 _liquidatorReward
 231 |     |         ) = _closeCdpByLiquidation(_liqState.cdpId);
 232 |     |         uint256 _cappedColPortion;
 233 |     |         uint256 _collSurplus;
 234 |     |         uint256 _debtToRedistribute;
 235 |     |         address _borrower = sortedCdps.getOwnerAddress(_liqState.cdpId);
 236 |     | 
 237 |     |         // I don't see an issue emitting the CdpUpdated() event up here and avoiding this extra cache, any objections?
 238 |     |         emit CdpUpdated(
 239 |     |             _liqState.cdpId,
 240 |     |             _borrower,
 241 |     |             msg.sender,
 242 |     |             _totalDebtToBurn,
 243 |     |             _totalColToSend,
 244 |     |             0,
 245 |     |             0,
 246 |     |             0,
 247 |     |             CdpOperation.liquidateInNormalMode
 248 |     |         );
 249 |     | 
 250 |     |         {
 251 |     |             (
 252 |     |                 _cappedColPortion,
 253 |     |                 _collSurplus,
 254 |     |                 _debtToRedistribute
 255 |     |             ) = _calculateFullLiquidationSurplusAndCap(
 256 |     |                 _liqState.ICR,
 257 |     |                 _liqState.price,
 258 |     |                 _totalDebtToBurn,
 259 |     |                 _totalColToSend
 260 |     |             );
 261 |     |             if (_collSurplus > 0) {
 262 |     |                 // due to division precision loss, should be zero surplus in normal mode
 263 |     |                 _cappedColPortion = _cappedColPortion + _collSurplus;
 264 |     |                 _collSurplus = 0;
 265 |     |             }
 266 |     |             if (_debtToRedistribute > 0) {
 267 |     |                 _totalDebtToBurn = _totalDebtToBurn - _debtToRedistribute;
 268 |     |             }
 269 |     |         }
 270 |     |         _liqState.totalDebtToBurn = _liqState.totalDebtToBurn + _totalDebtToBurn;
 271 |     |         _liqState.totalCollSharesToSend = _liqState.totalCollSharesToSend + _cappedColPortion;
 272 |     |         _liqState.totalDebtToRedistribute = _liqState.totalDebtToRedistribute + _debtToRedistribute;
 273 |     |         _liqState.totalLiquidatorRewardCollShares =
 274 |     |             _liqState.totalLiquidatorRewardCollShares +
 275 |     |             _liquidatorReward;
 276 |     | 
 277 |     |         // Emit events
 278 |     |         uint _debtToColl = (_totalDebtToBurn * DECIMAL_PRECISION) / _liqState.price;
 279 |     |         uint _cappedColl = collateral.getPooledEthByShares(_cappedColPortion + _liquidatorReward);
 280 |     | 
 281 |     |         emit CdpLiquidated(
 282 |     |             _liqState.cdpId,
 283 |     |             _borrower,
 284 |     |             _totalDebtToBurn,
 285 |     |             // please note this is the collateral share of the liquidated CDP
 286 |     |             _cappedColPortion,
 287 |     |             CdpOperation.liquidateInNormalMode,
 288 |     |             msg.sender,
 289 |     |             _cappedColl > _debtToColl ? (_cappedColl - _debtToColl) : 0
 290 |     |         );
 291 |     | 
 292 |     |         return _liqState;
 293 |     |     }
 294 |     | 
 295 |     |     function _liquidateIndividualCdpSetupCDPInRecoveryMode(
 296 |     |         LiquidationRecoveryModeLocals memory _recoveryState
 297 |     |     ) private returns (LiquidationRecoveryModeLocals memory) {
 298 |     |         // liquidate entire debt
 299 |     |         (
 300 |     |             uint256 _totalDebtToBurn,
 301 |     |             uint256 _totalColToSend,
 302 |     |             uint256 _liquidatorReward
 303 |     |         ) = _closeCdpByLiquidation(_recoveryState.cdpId);
 304 |     | 
 305 |     |         // cap the liquidated collateral if required
 306 |     |         uint256 _cappedColPortion;
 307 |     |         uint256 _collSurplus;
 308 |     |         uint256 _debtToRedistribute;
 309 |     |         address _borrower = sortedCdps.getOwnerAddress(_recoveryState.cdpId);
 310 |     | 
 311 |     |         // I don't see an issue emitting the CdpUpdated() event up here and avoiding an extra cache of the values, any objections?
 312 |     |         emit CdpUpdated(
 313 |     |             _recoveryState.cdpId,
 314 |     |             _borrower,
 315 |     |             msg.sender,
 316 |     |             _totalDebtToBurn,
 317 |     |             _totalColToSend,
 318 |     |             0,
 319 |     |             0,
 320 |     |             0,
 321 |     |             CdpOperation.liquidateInRecoveryMode
 322 |     |         );
 323 |     | 
 324 |     |         // avoid stack too deep
 325 |     |         {
 326 |     |             (
 327 |     |                 _cappedColPortion,
 328 |     |                 _collSurplus,
 329 |     |                 _debtToRedistribute
 330 |     |             ) = _calculateFullLiquidationSurplusAndCap(
 331 |     |                 _recoveryState.ICR,
 332 |     |                 _recoveryState.price,
 333 |     |                 _totalDebtToBurn,
 334 |     |                 _totalColToSend
 335 |     |             );
 336 |     |             if (_collSurplus > 0) {
 337 |     |                 if (_checkICRAgainstMCR(_recoveryState.ICR)) {
 338 |     |                     _cappedColPortion = _collSurplus + _cappedColPortion;
 339 |     |                     _collSurplus = 0;
 340 |     |                 } else {
 341 |     |                     collSurplusPool.increaseSurplusCollShares(
 342 |     |                         _recoveryState.cdpId,
 343 |     |                         _borrower,
 344 |     |                         _collSurplus,
 345 |     |                         0
 346 |     |                     );
 347 |     |                     _recoveryState.totalSurplusCollShares =
 348 |     |                         _recoveryState.totalSurplusCollShares +
 349 |     |                         _collSurplus;
 350 |     |                 }
 351 |     |             }
 352 |     |             if (_debtToRedistribute > 0) {
 353 |     |                 _totalDebtToBurn = _totalDebtToBurn - _debtToRedistribute;
 354 |     |             }
 355 |     |         }
 356 |     |         _recoveryState.totalDebtToBurn = _recoveryState.totalDebtToBurn + _totalDebtToBurn;
 357 |     |         _recoveryState.totalCollSharesToSend =
 358 |     |             _recoveryState.totalCollSharesToSend +
 359 |     |             _cappedColPortion;
 360 |     |         _recoveryState.totalDebtToRedistribute =
 361 |     |             _recoveryState.totalDebtToRedistribute +
 362 |     |             _debtToRedistribute;
 363 |     |         _recoveryState.totalLiquidatorRewardCollShares =
 364 |     |             _recoveryState.totalLiquidatorRewardCollShares +
 365 |     |             _liquidatorReward;
 366 |     | 
 367 |     |         // check if system back to normal mode
 368 |     |         _recoveryState.entireSystemDebt = _recoveryState.entireSystemDebt > _totalDebtToBurn
 369 |     |             ? _recoveryState.entireSystemDebt - _totalDebtToBurn
 370 |     |             : 0;
 371 |     |         _recoveryState.entireSystemColl = _recoveryState.entireSystemColl > _totalColToSend
 372 |     |             ? _recoveryState.entireSystemColl - _totalColToSend
 373 |     |             : 0;
 374 |     | 
 375 |     |         uint _debtToColl = (_totalDebtToBurn * DECIMAL_PRECISION) / _recoveryState.price;
 376 |     |         uint _cappedColl = collateral.getPooledEthByShares(_cappedColPortion + _liquidatorReward);
 377 |     |         emit CdpLiquidated(
 378 |     |             _recoveryState.cdpId,
 379 |     |             _borrower,
 380 |     |             _totalDebtToBurn,
 381 |     |             // please note this is the collateral share of the liquidated CDP
 382 |     |             _cappedColPortion,
 383 |     |             CdpOperation.liquidateInRecoveryMode,
 384 |     |             msg.sender,
 385 |     |             _cappedColl > _debtToColl ? (_cappedColl - _debtToColl) : 0
 386 |     |         );
 387 |     | 
 388 |     |         return _recoveryState;
 389 |     |     }
 390 |     | 
 391 |     |     // liquidate (and close) the CDP from an external liquidator
 392 |     |     // this function would return the liquidated debt and collateral of the given CDP
 393 |     |     // without emmiting events
 394 |     |     function _closeCdpByLiquidation(bytes32 _cdpId) private returns (uint256, uint256, uint256) {
 395 |     |         // calculate entire debt to repay
 396 |     |         (uint256 entireDebt, uint256 entireColl) = getSyncedDebtAndCollShares(_cdpId);
 397 |     | 
 398 |     |         // housekeeping after liquidation by closing the CDP
 399 |     |         uint256 _liquidatorReward = uint256(Cdps[_cdpId].liquidatorRewardShares);
 400 |     |         _closeCdp(_cdpId, Status.closedByLiquidation);
 401 |     | 
 402 |     |         return (entireDebt, entireColl, _liquidatorReward);
 403 |     |     }
 404 |     | 
 405 |     |     // Liquidate partially the CDP by an external liquidator
 406 |     |     // This function would return the liquidated debt and collateral of the given CDP
 407 |     |     function _liquidateCDPPartially(
 408 |     |         LiquidationLocals memory _partialState
 409 |     |     ) private returns (uint256, uint256) {
 410 |     |         bytes32 _cdpId = _partialState.cdpId;
 411 |     |         uint256 _partialDebt = _partialState.partialAmount;
 412 |     | 
 413 |     |         // calculate entire debt to repay
 414 |     |         CdpDebtAndCollShares memory _debtAndColl = _getSyncedDebtAndCollShares(_cdpId);
 415 |     |         _requirePartialLiqDebtSize(_partialDebt, _debtAndColl.debt, _partialState.price);
 416 |     |         uint256 newDebt = _debtAndColl.debt - _partialDebt;
 417 |     | 
 418 |     |         // credit to https://arxiv.org/pdf/2212.07306.pdf for details
 419 |     |         (uint256 _partialColl, uint256 newColl, ) = _calculatePartialLiquidationSurplusAndCap(
 420 |     |             _partialState.ICR,
 421 |     |             _partialState.price,
 422 |     |             _partialDebt,
 423 |     |             _debtAndColl.collShares
 424 |     |         );
 425 |     | 
 426 |     |         // early return: if new collateral is zero, we have a full liqudiation
 427 |     |         if (newColl == 0) {
 428 |     |             return (0, 0);
 429 |     |         }
 430 |     | 
 431 |     |         // If we have coll remaining, it must meet minimum CDP size requirements
 432 |     |         _requirePartialLiqCollSize(collateral.getPooledEthByShares(newColl));
 433 |     | 
 434 |     |         // updating the CDP accounting for partial liquidation
 435 |     |         _partiallyReduceCdpDebt(_cdpId, _partialDebt, _partialColl);
 436 |     | 
 437 |     |         // reInsert into sorted CDP list after partial liquidation
 438 |     |         {
 439 |     |             _reInsertPartialLiquidation(
 440 |     |                 _partialState,
 441 |     |                 EbtcMath._computeNominalCR(newColl, newDebt),
 442 |     |                 _debtAndColl.debt,
 443 |     |                 _debtAndColl.collShares
 444 |     |             );
 445 |     |             uint _debtToColl = (_partialDebt * DECIMAL_PRECISION) / _partialState.price;
 446 |     |             uint _cappedColl = collateral.getPooledEthByShares(_partialColl);
 447 |     |             emit CdpPartiallyLiquidated(
 448 |     |                 _cdpId,
 449 |     |                 sortedCdps.getOwnerAddress(_cdpId),
 450 |     |                 _partialDebt,
 451 |     |                 _partialColl,
 452 |     |                 CdpOperation.partiallyLiquidate,
 453 |     |                 msg.sender,
 454 |     |                 _cappedColl > _debtToColl ? (_cappedColl - _debtToColl) : 0
 455 |     |             );
 456 |     |         }
 457 |     |         return (_partialDebt, _partialColl);
 458 |     |     }
 459 |     | 
 460 |     |     function _partiallyReduceCdpDebt(
 461 |     |         bytes32 _cdpId,
 462 |     |         uint256 _partialDebt,
 463 |     |         uint256 _partialColl
 464 |     |     ) internal {
 465 |     |         Cdp storage _cdp = Cdps[_cdpId];
 466 |     | 
 467 |     |         uint256 _coll = _cdp.coll;
 468 |     |         uint256 _debt = _cdp.debt;
 469 |     | 
 470 |     |         uint256 newDebt = _debt - _partialDebt;
 471 |     | 
 472 |     |         _requireMinDebt(newDebt);
 473 |     | 
 474 |     |         _cdp.coll = _coll - _partialColl;
 475 |     |         _cdp.debt = newDebt;
 476 |     |         _updateStakeAndTotalStakes(_cdpId);
 477 |     |     }
 478 |     | 
 479 |     |     // Re-Insertion into SortedCdp list after partial liquidation
 480 |     |     function _reInsertPartialLiquidation(
 481 |     |         LiquidationLocals memory _partialState,
 482 |     |         uint256 _newNICR,
 483 |     |         uint256 _oldDebt,
 484 |     |         uint256 _oldColl
 485 |     |     ) internal {
 486 |     |         bytes32 _cdpId = _partialState.cdpId;
 487 |     | 
 488 |     |         // ensure new ICR does NOT decrease due to partial liquidation
 489 |     |         // if original ICR is above LICR
 490 |     |         if (_partialState.ICR > LICR) {
 491 |     |             require(
 492 |     |                 getCachedICR(_cdpId, _partialState.price) >= _partialState.ICR,
 493 |     |                 "LiquidationLibrary: !_newICR>=_ICR"
 494 |     |             );
 495 |     |         }
 496 |     | 
 497 |     |         // reInsert into sorted CDP list
 498 |     |         sortedCdps.reInsert(
 499 |     |             _cdpId,
 500 |     |             _newNICR,
 501 |     |             _partialState.upperPartialHint,
 502 |     |             _partialState.lowerPartialHint
 503 |     |         );
 504 |     |         emit CdpUpdated(
 505 |     |             _cdpId,
 506 |     |             sortedCdps.getOwnerAddress(_cdpId),
 507 |     |             msg.sender,
 508 |     |             _oldDebt,
 509 |     |             _oldColl,
 510 |     |             Cdps[_cdpId].debt,
 511 |     |             Cdps[_cdpId].coll,
 512 |     |             Cdps[_cdpId].stake,
 513 |     |             CdpOperation.partiallyLiquidate
 514 |     |         );
 515 |     |     }
 516 |     | 
 517 |     |     function _finalizeLiquidation(
 518 |     |         uint256 totalDebtToBurn,
 519 |     |         uint256 totalCollSharesToSend,
 520 |     |         uint256 totalDebtToRedistribute,
 521 |     |         uint256 totalLiquidatorRewardCollShares,
 522 |     |         uint256 totalSurplusCollShares,
 523 |     |         uint256 systemInitialCollShares,
 524 |     |         uint256 systemInitialDebt,
 525 |     |         uint256 price
 526 |     |     ) internal {
 527 |     |         // update the staking and collateral snapshots
 528 |     |         _updateSystemSnapshotsExcludeCollRemainder(totalCollSharesToSend);
 529 |     | 
 530 |     |         emit Liquidation(totalDebtToBurn, totalCollSharesToSend, totalLiquidatorRewardCollShares);
 531 |     | 
 532 |     |         _syncGracePeriodForGivenValues(
 533 |     |             systemInitialCollShares - totalCollSharesToSend - totalSurplusCollShares,
 534 |     |             systemInitialDebt - totalDebtToBurn,
 535 |     |             price
 536 |     |         );
 537 |     | 
 538 |     |         // redistribute debt if any
 539 |     |         if (totalDebtToRedistribute > 0) {
 540 |     |             _redistributeDebt(totalDebtToRedistribute);
 541 |     |         }
 542 |     | 
 543 |     |         // burn the debt from liquidator
 544 |     |         ebtcToken.burn(msg.sender, totalDebtToBurn);
 545 |     | 
 546 |     |         // offset debt from Active Pool
 547 |     |         activePool.decreaseSystemDebt(totalDebtToBurn);
 548 |     | 
 549 |     |         // CEI: ensure sending back collateral to liquidator is last thing to do
 550 |     |         activePool.transferSystemCollSharesAndLiquidatorReward(
 551 |     |             msg.sender,
 552 |     |             totalCollSharesToSend,
 553 |     |             totalLiquidatorRewardCollShares
 554 |     |         );
 555 |     |     }
 556 |     | 
 557 |     |     // Partial Liquidation Cap Logic
 558 |     |     function _calculatePartialLiquidationSurplusAndCap(
 559 |     |         uint256 _ICR,
 560 |     |         uint256 _price,
 561 |     |         uint256 _totalDebtToBurn,
 562 |     |         uint256 _totalColToSend
 563 |     |     ) private view returns (uint256 toLiquidator, uint256 collSurplus, uint256 debtToRedistribute) {
 564 |     |         uint256 _incentiveColl;
 565 |     | 
 566 |     |         // CLAMP
 567 |     |         if (_ICR > LICR) {
 568 |     |             // Cap at 10%
 569 |     |             _incentiveColl = (_totalDebtToBurn * (_ICR > MCR ? MCR : _ICR)) / _price;
 570 |     |         } else {
 571 |     |             // Min 103%
 572 |     |             _incentiveColl = (_totalDebtToBurn * LICR) / _price;
 573 |     |         }
 574 |     | 
 575 |     |         toLiquidator = collateral.getSharesByPooledEth(_incentiveColl);
 576 |     | 
 577 |     |         /// @audit MUST be like so, else we have debt redistribution, which we assume cannot happen in partial
 578 |     |         assert(toLiquidator < _totalColToSend); // Assert is correct here for Echidna
 579 |     | 
 580 |     |         /// Because of above we can subtract
 581 |     |         collSurplus = _totalColToSend - toLiquidator; // Can use unchecked but w/e
 582 |     |     }
 583 |     | 
 584 |     |     function _calculateFullLiquidationSurplusAndCap(
 585 |     |         uint256 _ICR,
 586 |     |         uint256 _price,
 587 |     |         uint256 _totalDebtToBurn,
 588 |     |         uint256 _totalColToSend
 589 |     |     ) private view returns (uint256 toLiquidator, uint256 collSurplus, uint256 debtToRedistribute) {
 590 |     |         uint256 _incentiveColl;
 591 |     | 
 592 |     |         if (_ICR > LICR) {
 593 |     |             _incentiveColl = (_totalDebtToBurn * (_ICR > MCR ? MCR : _ICR)) / _price;
 594 |     | 
 595 |     |             // Convert back to shares
 596 |     |             toLiquidator = collateral.getSharesByPooledEth(_incentiveColl);
 597 |     |         } else {
 598 |     |             // for full liquidation, there would be some bad debt to redistribute
 599 |     |             _incentiveColl = collateral.getPooledEthByShares(_totalColToSend);
 600 |     | 
 601 |     |             // Since it's full and there's bad debt we use spot conversion to
 602 |     |             // Determine the amount of debt that willl be repaid after adding the LICR discount
 603 |     |             // Basically this is buying underwater Coll
 604 |     |             // By repaying debt at 3% discount
 605 |     |             // Can there be a rounding error where the _debtToRepay > debtToBurn?
 606 |     |             uint256 _debtToRepay = (_incentiveColl * _price) / LICR;
 607 |     | 
 608 |     |             debtToRedistribute = _debtToRepay < _totalDebtToBurn
 609 |     |                 ? _totalDebtToBurn - _debtToRepay //  Bad Debt (to be redistributed) is (CdpDebt - Repaid)
 610 |     |                 : 0; // Else 0 (note we may underpay per the comment above, althought that may be imaginary)
 611 |     | 
 612 |     |             // now CDP owner should have zero surplus to claim
 613 |     |             toLiquidator = _totalColToSend;
 614 |     |         }
 615 |     | 
 616 |     |         toLiquidator = toLiquidator < _totalColToSend ? toLiquidator : _totalColToSend;
 617 |     |         collSurplus = (toLiquidator == _totalColToSend) ? 0 : _totalColToSend - toLiquidator;
 618 |     |     }
 619 |     | 
 620 |     |     // --- Batch liquidation functions ---
 621 |     | 
 622 |     |     function _getLiquidationValuesNormalMode(
 623 |     |         uint256 _price,
 624 |     |         uint256 _TCR,
 625 |     |         LocalVariables_LiquidationSequence memory vars,
 626 |     |         LiquidationValues memory singleLiquidation
 627 |     |     ) internal {
 628 |     |         LiquidationLocals memory _liqState = LiquidationLocals(
 629 |     |             vars.cdpId,
 630 |     |             0,
 631 |     |             _price,
 632 |     |             vars.ICR,
 633 |     |             vars.cdpId,
 634 |     |             vars.cdpId,
 635 |     |             (false),
 636 |     |             _TCR,
 637 |     |             0,
 638 |     |             0,
 639 |     |             0,
 640 |     |             0,
 641 |     |             0
 642 |     |         );
 643 |     | 
 644 |     |         LiquidationLocals memory _outputState = _liquidateIndividualCdpSetupCDPInNormalMode(
 645 |     |             _liqState
 646 |     |         );
 647 |     | 
 648 |     |         singleLiquidation.entireCdpDebt = _outputState.totalDebtToBurn;
 649 |     |         singleLiquidation.debtToBurn = _outputState.totalDebtToBurn;
 650 |     |         singleLiquidation.totalCollToSendToLiquidator = _outputState.totalCollSharesToSend;
 651 |     |         singleLiquidation.collSurplus = _outputState.totalSurplusCollShares;
 652 |     |         singleLiquidation.debtToRedistribute = _outputState.totalDebtToRedistribute;
 653 |     |         singleLiquidation.liquidatorCollSharesReward = _outputState.totalLiquidatorRewardCollShares;
 654 |     |     }
 655 |     | 
 656 |     |     function _getLiquidationValuesRecoveryMode(
 657 |     |         uint256 _price,
 658 |     |         uint256 _systemDebt,
 659 |     |         uint256 _systemCollShares,
 660 |     |         LocalVariables_LiquidationSequence memory vars,
 661 |     |         LiquidationValues memory singleLiquidation
 662 |     |     ) internal {
 663 |     |         LiquidationRecoveryModeLocals memory _recState = LiquidationRecoveryModeLocals(
 664 |     |             _systemDebt,
 665 |     |             _systemCollShares,
 666 |     |             0,
 667 |     |             0,
 668 |     |             0,
 669 |     |             vars.cdpId,
 670 |     |             _price,
 671 |     |             vars.ICR,
 672 |     |             0,
 673 |     |             0
 674 |     |         );
 675 |     | 
 676 |     |         LiquidationRecoveryModeLocals
 677 |     |             memory _outputState = _liquidateIndividualCdpSetupCDPInRecoveryMode(_recState);
 678 |     | 
 679 |     |         singleLiquidation.entireCdpDebt = _outputState.totalDebtToBurn;
 680 |     |         singleLiquidation.debtToBurn = _outputState.totalDebtToBurn;
 681 |     |         singleLiquidation.totalCollToSendToLiquidator = _outputState.totalCollSharesToSend;
 682 |     |         singleLiquidation.collSurplus = _outputState.totalSurplusCollShares;
 683 |     |         singleLiquidation.debtToRedistribute = _outputState.totalDebtToRedistribute;
 684 |     |         singleLiquidation.liquidatorCollSharesReward = _outputState.totalLiquidatorRewardCollShares;
 685 |     |     }
 686 |     | 
 687 |     |     /// @notice Attempt to liquidate a custom list of Cdps provided by the caller
 688 |     |     /// @notice Callable by anyone, accepts a custom list of Cdps addresses as an argument.
 689 |     |     /// @notice Steps through the provided list and attempts to liquidate every Cdp, until it reaches the end or it runs out of gas.
 690 |     |     /// @notice A Cdp is liquidated only if it meets the conditions for liquidation.
 691 |     |     /// @dev forwards msg.data directly to the liquidation library using OZ proxy core delegation function
 692 |     |     /// @param _cdpArray Array of Cdps to liquidate.
 693 |     |     function batchLiquidateCdps(bytes32[] memory _cdpArray) external nonReentrantSelfAndBOps {
 694 |     |         require(
 695 |     |             _cdpArray.length != 0,
 696 |     |             "LiquidationLibrary: Calldata address array must not be empty"
 697 |     |         );
 698 |     | 
 699 |     |         LocalVariables_OuterLiquidationFunction memory vars;
 700 |     |         LiquidationTotals memory totals;
 701 |     | 
 702 |     |         // taking fee to avoid accounted for the calculation of the TCR
 703 |     |         _syncGlobalAccounting();
 704 |     | 
 705 |     |         vars.price = priceFeed.fetchPrice();
 706 |     |         (uint256 _TCR, uint256 systemColl, uint256 systemDebt) = _getTCRWithSystemDebtAndCollShares(
 707 |     |             vars.price
 708 |     |         );
 709 |     |         vars.recoveryModeAtStart = _TCR < CCR ? true : false;
 710 |     | 
 711 |     |         // Perform the appropriate batch liquidation - tally values and obtain their totals.
 712 |     |         if (vars.recoveryModeAtStart) {
 713 |     |             totals = _getTotalFromBatchLiquidate_RecoveryMode(
 714 |     |                 vars.price,
 715 |     |                 systemColl,
 716 |     |                 systemDebt,
 717 |     |                 _cdpArray
 718 |     |             );
 719 |     |         } else {
 720 |     |             //  if !vars.recoveryModeAtStart
 721 |     |             totals = _getTotalsFromBatchLiquidate_NormalMode(vars.price, _TCR, _cdpArray);
 722 |     |         }
 723 |     | 
 724 |     |         require(totals.totalDebtInSequence > 0, "LiquidationLibrary: nothing to liquidate");
 725 |     | 
 726 |     |         // housekeeping leftover collateral for liquidated CDPs
 727 |     |         if (totals.totalCollSurplus > 0) {
 728 |     |             activePool.transferSystemCollShares(address(collSurplusPool), totals.totalCollSurplus);
 729 |     |         }
 730 |     | 
 731 |     |         _finalizeLiquidation(
 732 |     |             totals.totalDebtToBurn,
 733 |     |             totals.totalCollToSendToLiquidator,
 734 |     |             totals.totalDebtToRedistribute,
 735 |     |             totals.totalCollReward,
 736 |     |             totals.totalCollSurplus,
 737 |     |             systemColl,
 738 |     |             systemDebt,
 739 |     |             vars.price
 740 |     |         );
 741 |     |     }
 742 |     | 
 743 |     |     /*
 744 |     |      * This function is used when the batch liquidation starts during Recovery Mode. However, it
 745 |     |      * handle the case where the system *leaves* Recovery Mode, part way through the liquidation processing
 746 |     |      */
 747 |     |     function _getTotalFromBatchLiquidate_RecoveryMode(
 748 |     |         uint256 _price,
 749 |     |         uint256 _systemCollShares,
 750 |     |         uint256 _systemDebt,
 751 |     |         bytes32[] memory _cdpArray
 752 |     |     ) internal returns (LiquidationTotals memory totals) {
 753 |     |         LocalVariables_LiquidationSequence memory vars;
 754 |     |         LiquidationValues memory singleLiquidation;
 755 |     | 
 756 |     |         vars.backToNormalMode = false;
 757 |     |         vars.entireSystemDebt = _systemDebt;
 758 |     |         vars.entireSystemColl = _systemCollShares;
 759 |     |         uint256 _TCR = _computeTCRWithGivenSystemValues(
 760 |     |             vars.entireSystemColl,
 761 |     |             vars.entireSystemDebt,
 762 |     |             _price
 763 |     |         );
 764 |     |         uint256 _cnt = _cdpArray.length;
 765 |     |         bool[] memory _liqFlags = new bool[](_cnt);
 766 |     |         uint256 _start;
 767 |     |         for (vars.i = _start; ; ) {
 768 |     |             vars.cdpId = _cdpArray[vars.i];
 769 |     |             // only for active cdps
 770 |     |             if (vars.cdpId != bytes32(0) && Cdps[vars.cdpId].status == Status.active) {
 771 |     |                 vars.ICR = getSyncedICR(vars.cdpId, _price);
 772 |     | 
 773 |     |                 if (
 774 |     |                     !vars.backToNormalMode &&
 775 |     |                     (_checkICRAgainstMCR(vars.ICR) || canLiquidateRecoveryMode(vars.ICR, _TCR))
 776 |     |                 ) {
 777 |     |                     vars.price = _price;
 778 |     |                     _syncAccounting(vars.cdpId);
 779 |     |                     _getLiquidationValuesRecoveryMode(
 780 |     |                         _price,
 781 |     |                         vars.entireSystemDebt,
 782 |     |                         vars.entireSystemColl,
 783 |     |                         vars,
 784 |     |                         singleLiquidation
 785 |     |                     );
 786 |     | 
 787 |     |                     // Update aggregate trackers
 788 |     |                     vars.entireSystemDebt = vars.entireSystemDebt - singleLiquidation.debtToBurn;
 789 |     |                     vars.entireSystemColl =
 790 |     |                         vars.entireSystemColl -
 791 |     |                         singleLiquidation.totalCollToSendToLiquidator -
 792 |     |                         singleLiquidation.collSurplus;
 793 |     | 
 794 |     |                     // Add liquidation values to their respective running totals
 795 |     |                     totals = _addLiquidationValuesToTotals(totals, singleLiquidation);
 796 |     | 
 797 |     |                     _TCR = _computeTCRWithGivenSystemValues(
 798 |     |                         vars.entireSystemColl,
 799 |     |                         vars.entireSystemDebt,
 800 |     |                         _price
 801 |     |                     );
 802 |     |                     vars.backToNormalMode = _TCR < CCR ? false : true;
 803 |     |                     _liqFlags[vars.i] = true;
 804 |     |                 } else if (vars.backToNormalMode && _checkICRAgainstMCR(vars.ICR)) {
 805 |     |                     _syncAccounting(vars.cdpId);
 806 |     |                     _getLiquidationValuesNormalMode(_price, _TCR, vars, singleLiquidation);
 807 |     | 
 808 |     |                     // Add liquidation values to their respective running totals
 809 |     |                     totals = _addLiquidationValuesToTotals(totals, singleLiquidation);
 810 |     |                     _liqFlags[vars.i] = true;
 811 |     |                 }
 812 |     |                 // In Normal Mode skip cdps with ICR >= MCR
 813 |     |             }
 814 |     |             ++vars.i;
 815 |     |             if (vars.i == _cnt) {
 816 |     |                 break;
 817 |     |             }
 818 |     |         }
 819 |     |     }
 820 |     | 
 821 |     |     function _getTotalsFromBatchLiquidate_NormalMode(
 822 |     |         uint256 _price,
 823 |     |         uint256 _TCR,
 824 |     |         bytes32[] memory _cdpArray
 825 |     |     ) internal returns (LiquidationTotals memory totals) {
 826 |     |         LocalVariables_LiquidationSequence memory vars;
 827 |     |         LiquidationValues memory singleLiquidation;
 828 |     |         uint256 _cnt = _cdpArray.length;
 829 |     |         uint256 _start;
 830 |     |         for (vars.i = _start; ; ) {
 831 |     |             vars.cdpId = _cdpArray[vars.i];
 832 |     |             // only for active cdps
 833 |     |             if (vars.cdpId != bytes32(0) && Cdps[vars.cdpId].status == Status.active) {
 834 |     |                 vars.ICR = getSyncedICR(vars.cdpId, _price);
 835 |     | 
 836 |     |                 if (_checkICRAgainstMCR(vars.ICR)) {
 837 |     |                     _syncAccounting(vars.cdpId);
 838 |     |                     _getLiquidationValuesNormalMode(_price, _TCR, vars, singleLiquidation);
 839 |     | 
 840 |     |                     // Add liquidation values to their respective running totals
 841 |     |                     totals = _addLiquidationValuesToTotals(totals, singleLiquidation);
 842 |     |                 }
 843 |     |             }
 844 |     |             ++vars.i;
 845 |     |             if (vars.i == _cnt) {
 846 |     |                 break;
 847 |     |             }
 848 |     |         }
 849 |     |     }
 850 |     | 
 851 |     |     // --- Liquidation helper functions ---
 852 |     | 
 853 |     |     function _addLiquidationValuesToTotals(
 854 |     |         LiquidationTotals memory oldTotals,
 855 |     |         LiquidationValues memory singleLiquidation
 856 |     |     ) internal pure returns (LiquidationTotals memory newTotals) {
 857 |     |         // Tally all the values with their respective running totals
 858 |     |         newTotals.totalDebtInSequence =
 859 |     |             oldTotals.totalDebtInSequence +
 860 |     |             singleLiquidation.entireCdpDebt;
 861 |     |         newTotals.totalDebtToBurn = oldTotals.totalDebtToBurn + singleLiquidation.debtToBurn;
 862 |     |         newTotals.totalCollToSendToLiquidator =
 863 |     |             oldTotals.totalCollToSendToLiquidator +
 864 |     |             singleLiquidation.totalCollToSendToLiquidator;
 865 |     |         newTotals.totalDebtToRedistribute =
 866 |     |             oldTotals.totalDebtToRedistribute +
 867 |     |             singleLiquidation.debtToRedistribute;
 868 |     |         newTotals.totalCollSurplus = oldTotals.totalCollSurplus + singleLiquidation.collSurplus;
 869 |     |         newTotals.totalCollReward =
 870 |     |             oldTotals.totalCollReward +
 871 |     |             singleLiquidation.liquidatorCollSharesReward;
 872 |     | 
 873 |     |         return newTotals;
 874 |     |     }
 875 |     | 
 876 |     |     function _redistributeDebt(uint256 _debt) internal {
 877 |     |         if (_debt == 0) {
 878 |     |             return;
 879 |     |         }
 880 |     | 
 881 |     |         /*
 882 |     |          * Add distributed debt rewards-per-unit-staked to the running totals. Division uses a "feedback"
 883 |     |          * error correction, to keep the cumulative error low in the running totals systemDebtRedistributionIndex:
 884 |     |          *
 885 |     |          * 1) Form numerators which compensate for the floor division errors that occurred the last time this
 886 |     |          * function was called.
 887 |     |          * 2) Calculate "per-unit-staked" ratios.
 888 |     |          * 3) Multiply each ratio back by its denominator, to reveal the current floor division error.
 889 |     |          * 4) Store these errors for use in the next correction when this function is called.
 890 |     |          * 5) Note: static analysis tools complain about this "division before multiplication", however, it is intended.
 891 |     |          */
 892 |     |         uint256 EBTCDebtNumerator = (_debt * DECIMAL_PRECISION) + lastEBTCDebtErrorRedistribution;
 893 |     | 
 894 |     |         // Get the per-unit-staked terms
 895 |     |         uint256 _totalStakes = totalStakes;
 896 |     |         uint256 EBTCDebtRewardPerUnitStaked = EBTCDebtNumerator / _totalStakes;
 897 |     | 
 898 |     |         lastEBTCDebtErrorRedistribution =
 899 |     |             EBTCDebtNumerator -
 900 |     |             (EBTCDebtRewardPerUnitStaked * _totalStakes);
 901 |     | 
 902 |     |         // Add per-unit-staked terms to the running totals
 903 |     |         systemDebtRedistributionIndex = systemDebtRedistributionIndex + EBTCDebtRewardPerUnitStaked;
 904 |     | 
 905 |     |         emit SystemDebtRedistributionIndexUpdated(systemDebtRedistributionIndex);
 906 |     |     }
 907 |     | 
 908 |     |     // --- 'require' wrapper functions ---
 909 |     | 
 910 |     |     function _requirePartialLiqDebtSize(
 911 |     |         uint256 _partialDebt,
 912 |     |         uint256 _entireDebt,
 913 |     |         uint256 _price
 914 |     |     ) internal view {
 915 |     |         require(
 916 |     |             (_partialDebt + _convertDebtDenominationToBtc(MIN_NET_STETH_BALANCE, _price)) <=
 917 |     |                 _entireDebt,
 918 |     |             "LiquidationLibrary: Partial debt liquidated must be less than total debt"
 919 |     |         );
 920 |     |     }
 921 |     | 
 922 |     |     function _requirePartialLiqCollSize(uint256 _entireColl) internal pure {
 923 |     |         require(
 924 |     |             _entireColl >= MIN_NET_STETH_BALANCE,
 925 |     |             "LiquidationLibrary: Coll remaining in partially liquidated CDP must be >= minimum"
 926 |     |         );
 927 |     |     }
 928 |     | 
 929 |     |     function _requireMinDebt(uint256 _debt) internal pure {
 930 |     |         require(_debt >= MIN_CHANGE, "LiquidationLibrary: Debt must be above min");
 931 |     |     }
 932 |     | }
 933 |     | 

/mnt/c/Users/Lourens/Documents/Recon-Fuzz/collabs/ebtc/packages/contracts/contracts/LiquidationSequencer.sol
   1 |     | // SPDX-License-Identifier: MIT
   2 |     | 
   3 |     | pragma solidity 0.8.17;
   4 |     | 
   5 |     | import "./Interfaces/IPriceFeed.sol";
   6 |     | import "./Interfaces/ICdpManager.sol";
   7 |     | import "./Interfaces/ISortedCdps.sol";
   8 |     | import "./Interfaces/ICdpManagerData.sol";
   9 |     | import "./Dependencies/EbtcBase.sol";
  10 |     | 
  11 |     | /// @notice Helper contract to turn a sequence into CDP id array for batch liquidation
  12 |     | /// @dev Note this sequencer only serves as an approximation tool to provide "best-effort"
  13 |     | /// @dev that return a list of CDP ids which could be consumed by "CdpManager.batchLiquidateCdps()".
  14 |     | /// @dev It is possible that some of the returned Cdps might be skipped (not liquidatable any more)
  15 |     | /// @dev during liquidation execution due to change of the system states
  16 |     | /// @dev e.g., TCR brought back from Recovery Mode to Normal Mode
  17 | *   | contract LiquidationSequencer is EbtcBase {
  18 |     |     ICdpManager public immutable cdpManager;
  19 |     |     ISortedCdps public immutable sortedCdps;
  20 |     | 
  21 |     |     constructor(
  22 |     |         address _cdpManagerAddress,
  23 |     |         address _sortedCdpsAddress,
  24 |     |         address _priceFeedAddress,
  25 |     |         address _activePoolAddress,
  26 |     |         address _collateralAddress
  27 |     |     ) EbtcBase(_activePoolAddress, _priceFeedAddress, _collateralAddress) {
  28 |     |         cdpManager = ICdpManager(_cdpManagerAddress);
  29 |     |         sortedCdps = ISortedCdps(_sortedCdpsAddress);
  30 |     |     }
  31 |     | 
  32 |     |     /// @dev Get first N batch of liquidatable Cdps at current price
  33 |     |     /// @dev Non-view function that updates and returns live price at execution time
  34 |     |     /// @dev could use callStatic offline to save gas
  35 |     |     /// @param _n The number for sequential liquidation to be converted into a CdpId array batch
  36 |     |     /// @return _array The CdpId array batch converted from the specified sequential number
  37 | *   |     function sequenceLiqToBatchLiq(uint256 _n) external returns (bytes32[] memory _array) {
  38 |     |         uint256 _price = priceFeed.fetchPrice();
  39 | *   |         return sequenceLiqToBatchLiqWithPrice(_n, _price);
  40 |     |     }
  41 |     | 
  42 |     |     /// @dev Get first N batch of liquidatable Cdps at specified price
  43 |     |     /// @dev Non-view function that will sync global state
  44 |     |     /// @dev could use callStatic offline to save gas
  45 |     |     /// @param _n The number for sequential liquidation to be converted into a CdpId array batch
  46 |     |     /// @param _price The price of stETH:eBTC to be used to check if Cdp is liquidatable
  47 |     |     /// @return _array The CdpId array batch converted from the specified sequential number
  48 | *   |     function sequenceLiqToBatchLiqWithPrice(
  49 |     |         uint256 _n,
  50 |     |         uint256 _price
  51 | *   |     ) public returns (bytes32[] memory _array) {
  52 | *   |         cdpManager.syncGlobalAccountingAndGracePeriod();
  53 | *   |         (uint256 _TCR, , ) = _getTCRWithSystemDebtAndCollShares(_price);
  54 | *   |         return _sequenceLiqToBatchLiq(_n, _price, _TCR);
  55 |     |     }
  56 |     | 
  57 |     |     // return CdpId array (in NICR-decreasing order same as SortedCdps)
  58 |     |     // including the last N Cdps in sortedCdps for batch liquidation
  59 | *   |     function _sequenceLiqToBatchLiq(
  60 |     |         uint256 _n,
  61 |     |         uint256 _price,
  62 |     |         uint256 _TCR
  63 | *   |     ) internal view returns (bytes32[] memory _array) {
  64 | *   |         if (_n > 0) {
  65 |     |             // get count of liquidatable Cdps with 1st iteration
  66 | *   |             (uint256 _cnt, ) = _iterateOverSortedCdps(0, _TCR, _n, _price);
  67 |     | 
  68 |     |             // retrieve liquidatable Cdps with 2nd iteration
  69 | *   |             (uint256 _j, bytes32[] memory _returnedArray) = _iterateOverSortedCdps(
  70 | *   |                 _cnt,
  71 | *   |                 _TCR,
  72 | *   |                 _n,
  73 | *   |                 _price
  74 |     |             );
  75 | *   |             require(_j == _cnt, "LiquidationSequencer: wrong sequence conversion!");
  76 | *   |             _array = _returnedArray;
  77 |     |         }
  78 |     |     }
  79 |     | 
  80 | *   |     function _iterateOverSortedCdps(
  81 |     |         uint256 _realCount,
  82 |     |         uint256 _TCR,
  83 |     |         uint256 _n,
  84 |     |         uint256 _price
  85 | *   |     ) internal view returns (uint256 _cnt, bytes32[] memory _array) {
  86 |     |         // if there is already a count (calculated from previous iteration)
  87 |     |         // we use the value to initialize CDP id array for return
  88 | *   |         if (_realCount > 0) {
  89 | *   |             _array = new bytes32[](_realCount);
  90 |     |         }
  91 |     | 
  92 |     |         // initialize variables for this iteration
  93 | *   |         bytes32 _last = sortedCdps.getLast();
  94 | *   |         bytes32 _first = sortedCdps.getFirst();
  95 | *   |         bytes32 _cdpId = _last;
  96 |     | 
  97 | *   |         for (uint256 i = 0; i < (_realCount > 0 ? _realCount : _n) && _cdpId != _first; ) {
  98 | *   |             bool _liquidatable = _checkICRAgainstLiqThreshold(
  99 | *   |                 cdpManager.getSyncedICR(_cdpId, _price),
 100 | *   |                 _TCR
 101 |     |             );
 102 | *   |             if (_liquidatable) {
 103 | *   |                 if (_realCount > 0) {
 104 | *   |                     _array[_realCount - _cnt - 1] = _cdpId;
 105 |     |                 }
 106 |     |                 unchecked {
 107 | *   |                     ++_cnt;
 108 |     |                 }
 109 | *   |                 _cdpId = sortedCdps.getPrev(_cdpId);
 110 |     |             } else {
 111 |     |                 // breaking loop early if not liquidatable due to sorted (descending) list of Cdps
 112 | *   |                 break;
 113 |     |             }
 114 |     |             unchecked {
 115 | *   |                 ++i;
 116 |     |             }
 117 |     |         }
 118 |     |     }
 119 |     | }
 120 |     | 

/mnt/c/Users/Lourens/Documents/Recon-Fuzz/collabs/ebtc/packages/contracts/contracts/PriceFeed.sol
   1 |     | // SPDX-License-Identifier: MIT
   2 |     | 
   3 |     | pragma solidity 0.8.17;
   4 |     | 
   5 |     | import "./Interfaces/IPriceFeed.sol";
   6 |     | import "./Interfaces/IFallbackCaller.sol";
   7 |     | import "./Dependencies/AggregatorV3Interface.sol";
   8 |     | import "./Dependencies/BaseMath.sol";
   9 |     | import "./Dependencies/EbtcMath.sol";
  10 |     | import "./Dependencies/AuthNoOwner.sol";
  11 |     | import "./FixedAdapter.sol";
  12 |     | 
  13 |     | /*
  14 |     |  * PriceFeed for mainnet deployment, it connects to two Chainlink's live feeds, ETH:BTC and
  15 |     |  * stETH:ETH, which are used to aggregate the price feed of stETH:BTC in conjuction.
  16 |     |  * It also allows for a fallback oracle to intervene in case that the primary Chainlink oracle fails.
  17 |     |  *
  18 |     |  * The PriceFeed uses Chainlink as primary oracle and allows for an optional fallback source. It contains logic for
  19 |     |  * switching oracles based on oracle failures, timeouts, and conditions for returning to the primary
  20 |     |  * Chainlink oracle. In addition, it contains the mechanism to add or remove the fallback oracle through governance.
  21 |     |  */
  22 |     | contract PriceFeed is BaseMath, IPriceFeed, AuthNoOwner {
  23 |     |     string public constant NAME = "PriceFeed";
  24 |     | 
  25 |     |     // Chainlink oracles in mainnet
  26 |     |     AggregatorV3Interface public immutable ETH_BTC_CL_FEED;
  27 |     |     AggregatorV3Interface public immutable STETH_ETH_CL_FEED;
  28 |     |     // STETH_ETH_FIXED_FEED must have the same decimals as STETH_ETH_CL_FEED
  29 |     |     AggregatorV3Interface public immutable STETH_ETH_FIXED_FEED;
  30 |     | 
  31 |     |     uint256 public immutable DENOMINATOR;
  32 |     |     uint256 public immutable SCALED_DECIMAL;
  33 |     | 
  34 |     |     // Fallback feed
  35 |     |     IFallbackCaller public fallbackCaller; // Wrapper contract that calls the fallback system
  36 |     | 
  37 |     |     // Maximum time period allowed since Chainlink's latest round data timestamp, beyond which Chainlink is considered frozen.
  38 |     |     uint256 public constant TIMEOUT_ETH_BTC_FEED = 4800; // 1 hours & 20min: 60 * 80
  39 |     |     uint256 public constant TIMEOUT_STETH_ETH_FEED = 90000; // 25 hours: 60 * 60 * 25
  40 |     |     uint256 constant INVALID_PRICE = 0;
  41 |     | 
  42 |     |     /**
  43 |     |      * @notice Maximum number of resulting and feed decimals
  44 |     |      */
  45 |     |     uint8 public constant MAX_DECIMALS = 18;
  46 |     | 
  47 |     |     // Maximum deviation allowed between two consecutive Chainlink oracle prices. 18-digit precision.
  48 |     |     uint256 public constant MAX_PRICE_DEVIATION_FROM_PREVIOUS_ROUND = 5e17; // 50%
  49 |     | 
  50 |     |     /*
  51 |     |      * The maximum relative price difference between two oracle responses allowed in order for the PriceFeed
  52 |     |      * to return to using the Chainlink oracle. 18-digit precision.
  53 |     |      */
  54 |     |     uint256 public constant MAX_PRICE_DIFFERENCE_BETWEEN_ORACLES = 5e16; // 5%
  55 |     | 
  56 |     |     // The last good price seen from an oracle by eBTC
  57 |     |     uint256 public lastGoodPrice;
  58 |     | 
  59 |     |     // The current status of the PriceFeed, which determines the conditions for the next price fetch attempt
  60 |     |     Status public status;
  61 |     | 
  62 |     |     // Dynamic feed = Chainlink stETH/ETH feed
  63 |     |     // Static feed = 1:1 FixedAdapter
  64 |     |     // defaults to static feed
  65 |     |     bool public useDynamicFeed;
  66 |     | 
  67 |     |     // --- Dependency setters ---
  68 |     | 
  69 |     |     /// @notice Sets the addresses of the contracts and initializes the system
  70 |     |     /// @param _fallbackCallerAddress The address of the Fallback oracle contract
  71 |     |     /// @param _authorityAddress The address of the Authority contract
  72 |     |     /// @param _collEthCLFeed The address of the collateral-ETH ChainLink feed
  73 |     |     /// @param _ethBtcCLFeed The address of the ETH-BTC ChainLink feed
  74 |     |     constructor(
  75 |     |         address _fallbackCallerAddress,
  76 |     |         address _authorityAddress,
  77 |     |         address _collEthCLFeed,
  78 |     |         address _ethBtcCLFeed,
  79 |     |         bool _useDynamicFeed
  80 |     |     ) {
  81 |     |         fallbackCaller = IFallbackCaller(_fallbackCallerAddress);
  82 |     | 
  83 |     |         _initializeAuthority(_authorityAddress);
  84 |     | 
  85 |     |         emit FallbackCallerChanged(address(0), _fallbackCallerAddress);
  86 |     | 
  87 |     |         ETH_BTC_CL_FEED = AggregatorV3Interface(_ethBtcCLFeed);
  88 |     |         STETH_ETH_CL_FEED = AggregatorV3Interface(_collEthCLFeed);
  89 |     |         STETH_ETH_FIXED_FEED = new FixedAdapter();
  90 |     | 
  91 |     |         uint8 ethBtcDecimals = ETH_BTC_CL_FEED.decimals();
  92 |     |         require(ethBtcDecimals <= MAX_DECIMALS);
  93 |     |         uint8 stEthEthDecimals = STETH_ETH_CL_FEED.decimals();
  94 |     |         require(stEthEthDecimals <= MAX_DECIMALS);
  95 |     |         require(stEthEthDecimals == STETH_ETH_FIXED_FEED.decimals());
  96 |     | 
  97 |     |         DENOMINATOR =
  98 |     |             10 ** ((stEthEthDecimals > ethBtcDecimals ? stEthEthDecimals : ethBtcDecimals) * 2);
  99 |     |         SCALED_DECIMAL = stEthEthDecimals > ethBtcDecimals
 100 |     |             ? 10 ** (stEthEthDecimals - ethBtcDecimals)
 101 |     |             : 10 ** (ethBtcDecimals - stEthEthDecimals);
 102 |     | 
 103 |     |         useDynamicFeed = _useDynamicFeed;
 104 |     | 
 105 |     |         // Get an initial price from Chainlink to serve as first reference for lastGoodPrice
 106 |     |         ChainlinkResponse memory chainlinkResponse = _getCurrentChainlinkResponse();
 107 |     |         ChainlinkResponse memory prevChainlinkResponse = _getPrevChainlinkResponse(
 108 |     |             chainlinkResponse.roundEthBtcId,
 109 |     |             chainlinkResponse.roundStEthEthId
 110 |     |         );
 111 |     | 
 112 |     |         require(
 113 |     |             !_chainlinkIsBroken(chainlinkResponse, prevChainlinkResponse) &&
 114 |     |                 !_chainlinkIsFrozen(chainlinkResponse),
 115 |     |             "PriceFeed: Chainlink must be working and current"
 116 |     |         );
 117 |     | 
 118 |     |         _storeChainlinkPrice(chainlinkResponse.answer);
 119 |     | 
 120 |     |         // Explicitly set initial system status after `require` checks
 121 |     |         status = Status.chainlinkWorking;
 122 |     | 
 123 |     |         // emit STETH_ETH_FIXED_FEED address
 124 |     |         emit CollateralFeedSourceUpdated(address(_collateralFeed()));
 125 |     |     }
 126 |     | 
 127 |     |     // --- Functions ---
 128 |     | 
 129 |     |     function setCollateralFeedSource(bool _useDynamicFeed) external requiresAuth {
 130 |     |         useDynamicFeed = _useDynamicFeed;
 131 |     |         emit CollateralFeedSourceUpdated(address(_collateralFeed()));
 132 |     |     }
 133 |     | 
 134 |     |     /// @notice Returns the latest price obtained from the Oracle
 135 |     |     /// @dev Called by eBTC functions that require a current price. Also callable permissionlessly.
 136 |     |     /// @dev Non-view function - it updates and stores the last good price seen by eBTC.
 137 |     |     /// @dev Uses a main oracle (Chainlink) and a fallback oracle in case Chainlink fails. If both fail, it uses the last good price seen by eBTC.
 138 |     |     /// @dev The fallback oracle address can be swapped by the Authority. The fallback oracle must conform to the IFallbackCaller interface.
 139 |     |     /// @return The latest price fetched from the Oracle
 140 |     |     function fetchPrice() external override returns (uint256) {
 141 |     |         // Get current and previous price data from Chainlink, and current price data from Fallback
 142 |     |         ChainlinkResponse memory chainlinkResponse = _getCurrentChainlinkResponse();
 143 |     |         ChainlinkResponse memory prevChainlinkResponse = _getPrevChainlinkResponse(
 144 |     |             chainlinkResponse.roundEthBtcId,
 145 |     |             chainlinkResponse.roundStEthEthId
 146 |     |         );
 147 |     |         FallbackResponse memory fallbackResponse = _getCurrentFallbackResponse();
 148 |     | 
 149 |     |         // --- CASE 1: System fetched last price from Chainlink  ---
 150 |     |         if (status == Status.chainlinkWorking) {
 151 |     |             // If Chainlink is broken, try Fallback
 152 |     |             if (_chainlinkIsBroken(chainlinkResponse, prevChainlinkResponse)) {
 153 |     |                 // If Fallback is broken then both oracles are untrusted, so return the last good price
 154 |     |                 if (_fallbackIsBroken(fallbackResponse)) {
 155 |     |                     _changeStatus(Status.bothOraclesUntrusted);
 156 |     |                     return INVALID_PRICE;
 157 |     |                 }
 158 |     |                 /*
 159 |     |                  * If Fallback is only frozen but otherwise returning valid data, return the last good price.
 160 |     |                  * Fallback may need to be tipped to return current data.
 161 |     |                  */
 162 |     |                 if (_fallbackIsFrozen(fallbackResponse)) {
 163 |     |                     _changeStatus(Status.usingFallbackChainlinkUntrusted);
 164 |     |                     return INVALID_PRICE;
 165 |     |                 }
 166 |     | 
 167 |     |                 // If Chainlink is broken and Fallback is working, switch to Fallback and return current Fallback price
 168 |     |                 _changeStatus(Status.usingFallbackChainlinkUntrusted);
 169 |     |                 return _storeFallbackPrice(fallbackResponse);
 170 |     |             }
 171 |     | 
 172 |     |             // If Chainlink is frozen, try Fallback
 173 |     |             if (_chainlinkIsFrozen(chainlinkResponse)) {
 174 |     |                 // If Fallback is broken too, remember Fallback broke, and return last good price
 175 |     |                 if (_fallbackIsBroken(fallbackResponse)) {
 176 |     |                     _changeStatus(Status.usingChainlinkFallbackUntrusted);
 177 |     |                     return INVALID_PRICE;
 178 |     |                 }
 179 |     | 
 180 |     |                 // If Fallback is frozen or working, remember Chainlink froze, and switch to Fallback
 181 |     |                 _changeStatus(Status.usingFallbackChainlinkFrozen);
 182 |     | 
 183 |     |                 if (_fallbackIsFrozen(fallbackResponse)) {
 184 |     |                     return INVALID_PRICE;
 185 |     |                 }
 186 |     | 
 187 |     |                 // If Fallback is working, use it
 188 |     |                 return _storeFallbackPrice(fallbackResponse);
 189 |     |             }
 190 |     | 
 191 |     |             // If Chainlink price has changed by > 50% between two consecutive rounds, compare it to Fallback's price
 192 |     |             if (_chainlinkPriceChangeAboveMax(chainlinkResponse, prevChainlinkResponse)) {
 193 |     |                 // If Fallback is broken, both oracles are untrusted, and return last good price
 194 |     |                 // We don't trust CL for now given this large price differential
 195 |     |                 if (_fallbackIsBroken(fallbackResponse)) {
 196 |     |                     _changeStatus(Status.bothOraclesUntrusted);
 197 |     |                     return INVALID_PRICE;
 198 |     |                 }
 199 |     | 
 200 |     |                 // If Fallback is frozen, switch to Fallback and return last good price
 201 |     |                 // We don't trust CL for now given this large price differential
 202 |     |                 if (_fallbackIsFrozen(fallbackResponse)) {
 203 |     |                     _changeStatus(Status.usingFallbackChainlinkUntrusted);
 204 |     |                     return INVALID_PRICE;
 205 |     |                 }
 206 |     | 
 207 |     |                 /*
 208 |     |                  * If Fallback is live and both oracles have a similar price, conclude that Chainlink's large price deviation between
 209 |     |                  * two consecutive rounds was likely a legitmate market price movement, and so continue using Chainlink
 210 |     |                  */
 211 |     |                 if (_bothOraclesSimilarPrice(chainlinkResponse, fallbackResponse)) {
 212 |     |                     return _storeChainlinkPrice(chainlinkResponse.answer);
 213 |     |                 }
 214 |     | 
 215 |     |                 // If Fallback is live but the oracles differ too much in price, conclude that Chainlink's initial price deviation was
 216 |     |                 // an oracle failure. Switch to Fallback, and use Fallback price
 217 |     |                 _changeStatus(Status.usingFallbackChainlinkUntrusted);
 218 |     |                 return _storeFallbackPrice(fallbackResponse);
 219 |     |             }
 220 |     | 
 221 |     |             // If Chainlink is working and Fallback is broken, remember Fallback is broken
 222 |     |             if (_fallbackIsBroken(fallbackResponse)) {
 223 |     |                 _changeStatus(Status.usingChainlinkFallbackUntrusted);
 224 |     |             }
 225 |     | 
 226 |     |             // If Chainlink is working, return Chainlink current price (no status change)
 227 |     |             return _storeChainlinkPrice(chainlinkResponse.answer);
 228 |     |         }
 229 |     | 
 230 |     |         // --- CASE 2: The system fetched last price from Fallback ---
 231 |     |         if (status == Status.usingFallbackChainlinkUntrusted) {
 232 |     |             if (_fallbackIsBroken(fallbackResponse)) {
 233 |     |                 _changeStatus(Status.bothOraclesUntrusted);
 234 |     |                 return INVALID_PRICE;
 235 |     |             }
 236 |     | 
 237 |     |             /*
 238 |     |              * If Fallback is only frozen but otherwise returning valid data, just return the last good price.
 239 |     |              * Fallback may need to be tipped to return current data.
 240 |     |              */
 241 |     |             if (_fallbackIsFrozen(fallbackResponse)) {
 242 |     |                 return INVALID_PRICE;
 243 |     |             }
 244 |     | 
 245 |     |             // If both Fallback and Chainlink are live, unbroken, and reporting similar prices, switch back to Chainlink
 246 |     |             if (
 247 |     |                 _bothOraclesLiveAndUnbrokenAndSimilarPrice(
 248 |     |                     chainlinkResponse,
 249 |     |                     prevChainlinkResponse,
 250 |     |                     fallbackResponse
 251 |     |                 )
 252 |     |             ) {
 253 |     |                 _changeStatus(Status.chainlinkWorking);
 254 |     |                 return _storeChainlinkPrice(chainlinkResponse.answer);
 255 |     |             }
 256 |     | 
 257 |     |             // Otherwise, use Fallback price
 258 |     |             return _storeFallbackPrice(fallbackResponse);
 259 |     |         }
 260 |     | 
 261 |     |         // --- CASE 3: Both oracles were untrusted at the last price fetch ---
 262 |     |         if (status == Status.bothOraclesUntrusted) {
 263 |     |             /*
 264 |     |              * If there's no fallback, only use Chainlink
 265 |     |              */
 266 |     |             if (address(fallbackCaller) == address(0)) {
 267 |     |                 // If CL has resumed working
 268 |     |                 if (
 269 |     |                     !_chainlinkIsBroken(chainlinkResponse, prevChainlinkResponse) &&
 270 |     |                     !_chainlinkIsFrozen(chainlinkResponse) &&
 271 |     |                     !_chainlinkPriceChangeAboveMax(chainlinkResponse, prevChainlinkResponse)
 272 |     |                 ) {
 273 |     |                     _changeStatus(Status.usingChainlinkFallbackUntrusted);
 274 |     |                     return _storeChainlinkPrice(chainlinkResponse.answer);
 275 |     |                 } else {
 276 |     |                     return INVALID_PRICE;
 277 |     |                 }
 278 |     |             }
 279 |     | 
 280 |     |             /*
 281 |     |              * If both oracles are now live, unbroken and similar price, we assume that they are reporting
 282 |     |              * accurately, and so we switch back to Chainlink.
 283 |     |              */
 284 |     |             if (
 285 |     |                 _bothOraclesLiveAndUnbrokenAndSimilarPrice(
 286 |     |                     chainlinkResponse,
 287 |     |                     prevChainlinkResponse,
 288 |     |                     fallbackResponse
 289 |     |                 )
 290 |     |             ) {
 291 |     |                 _changeStatus(Status.chainlinkWorking);
 292 |     |                 return _storeChainlinkPrice(chainlinkResponse.answer);
 293 |     |             }
 294 |     | 
 295 |     |             // Otherwise, return the last good price - both oracles are still untrusted (no status change)
 296 |     |             return INVALID_PRICE;
 297 |     |         }
 298 |     | 
 299 |     |         // --- CASE 4: Using Fallback, and Chainlink is frozen ---
 300 |     |         if (status == Status.usingFallbackChainlinkFrozen) {
 301 |     |             if (_chainlinkIsBroken(chainlinkResponse, prevChainlinkResponse)) {
 302 |     |                 // If both Oracles are broken, return last good price
 303 |     |                 if (_fallbackIsBroken(fallbackResponse)) {
 304 |     |                     _changeStatus(Status.bothOraclesUntrusted);
 305 |     |                     return INVALID_PRICE;
 306 |     |                 }
 307 |     | 
 308 |     |                 // If Chainlink is broken, remember it and switch to using Fallback
 309 |     |                 _changeStatus(Status.usingFallbackChainlinkUntrusted);
 310 |     | 
 311 |     |                 if (_fallbackIsFrozen(fallbackResponse)) {
 312 |     |                     return INVALID_PRICE;
 313 |     |                 }
 314 |     | 
 315 |     |                 // If Fallback is working, return Fallback current price
 316 |     |                 return _storeFallbackPrice(fallbackResponse);
 317 |     |             }
 318 |     | 
 319 |     |             if (_chainlinkIsFrozen(chainlinkResponse)) {
 320 |     |                 // if Chainlink is frozen and Fallback is broken, remember Fallback broke, and return last good price
 321 |     |                 if (_fallbackIsBroken(fallbackResponse)) {
 322 |     |                     _changeStatus(Status.usingChainlinkFallbackUntrusted);
 323 |     |                     return INVALID_PRICE;
 324 |     |                 }
 325 |     | 
 326 |     |                 // If both are frozen, just use lastGoodPrice
 327 |     |                 if (_fallbackIsFrozen(fallbackResponse)) {
 328 |     |                     return INVALID_PRICE;
 329 |     |                 }
 330 |     | 
 331 |     |                 // if Chainlink is frozen and Fallback is working, keep using Fallback (no status change)
 332 |     |                 return _storeFallbackPrice(fallbackResponse);
 333 |     |             }
 334 |     | 
 335 |     |             if (_chainlinkPriceChangeAboveMax(chainlinkResponse, prevChainlinkResponse)) {
 336 |     |                 // if Chainlink price is deviated between rounds and fallback is broken, just use lastGoodPrice
 337 |     |                 if (_fallbackIsBroken(fallbackResponse)) {
 338 |     |                     _changeStatus(Status.bothOraclesUntrusted);
 339 |     |                     return INVALID_PRICE;
 340 |     |                 }
 341 |     | 
 342 |     |                 // If Chainlink price is deviated between rounds, remember it and keep using fallback
 343 |     |                 _changeStatus(Status.usingFallbackChainlinkUntrusted);
 344 |     | 
 345 |     |                 // If fallback is frozen, just use lastGoodPrice
 346 |     |                 if (_fallbackIsFrozen(fallbackResponse)) {
 347 |     |                     return INVALID_PRICE;
 348 |     |                 }
 349 |     | 
 350 |     |                 // otherwise fallback is working and keep using its latest response
 351 |     |                 return _storeFallbackPrice(fallbackResponse);
 352 |     |             }
 353 |     | 
 354 |     |             // if Chainlink is live and Fallback is broken, remember Fallback broke, and return Chainlink price
 355 |     |             if (_fallbackIsBroken(fallbackResponse)) {
 356 |     |                 _changeStatus(Status.usingChainlinkFallbackUntrusted);
 357 |     |                 return _storeChainlinkPrice(chainlinkResponse.answer);
 358 |     |             }
 359 |     | 
 360 |     |             // If Chainlink is live and Fallback is frozen, just use last good price (no status change) since we have no basis for comparison
 361 |     |             if (_fallbackIsFrozen(fallbackResponse)) {
 362 |     |                 return INVALID_PRICE;
 363 |     |             }
 364 |     | 
 365 |     |             // If Chainlink is live and Fallback is working, compare prices. Switch to Chainlink
 366 |     |             // if prices are within 5%, and return Chainlink price.
 367 |     |             if (_bothOraclesSimilarPrice(chainlinkResponse, fallbackResponse)) {
 368 |     |                 _changeStatus(Status.chainlinkWorking);
 369 |     |                 return _storeChainlinkPrice(chainlinkResponse.answer);
 370 |     |             }
 371 |     | 
 372 |     |             // Otherwise if Chainlink is live but price not within 5% of Fallback, distrust Chainlink, and return Fallback price
 373 |     |             _changeStatus(Status.usingFallbackChainlinkUntrusted);
 374 |     |             return _storeFallbackPrice(fallbackResponse);
 375 |     |         }
 376 |     | 
 377 |     |         // --- CASE 5: Using Chainlink, Fallback is untrusted ---
 378 |     |         if (status == Status.usingChainlinkFallbackUntrusted) {
 379 |     |             // If Chainlink breaks, now both oracles are untrusted
 380 |     |             if (_chainlinkIsBroken(chainlinkResponse, prevChainlinkResponse)) {
 381 |     |                 _changeStatus(Status.bothOraclesUntrusted);
 382 |     |                 return INVALID_PRICE;
 383 |     |             }
 384 |     | 
 385 |     |             // If Chainlink is frozen, return last good price (no status change)
 386 |     |             if (_chainlinkIsFrozen(chainlinkResponse)) {
 387 |     |                 return INVALID_PRICE;
 388 |     |             }
 389 |     | 
 390 |     |             // If Chainlink is live but deviated >50% from it's previous price and Fallback is still untrusted, switch
 391 |     |             // to bothOraclesUntrusted and return last good price
 392 |     |             if (_chainlinkPriceChangeAboveMax(chainlinkResponse, prevChainlinkResponse)) {
 393 |     |                 _changeStatus(Status.bothOraclesUntrusted);
 394 |     |                 return INVALID_PRICE;
 395 |     |             }
 396 |     | 
 397 |     |             // If Chainlink and Fallback are both live, unbroken and similar price, switch back to chainlinkWorking and return Chainlink price
 398 |     |             if (
 399 |     |                 _bothOraclesLiveAndUnbrokenAndSimilarPrice(
 400 |     |                     chainlinkResponse,
 401 |     |                     prevChainlinkResponse,
 402 |     |                     fallbackResponse
 403 |     |                 )
 404 |     |             ) {
 405 |     |                 if (address(fallbackCaller) != address(0)) {
 406 |     |                     _changeStatus(Status.chainlinkWorking);
 407 |     |                 }
 408 |     |                 return _storeChainlinkPrice(chainlinkResponse.answer);
 409 |     |             }
 410 |     | 
 411 |     |             // Otherwise if Chainlink is live and deviated <50% from it's previous price and Fallback is still untrusted,
 412 |     |             // return Chainlink price (no status change)
 413 |     |             return _storeChainlinkPrice(chainlinkResponse.answer);
 414 |     |         }
 415 |     | 
 416 |     |         /// @audit This should never be used, but we added it for the Certora Prover
 417 |     |         return INVALID_PRICE;
 418 |     |     }
 419 |     | 
 420 |     |     // --- Governance Functions ---
 421 |     |     /// @notice Sets a new fallback oracle
 422 |     |     /// @dev Healthy response of new oracle is checked, with extra event emitted on failure
 423 |     |     /// @param _fallbackCaller The address of the new IFallbackCaller compliant oracle\
 424 |     |     function setFallbackCaller(address _fallbackCaller) external requiresAuth {
 425 |     |         // health check-up before officially set it up
 426 |     |         IFallbackCaller newFallbackCaler = IFallbackCaller(_fallbackCaller);
 427 |     |         FallbackResponse memory fallbackResponse;
 428 |     | 
 429 |     |         if (_fallbackCaller != address(0)) {
 430 |     |             try newFallbackCaler.getFallbackResponse() returns (
 431 |     |                 uint256 answer,
 432 |     |                 uint256 timestampRetrieved,
 433 |     |                 bool success
 434 |     |             ) {
 435 |     |                 fallbackResponse.answer = answer;
 436 |     |                 fallbackResponse.timestamp = timestampRetrieved;
 437 |     |                 fallbackResponse.success = success;
 438 |     |                 if (
 439 |     |                     !_fallbackIsBroken(fallbackResponse) &&
 440 |     |                     !_responseTimeout(fallbackResponse.timestamp, newFallbackCaler.fallbackTimeout())
 441 |     |                 ) {
 442 |     |                     address oldFallbackCaller = address(fallbackCaller);
 443 |     |                     fallbackCaller = newFallbackCaler;
 444 |     |                     emit FallbackCallerChanged(oldFallbackCaller, _fallbackCaller);
 445 |     |                 }
 446 |     |             } catch {
 447 |     |                 emit UnhealthyFallbackCaller(_fallbackCaller, block.timestamp);
 448 |     |             }
 449 |     |         } else {
 450 |     |             address oldFallbackCaller = address(fallbackCaller);
 451 |     |             // NOTE: assume intentionally bricking fallback!!!
 452 |     |             fallbackCaller = newFallbackCaler;
 453 |     |             emit FallbackCallerChanged(oldFallbackCaller, _fallbackCaller);
 454 |     |         }
 455 |     |     }
 456 |     | 
 457 |     |     // --- Helper functions ---
 458 |     | 
 459 |     |     /// @notice Checks if Chainlink oracle is broken by checking both the current and previous responses
 460 |     |     /// @dev Chainlink is considered broken if its current or previous round data is in any way bad. We check the previous round for two reasons.
 461 |     |     /// @dev 1. It is necessary data for the price deviation check in case 1
 462 |     |     /// @dev 2. Chainlink is the PriceFeed's preferred primary oracle - having two consecutive valid round responses adds peace of mind when using or returning to Chainlink.
 463 |     |     /// @param _currentResponse The latest response from the Chainlink oracle
 464 |     |     /// @param _prevResponse The previous response from the Chainlink oracle
 465 |     |     /// @return A boolean indicating whether the Chainlink oracle is broken
 466 |     |     function _chainlinkIsBroken(
 467 |     |         ChainlinkResponse memory _currentResponse,
 468 |     |         ChainlinkResponse memory _prevResponse
 469 |     |     ) internal view returns (bool) {
 470 |     |         return _badChainlinkResponse(_currentResponse) || _badChainlinkResponse(_prevResponse);
 471 |     |     }
 472 |     | 
 473 |     |     /// @notice Checks for a bad response from the Chainlink oracle
 474 |     |     /// @dev A response is considered bad if the success value reports failure, or if the timestamp is invalid (0 or in the future)
 475 |     |     /// @param _response The response from the Chainlink oracle to evaluate
 476 |     |     /// @return A boolean indicating whether the Chainlink oracle response is bad
 477 |     | 
 478 |     |     function _badChainlinkResponse(ChainlinkResponse memory _response) internal view returns (bool) {
 479 |     |         // Check for response call reverted
 480 |     |         if (!_response.success) {
 481 |     |             return true;
 482 |     |         }
 483 |     | 
 484 |     |         // Check for an invalid timestamp that is 0, or in the future
 485 |     |         if (
 486 |     |             _response.timestampEthBtc == 0 ||
 487 |     |             _response.timestampEthBtc > block.timestamp ||
 488 |     |             _response.timestampStEthEth == 0 ||
 489 |     |             _response.timestampStEthEth > block.timestamp
 490 |     |         ) {
 491 |     |             return true;
 492 |     |         }
 493 |     | 
 494 |     |         return false;
 495 |     |     }
 496 |     | 
 497 |     |     /// @notice Checks if the Chainlink oracle is frozen
 498 |     |     /// @dev The oracle is considered frozen if either of the feed timestamps are older than the threshold specified by the static timeout thresholds
 499 |     |     /// @param _response The response from the Chainlink oracle to evaluate
 500 |     |     /// @return A boolean indicating whether the Chainlink oracle is frozen
 501 |     |     function _chainlinkIsFrozen(ChainlinkResponse memory _response) internal view returns (bool) {
 502 |     |         return
 503 |     |             _responseTimeout(_response.timestampEthBtc, TIMEOUT_ETH_BTC_FEED) ||
 504 |     |             _responseTimeout(_response.timestampStEthEth, TIMEOUT_STETH_ETH_FEED);
 505 |     |     }
 506 |     | 
 507 |     |     /// @notice Checks if the price change between Chainlink oracle rounds is above the maximum threshold allowed
 508 |     |     /// @param _currentResponse The latest response from the Chainlink oracle
 509 |     |     /// @param _prevResponse The previous response from the Chainlink oracle
 510 |     |     /// @return A boolean indicating whether the price change from Chainlink oracle is above the maximum threshold allowed
 511 |     |     function _chainlinkPriceChangeAboveMax(
 512 |     |         ChainlinkResponse memory _currentResponse,
 513 |     |         ChainlinkResponse memory _prevResponse
 514 |     |     ) internal pure returns (bool) {
 515 |     |         uint256 minPrice = EbtcMath._min(_currentResponse.answer, _prevResponse.answer);
 516 |     |         uint256 maxPrice = EbtcMath._max(_currentResponse.answer, _prevResponse.answer);
 517 |     | 
 518 |     |         /*
 519 |     |          * Use the larger price as the denominator:
 520 |     |          * - If price decreased, the percentage deviation is in relation to the the previous price.
 521 |     |          * - If price increased, the percentage deviation is in relation to the current price.
 522 |     |          */
 523 |     |         uint256 percentDeviation = maxPrice > 0
 524 |     |             ? ((maxPrice - minPrice) * EbtcMath.DECIMAL_PRECISION) / maxPrice
 525 |     |             : 0;
 526 |     | 
 527 |     |         // Return true if price has more than doubled, or more than halved.
 528 |     |         return percentDeviation > MAX_PRICE_DEVIATION_FROM_PREVIOUS_ROUND;
 529 |     |     }
 530 |     | 
 531 |     |     function _fallbackIsBroken(FallbackResponse memory _response) internal view returns (bool) {
 532 |     |         // Check for response call reverted
 533 |     |         if (!_response.success) {
 534 |     |             return true;
 535 |     |         }
 536 |     |         // Check for an invalid timeStamp that is 0, or in the future
 537 |     |         if (_response.timestamp == 0 || _response.timestamp > block.timestamp) {
 538 |     |             return true;
 539 |     |         }
 540 |     |         // Check for zero price (FallbackCaller must ensure that the price is not negative and return 0 if it is)
 541 |     |         if (_response.answer == 0) {
 542 |     |             return true;
 543 |     |         }
 544 |     | 
 545 |     |         return false;
 546 |     |     }
 547 |     | 
 548 |     |     /// @notice Checks if the fallback oracle is frozen by comparing the current timestamp with the timeout value.
 549 |     |     /// @param _fallbackResponse Response from the fallback oracle to check
 550 |     |     /// @return A boolean indicating whether the fallback oracle is frozen.
 551 |     |     function _fallbackIsFrozen(
 552 |     |         FallbackResponse memory _fallbackResponse
 553 |     |     ) internal view returns (bool) {
 554 |     |         return
 555 |     |             _fallbackResponse.timestamp > 0 &&
 556 |     |             _responseTimeout(_fallbackResponse.timestamp, fallbackCaller.fallbackTimeout());
 557 |     |     }
 558 |     | 
 559 |     |     function _responseTimeout(uint256 _timestamp, uint256 _timeout) internal view returns (bool) {
 560 |     |         return block.timestamp - _timestamp > _timeout;
 561 |     |     }
 562 |     | 
 563 |     |     /// @notice Checks if both the Chainlink and fallback oracles are live, unbroken, and reporting similar prices.
 564 |     |     /// @param _chainlinkResponse The latest response from the Chainlink oracle.
 565 |     |     /// @param _prevChainlinkResponse The previous response from the Chainlink oracle.
 566 |     |     /// @param _fallbackResponse The latest response from the fallback oracle.
 567 |     |     /// @return A boolean indicating whether both oracles are live, unbroken, and reporting similar prices.
 568 |     | 
 569 |     |     function _bothOraclesLiveAndUnbrokenAndSimilarPrice(
 570 |     |         ChainlinkResponse memory _chainlinkResponse,
 571 |     |         ChainlinkResponse memory _prevChainlinkResponse,
 572 |     |         FallbackResponse memory _fallbackResponse
 573 |     |     ) internal view returns (bool) {
 574 |     |         // Return false if either oracle is broken or frozen
 575 |     |         if (
 576 |     |             (address(fallbackCaller) != address(0) &&
 577 |     |                 (_fallbackIsBroken(_fallbackResponse) || _fallbackIsFrozen(_fallbackResponse))) ||
 578 |     |             _chainlinkIsBroken(_chainlinkResponse, _prevChainlinkResponse) ||
 579 |     |             _chainlinkIsFrozen(_chainlinkResponse)
 580 |     |         ) {
 581 |     |             return false;
 582 |     |         }
 583 |     | 
 584 |     |         return _bothOraclesSimilarPrice(_chainlinkResponse, _fallbackResponse);
 585 |     |     }
 586 |     | 
 587 |     |     /// @notice Checks if the prices reported by the Chainlink and fallback oracles are similar, within the maximum deviation specified by MAX_PRICE_DIFFERENCE_BETWEEN_ORACLES.
 588 |     |     /// @param _chainlinkResponse The response from the Chainlink oracle.
 589 |     |     /// @param _fallbackResponse The response from the fallback oracle.
 590 |     |     /// @return A boolean indicating whether the prices reported by both oracles are similar.
 591 |     | 
 592 |     |     function _bothOraclesSimilarPrice(
 593 |     |         ChainlinkResponse memory _chainlinkResponse,
 594 |     |         FallbackResponse memory _fallbackResponse
 595 |     |     ) internal view returns (bool) {
 596 |     |         if (address(fallbackCaller) == address(0)) {
 597 |     |             return true;
 598 |     |         }
 599 |     |         // Get the relative price difference between the oracles. Use the lower price as the denominator, i.e. the reference for the calculation.
 600 |     |         uint256 minPrice = EbtcMath._min(_fallbackResponse.answer, _chainlinkResponse.answer);
 601 |     |         if (minPrice == 0) return false;
 602 |     |         uint256 maxPrice = EbtcMath._max(_fallbackResponse.answer, _chainlinkResponse.answer);
 603 |     |         uint256 percentPriceDifference = ((maxPrice - minPrice) * EbtcMath.DECIMAL_PRECISION) /
 604 |     |             minPrice;
 605 |     | 
 606 |     |         /*
 607 |     |          * Return true if the relative price difference is <= MAX_PRICE_DIFFERENCE_BETWEEN_ORACLES: if so, we assume both oracles are probably reporting
 608 |     |          * the honest market price, as it is unlikely that both have been broken/hacked and are still in-sync.
 609 |     |          */
 610 |     |         return percentPriceDifference <= MAX_PRICE_DIFFERENCE_BETWEEN_ORACLES;
 611 |     |     }
 612 |     | 
 613 |     |     /// @notice Changes the status of the oracle state machine
 614 |     |     /// @param _status The new status of the contract.
 615 |     |     function _changeStatus(Status _status) internal {
 616 |     |         status = _status;
 617 |     |         emit PriceFeedStatusChanged(_status);
 618 |     |     }
 619 |     | 
 620 |     |     /// @notice Stores the latest valid price.
 621 |     |     /// @param _currentPrice The price to be stored.
 622 |     |     function _storePrice(uint256 _currentPrice) internal {
 623 |     |         emit LastGoodPriceUpdated(_currentPrice);
 624 |     |     }
 625 |     | 
 626 |     |     /// @notice Stores the price reported by the fallback oracle.
 627 |     |     /// @param _fallbackResponse The latest response from the fallback oracle.
 628 |     |     /// @return The price reported by the fallback oracle.
 629 |     |     function _storeFallbackPrice(
 630 |     |         FallbackResponse memory _fallbackResponse
 631 |     |     ) internal returns (uint256) {
 632 |     |         _storePrice(_fallbackResponse.answer);
 633 |     |         return _fallbackResponse.answer;
 634 |     |     }
 635 |     | 
 636 |     |     /// @notice Stores the price reported by the Chainlink oracle.
 637 |     |     /// @param _answer The latest price reported by the Chainlink oracle.
 638 |     |     /// @return The price reported by the Chainlink oracle.
 639 |     |     function _storeChainlinkPrice(uint256 _answer) internal returns (uint256) {
 640 |     |         _storePrice(_answer);
 641 |     |         return _answer;
 642 |     |     }
 643 |     | 
 644 |     |     // --- Oracle response wrapper functions ---
 645 |     | 
 646 |     |     /// @notice Retrieves the latest response from the fallback oracle. If the fallback oracle address is set to the zero address, it returns a failing struct.
 647 |     |     /// @return fallbackResponse The latest response from the fallback oracle.
 648 |     | 
 649 |     |     function _getCurrentFallbackResponse()
 650 |     |         internal
 651 |     |         view
 652 |     |         returns (FallbackResponse memory fallbackResponse)
 653 |     |     {
 654 |     |         if (address(fallbackCaller) != address(0)) {
 655 |     |             try fallbackCaller.getFallbackResponse() returns (
 656 |     |                 uint256 answer,
 657 |     |                 uint256 timestampRetrieved,
 658 |     |                 bool success
 659 |     |             ) {
 660 |     |                 fallbackResponse.answer = answer;
 661 |     |                 fallbackResponse.timestamp = timestampRetrieved;
 662 |     |                 fallbackResponse.success = success;
 663 |     |             } catch {
 664 |     |                 // If call to Fallback reverts, return a zero response with success = false
 665 |     |             }
 666 |     |         } // If unset we return a zero response with success = false
 667 |     | 
 668 |     |         // Return is implicit
 669 |     |     }
 670 |     | 
 671 |     |     function _collateralFeed() private view returns (AggregatorV3Interface) {
 672 |     |         return useDynamicFeed ? STETH_ETH_CL_FEED : STETH_ETH_FIXED_FEED;
 673 |     |     }
 674 |     | 
 675 |     |     /// @notice Fetches Chainlink responses for the current round of data for both ETH-BTC and stETH-ETH price feeds.
 676 |     |     /// @return chainlinkResponse A struct containing data retrieved from the price feeds, including the round IDs, timestamps, aggregated price, and a success flag.
 677 |     |     function _getCurrentChainlinkResponse()
 678 |     |         internal
 679 |     |         view
 680 |     |         returns (ChainlinkResponse memory chainlinkResponse)
 681 |     |     {
 682 |     |         // Try to get latest prices data:
 683 |     |         int256 ethBtcAnswer;
 684 |     |         int256 stEthEthAnswer;
 685 |     |         try ETH_BTC_CL_FEED.latestRoundData() returns (
 686 |     |             uint80 roundId,
 687 |     |             int256 answer,
 688 |     |             uint256,
 689 |     |             /* startedAt */
 690 |     |             uint256 timestamp,
 691 |     |             uint80 /* answeredInRound */
 692 |     |         ) {
 693 |     |             ethBtcAnswer = answer;
 694 |     |             chainlinkResponse.roundEthBtcId = roundId;
 695 |     |             chainlinkResponse.timestampEthBtc = timestamp;
 696 |     |         } catch {
 697 |     |             // If call to Chainlink aggregator reverts, return a zero response with success = false
 698 |     |             return chainlinkResponse;
 699 |     |         }
 700 |     | 
 701 |     |         try _collateralFeed().latestRoundData() returns (
 702 |     |             uint80 roundId,
 703 |     |             int256 answer,
 704 |     |             uint256,
 705 |     |             /* startedAt */
 706 |     |             uint256 timestamp,
 707 |     |             uint80 /* answeredInRound */
 708 |     |         ) {
 709 |     |             stEthEthAnswer = answer;
 710 |     |             chainlinkResponse.roundStEthEthId = roundId;
 711 |     |             chainlinkResponse.timestampStEthEth = timestamp;
 712 |     |         } catch {
 713 |     |             // If call to Chainlink aggregator reverts, return a zero response with success = false
 714 |     |             return chainlinkResponse;
 715 |     |         }
 716 |     | 
 717 |     |         if (
 718 |     |             _checkHealthyCLResponse(chainlinkResponse.roundEthBtcId, ethBtcAnswer) &&
 719 |     |             _checkHealthyCLResponse(chainlinkResponse.roundStEthEthId, stEthEthAnswer)
 720 |     |         ) {
 721 |     |             chainlinkResponse.answer = _formatClAggregateAnswer(ethBtcAnswer, stEthEthAnswer);
 722 |     |         } else {
 723 |     |             return chainlinkResponse;
 724 |     |         }
 725 |     | 
 726 |     |         chainlinkResponse.success = true;
 727 |     |     }
 728 |     | 
 729 |     |     /// @notice Returns if the CL feed is healthy or not, based on: negative value and null round id. For price aggregation
 730 |     |     /// @param _roundId The aggregator round of the target CL feed
 731 |     |     /// @param _answer CL price price reported for target feeds
 732 |     |     /// @return The boolean state indicating CL response health for aggregation
 733 |     |     function _checkHealthyCLResponse(uint80 _roundId, int256 _answer) internal view returns (bool) {
 734 |     |         if (_answer <= 0) return false;
 735 |     |         if (_roundId == 0) return false;
 736 |     | 
 737 |     |         return true;
 738 |     |     }
 739 |     | 
 740 |     |     /// @notice Fetches Chainlink responses for the previous round of data for both ETH-BTC and stETH-ETH price feeds.
 741 |     |     /// @param _currentRoundEthBtcId The current round ID for the ETH-BTC price feed.
 742 |     |     /// @param _currentRoundStEthEthId The current round ID for the stETH-ETH price feed.
 743 |     |     /// @return prevChainlinkResponse A struct containing data retrieved from the price feeds, including the round IDs, timestamps, aggregated price, and a success flag.
 744 |     |     function _getPrevChainlinkResponse(
 745 |     |         uint80 _currentRoundEthBtcId,
 746 |     |         uint80 _currentRoundStEthEthId
 747 |     |     ) internal view returns (ChainlinkResponse memory prevChainlinkResponse) {
 748 |     |         // If first round, early return
 749 |     |         // Handles revert from underflow in _currentRoundEthBtcId - 1
 750 |     |         // and _currentRoundStEthEthId - 1
 751 |     |         // Behavior should be indentical to following block if this revert was caught
 752 |     |         if (_currentRoundEthBtcId == 0 || _currentRoundStEthEthId == 0) {
 753 |     |             return prevChainlinkResponse;
 754 |     |         }
 755 |     | 
 756 |     |         // Try to get latest prices data from prev round:
 757 |     |         int256 ethBtcAnswer;
 758 |     |         int256 stEthEthAnswer;
 759 |     |         try ETH_BTC_CL_FEED.getRoundData(_currentRoundEthBtcId - 1) returns (
 760 |     |             uint80 roundId,
 761 |     |             int256 answer,
 762 |     |             uint256,
 763 |     |             /* startedAt */
 764 |     |             uint256 timestamp,
 765 |     |             uint80 /* answeredInRound */
 766 |     |         ) {
 767 |     |             ethBtcAnswer = answer;
 768 |     |             prevChainlinkResponse.roundEthBtcId = roundId;
 769 |     |             prevChainlinkResponse.timestampEthBtc = timestamp;
 770 |     |         } catch {
 771 |     |             // If call to Chainlink aggregator reverts, return a zero response with success = false
 772 |     |             return prevChainlinkResponse;
 773 |     |         }
 774 |     | 
 775 |     |         try _collateralFeed().getRoundData(_currentRoundStEthEthId - 1) returns (
 776 |     |             uint80 roundId,
 777 |     |             int256 answer,
 778 |     |             uint256,
 779 |     |             /* startedAt */
 780 |     |             uint256 timestamp,
 781 |     |             uint80 /* answeredInRound */
 782 |     |         ) {
 783 |     |             stEthEthAnswer = answer;
 784 |     |             prevChainlinkResponse.roundStEthEthId = roundId;
 785 |     |             prevChainlinkResponse.timestampStEthEth = timestamp;
 786 |     |         } catch {
 787 |     |             // If call to Chainlink aggregator reverts, return a zero response with success = false
 788 |     |             return prevChainlinkResponse;
 789 |     |         }
 790 |     | 
 791 |     |         if (
 792 |     |             _checkHealthyCLResponse(prevChainlinkResponse.roundEthBtcId, ethBtcAnswer) &&
 793 |     |             _checkHealthyCLResponse(prevChainlinkResponse.roundStEthEthId, stEthEthAnswer)
 794 |     |         ) {
 795 |     |             prevChainlinkResponse.answer = _formatClAggregateAnswer(ethBtcAnswer, stEthEthAnswer);
 796 |     |         } else {
 797 |     |             return prevChainlinkResponse;
 798 |     |         }
 799 |     | 
 800 |     |         prevChainlinkResponse.success = true;
 801 |     |     }
 802 |     | 
 803 |     |     // @notice Returns the price of stETH:BTC in 18 decimals denomination
 804 |     |     // @param _ethBtcAnswer CL price retrieve from ETH:BTC feed
 805 |     |     // @param _stEthEthAnswer CL price retrieve from stETH:BTC feed
 806 |     |     // @return The aggregated calculated price for stETH:BTC
 807 |     |     function _formatClAggregateAnswer(
 808 |     |         int256 _ethBtcAnswer,
 809 |     |         int256 _stEthEthAnswer
 810 |     |     ) internal view returns (uint256) {
 811 |     |         return
 812 |     |             (SCALED_DECIMAL *
 813 |     |                 uint256(_ethBtcAnswer) *
 814 |     |                 uint256(_stEthEthAnswer) *
 815 |     |                 EbtcMath.DECIMAL_PRECISION) / DENOMINATOR;
 816 |     |     }
 817 |     | }
 818 |     | 

/mnt/c/Users/Lourens/Documents/Recon-Fuzz/collabs/ebtc/packages/contracts/contracts/SortedCdps.sol
   1 |     | // SPDX-License-Identifier: MIT
   2 |     | 
   3 |     | pragma solidity 0.8.17;
   4 |     | 
   5 |     | import "./Interfaces/ISortedCdps.sol";
   6 |     | import "./Interfaces/ICdpManager.sol";
   7 |     | import "./Interfaces/IBorrowerOperations.sol";
   8 |     | 
   9 |     | /*
  10 |     |  * A sorted doubly linked list with nodes sorted in descending order.
  11 |     |  *
  12 |     |  * Nodes map to active Cdps in the system by Id.
  13 |     |  * Nodes are ordered according to their current nominal individual collateral ratio (NICR),
  14 |     |  * which is like the ICR but without the price, i.e., just collateral / debt.
  15 |     |  *
  16 |     |  * The list optionally accepts insert position hints.
  17 |     |  *
  18 |     |  * NICRs are computed dynamically at runtime, and not stored on the Node. This is because NICRs of active Cdps
  19 |     |  * change dynamically as liquidation events occur.
  20 |     |  *
  21 |     |  * The list relies on the fact that liquidation events preserve ordering: a liquidation decreases the NICRs of all active Cdps,
  22 |     |  * but maintains their order. A node inserted based on current NICR will maintain the correct position,
  23 |     |  * relative to it's peers, as rewards accumulate, as long as it's raw collateral and debt have not changed.
  24 |     |  * Thus, Nodes remain sorted by current NICR.
  25 |     |  *
  26 |     |  * Nodes need only be re-inserted upon a CDP operation - when the owner adds or removes collateral or debt
  27 |     |  * to their position.
  28 |     |  *
  29 |     |  * The list is a modification of the following audited SortedDoublyLinkedList:
  30 |     |  * https://github.com/livepeer/protocol/blob/master/contracts/libraries/SortedDoublyLL.sol
  31 |     |  *
  32 |     |  *
  33 |     |  * Changes made in the Liquity implementation:
  34 |     |  *
  35 |     |  * - Keys have been removed from nodes
  36 |     |  *
  37 |     |  * - Ordering checks for insertion are performed by comparing an NICR argument to the current NICR, calculated at runtime.
  38 |     |  *   The list relies on the property that ordering by ICR is maintained as the stETH:BTC price varies.
  39 |     |  *
  40 |     |  * - Public functions with parameters have been made internal to save gas, and given an external wrapper function for external access
  41 |     |  *
  42 |     |  *
  43 |     |  * Changes made in the Ebtc implementation:
  44 |     |  *
  45 |     |  * - Positions are now indexed by Ids, not addresses. Functions to generate Ids are provided.
  46 |     |  *
  47 |     |  * - Added batchRemove functions to optimize redemptions.
  48 |     |  *
  49 |     |  * - Added more O(n) getter functions and pagination-flavor variants, intended for off-chain use.
  50 |     |  */
  51 |     | contract SortedCdps is ISortedCdps {
  52 |     |     string public constant NAME = "SortedCdps";
  53 |     | 
  54 |     |     address public immutable borrowerOperationsAddress;
  55 |     | 
  56 |     |     ICdpManager public immutable cdpManager;
  57 |     | 
  58 |     |     uint256 public immutable maxSize;
  59 |     | 
  60 |     |     uint256 constant ADDRESS_SHIFT = 96; // 8 * 12; Puts the address at leftmost bytes32 position
  61 |     |     uint256 constant BLOCK_SHIFT = 64; // 8 * 8; Puts the block value after the address
  62 |     | 
  63 |     |     // Information for a node in the list
  64 |     |     struct Node {
  65 |     |         bytes32 nextId; // Id of next node (smaller NICR) in the list
  66 |     |         bytes32 prevId; // Id of previous node (larger NICR) in the list
  67 |     |     }
  68 |     | 
  69 |     |     // Information for the list
  70 |     |     struct Data {
  71 |     |         bytes32 head; // Head of the list. Also the node in the list with the largest NICR
  72 |     |         bytes32 tail; // Tail of the list. Also the node in the list with the smallest NICR
  73 |     |         mapping(bytes32 => Node) nodes; // Track the corresponding ids for each node in the list
  74 |     |     }
  75 |     | 
  76 |     |     uint256 public size; // Current size of the list
  77 |     | 
  78 |     |     Data public data;
  79 |     | 
  80 |     |     uint256 public nextCdpNonce;
  81 |     |     bytes32 public constant dummyId =
  82 |     |         0x0000000000000000000000000000000000000000000000000000000000000000;
  83 |     | 
  84 |     |     /// @notice Constructor
  85 |     |     /// @dev Sets max list size
  86 |     |     /// @param _size Max number of nodes allowed in the list
  87 |     |     /// @param _cdpManagerAddress Address of CdpManager contract
  88 |     |     /// @param _borrowerOperationsAddress Address of BorrowerOperations contract
  89 |     |     constructor(uint256 _size, address _cdpManagerAddress, address _borrowerOperationsAddress) {
  90 |     |         if (_size == 0) {
  91 |     |             _size = type(uint256).max;
  92 |     |         }
  93 |     | 
  94 |     |         maxSize = _size;
  95 |     | 
  96 |     |         cdpManager = ICdpManager(_cdpManagerAddress);
  97 |     |         borrowerOperationsAddress = _borrowerOperationsAddress;
  98 |     |     }
  99 |     | 
 100 |     |     /// @notice Encodes a unique CDP Id from owner, block and nonce
 101 |     |     /// @dev Inspired https://github.com/balancer-labs/balancer-v2-monorepo/blob/18bd5fb5d87b451cc27fbd30b276d1fb2987b529/pkg/vault/contracts/PoolRegistry.sol
 102 |     |     /// @param owner Owner address of the CDP
 103 |     |     /// @param blockHeight Block number when CDP opened
 104 |     |     /// @param nonce Unique nonce for CDP
 105 |     |     /// @return Unique bytes32 CDP Id
 106 |     |     function toCdpId(
 107 |     |         address owner,
 108 |     |         uint256 blockHeight,
 109 |     |         uint256 nonce
 110 |     |     ) public pure returns (bytes32) {
 111 |     |         bytes32 serialized;
 112 |     | 
 113 |     |         serialized |= bytes32(nonce);
 114 |     |         serialized |= bytes32(blockHeight) << BLOCK_SHIFT; // to accommendate more than 4.2 billion blocks
 115 |     |         serialized |= bytes32(uint256(uint160(owner))) << ADDRESS_SHIFT;
 116 |     | 
 117 |     |         return serialized;
 118 |     |     }
 119 |     | 
 120 |     |     /// @notice Get owner address of a given CDP, given CdpId.
 121 |     |     /// @dev The owner address is stored in the first 20 bytes of the CdpId
 122 |     |     /// @param cdpId cdpId of CDP to get owner of
 123 |     |     /// @return owner address of the CDP
 124 |     |     function getOwnerAddress(bytes32 cdpId) public pure override returns (address) {
 125 |     |         uint256 _tmp = uint256(cdpId) >> ADDRESS_SHIFT;
 126 |     |         return address(uint160(_tmp));
 127 |     |     }
 128 |     | 
 129 |     |     /// @notice Get dummy non-existent CDP Id
 130 |     |     /// @return Dummy non-existent CDP Id
 131 |     |     function nonExistId() public pure override returns (bytes32) {
 132 |     |         return dummyId;
 133 |     |     }
 134 |     | 
 135 |     |     /// @notice Find a specific CDP for a given owner, indexed by it's place in the linked list relative to other Cdps owned by the same address
 136 |     |     /// @notice Reverts if the index exceeds the number of active Cdps owned by the given owner
 137 |     |     /// @dev Intended for off-chain use, O(n) operation on size of SortedCdps linked list
 138 |     |     /// @param owner address of CDP owner
 139 |     |     /// @param index index of CDP, ordered by position in linked list relative to Cdps of the same owner
 140 |     |     /// @return CDP Id if found
 141 |     |     function cdpOfOwnerByIndex(
 142 |     |         address owner,
 143 |     |         uint256 index
 144 |     |     ) external view override returns (bytes32) {
 145 |     |         (bytes32 _cdpId, ) = _cdpOfOwnerByIndex(owner, index, dummyId, 0);
 146 |     |         return _cdpId;
 147 |     |     }
 148 |     | 
 149 |     |     /// @dev a pagination-flavor search (from least ICR to biggest ICR) for CDP owned by given owner and specified index (starting at given CDP)
 150 |     |     /// @param owner address of CDP owner
 151 |     |     /// @param index index of CDP, ordered by position in linked list relative to Cdps of the same owner
 152 |     |     /// @param startNodeId the seach traversal will start at this given CDP instead of the tail of the list
 153 |     |     /// @param maxNodes the traversal will go through the list by this given maximum limit of number of Cdps
 154 |     |     /// @return CDP Id if found, else return last seen CDP
 155 |     |     /// @return True if CDP found, false otherwise
 156 |     |     function cdpOfOwnerByIdx(
 157 |     |         address owner,
 158 |     |         uint256 index,
 159 |     |         bytes32 startNodeId,
 160 |     |         uint maxNodes
 161 |     |     ) external view override returns (bytes32, bool) {
 162 |     |         return _cdpOfOwnerByIndex(owner, index, startNodeId, maxNodes);
 163 |     |     }
 164 |     | 
 165 |     |     /// @notice Get a user CDP by index using pagination
 166 |     |     /// @dev return EITHER the found CDP owned by given owner & index with a true indicator OR
 167 |     |     /// @dev current lastly-visited CDP as the startNode for next pagination with a false indicator
 168 |     |     /// @param owner Owner address to get CDP for
 169 |     |     /// @param index Index of CDP amongst user's Cdps
 170 |     |     /// @param startNodeId Start position CDP Id
 171 |     |     /// @param maxNodes Max number of Cdps to traverse
 172 |     |     /// @return cdpId The CDP Id if found, otherwise return current lastly-visited CDP as the startNode for next pagination
 173 |     |     /// @return found True if the CDP was found, false otherwise
 174 |     |     function _cdpOfOwnerByIndex(
 175 |     |         address owner,
 176 |     |         uint256 index,
 177 |     |         bytes32 startNodeId,
 178 |     |         uint maxNodes
 179 |     |     ) internal view returns (bytes32, bool) {
 180 |     |         // walk the list, until we get to the indexed CDP
 181 |     |         // start at the given node or from the tail of list
 182 |     |         bytes32 _currentCdpId = (startNodeId == dummyId ? data.tail : startNodeId);
 183 |     |         uint _currentIndex = 0;
 184 |     |         uint i;
 185 |     | 
 186 |     |         while (_currentCdpId != dummyId) {
 187 |     |             // if the current CDP is owned by specified owner
 188 |     |             if (getOwnerAddress(_currentCdpId) == owner) {
 189 |     |                 // if the current index of the owner CDP matches specified index
 190 |     |                 if (_currentIndex == index) {
 191 |     |                     return (_currentCdpId, true);
 192 |     |                 } else {
 193 |     |                     // if not, increment the owner index as we've seen a CDP owned by them
 194 |     |                     _currentIndex = _currentIndex + 1;
 195 |     |                 }
 196 |     |             }
 197 |     |             ++i;
 198 |     | 
 199 |     |             // move to the next CDP in the list
 200 |     |             _currentCdpId = data.nodes[_currentCdpId].prevId;
 201 |     | 
 202 |     |             // cut the run if we exceed expected iterations through the loop
 203 |     |             if (maxNodes > 0 && i >= maxNodes) {
 204 |     |                 break;
 205 |     |             }
 206 |     |         }
 207 |     |         // if we reach maximum iteration or end of list
 208 |     |         // without seeing the specified index for the owner
 209 |     |         // then maybe a new pagination is needed
 210 |     |         return (_currentCdpId, false);
 211 |     |     }
 212 |     | 
 213 |     |     /// @notice Get active CDP count for an owner address
 214 |     |     /// @dev Intended for off-chain use, O(n) operation on size of linked list
 215 |     |     /// @param owner Owner address to count Cdps for
 216 |     |     /// @return count Number of active Cdps owned by the address
 217 |     |     function cdpCountOf(address owner) external view override returns (uint256) {
 218 |     |         (uint256 _cnt, ) = _cdpCountOf(owner, dummyId, 0);
 219 |     |         return _cnt;
 220 |     |     }
 221 |     | 
 222 |     |     /// @notice a Pagination-flavor search for the count of Cdps owned by given owner
 223 |     |     /// @notice Starts from a given CdpId in the sorted list, and moves from lowest ICR to highest ICR
 224 |     |     /// @param startNodeId the count traversal will start at this given CDP instead of the tail of the list
 225 |     |     /// @param maxNodes the traversal will go through the list by this given maximum limit of number of Cdps
 226 |     |     /// @return count Number of active Cdps owned by the address in the segment of the list traversed
 227 |     |     /// @return last seen CDP for the startNode for next pagination
 228 |     |     function getCdpCountOf(
 229 |     |         address owner,
 230 |     |         bytes32 startNodeId,
 231 |     |         uint maxNodes
 232 |     |     ) external view override returns (uint256, bytes32) {
 233 |     |         return _cdpCountOf(owner, startNodeId, maxNodes);
 234 |     |     }
 235 |     | 
 236 |     |     /// @dev return the found CDP count owned by given owner with
 237 |     |     /// @dev current lastly-visited CDP as the startNode for next pagination
 238 |     |     function _cdpCountOf(
 239 |     |         address owner,
 240 |     |         bytes32 startNodeId,
 241 |     |         uint maxNodes
 242 |     |     ) internal view returns (uint256, bytes32) {
 243 |     |         // walk the list, until we get to the count
 244 |     |         // start at the given node or from the tail of list
 245 |     |         bytes32 _currentCdpId = (startNodeId == dummyId ? data.tail : startNodeId);
 246 |     |         uint _ownedCount = 0;
 247 |     |         uint i = 0;
 248 |     | 
 249 |     |         while (_currentCdpId != dummyId) {
 250 |     |             // if the current CDP is owned by specified owner
 251 |     |             if (getOwnerAddress(_currentCdpId) == owner) {
 252 |     |                 _ownedCount = _ownedCount + 1;
 253 |     |             }
 254 |     |             ++i;
 255 |     | 
 256 |     |             // move to the next CDP in the list
 257 |     |             _currentCdpId = data.nodes[_currentCdpId].prevId;
 258 |     | 
 259 |     |             // cut the run if we exceed expected iterations through the loop
 260 |     |             if (maxNodes > 0 && i >= maxNodes) {
 261 |     |                 break;
 262 |     |             }
 263 |     |         }
 264 |     |         return (_ownedCount, _currentCdpId);
 265 |     |     }
 266 |     | 
 267 |     |     /// @notice Get all active Cdps for a given address
 268 |     |     /// @dev Intended for off-chain use, O(n) operation on size of linked list
 269 |     |     /// @param owner address of CDP owner
 270 |     |     /// @return cdps all CdpIds of the specified owner
 271 |     |     function getCdpsOf(address owner) external view override returns (bytes32[] memory cdps) {
 272 |     |         // Naive method uses two-pass strategy to determine exactly how many Cdps are owned by owner
 273 |     |         // This roughly halves the amount of Cdps we can process before relying on pagination or off-chain methods
 274 |     |         (uint _ownedCount, ) = _cdpCountOf(owner, dummyId, 0);
 275 |     |         if (_ownedCount > 0) {
 276 |     |             (bytes32[] memory _allCdps, , ) = _getCdpsOf(owner, dummyId, 0, _ownedCount);
 277 |     |             cdps = _allCdps;
 278 |     |         }
 279 |     |     }
 280 |     | 
 281 |     |     /// @dev a pagination-flavor search retrieval of (from least ICR to biggest ICR) Cdps owned by given owner (starting at given CDP)
 282 |     |     /// @param startNodeId the traversal will start at this given CDP instead of the tail of the list
 283 |     |     /// @param maxNodes the traversal will go through the list by this given maximum limit of number of Cdps
 284 |     |     /// @return all CdpIds of the specified owner found by search starting at the specified startNodeId for the specified maximum iteration count
 285 |     |     /// @return found number of Cdp for the owner
 286 |     |     /// @return starting CdpId for next pagination within current SortedCdps
 287 |     |     function getAllCdpsOf(
 288 |     |         address owner,
 289 |     |         bytes32 startNodeId,
 290 |     |         uint maxNodes
 291 |     |     ) external view override returns (bytes32[] memory, uint256, bytes32) {
 292 |     |         // Naive method uses two-pass strategy to determine exactly how many Cdps are owned by owner
 293 |     |         // This roughly halves the amount of Cdps we can process before relying on pagination or off-chain methods
 294 |     |         (uint _ownedCount, ) = _cdpCountOf(owner, startNodeId, maxNodes);
 295 |     |         return _getCdpsOf(owner, startNodeId, maxNodes, _ownedCount);
 296 |     |     }
 297 |     | 
 298 |     |     /// @dev return EITHER the found Cdps (also the count) owned by given owner OR empty array with
 299 |     |     /// @dev current lastly-visited CDP as the startNode for next pagination
 300 |     |     function _getCdpsOf(
 301 |     |         address owner,
 302 |     |         bytes32 startNodeId,
 303 |     |         uint maxNodes,
 304 |     |         uint maxArraySize
 305 |     |     ) internal view returns (bytes32[] memory, uint256, bytes32) {
 306 |     |         if (maxArraySize == 0) {
 307 |     |             return (new bytes32[](0), 0, dummyId);
 308 |     |         }
 309 |     | 
 310 |     |         // Two-pass strategy, halving the amount of Cdps we can process before relying on pagination or off-chain methods
 311 |     |         bytes32[] memory userCdps = new bytes32[](maxArraySize);
 312 |     |         uint i = 0;
 313 |     |         uint _cdpRetrieved;
 314 |     | 
 315 |     |         // walk the list, until we get to the index
 316 |     |         // start at the given node or from the tail of list
 317 |     |         bytes32 _currentCdpId = (startNodeId == dummyId ? data.tail : startNodeId);
 318 |     | 
 319 |     |         while (_currentCdpId != dummyId) {
 320 |     |             // if the current CDP is owned by specified owner
 321 |     |             if (getOwnerAddress(_currentCdpId) == owner) {
 322 |     |                 userCdps[_cdpRetrieved] = _currentCdpId;
 323 |     |                 ++_cdpRetrieved;
 324 |     |             }
 325 |     |             ++i;
 326 |     | 
 327 |     |             // move to the next CDP in the list
 328 |     |             _currentCdpId = data.nodes[_currentCdpId].prevId;
 329 |     | 
 330 |     |             // cut the run if we exceed expected iterations through the loop
 331 |     |             if (maxNodes > 0 && i >= maxNodes) {
 332 |     |                 break;
 333 |     |             }
 334 |     |         }
 335 |     | 
 336 |     |         return (userCdps, _cdpRetrieved, _currentCdpId);
 337 |     |     }
 338 |     | 
 339 |     |     /// @notice Add a node to the list
 340 |     |     /// @param owner CDP owner for corresponding Id
 341 |     |     /// @param _NICR Node's NICR
 342 |     |     /// @param _prevId Id of previous node for the insert position
 343 |     |     /// @param _nextId Id of next node for the insert position
 344 |     |     /// @return _id Id of the new node
 345 |     |     function insert(
 346 |     |         address owner,
 347 |     |         uint256 _NICR,
 348 |     |         bytes32 _prevId,
 349 |     |         bytes32 _nextId
 350 |     |     ) external override returns (bytes32) {
 351 |     |         _requireCallerIsBOorCdpM();
 352 |     |         bytes32 _id = toCdpId(owner, block.number, nextCdpNonce);
 353 |     |         require(cdpManager.getCdpStatus(_id) == 0, "SortedCdps: new id is NOT nonExistent!");
 354 |     | 
 355 |     |         _insert(_id, _NICR, _prevId, _nextId);
 356 |     | 
 357 |     |         unchecked {
 358 |     |             ++nextCdpNonce;
 359 |     |         }
 360 |     | 
 361 |     |         return _id;
 362 |     |     }
 363 |     | 
 364 |     |     function _insert(bytes32 _id, uint256 _NICR, bytes32 _prevId, bytes32 _nextId) internal {
 365 |     |         // List must not be full
 366 |     |         require(!isFull(), "SortedCdps: List is full");
 367 |     |         // List must not already contain node
 368 |     |         require(!contains(_id), "SortedCdps: List already contains the node");
 369 |     |         // Node id must not be null
 370 |     |         require(_id != dummyId, "SortedCdps: Id cannot be zero");
 371 |     |         // NICR must be non-zero
 372 |     |         require(_NICR > 0, "SortedCdps: NICR must be positive");
 373 |     | 
 374 |     |         bytes32 prevId = _prevId;
 375 |     |         bytes32 nextId = _nextId;
 376 |     | 
 377 |     |         if (!_validInsertPosition(_NICR, prevId, nextId)) {
 378 |     |             // Sender's hint was not a valid insert position
 379 |     |             // Use sender's hint to find a valid insert position
 380 |     |             (prevId, nextId) = _findInsertPosition(_NICR, prevId, nextId);
 381 |     |         }
 382 |     | 
 383 |     |         if (prevId == dummyId && nextId == dummyId) {
 384 |     |             // Insert as head and tail
 385 |     |             data.head = _id;
 386 |     |             data.tail = _id;
 387 |     |         } else if (prevId == dummyId) {
 388 |     |             // Insert before `prevId` as the head
 389 |     |             data.nodes[_id].nextId = data.head;
 390 |     |             data.nodes[data.head].prevId = _id;
 391 |     |             data.head = _id;
 392 |     |         } else if (nextId == dummyId) {
 393 |     |             // Insert after `nextId` as the tail
 394 |     |             data.nodes[_id].prevId = data.tail;
 395 |     |             data.nodes[data.tail].nextId = _id;
 396 |     |             data.tail = _id;
 397 |     |         } else {
 398 |     |             // Insert at insert position between `prevId` and `nextId`
 399 |     |             data.nodes[_id].nextId = nextId;
 400 |     |             data.nodes[_id].prevId = prevId;
 401 |     |             data.nodes[prevId].nextId = _id;
 402 |     |             data.nodes[nextId].prevId = _id;
 403 |     |         }
 404 |     | 
 405 |     |         size = size + 1;
 406 |     |         emit NodeAdded(_id, _NICR);
 407 |     |     }
 408 |     | 
 409 |     |     /// @notice Remove a node from the sorted list, by Id
 410 |     |     /// @param _id The CdpId to be removed
 411 |     |     function remove(bytes32 _id) external override {
 412 |     |         _requireCallerIsCdpManager();
 413 |     |         _remove(_id);
 414 |     |     }
 415 |     | 
 416 |     |     /// @notice Batch a node from the sorted list, by Id
 417 |     |     /// @notice Strong trust assumption that the specified nodes are sorted in the same order as in the input array
 418 |     |     /// @dev Optimization to reduce gas cost for removing multiple nodes on redemption
 419 |     |     /// @param _ids Array of CdpIds to remove
 420 |     |     function batchRemove(bytes32[] memory _ids) external override {
 421 |     |         _requireCallerIsCdpManager();
 422 |     |         uint256 _len = _ids.length;
 423 |     |         require(_len > 1, "SortedCdps: batchRemove() only apply to multiple cdpIds!");
 424 |     | 
 425 |     |         bytes32 _firstPrev = data.nodes[_ids[0]].prevId;
 426 |     |         bytes32 _lastNext = data.nodes[_ids[_len - 1]].nextId;
 427 |     | 
 428 |     |         require(
 429 |     |             _firstPrev != dummyId || _lastNext != dummyId,
 430 |     |             "SortedCdps: batchRemove() leave ZERO node left!"
 431 |     |         );
 432 |     | 
 433 |     |         for (uint256 i = 0; i < _len; ++i) {
 434 |     |             require(contains(_ids[i]), "SortedCdps: List does not contain the id");
 435 |     |         }
 436 |     | 
 437 |     |         // orphan nodes in between to save gas
 438 |     |         if (_firstPrev != dummyId) {
 439 |     |             data.nodes[_firstPrev].nextId = _lastNext;
 440 |     |         } else {
 441 |     |             data.head = _lastNext;
 442 |     |         }
 443 |     |         if (_lastNext != dummyId) {
 444 |     |             data.nodes[_lastNext].prevId = _firstPrev;
 445 |     |         } else {
 446 |     |             data.tail = _firstPrev;
 447 |     |         }
 448 |     | 
 449 |     |         // delete node & owner storages to get gas refund
 450 |     |         for (uint i = 0; i < _len; ++i) {
 451 |     |             delete data.nodes[_ids[i]];
 452 |     |             emit NodeRemoved(_ids[i]);
 453 |     |         }
 454 |     |         size = size - _len;
 455 |     |     }
 456 |     | 
 457 |     |     function _remove(bytes32 _id) internal {
 458 |     |         // List must contain the node
 459 |     |         require(contains(_id), "SortedCdps: List does not contain the id");
 460 |     | 
 461 |     |         if (size > 1) {
 462 |     |             // List contains more than a single node
 463 |     |             if (_id == data.head) {
 464 |     |                 // The removed node is the head
 465 |     |                 // Set head to next node
 466 |     |                 data.head = data.nodes[_id].nextId;
 467 |     |                 // Set prev pointer of new head to null
 468 |     |                 data.nodes[data.head].prevId = dummyId;
 469 |     |             } else if (_id == data.tail) {
 470 |     |                 // The removed node is the tail
 471 |     |                 // Set tail to previous node
 472 |     |                 data.tail = data.nodes[_id].prevId;
 473 |     |                 // Set next pointer of new tail to null
 474 |     |                 data.nodes[data.tail].nextId = dummyId;
 475 |     |             } else {
 476 |     |                 // The removed node is neither the head nor the tail
 477 |     |                 // Set next pointer of previous node to the next node
 478 |     |                 data.nodes[data.nodes[_id].prevId].nextId = data.nodes[_id].nextId;
 479 |     |                 // Set prev pointer of next node to the previous node
 480 |     |                 data.nodes[data.nodes[_id].nextId].prevId = data.nodes[_id].prevId;
 481 |     |             }
 482 |     |         } else {
 483 |     |             // List contains a single node
 484 |     |             // Set the head and tail to null
 485 |     |             data.head = dummyId;
 486 |     |             data.tail = dummyId;
 487 |     |         }
 488 |     | 
 489 |     |         delete data.nodes[_id];
 490 |     |         size = size - 1;
 491 |     |         emit NodeRemoved(_id);
 492 |     |     }
 493 |     | 
 494 |     |     /// @notice Re-insert an existing node at a new position, based on its new NICR
 495 |     |     /// @param _id Node's id
 496 |     |     /// @param _newNICR Node's new NICR
 497 |     |     /// @param _prevId Id of previous node for the new insert position
 498 |     |     /// @param _nextId Id of next node for the new insert position
 499 |     |     function reInsert(
 500 |     |         bytes32 _id,
 501 |     |         uint256 _newNICR,
 502 |     |         bytes32 _prevId,
 503 |     |         bytes32 _nextId
 504 |     |     ) external override {
 505 |     |         _requireCallerIsBOorCdpM();
 506 |     |         // List must contain the node
 507 |     |         require(contains(_id), "SortedCdps: List does not contain the id");
 508 |     |         // NICR must be non-zero
 509 |     |         require(_newNICR > 0, "SortedCdps: NICR must be positive");
 510 |     | 
 511 |     |         // Remove node from the list
 512 |     |         _remove(_id);
 513 |     | 
 514 |     |         _insert(_id, _newNICR, _prevId, _nextId);
 515 |     |     }
 516 |     | 
 517 |     |     /// @dev Checks if the list contains a given node Id
 518 |     |     /// @param _id The Id of the node
 519 |     |     /// @return true if the node exists, false otherwise
 520 |     |     function contains(bytes32 _id) public view override returns (bool) {
 521 |     |         bool _exist = _id != dummyId && (data.head == _id || data.tail == _id);
 522 |     |         if (!_exist) {
 523 |     |             Node memory _node = data.nodes[_id];
 524 |     |             _exist = _id != dummyId && (_node.nextId != dummyId && _node.prevId != dummyId);
 525 |     |         }
 526 |     |         return _exist;
 527 |     |     }
 528 |     | 
 529 |     |     /// @dev Checks if the list is full
 530 |     |     /// @return true if the list is full, false otherwise
 531 |     |     function isFull() public view override returns (bool) {
 532 |     |         return size == maxSize;
 533 |     |     }
 534 |     | 
 535 |     |     /// @dev Checks if the list is empty
 536 |     |     /// @return true if the list is empty, false otherwise
 537 |     |     function isEmpty() public view override returns (bool) {
 538 |     |         return size == 0;
 539 |     |     }
 540 |     | 
 541 |     |     /// @dev Returns the current size of the list
 542 |     |     /// @return The current size of the list
 543 |     |     function getSize() external view override returns (uint256) {
 544 |     |         return size;
 545 |     |     }
 546 |     | 
 547 |     |     /// @dev Returns the maximum size of the list
 548 |     |     /// @return The maximum size of the list
 549 |     |     function getMaxSize() external view override returns (uint256) {
 550 |     |         return maxSize;
 551 |     |     }
 552 |     | 
 553 |     |     /// @dev Returns the first node in the list (node with the largest NICR)
 554 |     |     /// @return The Id of the first node
 555 |     |     function getFirst() external view override returns (bytes32) {
 556 |     |         return data.head;
 557 |     |     }
 558 |     | 
 559 |     |     /// @dev Returns the last node in the list (node with the smallest NICR)
 560 |     |     /// @return The Id of the last node
 561 |     |     function getLast() external view override returns (bytes32) {
 562 |     |         return data.tail;
 563 |     |     }
 564 |     | 
 565 |     |     /// @dev Returns the next node (with a smaller NICR) in the list for a given node
 566 |     |     /// @param _id The Id of the node
 567 |     |     /// @return The Id of the next node
 568 |     |     function getNext(bytes32 _id) external view override returns (bytes32) {
 569 |     |         return data.nodes[_id].nextId;
 570 |     |     }
 571 |     | 
 572 |     |     /// @dev Returns the previous node (with a larger NICR) in the list for a given node
 573 |     |     /// @param _id The Id of the node
 574 |     |     /// @return The Id of the previous node
 575 |     |     function getPrev(bytes32 _id) external view override returns (bytes32) {
 576 |     |         return data.nodes[_id].prevId;
 577 |     |     }
 578 |     | 
 579 |     |     /// @dev Check if a pair of nodes is a valid insertion point for a new node with the given NICR
 580 |     |     /// @param _NICR Node's NICR
 581 |     |     /// @param _prevId Id of previous node for the insert position
 582 |     |     /// @param _nextId Id of next node for the insert position
 583 |     |     /// @return true if the position is valid, false otherwise
 584 |     |     function validInsertPosition(
 585 |     |         uint256 _NICR,
 586 |     |         bytes32 _prevId,
 587 |     |         bytes32 _nextId
 588 |     |     ) external view override returns (bool) {
 589 |     |         return _validInsertPosition(_NICR, _prevId, _nextId);
 590 |     |     }
 591 |     | 
 592 |     |     function _validInsertPosition(
 593 |     |         uint256 _NICR,
 594 |     |         bytes32 _prevId,
 595 |     |         bytes32 _nextId
 596 |     |     ) internal view returns (bool) {
 597 |     |         if (_prevId == dummyId && _nextId == dummyId) {
 598 |     |             // `(null, null)` is a valid insert position if the list is empty
 599 |     |             return isEmpty();
 600 |     |         } else if (_prevId == dummyId) {
 601 |     |             // `(null, _nextId)` is a valid insert position if `_nextId` is the head of the list
 602 |     |             return data.head == _nextId && _NICR >= cdpManager.getCachedNominalICR(_nextId);
 603 |     |         } else if (_nextId == dummyId) {
 604 |     |             // `(_prevId, null)` is a valid insert position if `_prevId` is the tail of the list
 605 |     |             return data.tail == _prevId && _NICR <= cdpManager.getCachedNominalICR(_prevId);
 606 |     |         } else {
 607 |     |             // `(_prevId, _nextId)` is a valid insert position if they are adjacent nodes and `_NICR` falls between the two nodes' NICRs
 608 |     |             return
 609 |     |                 data.nodes[_prevId].nextId == _nextId &&
 610 |     |                 cdpManager.getCachedNominalICR(_prevId) >= _NICR &&
 611 |     |                 _NICR >= cdpManager.getCachedNominalICR(_nextId);
 612 |     |         }
 613 |     |     }
 614 |     | 
 615 |     |     /// @dev Descend the list (larger NICRs to smaller NICRs) to find a valid insert position
 616 |     |     /// @param _NICR Node's NICR
 617 |     |     /// @param _startId Id of node to start descending the list from
 618 |     |     /// @return The previous node Id for the inserted node
 619 |     |     /// @return The next node Id for the inserted node
 620 |     |     function _descendList(uint256 _NICR, bytes32 _startId) internal view returns (bytes32, bytes32) {
 621 |     |         // If `_startId` is the head, check if the insert position is before the head
 622 |     |         if (data.head == _startId && _NICR >= cdpManager.getCachedNominalICR(_startId)) {
 623 |     |             return (dummyId, _startId);
 624 |     |         }
 625 |     | 
 626 |     |         bytes32 prevId = _startId;
 627 |     |         bytes32 nextId = data.nodes[prevId].nextId;
 628 |     | 
 629 |     |         // Descend the list until we reach the end or until we find a valid insert position
 630 |     |         while (prevId != dummyId && !_validInsertPosition(_NICR, prevId, nextId)) {
 631 |     |             prevId = data.nodes[prevId].nextId;
 632 |     |             nextId = data.nodes[prevId].nextId;
 633 |     |         }
 634 |     | 
 635 |     |         return (prevId, nextId);
 636 |     |     }
 637 |     | 
 638 |     |     /// @dev Ascend the list (smaller NICRs to larger NICRs) to find a valid insert position
 639 |     |     /// @param _NICR Node's NICR
 640 |     |     /// @param _startId Id of node to start ascending the list from
 641 |     |     /// @return The previous node Id for the inserted node
 642 |     |     /// @return The next node Id for the inserted node
 643 |     |     function _ascendList(uint256 _NICR, bytes32 _startId) internal view returns (bytes32, bytes32) {
 644 |     |         // If `_startId` is the tail, check if the insert position is after the tail
 645 |     |         if (data.tail == _startId && _NICR <= cdpManager.getCachedNominalICR(_startId)) {
 646 |     |             return (_startId, dummyId);
 647 |     |         }
 648 |     | 
 649 |     |         bytes32 nextId = _startId;
 650 |     |         bytes32 prevId = data.nodes[nextId].prevId;
 651 |     | 
 652 |     |         // Ascend the list until we reach the end or until we find a valid insertion point
 653 |     |         while (nextId != dummyId && !_validInsertPosition(_NICR, prevId, nextId)) {
 654 |     |             nextId = data.nodes[nextId].prevId;
 655 |     |             prevId = data.nodes[nextId].prevId;
 656 |     |         }
 657 |     | 
 658 |     |         return (prevId, nextId);
 659 |     |     }
 660 |     | 
 661 |     |     /// @dev Find the insert position for a node with the given NICR
 662 |     |     /// @param _NICR Node's NICR
 663 |     |     /// @param _prevId Id of previous node for the insert position
 664 |     |     /// @param _nextId Id of next node for the insert position
 665 |     |     /// @return The previous node Id for the inserted node
 666 |     |     /// @return The next node Id for the inserted node
 667 |     |     function findInsertPosition(
 668 |     |         uint256 _NICR,
 669 |     |         bytes32 _prevId,
 670 |     |         bytes32 _nextId
 671 |     |     ) external view override returns (bytes32, bytes32) {
 672 |     |         return _findInsertPosition(_NICR, _prevId, _nextId);
 673 |     |     }
 674 |     | 
 675 |     |     function _findInsertPosition(
 676 |     |         uint256 _NICR,
 677 |     |         bytes32 _prevId,
 678 |     |         bytes32 _nextId
 679 |     |     ) internal view returns (bytes32, bytes32) {
 680 |     |         bytes32 prevId = _prevId;
 681 |     |         bytes32 nextId = _nextId;
 682 |     | 
 683 |     |         if (prevId != dummyId) {
 684 |     |             if (!contains(prevId) || _NICR > cdpManager.getCachedNominalICR(prevId)) {
 685 |     |                 // `prevId` does not exist anymore or now has a smaller NICR than the given NICR
 686 |     |                 prevId = dummyId;
 687 |     |             }
 688 |     |         }
 689 |     | 
 690 |     |         if (nextId != dummyId) {
 691 |     |             if (!contains(nextId) || _NICR < cdpManager.getCachedNominalICR(nextId)) {
 692 |     |                 // `nextId` does not exist anymore or now has a larger NICR than the given NICR
 693 |     |                 nextId = dummyId;
 694 |     |             }
 695 |     |         }
 696 |     | 
 697 |     |         if (prevId == dummyId && nextId == dummyId) {
 698 |     |             // No hint - descend list starting from head
 699 |     |             return _descendList(_NICR, data.head);
 700 |     |         } else if (prevId == dummyId) {
 701 |     |             // No `prevId` for hint - ascend list starting from `nextId`
 702 |     |             return _ascendList(_NICR, nextId);
 703 |     |         } else if (nextId == dummyId) {
 704 |     |             // No `nextId` for hint - descend list starting from `prevId`
 705 |     |             return _descendList(_NICR, prevId);
 706 |     |         } else {
 707 |     |             // Descend list starting from `prevId`
 708 |     |             return _descendList(_NICR, prevId);
 709 |     |         }
 710 |     |     }
 711 |     | 
 712 |     |     // === Modifiers ===
 713 |     | 
 714 |     |     /// @dev Asserts that the caller of the function is the CdpManager
 715 |     |     function _requireCallerIsCdpManager() internal view {
 716 |     |         require(msg.sender == address(cdpManager), "SortedCdps: Caller is not the CdpManager");
 717 |     |     }
 718 |     | 
 719 |     |     /// @dev Asserts that the caller of the function is either the BorrowerOperations contract or the CdpManager
 720 |     |     function _requireCallerIsBOorCdpM() internal view {
 721 |     |         require(
 722 |     |             msg.sender == borrowerOperationsAddress || msg.sender == address(cdpManager),
 723 |     |             "SortedCdps: Caller is neither BO nor CdpM"
 724 |     |         );
 725 |     |     }
 726 |     | }
 727 |     | 

/mnt/c/Users/Lourens/Documents/Recon-Fuzz/collabs/ebtc/packages/contracts/contracts/SyncedLiquidationSequencer.sol
   1 |     | // SPDX-License-Identifier: MIT
   2 |     | 
   3 |     | pragma solidity 0.8.17;
   4 |     | 
   5 |     | import "./Interfaces/IPriceFeed.sol";
   6 |     | import "./Interfaces/ICdpManager.sol";
   7 |     | import "./Interfaces/ISortedCdps.sol";
   8 |     | import "./Interfaces/ICdpManagerData.sol";
   9 |     | import "./Dependencies/EbtcBase.sol";
  10 |     | 
  11 |     | /// @notice Helper to turn a sequence into CDP id array for batch liquidation
  12 |     | contract SyncedLiquidationSequencer is EbtcBase {
  13 |     |     ICdpManager public immutable cdpManager;
  14 |     |     ISortedCdps public immutable sortedCdps;
  15 |     | 
  16 |     |     /// @param _cdpManagerAddress Address of CdpManager contract
  17 |     |     /// @param _sortedCdpsAddress Address of SortedCdps contract
  18 |     |     /// @param _priceFeedAddress Address of price feed
  19 |     |     /// @param _activePoolAddress Address of ActivePool
  20 |     |     /// @param _collateralAddress Address of collateral contract
  21 |     |     constructor(
  22 |     |         address _cdpManagerAddress,
  23 |     |         address _sortedCdpsAddress,
  24 |     |         address _priceFeedAddress,
  25 |     |         address _activePoolAddress,
  26 |     |         address _collateralAddress
  27 |     |     ) EbtcBase(_activePoolAddress, _priceFeedAddress, _collateralAddress) {
  28 |     |         cdpManager = ICdpManager(_cdpManagerAddress);
  29 |     |         sortedCdps = ISortedCdps(_sortedCdpsAddress);
  30 |     |     }
  31 |     | 
  32 |     |     /// @notice Get first N batch of liquidatable Cdps at current price, starting at lowest ICR
  33 |     |     /// @dev Non-view function that updates and returns live price at execution time
  34 |     |     /// @param _n Number of Cdps to retrieve
  35 |     |     /// @return _array Array of CDP IDs to batch liquidate
  36 |     |     function sequenceLiqToBatchLiq(uint256 _n) external returns (bytes32[] memory _array) {
  37 |     |         uint256 _price = priceFeed.fetchPrice();
  38 |     |         return sequenceLiqToBatchLiqWithPrice(_n, _price);
  39 |     |     }
  40 |     | 
  41 |     |     /// @notice Get first N batch of liquidatable Cdps at specified price, starting at lowest ICR
  42 |     |     /// @param _n Number of Cdps to retrieve
  43 |     |     /// @param _price stETH/BTC price
  44 |     |     /// @return _array Array of CDP IDs
  45 |     |     function sequenceLiqToBatchLiqWithPrice(
  46 |     |         uint256 _n,
  47 |     |         uint256 _price
  48 |     |     ) public view returns (bytes32[] memory _array) {
  49 |     |         (uint256 _TCR, , ) = _getTCRWithSystemDebtAndCollShares(_price);
  50 |     |         bool _recoveryModeAtStart = _TCR < CCR ? true : false;
  51 |     |         return _sequenceLiqToBatchLiq(_n, _recoveryModeAtStart, _price);
  52 |     |     }
  53 |     | 
  54 |     |     /// @notice Returns array of liquidatable CDP ids
  55 |     |     /// @param _n Number of Cdps to retrieve
  56 |     |     /// @param _recoveryModeAtStart Initial recovery mode state
  57 |     |     /// @param _price stETH/BTC price
  58 |     |     /// @return _array Array of CDP IDs for batch liquidation (in NICR-decreasing order, same as SortedCdps)
  59 |     |     function _sequenceLiqToBatchLiq(
  60 |     |         uint256 _n,
  61 |     |         bool _recoveryModeAtStart,
  62 |     |         uint256 _price
  63 |     |     ) internal view returns (bytes32[] memory _array) {
  64 |     |         if (_n > 0) {
  65 |     |             bytes32 _last = sortedCdps.getLast();
  66 |     |             bytes32 _first = sortedCdps.getFirst();
  67 |     |             bytes32 _cdpId = _last;
  68 |     | 
  69 |     |             uint256 _TCR = cdpManager.getSyncedTCR(_price);
  70 |     | 
  71 |     |             // get count of liquidatable Cdps
  72 |     |             uint256 _cnt;
  73 |     |             for (uint256 i = 0; i < _n && _cdpId != _first; ++i) {
  74 |     |                 uint256 _icr = cdpManager.getSyncedICR(_cdpId, _price); /// @audit This is view ICR and not real ICR
  75 |     |                 uint256 _cdpStatus = cdpManager.getCdpStatus(_cdpId);
  76 |     |                 bool _liquidatable = _canLiquidateInCurrentMode(_recoveryModeAtStart, _icr, _TCR);
  77 |     |                 if (_liquidatable && _cdpStatus == 1) {
  78 |     |                     _cnt += 1;
  79 |     |                 }
  80 |     |                 _cdpId = sortedCdps.getPrev(_cdpId);
  81 |     |             }
  82 |     | 
  83 |     |             // retrieve liquidatable Cdps
  84 |     |             _array = new bytes32[](_cnt);
  85 |     |             _cdpId = _last;
  86 |     |             uint256 _j;
  87 |     |             for (uint256 i = 0; i < _n && _cdpId != _first; ++i) {
  88 |     |                 uint256 _icr = cdpManager.getSyncedICR(_cdpId, _price);
  89 |     |                 uint256 _cdpStatus = cdpManager.getCdpStatus(_cdpId);
  90 |     |                 bool _liquidatable = _canLiquidateInCurrentMode(_recoveryModeAtStart, _icr, _TCR);
  91 |     |                 if (_liquidatable && _cdpStatus == 1) {
  92 |     |                     // 1 = ICdpManagerData.Status.active
  93 |     |                     _array[_cnt - _j - 1] = _cdpId;
  94 |     |                     _j += 1;
  95 |     |                 }
  96 |     |                 _cdpId = sortedCdps.getPrev(_cdpId);
  97 |     |             }
  98 |     |             require(_j == _cnt, "LiquidationLibrary: wrong sequence conversion!");
  99 |     |         }
 100 |     |     }
 101 |     | 
 102 |     |     /// @notice Internal helper function to check if given ICR value can be liquidated in current mode
 103 |     |     /// @dev Assumes correct input values
 104 |     |     /// @param _recovery Current recovery mode state
 105 |     |     /// @param _icr CDP's current ICR
 106 |     |     /// @param _TCR Current total system collateralization ratio
 107 |     |     /// @return True if liquidatable
 108 |     |     function _canLiquidateInCurrentMode(
 109 |     |         bool _recovery,
 110 |     |         uint256 _icr,
 111 |     |         uint256 _TCR
 112 |     |     ) internal view returns (bool) {
 113 |     |         bool _liquidatable = _recovery ? (_icr < MCR || _icr <= _TCR) : _icr < MCR;
 114 |     | 
 115 |     |         return _liquidatable;
 116 |     |     }
 117 |     | }
 118 |     | 

/mnt/c/Users/Lourens/Documents/Recon-Fuzz/collabs/ebtc/packages/contracts/contracts/TestContracts/AccruableCdpManager.sol
  1 |     | // SPDX-License-Identifier: MIT
  2 |     | 
  3 |     | pragma solidity 0.8.17;
  4 |     | 
  5 |     | import "../CdpManager.sol";
  6 |     | 
  7 |     | contract AccruableCdpManager is CdpManager {
  8 |     |     constructor(
  9 |     |         address _liquidationLibraryAddress,
 10 |     |         address _authorityAddress,
 11 |     |         address _borrowerOperationsAddress,
 12 |     |         address _collSurplusPoolAddress,
 13 |     |         address _ebtcTokenAddress,
 14 |     |         address _sortedCdpsAddress,
 15 |     |         address _activePoolAddress,
 16 |     |         address _priceFeedAddress,
 17 |     |         address _collTokenAddress
 18 |     |     )
 19 |     |         CdpManager(
 20 |     |             _liquidationLibraryAddress,
 21 |     |             _authorityAddress,
 22 |     |             _borrowerOperationsAddress,
 23 |     |             _collSurplusPoolAddress,
 24 |     |             _ebtcTokenAddress,
 25 |     |             _sortedCdpsAddress,
 26 |     |             _activePoolAddress,
 27 |     |             _priceFeedAddress,
 28 |     |             _collTokenAddress
 29 |     |         )
 30 |     |     {
 31 |     |         /// @audit Based on the idea that Foundry and Echidna will not fork mainnet
 32 |     |         // require(block.chainid != 1, "No prod!!!!"); /// @audit CANNOT SET, PLS HAAAALP
 33 |     |     }
 34 |     | 
 35 |     |     function syncGlobalAccountingInternal() external {
 36 |     |         _syncGlobalAccounting();
 37 |     |     }
 38 |     | 
 39 |     |     function syncAccounting(bytes32 _cdpId) external virtual override {
 40 |     |         return _syncAccounting(_cdpId);
 41 |     |     }
 42 |     | }
 43 |     | 

/mnt/c/Users/Lourens/Documents/Recon-Fuzz/collabs/ebtc/packages/contracts/contracts/TestContracts/BaseStorageVariables.sol
  1 |     | // SPDX-License-Identifier: UNLICENSED
  2 |     | pragma solidity 0.8.17;
  3 |     | 
  4 |     | import {WETH9} from "./WETH9.sol";
  5 |     | import {BorrowerOperations} from "../BorrowerOperations.sol";
  6 |     | import {PriceFeedTestnet} from "./testnet/PriceFeedTestnet.sol";
  7 |     | import {PriceFeedOracleTester} from "./PriceFeedOracleTester.sol";
  8 |     | import {EbtcFeed} from "../EbtcFeed.sol";
  9 |     | import {SortedCdps} from "../SortedCdps.sol";
 10 |     | import {CdpManager} from "../CdpManager.sol";
 11 |     | import {LiquidationLibrary} from "../LiquidationLibrary.sol";
 12 |     | import {LiquidationSequencer} from "../LiquidationSequencer.sol";
 13 |     | import {SyncedLiquidationSequencer} from "../SyncedLiquidationSequencer.sol";
 14 |     | import {ActivePool} from "../ActivePool.sol";
 15 |     | import {HintHelpers} from "../HintHelpers.sol";
 16 |     | import {FeeRecipient} from "../FeeRecipient.sol";
 17 |     | import {EBTCToken} from "../EBTCToken.sol";
 18 |     | import {CollSurplusPool} from "../CollSurplusPool.sol";
 19 |     | import {FunctionCaller} from "./FunctionCaller.sol";
 20 |     | import {CollateralTokenTester} from "./CollateralTokenTester.sol";
 21 |     | import {Governor} from "../Governor.sol";
 22 |     | import {EBTCDeployer} from "../EBTCDeployer.sol";
 23 |     | import {Actor} from "./invariants/Actor.sol";
 24 |     | import {CRLens} from "./CRLens.sol";
 25 |     | import {Simulator} from "./invariants/Simulator.sol";
 26 |     | 
 27 |     | abstract contract BaseStorageVariables {
 28 |     |     PriceFeedTestnet internal priceFeedMock;
 29 |     |     EbtcFeed internal ebtcFeed;
 30 |     |     PriceFeedOracleTester internal primaryOracle;
 31 |     |     SortedCdps internal sortedCdps;
 32 |     |     CdpManager internal cdpManager;
 33 |     |     WETH9 internal weth;
 34 |     |     ActivePool internal activePool;
 35 |     |     CollSurplusPool internal collSurplusPool;
 36 |     |     FunctionCaller internal functionCaller;
 37 |     |     BorrowerOperations internal borrowerOperations;
 38 |     |     HintHelpers internal hintHelpers;
 39 |     |     EBTCToken internal eBTCToken;
 40 |     |     CollateralTokenTester internal collateral;
 41 |     |     Governor internal authority;
 42 |     |     LiquidationLibrary internal liqudationLibrary;
 43 |     |     LiquidationSequencer internal liquidationSequencer;
 44 |     |     SyncedLiquidationSequencer internal syncedLiquidationSequencer;
 45 |     |     EBTCDeployer internal ebtcDeployer;
 46 |     |     address internal defaultGovernance;
 47 |     | 
 48 |     |     // LQTY Stuff
 49 |     |     FeeRecipient internal feeRecipient;
 50 |     | 
 51 |     |     mapping(address => Actor) internal actors;
 52 |     |     Actor internal actor;
 53 |     | 
 54 |     |     CRLens internal crLens;
 55 |     |     Simulator internal simulator;
 56 |     | 
 57 |     |     uint internal constant NUMBER_OF_ACTORS = 3;
 58 |     |     uint internal constant INITIAL_ETH_BALANCE = 1e24;
 59 | *   |     uint internal constant INITIAL_COLL_BALANCE = 1e21;
 60 |     | 
 61 |     |     uint internal constant diff_tolerance = 0.000000000002e18; //compared to 1e18
 62 | *   |     uint internal constant MAX_PRICE_CHANGE_PERCENT = 1.05e18; //compared to 1e18
 63 | *   |     uint internal constant MAX_REBASE_PERCENT = 1.1e18; //compared to 1e18
 64 | *   |     uint internal constant MAX_FLASHLOAN_ACTIONS = 4;
 65 |     | 
 66 |     |     uint256 totalCdpDustMaxCap; // The amount of dust we expect if each cdp will lock in at most 1 wei of error
 67 |     | }
 68 |     | 

/mnt/c/Users/Lourens/Documents/Recon-Fuzz/collabs/ebtc/packages/contracts/contracts/TestContracts/CRLens.sol
   1 |     | // SPDX-License-Identifier: MIT
   2 |     | 
   3 |     | pragma solidity 0.8.17;
   4 |     | 
   5 |     | import "@crytic/properties/contracts/util/Hevm.sol";
   6 |     | 
   7 |     | import "../Interfaces/IPriceFeed.sol";
   8 |     | import "../Interfaces/IBorrowerOperations.sol";
   9 |     | import "../Interfaces/ICdpManager.sol";
  10 |     | 
  11 |     | /// @notice The contract allows to check real CR of Cdps
  12 |     | ///   Acknowledgement: https://github.com/Uniswap/v3-periphery/blob/main/contracts/lens/Quoter.sol
  13 | *   | contract CRLens {
  14 |     |     ICdpManager public immutable cdpManager;
  15 |     |     IBorrowerOperations public immutable borrowerOperations;
  16 |     |     IPriceFeed public immutable priceFeed;
  17 |     | 
  18 |     |     constructor(address _cdpManager, address _borrowerOperations, address _priceFeed) {
  19 |     |         cdpManager = ICdpManager(_cdpManager);
  20 |     |         borrowerOperations = IBorrowerOperations(_borrowerOperations);
  21 |     |         priceFeed = IPriceFeed(_priceFeed);
  22 |     |     }
  23 |     | 
  24 |     |     // == CORE FUNCTIONS == //
  25 |     | 
  26 |     |     /// @notice Returns the TCR of the system after the fee split
  27 |     |     /// @dev Call this from offChain with `eth_call` to avoid paying for gas
  28 | *   |     function getRealTCR(bool revertValue) external returns (uint256) {
  29 |     |         // Synch State
  30 | *   |         cdpManager.syncGlobalAccountingAndGracePeriod();
  31 |     | 
  32 |     |         // Return latest
  33 | *   |         uint price = priceFeed.fetchPrice();
  34 | *   |         uint256 tcr = cdpManager.getCachedTCR(price);
  35 |     | 
  36 | *   |         if (revertValue) {
  37 |     |             assembly {
  38 | *   |                 let ptr := mload(0x40)
  39 | *   |                 mstore(ptr, tcr)
  40 | *   |                 revert(ptr, 32)
  41 |     |             }
  42 |     |         }
  43 |     | 
  44 |     |         return tcr;
  45 |     |     }
  46 |     | 
  47 |     |     /// @notice Return the ICR of a CDP after the fee split
  48 |     |     /// @dev Call this from offChain with `eth_call` to avoid paying for gas
  49 |     |     function getRealICR(bytes32 cdpId, bool revertValue) external returns (uint256) {
  50 |     |         hevm.prank(address(borrowerOperations));
  51 |     |         cdpManager.syncAccounting(cdpId);
  52 |     |         uint price = priceFeed.fetchPrice();
  53 |     |         uint256 icr = cdpManager.getCachedICR(cdpId, price);
  54 |     | 
  55 |     |         if (revertValue) {
  56 |     |             assembly {
  57 |     |                 let ptr := mload(0x40)
  58 |     |                 mstore(ptr, icr)
  59 |     |                 revert(ptr, 32)
  60 |     |             }
  61 |     |         }
  62 |     | 
  63 |     |         return icr;
  64 |     |     }
  65 |     | 
  66 |     |     /// @notice Return the ICR of a CDP after the fee split
  67 |     |     /// @dev Call this from offChain with `eth_call` to avoid paying for gas
  68 | *   |     function getRealNICR(bytes32 cdpId, bool revertValue) external returns (uint256) {
  69 | *   |         hevm.prank(address(borrowerOperations));
  70 | *   |         cdpManager.syncAccounting(cdpId);
  71 | *   |         uint price = priceFeed.fetchPrice();
  72 | *   |         uint256 icr = cdpManager.getCachedNominalICR(cdpId);
  73 |     | 
  74 | *   |         if (revertValue) {
  75 |     |             assembly {
  76 | *   |                 let ptr := mload(0x40)
  77 | *   |                 mstore(ptr, icr)
  78 | *   |                 revert(ptr, 32)
  79 |     |             }
  80 |     |         }
  81 |     | 
  82 |     |         return icr;
  83 |     |     }
  84 |     | 
  85 | *   |     function getRealStake(bytes32 cdpId) external returns (uint256) {
  86 | *   |         cdpManager.syncAccounting(cdpId);
  87 |     |         uint256 collShares = cdpManager.getCdpCollShares(cdpId);
  88 | *   |         return
  89 | *   |             cdpManager.totalCollateralSnapshot() == 0
  90 |     |                 ? collShares
  91 |     |                 : (collShares * cdpManager.totalStakesSnapshot()) /
  92 |     |                     cdpManager.totalCollateralSnapshot();
  93 |     |     }
  94 |     | 
  95 |     |     /// @dev Returns 1 if we're in RM
  96 | *   |     function getCheckRecoveryMode(bool revertValue) external returns (uint256) {
  97 |     |         // Synch State
  98 | *   |         cdpManager.syncGlobalAccountingAndGracePeriod();
  99 |     | 
 100 |     |         // Return latest
 101 | *   |         uint price = priceFeed.fetchPrice();
 102 | *   |         uint256 isRm = cdpManager.checkRecoveryMode(price) == true ? 1 : 0;
 103 |     | 
 104 | *   |         if (revertValue) {
 105 |     |             assembly {
 106 | *   |                 let ptr := mload(0x40)
 107 | *   |                 mstore(ptr, isRm)
 108 | *   |                 revert(ptr, 32)
 109 |     |             }
 110 |     |         }
 111 |     | 
 112 |     |         return isRm;
 113 |     |     }
 114 |     | 
 115 |     |     // == REVERT LOGIC == //
 116 |     |     // Thanks to: https://github.com/Uniswap/v3-periphery/blob/main/contracts/lens/Quoter.sol
 117 |     |     // NOTE: You should never use these in prod, these are just for testing //
 118 |     | 
 119 | *   |     function parseRevertReason(bytes memory reason) private pure returns (uint256) {
 120 | *   |         if (reason.length != 32) {
 121 |     |             if (reason.length < 68) revert("Unexpected error");
 122 |     |             assembly {
 123 |     |                 reason := add(reason, 0x04)
 124 |     |             }
 125 |     |             revert(abi.decode(reason, (string)));
 126 |     |         }
 127 | *   |         return abi.decode(reason, (uint256));
 128 |     |     }
 129 |     | 
 130 |     |     /// @notice Returns the TCR of the system after the fee split
 131 |     |     /// @dev Call this from offChain with `eth_call` to avoid paying for gas
 132 |     |     ///     These cost more gas, there should never be a reason for you to use them beside integration with Echidna
 133 | *   |     function quoteRealTCR() external returns (uint256) {
 134 | *   |         try this.getRealTCR(true) {} catch (bytes memory reason) {
 135 |     |             return parseRevertReason(reason);
 136 |     |         }
 137 |     |     }
 138 |     | 
 139 |     |     /// @notice Returns the ICR of the system after the fee split
 140 |     |     /// @dev Call this from offChain with `eth_call` to avoid paying for gas
 141 |     |     ///     These cost more gas, there should never be a reason for you to use them beside integration with Echidna
 142 |     |     function quoteRealICR(bytes32 cdpId) external returns (uint256) {
 143 |     |         try this.getRealICR(cdpId, true) {} catch (bytes memory reason) {
 144 |     |             return parseRevertReason(reason);
 145 |     |         }
 146 |     |     }
 147 |     | 
 148 |     |     /// @notice Returns the NICR of the system after the fee split
 149 |     |     /// @dev Call this from offChain with `eth_call` to avoid paying for gas
 150 |     |     ///     These cost more gas, there should never be a reason for you to use them beside integration with Echidna
 151 | *   |     function quoteRealNICR(bytes32 cdpId) external returns (uint256) {
 152 | *   |         try this.getRealNICR(cdpId, true) {} catch (bytes memory reason) {
 153 | *   |             return parseRevertReason(reason);
 154 |     |         }
 155 |     |     }
 156 |     | 
 157 |     |     /// @notice Returns whether the system is in RM after taking fee split
 158 |     |     /// @dev Call this from offChain with `eth_call` to avoid paying for gas
 159 |     |     ///     These cost more gas, there should never be a reason for you to use them beside integration with Echidna
 160 | *   |     function quoteCheckRecoveryMode() external returns (uint256) {
 161 | *   |         try this.getCheckRecoveryMode(true) {} catch (bytes memory reason) {
 162 | *   |             return parseRevertReason(reason);
 163 |     |         }
 164 |     |     }
 165 |     | 
 166 |     |     function quoteAnything(function() external anything) external returns (uint256) {
 167 |     |         try anything() {} catch (bytes memory reason) {
 168 |     |             return parseRevertReason(reason);
 169 |     |         }
 170 |     |     }
 171 |     | }
 172 |     | 

/mnt/c/Users/Lourens/Documents/Recon-Fuzz/collabs/ebtc/packages/contracts/contracts/TestContracts/CollateralTokenTester.sol
   1 |     | // SPDX-License-Identifier: MIT
   2 |     | pragma solidity 0.8.17;
   3 |     | 
   4 |     | import "../Dependencies/ICollateralToken.sol";
   5 |     | import "../Dependencies/ICollateralTokenOracle.sol";
   6 |     | import "../Dependencies/Ownable.sol";
   7 |     | 
   8 |     | interface IEbtcInternalPool {
   9 |     |     function increaseSystemCollShares(uint256 _value) external;
  10 |     | }
  11 |     | 
  12 |     | // based on WETH9 contract
  13 |     | contract CollateralTokenTester is ICollateralToken, ICollateralTokenOracle, Ownable {
  14 |     |     string public override name = "Collateral Token Tester in eBTC";
  15 |     |     string public override symbol = "CollTester";
  16 |     |     uint8 public override decimals = 18;
  17 |     | 
  18 |     |     event TransferShares(address indexed from, address indexed to, uint256 sharesValue);
  19 |     |     event Deposit(address indexed dst, uint256 wad, uint256 _share);
  20 |     |     event Withdrawal(address indexed src, uint256 wad, uint256 _share);
  21 |     |     event UncappedMinterAdded(address indexed account);
  22 |     |     event UncappedMinterRemoved(address indexed account);
  23 |     |     event MintCapSet(uint256 indexed newCap);
  24 |     |     event MintCooldownSet(uint256 indexed newCooldown);
  25 |     | 
  26 |     |     mapping(address => mapping(address => uint256)) public override allowance;
  27 |     |     mapping(address => bool) public isUncappedMinter;
  28 |     |     mapping(address => uint256) public lastMintTime;
  29 |     | 
  30 |     |     // Faucet capped at 10 Collateral tokens per day
  31 |     |     uint256 public mintCap = 10e18;
  32 |     |     uint256 public mintCooldown = 60 * 60 * 24;
  33 |     | 
  34 |     |     // NOTE: Seeded a 1e18 to avoid bs
  35 |     |     uint256 _getTotalShares = 1e18;
  36 |     |     uint256 _getTotalPooledEther = 1e18;
  37 |     |     mapping(address => uint256) public shares;
  38 |     | 
  39 |     |     uint256 private epochsPerFrame = 225;
  40 |     |     uint256 private slotsPerEpoch = 32;
  41 |     |     uint256 private secondsPerSlot = 12;
  42 |     | 
  43 |     |     receive() external payable {
  44 |     |         deposit();
  45 |     |     }
  46 |     | 
  47 |     |     function deposit() public payable {
  48 |     |         uint256 _share = getSharesByPooledEth(msg.value);
  49 |     |         shares[msg.sender] += _share;
  50 |     |         _getTotalShares += _share;
  51 |     |         _getTotalPooledEther += msg.value;
  52 |     | 
  53 |     |         emit Deposit(msg.sender, msg.value, _share);
  54 |     |     }
  55 |     | 
  56 |     |     /// @dev Deposit collateral without ether for testing purposes
  57 |     |     function forceDeposit(uint256 ethToDeposit) external {
  58 |     |         if (!isUncappedMinter[msg.sender]) {
  59 |     |             require(ethToDeposit <= mintCap, "CollTester: Above mint cap");
  60 |     |             require(
  61 |     |                 lastMintTime[msg.sender] == 0 ||
  62 |     |                     lastMintTime[msg.sender] + mintCooldown < block.timestamp,
  63 |     |                 "CollTester: Cooldown period not completed"
  64 |     |             );
  65 |     |             lastMintTime[msg.sender] = block.timestamp;
  66 |     |         }
  67 |     |         uint256 _share = getSharesByPooledEth(ethToDeposit);
  68 |     |         shares[msg.sender] += _share;
  69 |     |         _getTotalShares += _share;
  70 |     |         _getTotalPooledEther += ethToDeposit;
  71 |     | 
  72 |     |         emit Deposit(msg.sender, ethToDeposit, _share);
  73 |     |     }
  74 |     | 
  75 |     |     function withdraw(uint256 wad) public {
  76 |     |         uint256 _share = getSharesByPooledEth(wad);
  77 |     |         require(shares[msg.sender] >= _share);
  78 |     |         shares[msg.sender] -= _share;
  79 |     |         _getTotalShares -= _share;
  80 |     |         payable(msg.sender).transfer(wad);
  81 |     |         emit Withdrawal(msg.sender, wad, _share);
  82 |     |     }
  83 |     | 
  84 |     |     function totalSupply() public view override returns (uint) {
  85 |     |         return _getTotalPooledEther;
  86 |     |     }
  87 |     | 
  88 |     |     // Permissioned functions
  89 |     |     function addUncappedMinter(address account) external onlyOwner {
  90 |     |         isUncappedMinter[account] = true;
  91 |     |         emit UncappedMinterAdded(account);
  92 |     |     }
  93 |     | 
  94 |     |     function removeUncappedMinter(address account) external onlyOwner {
  95 |     |         isUncappedMinter[account] = false;
  96 |     |         emit UncappedMinterRemoved(account);
  97 |     |     }
  98 |     | 
  99 |     |     function setMintCap(uint256 newCap) external onlyOwner {
 100 |     |         mintCap = newCap;
 101 |     |         emit MintCapSet(newCap);
 102 |     |     }
 103 |     | 
 104 |     |     function setMintCooldown(uint256 newCooldown) external onlyOwner {
 105 |     |         mintCooldown = newCooldown;
 106 |     |         emit MintCooldownSet(newCooldown);
 107 |     |     }
 108 |     | 
 109 |     |     // helper to set allowance in test
 110 |     |     function nonStandardSetApproval(
 111 |     |         address owner,
 112 |     |         address guy,
 113 |     |         uint256 wad
 114 |     |     ) external returns (bool) {
 115 |     |         allowance[owner][guy] = wad;
 116 |     |         emit Approval(owner, guy, wad);
 117 |     |         return true;
 118 |     |     }
 119 |     | 
 120 |     |     function approve(address guy, uint256 wad) public override returns (bool) {
 121 |     |         allowance[msg.sender][guy] = wad;
 122 |     |         emit Approval(msg.sender, guy, wad);
 123 |     |         return true;
 124 |     |     }
 125 |     | 
 126 |     |     function transfer(address dst, uint256 wad) public override returns (bool) {
 127 |     |         return transferFrom(msg.sender, dst, wad);
 128 |     |     }
 129 |     | 
 130 |     |     function transferFrom(address src, address dst, uint256 wad) public override returns (bool) {
 131 |     |         uint256 _share = getSharesByPooledEth(wad);
 132 |     |         require(shares[src] >= _share, "ERC20: transfer amount exceeds balance");
 133 |     | 
 134 |     |         if (src != msg.sender && allowance[src][msg.sender] != type(uint256).max) {
 135 |     |             require(allowance[src][msg.sender] >= wad);
 136 |     |             allowance[src][msg.sender] -= wad;
 137 |     |         }
 138 |     | 
 139 |     |         shares[src] -= _share;
 140 |     |         shares[dst] += _share;
 141 |     | 
 142 |     |         _emitTransferEvents(src, dst, wad, _share);
 143 |     | 
 144 |     |         return true;
 145 |     |     }
 146 |     | 
 147 |     |     // tests should adjust the ratio by this function
 148 |     |     function setEthPerShare(uint256 _ePerS) external {
 149 |     |         // We change this
 150 |     |         _getTotalPooledEther = _div(_mul(_getTotalShares, _ePerS), 1e18);
 151 |     |     }
 152 |     | 
 153 |     |     function getEthPerShare() external view returns (uint256) {
 154 |     |         return _div(_mul(1e18, _getTotalPooledEther), _getTotalShares);
 155 |     |     }
 156 |     | 
 157 |     |     /***
 158 |     |         function getSharesByPooledEth(uint256 _ethAmount) public view returns (uint256) {
 159 |     |             return _ethAmount
 160 |     |                 .mul(_getTotalShares())
 161 |     |                 .div(_getTotalPooledEther());
 162 |     |         }
 163 |     |      */
 164 |     | 
 165 |     |     function getSharesByPooledEth(uint256 _ethAmount) public view override returns (uint256) {
 166 |     |         return _div(_mul(_ethAmount, _getTotalShares), _getTotalPooledEther);
 167 |     |     }
 168 |     | 
 169 |     |     /**
 170 |     |             function getPooledEthByShares(uint256 _sharesAmount) public view returns (uint256) {
 171 |     |             return _sharesAmount
 172 |     |                 .mul(_getTotalPooledEther())
 173 |     |                 .div(_getTotalShares());
 174 |     |         }
 175 |     |      */
 176 |     | 
 177 |     |     function getPooledEthByShares(uint256 _sharesAmount) public view override returns (uint256) {
 178 |     |         return _div(_mul(_sharesAmount, _getTotalPooledEther), _getTotalShares);
 179 |     |     }
 180 |     | 
 181 |     |     function transferShares(
 182 |     |         address _recipient,
 183 |     |         uint256 _sharesAmount
 184 |     |     ) public override returns (uint256) {
 185 |     |         uint256 _tknAmt = getPooledEthByShares(_sharesAmount);
 186 |     | 
 187 |     |         // NOTE: Changed here to transfer underlying shares without rounding
 188 |     |         shares[msg.sender] -= _sharesAmount;
 189 |     |         shares[_recipient] += _sharesAmount;
 190 |     | 
 191 |     |         _emitTransferEvents(msg.sender, _recipient, _tknAmt, _sharesAmount);
 192 |     | 
 193 |     |         return _tknAmt;
 194 |     |     }
 195 |     | 
 196 |     |     function sharesOf(address _account) public view override returns (uint256) {
 197 |     |         return shares[_account];
 198 |     |     }
 199 |     | 
 200 |     |     function getOracle() external view override returns (address) {
 201 |     |         return address(this);
 202 |     |     }
 203 |     | 
 204 |     |     function getBeaconSpec() public view override returns (uint64, uint64, uint64, uint64) {
 205 |     |         return (
 206 |     |             uint64(epochsPerFrame),
 207 |     |             uint64(slotsPerEpoch),
 208 |     |             uint64(secondsPerSlot),
 209 |     |             uint64(block.timestamp)
 210 |     |         );
 211 |     |     }
 212 |     | 
 213 |     |     function setBeaconSpec(
 214 |     |         uint64 _epochsPerFrame,
 215 |     |         uint64 _slotsPerEpoch,
 216 |     |         uint64 _secondsPerSlot
 217 |     |     ) external {
 218 |     |         epochsPerFrame = _epochsPerFrame;
 219 |     |         slotsPerEpoch = _slotsPerEpoch;
 220 |     |         secondsPerSlot = _secondsPerSlot;
 221 |     |     }
 222 |     | 
 223 |     |     function decreaseAllowance(
 224 |     |         address spender,
 225 |     |         uint256 subtractedValue
 226 |     |     ) external override returns (bool) {
 227 |     |         approve(spender, allowance[msg.sender][spender] - subtractedValue);
 228 |     |         return true;
 229 |     |     }
 230 |     | 
 231 |     |     function balanceOf(address _usr) external view override returns (uint256) {
 232 |     |         return getPooledEthByShares(shares[_usr]);
 233 |     |     }
 234 |     | 
 235 |     |     function increaseAllowance(
 236 |     |         address spender,
 237 |     |         uint256 addedValue
 238 |     |     ) external override returns (bool) {
 239 |     |         approve(spender, allowance[msg.sender][spender] + addedValue);
 240 |     |         return true;
 241 |     |     }
 242 |     | 
 243 |     |     // internal helper functions
 244 |     |     function _mul(uint256 a, uint256 b) internal pure returns (uint256) {
 245 |     |         if (a == 0) {
 246 |     |             return 0;
 247 |     |         }
 248 |     |         uint256 c = a * b;
 249 |     |         require(c / a == b, "SafeMath: multiplication overflow");
 250 |     |         return c;
 251 |     |     }
 252 |     | 
 253 |     |     function _div(uint256 a, uint256 b) internal pure returns (uint256) {
 254 |     |         require(b > 0, "SafeMath: zero denominator");
 255 |     |         uint256 c = a / b;
 256 |     |         return c;
 257 |     |     }
 258 |     | 
 259 |     |     // dummy test purpose
 260 |     |     function feeRecipientAddress() external view returns (address) {
 261 |     |         return address(this);
 262 |     |     }
 263 |     | 
 264 |     |     function authority() external view returns (address) {
 265 |     |         return address(this);
 266 |     |     }
 267 |     | 
 268 |     |     /**
 269 |     |      * @dev Emits {Transfer} and {TransferShares} events
 270 |     |      */
 271 |     |     function _emitTransferEvents(
 272 |     |         address _from,
 273 |     |         address _to,
 274 |     |         uint _tokenAmount,
 275 |     |         uint256 _sharesAmount
 276 |     |     ) internal {
 277 |     |         emit Transfer(_from, _to, _tokenAmount);
 278 |     |         emit TransferShares(_from, _to, _sharesAmount);
 279 |     |     }
 280 |     | }
 281 |     | 

/mnt/c/Users/Lourens/Documents/Recon-Fuzz/collabs/ebtc/packages/contracts/contracts/TestContracts/EBTCTokenTester.sol
  1 |     | // SPDX-License-Identifier: MIT
  2 |     | 
  3 |     | pragma solidity 0.8.17;
  4 |     | 
  5 |     | import "../EBTCToken.sol";
  6 |     | 
  7 |     | contract EBTCTokenTester is EBTCToken {
  8 |     |     bytes32 private immutable _PERMIT_TYPEHASH =
  9 |     |         0x6e71edae12b1b97f4d1f60370fef10105fa2faae0126114a169c64845d6126c9;
 10 |     | 
 11 |     |     constructor(
 12 |     |         address _cdpManagerAddress,
 13 |     |         address _borrowerOperationsAddress,
 14 |     |         address _authorityAddress
 15 |     |     ) EBTCToken(_cdpManagerAddress, _borrowerOperationsAddress, _authorityAddress) {}
 16 |     | 
 17 |     |     function unprotectedMint(address _account, uint256 _amount) external {
 18 |     |         // No check on caller here
 19 |     | 
 20 |     |         _mint(_account, _amount);
 21 |     |     }
 22 |     | 
 23 |     |     function unprotectedBurn(address _account, uint256 _amount) external {
 24 |     |         // No check on caller here
 25 |     | 
 26 |     |         _burn(_account, _amount);
 27 |     |     }
 28 |     | 
 29 |     |     function unprotectedSendToPool(address _sender, address _poolAddress, uint256 _amount) external {
 30 |     |         // No check on caller here
 31 |     | 
 32 |     |         _transfer(_sender, _poolAddress, _amount);
 33 |     |     }
 34 |     | 
 35 |     |     function unprotectedReturnFromPool(
 36 |     |         address _poolAddress,
 37 |     |         address _receiver,
 38 |     |         uint256 _amount
 39 |     |     ) external {
 40 |     |         // No check on caller here
 41 |     | 
 42 |     |         _transfer(_poolAddress, _receiver, _amount);
 43 |     |     }
 44 |     | 
 45 |     |     function callInternalApprove(address owner, address spender, uint256 amount) external {
 46 |     |         _approve(owner, spender, amount);
 47 |     |     }
 48 |     | 
 49 |     |     function getChainId() external view returns (uint256 chainID) {
 50 |     |         //return _chainID(); // it’s private
 51 |     |         assembly {
 52 |     |             chainID := chainid()
 53 |     |         }
 54 |     |     }
 55 |     | 
 56 |     |     function getDigest(
 57 |     |         address owner,
 58 |     |         address spender,
 59 |     |         uint256 amount,
 60 |     |         uint256 nonce,
 61 |     |         uint256 deadline
 62 |     |     ) external view returns (bytes32) {
 63 |     |         return
 64 |     |             keccak256(
 65 |     |                 abi.encodePacked(
 66 |     |                     uint16(0x1901),
 67 |     |                     domainSeparator(),
 68 |     |                     keccak256(abi.encode(_PERMIT_TYPEHASH, owner, spender, amount, nonce, deadline))
 69 |     |                 )
 70 |     |             );
 71 |     |     }
 72 |     | 
 73 |     |     function recoverAddress(
 74 |     |         bytes32 digest,
 75 |     |         uint8 v,
 76 |     |         bytes32 r,
 77 |     |         bytes32 s
 78 |     |     ) external pure returns (address) {
 79 |     |         return ecrecover(digest, v, r, s);
 80 |     |     }
 81 |     | }
 82 |     | 

/mnt/c/Users/Lourens/Documents/Recon-Fuzz/collabs/ebtc/packages/contracts/contracts/TestContracts/FunctionCaller.sol
  1 |     | // SPDX-License-Identifier: MIT
  2 |     | 
  3 |     | pragma solidity 0.8.17;
  4 |     | 
  5 |     | import "../Interfaces/ICdpManager.sol";
  6 |     | import "../Interfaces/ISortedCdps.sol";
  7 |     | import "../Interfaces/IPriceFeed.sol";
  8 |     | import "../Dependencies/EbtcMath.sol";
  9 |     | 
 10 |     | /* Wrapper contract - used for calculating gas of read-only and internal functions. 
 11 |     | Not part of the Liquity application. */
 12 |     | contract FunctionCaller {
 13 |     |     ICdpManager cdpManager;
 14 |     |     address public cdpManagerAddress;
 15 |     | 
 16 |     |     ISortedCdps sortedCdps;
 17 |     |     address public sortedCdpsAddress;
 18 |     | 
 19 |     |     IPriceFeed priceFeed;
 20 |     |     address public priceFeedAddress;
 21 |     | 
 22 |     |     // --- Dependency setters ---
 23 |     | 
 24 |     |     function setCdpManagerAddress(address _cdpManagerAddress) external {
 25 |     |         cdpManagerAddress = _cdpManagerAddress;
 26 |     |         cdpManager = ICdpManager(_cdpManagerAddress);
 27 |     |     }
 28 |     | 
 29 |     |     function setSortedCdpsAddress(address _sortedCdpsAddress) external {
 30 |     |         cdpManagerAddress = _sortedCdpsAddress;
 31 |     |         sortedCdps = ISortedCdps(_sortedCdpsAddress);
 32 |     |     }
 33 |     | 
 34 |     |     function setPriceFeedAddress(address _priceFeedAddress) external {
 35 |     |         priceFeedAddress = _priceFeedAddress;
 36 |     |         priceFeed = IPriceFeed(_priceFeedAddress);
 37 |     |     }
 38 |     | 
 39 |     |     // --- Non-view wrapper functions used for calculating gas ---
 40 |     | 
 41 |     |     function cdpManager_getCachedICR(
 42 |     |         bytes32 _cdpId,
 43 |     |         uint256 _price
 44 |     |     ) external view returns (uint256) {
 45 |     |         return cdpManager.getCachedICR(_cdpId, _price);
 46 |     |     }
 47 |     | 
 48 |     |     function sortedCdps_findInsertPosition(
 49 |     |         uint256 _NICR,
 50 |     |         bytes32 _prevId,
 51 |     |         bytes32 _nextId
 52 |     |     ) external view returns (bytes32, bytes32) {
 53 |     |         return sortedCdps.findInsertPosition(_NICR, _prevId, _nextId);
 54 |     |     }
 55 |     | }
 56 |     | 

/mnt/c/Users/Lourens/Documents/Recon-Fuzz/collabs/ebtc/packages/contracts/contracts/TestContracts/Pretty.sol
   1 |     | // https://github.com/one-hundred-proof/kyberswap-exploit/blob/main/lib/helpers/Pretty.sol
   2 |     | 
   3 |     | pragma solidity 0.8.17;
   4 |     | 
   5 |     | library Strings {
   6 |     |     function concat(
   7 |     |         string memory _base,
   8 |     |         string memory _value
   9 |     |     ) internal pure returns (string memory) {
  10 |     |         bytes memory _baseBytes = bytes(_base);
  11 |     |         bytes memory _valueBytes = bytes(_value);
  12 |     | 
  13 |     |         string memory _tmpValue = new string(_baseBytes.length + _valueBytes.length);
  14 |     |         bytes memory _newValue = bytes(_tmpValue);
  15 |     | 
  16 |     |         uint i;
  17 |     |         uint j;
  18 |     | 
  19 |     |         for (i = 0; i < _baseBytes.length; i++) {
  20 |     |             _newValue[j++] = _baseBytes[i];
  21 |     |         }
  22 |     | 
  23 |     |         for (i = 0; i < _valueBytes.length; i++) {
  24 |     |             _newValue[j++] = _valueBytes[i];
  25 |     |         }
  26 |     | 
  27 |     |         return string(_newValue);
  28 |     |     }
  29 |     | }
  30 |     | 
  31 |     | library Pretty {
  32 |     |     uint8 constant DEFAULT_DECIMALS = 18;
  33 |     | 
  34 |     |     function toBitString(uint256 n) external pure returns (string memory) {
  35 |     |         return uintToBitString(n, 256);
  36 |     |     }
  37 |     | 
  38 |     |     function toBitString(uint256 n, uint8 decimals) external pure returns (string memory) {
  39 |     |         return uintToBitString(n, decimals);
  40 |     |     }
  41 |     | 
  42 |     |     function pretty(uint256 n) external pure returns (string memory) {
  43 |     |         return
  44 |     |             n == type(uint256).max ? "type(uint256).max" : n == type(uint128).max
  45 |     |                 ? "type(uint128).max"
  46 |     |                 : _pretty(n, DEFAULT_DECIMALS);
  47 |     |     }
  48 |     | 
  49 |     |     function pretty(bool value) external pure returns (string memory) {
  50 |     |         return value ? "true" : "false";
  51 |     |     }
  52 |     | 
  53 |     |     function pretty(uint256 n, uint8 decimals) external pure returns (string memory) {
  54 |     |         return _pretty(n, decimals);
  55 |     |     }
  56 |     | 
  57 |     |     function pretty(uint128 n) external pure returns (string memory) {
  58 |     |         return _pretty(uint128(n), DEFAULT_DECIMALS);
  59 |     |     }
  60 |     | 
  61 |     |     function pretty(uint128 n, uint8 decimals) external pure returns (string memory) {
  62 |     |         return _pretty(uint128(n), decimals);
  63 |     |     }
  64 |     | 
  65 |     |     function pretty(uint64 n) external pure returns (string memory) {
  66 |     |         return _pretty(uint64(n), DEFAULT_DECIMALS);
  67 |     |     }
  68 |     | 
  69 |     |     function pretty(uint64 n, uint8 decimals) external pure returns (string memory) {
  70 |     |         return _pretty(uint64(n), decimals);
  71 |     |     }
  72 |     | 
  73 |     |     function pretty(int256 n) external pure returns (string memory) {
  74 |     |         return _prettyInt(n, DEFAULT_DECIMALS);
  75 |     |     }
  76 |     | 
  77 |     |     function pretty(int256 n, uint8 decimals) external pure returns (string memory) {
  78 |     |         return _prettyInt(n, decimals);
  79 |     |     }
  80 |     | 
  81 |     |     function _pretty(uint256 n, uint8 decimals) internal pure returns (string memory) {
  82 |     |         bool pastDecimals = decimals == 0;
  83 |     |         uint256 place = 0;
  84 |     |         uint256 r; // remainder
  85 |     |         string memory s = "";
  86 |     | 
  87 |     |         while (n != 0) {
  88 |     |             r = n % 10;
  89 |     |             n /= 10;
  90 |     |             place++;
  91 |     |             s = Strings.concat(toDigit(r), s);
  92 |     |             if (pastDecimals && place % 3 == 0 && n != 0) {
  93 |     |                 s = Strings.concat("_", s);
  94 |     |             }
  95 |     |             if (!pastDecimals && place == decimals) {
  96 |     |                 pastDecimals = true;
  97 |     |                 place = 0;
  98 |     |                 s = Strings.concat("_", s);
  99 |     |             }
 100 |     |         }
 101 |     |         if (pastDecimals && place == 0) {
 102 |     |             s = Strings.concat("0", s);
 103 |     |         }
 104 |     |         if (!pastDecimals) {
 105 |     |             uint256 i;
 106 |     |             uint256 upper = (decimals >= place ? decimals - place : 0);
 107 |     |             for (i = 0; i < upper; ++i) {
 108 |     |                 s = Strings.concat("0", s);
 109 |     |             }
 110 |     |             s = Strings.concat("0_", s);
 111 |     |         }
 112 |     |         return s;
 113 |     |     }
 114 |     | 
 115 |     |     function _prettyInt(int256 n, uint8 decimals) internal pure returns (string memory) {
 116 |     |         bool isNegative = n < 0;
 117 |     |         string memory s = "";
 118 |     |         if (isNegative) {
 119 |     |             s = "-";
 120 |     |         }
 121 |     |         return Strings.concat(s, _pretty(uint256(isNegative ? -n : n), decimals));
 122 |     |     }
 123 |     | 
 124 |     |     function toDigit(uint256 n) internal pure returns (string memory) {
 125 |     |         if (n == 0) {
 126 |     |             return "0";
 127 |     |         } else if (n == 1) {
 128 |     |             return "1";
 129 |     |         } else if (n == 2) {
 130 |     |             return "2";
 131 |     |         } else if (n == 3) {
 132 |     |             return "3";
 133 |     |         } else if (n == 4) {
 134 |     |             return "4";
 135 |     |         } else if (n == 5) {
 136 |     |             return "5";
 137 |     |         } else if (n == 6) {
 138 |     |             return "6";
 139 |     |         } else if (n == 7) {
 140 |     |             return "7";
 141 |     |         } else if (n == 8) {
 142 |     |             return "8";
 143 |     |         } else if (n == 9) {
 144 |     |             return "9";
 145 |     |         } else {
 146 |     |             revert("Not in range 0 to 10");
 147 |     |         }
 148 |     |     }
 149 |     | 
 150 |     |     function uintToBitString(uint256 n, uint16 bits) internal pure returns (string memory) {
 151 |     |         string memory s = "";
 152 |     |         for (uint256 i; i < bits; i++) {
 153 |     |             if (n % 2 == 0) {
 154 |     |                 s = Strings.concat("0", s);
 155 |     |             } else {
 156 |     |                 s = Strings.concat("1", s);
 157 |     |             }
 158 |     |             n = n / 2;
 159 |     |         }
 160 |     |         return s;
 161 |     |     }
 162 |     | }
 163 |     | 

/mnt/c/Users/Lourens/Documents/Recon-Fuzz/collabs/ebtc/packages/contracts/contracts/TestContracts/PriceFeedOracleTester.sol
  1 |     | // SPDX-License-Identifier: MIT
  2 |     | pragma solidity 0.8.17;
  3 |     | 
  4 |     | import {PriceFeed} from "../PriceFeed.sol";
  5 |     | import {IPriceFetcher} from "../Interfaces/IOracleCaller.sol";
  6 |     | 
  7 |     | contract PriceFeedOracleTester {
  8 |     |     enum ErrorState {
  9 |     |         NONE,
 10 |     |         REVERT_BOMB,
 11 |     |         RETURN_BOMB,
 12 |     |         RETURN_BYTES,
 13 |     |         REVERT_CUSTOM_ERROR,
 14 |     |         REVERT_CUSTOM_ERROR_PARAMS,
 15 |     |         BURN_ALL_GAS,
 16 |     |         SELF_DESTRUCT,
 17 |     |         COUNT // Number of elements
 18 |     |     }
 19 |     | 
 20 |     |     IPriceFetcher public priceFeed;
 21 |     |     ErrorState public errorState;
 22 |     | 
 23 |     |     error InvalidAddress();
 24 |     |     error InvalidNumber(uint224);
 25 |     | 
 26 |     |     constructor(address _priceFeed) {
 27 |     |         priceFeed = IPriceFetcher(_priceFeed);
 28 |     |         errorState = ErrorState.NONE;
 29 |     |     }
 30 |     | 
 31 |     |     function fetchPrice() external returns (uint256) {
 32 |     |         if (errorState == ErrorState.NONE) {
 33 |     |             return priceFeed.fetchPrice();
 34 |     |         } else if (errorState == ErrorState.REVERT_BOMB) {
 35 |     |             revBytes(2_000_000);
 36 |     |         } else if (errorState == ErrorState.RETURN_BOMB) {
 37 |     |             retBytes(2_000_000);
 38 |     |         } else if (errorState == ErrorState.RETURN_BYTES) {
 39 |     |             retByteArray();
 40 |     |         } else if (errorState == ErrorState.REVERT_CUSTOM_ERROR) {
 41 |     |             revert InvalidAddress();
 42 |     |         } else if (errorState == ErrorState.REVERT_CUSTOM_ERROR_PARAMS) {
 43 |     |             revert InvalidNumber(12346);
 44 |     |         } else if (errorState == ErrorState.BURN_ALL_GAS) {
 45 |     |             uint256 counter;
 46 |     |             while (true) {
 47 |     |                 counter += 1;
 48 |     |             }
 49 |     |         } else if (errorState == ErrorState.SELF_DESTRUCT) {
 50 |     |             selfdestruct(payable(msg.sender));
 51 |     |         }
 52 |     |     }
 53 |     | 
 54 |     |     function revBytes(uint256 _bytes) internal pure {
 55 |     |         assembly {
 56 |     |             revert(0, _bytes)
 57 |     |         }
 58 |     |     }
 59 |     | 
 60 |     |     function retBytes(uint256 _bytes) public pure {
 61 |     |         assembly {
 62 |     |             return(0, _bytes)
 63 |     |         }
 64 |     |     }
 65 |     | 
 66 |     |     function retByteArray() public pure {
 67 |     |         uint256[] memory entries = new uint256[](250);
 68 |     |         bytes memory retData = abi.encode(entries);
 69 |     |         uint256 retLen = retData.length;
 70 |     |         assembly {
 71 |     |             return(add(retData, 0x20), retLen)
 72 |     |         }
 73 |     |     }
 74 |     | 
 75 |     |     function setErrorState(ErrorState _errorState) external {
 76 |     |         errorState = _errorState;
 77 |     |     }
 78 |     | }
 79 |     | 

/mnt/c/Users/Lourens/Documents/Recon-Fuzz/collabs/ebtc/packages/contracts/contracts/TestContracts/WETH9.sol
   1 |     | /**
   2 |     |  *Submitted for verification at Etherscan.io on 2017-12-12
   3 |     |  */
   4 |     | 
   5 |     | // Copyright (C) 2015, 2016, 2017 Dapphub
   6 |     | 
   7 |     | // This program is free software: you can redistribute it and/or modify
   8 |     | // it under the terms of the GNU General Public License as published by
   9 |     | // the Free Software Foundation, either version 3 of the License, or
  10 |     | // (at your option) any later version.
  11 |     | 
  12 |     | // This program is distributed in the hope that it will be useful,
  13 |     | // but WITHOUT ANY WARRANTY; without even the implied warranty of
  14 |     | // MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
  15 |     | // GNU General Public License for more details.
  16 |     | 
  17 |     | // You should have received a copy of the GNU General Public License
  18 |     | // along with this program.  If not, see <http://www.gnu.org/licenses/>.
  19 |     | 
  20 |     | pragma solidity 0.8.17;
  21 |     | 
  22 |     | contract WETH9 {
  23 |     |     string public name = "Wrapped Ether";
  24 |     |     string public symbol = "WETH";
  25 |     |     uint8 public decimals = 18;
  26 |     | 
  27 |     |     event Approval(address indexed src, address indexed guy, uint256 wad);
  28 |     |     event Transfer(address indexed src, address indexed dst, uint256 wad);
  29 |     |     event Deposit(address indexed dst, uint256 wad);
  30 |     |     event Withdrawal(address indexed src, uint256 wad);
  31 |     | 
  32 |     |     mapping(address => uint256) public balanceOf;
  33 |     |     mapping(address => mapping(address => uint256)) public allowance;
  34 |     | 
  35 |     |     function receive() public payable {
  36 |     |         deposit();
  37 |     |     }
  38 |     | 
  39 |     |     function deposit() public payable {
  40 |     |         balanceOf[msg.sender] += msg.value;
  41 |     |         emit Deposit(msg.sender, msg.value);
  42 |     |     }
  43 |     | 
  44 |     |     function withdraw(uint256 wad) public {
  45 |     |         require(balanceOf[msg.sender] >= wad);
  46 |     |         balanceOf[msg.sender] -= wad;
  47 |     |         payable(msg.sender).transfer(wad);
  48 |     |         emit Withdrawal(msg.sender, wad);
  49 |     |     }
  50 |     | 
  51 |     |     function totalSupply() public view returns (uint256) {
  52 |     |         return address(this).balance;
  53 |     |     }
  54 |     | 
  55 |     |     function approve(address guy, uint256 wad) public returns (bool) {
  56 |     |         allowance[msg.sender][guy] = wad;
  57 |     |         emit Approval(msg.sender, guy, wad);
  58 |     |         return true;
  59 |     |     }
  60 |     | 
  61 |     |     function transfer(address dst, uint256 wad) public virtual returns (bool) {
  62 |     |         return transferFrom(msg.sender, dst, wad);
  63 |     |     }
  64 |     | 
  65 |     |     function transferFrom(address src, address dst, uint256 wad) public returns (bool) {
  66 |     |         require(balanceOf[src] >= wad);
  67 |     | 
  68 |     |         if (src != msg.sender && allowance[src][msg.sender] != type(uint256).max) {
  69 |     |             require(allowance[src][msg.sender] >= wad);
  70 |     |             allowance[src][msg.sender] -= wad;
  71 |     |         }
  72 |     | 
  73 |     |         balanceOf[src] -= wad;
  74 |     |         balanceOf[dst] += wad;
  75 |     | 
  76 |     |         emit Transfer(src, dst, wad);
  77 |     | 
  78 |     |         return true;
  79 |     |     }
  80 |     | }
  81 |     | 
  82 |     | /*
  83 |     |                     GNU GENERAL PUBLIC LICENSE
  84 |     |                        Version 3, 29 June 2007
  85 |     | 
  86 |     |  Copyright (C) 2007 Free Software Foundation, Inc. <http://fsf.org/>
  87 |     |  Everyone is permitted to copy and distribute verbatim copies
  88 |     |  of this license document, but changing it is not allowed.
  89 |     | 
  90 |     |                             Preamble
  91 |     | 
  92 |     |   The GNU General Public License is a free, copyleft license for
  93 |     | software and other kinds of works.
  94 |     | 
  95 |     |   The licenses for most software and other practical works are designed
  96 |     | to take away your freedom to share and change the works.  By contrast,
  97 |     | the GNU General Public License is intended to guarantee your freedom to
  98 |     | share and change all versions of a program--to make sure it remains free
  99 |     | software for all its users.  We, the Free Software Foundation, use the
 100 |     | GNU General Public License for most of our software; it applies also to
 101 |     | any other work released this way by its authors.  You can apply it to
 102 |     | your programs, too.
 103 |     | 
 104 |     |   When we speak of free software, we are referring to freedom, not
 105 |     | price.  Our General Public Licenses are designed to make sure that you
 106 |     | have the freedom to distribute copies of free software (and charge for
 107 |     | them if you wish), that you receive source code or can get it if you
 108 |     | want it, that you can change the software or use pieces of it in new
 109 |     | free programs, and that you know you can do these things.
 110 |     | 
 111 |     |   To protect your rights, we need to prevent others from denying you
 112 |     | these rights or asking you to surrender the rights.  Therefore, you have
 113 |     | certain responsibilities if you distribute copies of the software, or if
 114 |     | you modify it: responsibilities to respect the freedom of others.
 115 |     | 
 116 |     |   For example, if you distribute copies of such a program, whether
 117 |     | gratis or for a fee, you must pass on to the recipients the same
 118 |     | freedoms that you received.  You must make sure that they, too, receive
 119 |     | or can get the source code.  And you must show them these terms so they
 120 |     | know their rights.
 121 |     | 
 122 |     |   Developers that use the GNU GPL protect your rights with two steps:
 123 |     | (1) assert copyright on the software, and (2) offer you this License
 124 |     | giving you legal permission to copy, distribute and/or modify it.
 125 |     | 
 126 |     |   For the developers' and authors' protection, the GPL clearly explains
 127 |     | that there is no warranty for this free software.  For both users' and
 128 |     | authors' sake, the GPL requires that modified versions be marked as
 129 |     | changed, so that their problems will not be attributed erroneously to
 130 |     | authors of previous versions.
 131 |     | 
 132 |     |   Some devices are designed to deny users access to install or run
 133 |     | modified versions of the software inside them, although the manufacturer
 134 |     | can do so.  This is fundamentally incompatible with the aim of
 135 |     | protecting users' freedom to change the software.  The systematic
 136 |     | pattern of such abuse occurs in the area of products for individuals to
 137 |     | use, which is precisely where it is most unacceptable.  Therefore, we
 138 |     | have designed this version of the GPL to prohibit the practice for those
 139 |     | products.  If such problems arise substantially in other domains, we
 140 |     | stand ready to extend this provision to those domains in future versions
 141 |     | of the GPL, as needed to protect the freedom of users.
 142 |     | 
 143 |     |   Finally, every program is threatened constantly by software patents.
 144 |     | States should not allow patents to restrict development and use of
 145 |     | software on general-purpose computers, but in those that do, we wish to
 146 |     | avoid the special danger that patents applied to a free program could
 147 |     | make it effectively proprietary.  To prevent this, the GPL assures that
 148 |     | patents cannot be used to render the program non-free.
 149 |     | 
 150 |     |   The precise terms and conditions for copying, distribution and
 151 |     | modification follow.
 152 |     | 
 153 |     |                        TERMS AND CONDITIONS
 154 |     | 
 155 |     |   0. Definitions.
 156 |     | 
 157 |     |   "This License" refers to version 3 of the GNU General Public License.
 158 |     | 
 159 |     |   "Copyright" also means copyright-like laws that apply to other kinds of
 160 |     | works, such as semiconductor masks.
 161 |     | 
 162 |     |   "The Program" refers to any copyrightable work licensed under this
 163 |     | License.  Each licensee is addressed as "you".  "Licensees" and
 164 |     | "recipients" may be individuals or organizations.
 165 |     | 
 166 |     |   To "modify" a work means to copy from or adapt all or part of the work
 167 |     | in a fashion requiring copyright permission, other than the making of an
 168 |     | exact copy.  The resulting work is called a "modified version" of the
 169 |     | earlier work or a work "based on" the earlier work.
 170 |     | 
 171 |     |   A "covered work" means either the unmodified Program or a work based
 172 |     | on the Program.
 173 |     | 
 174 |     |   To "propagate" a work means to do anything with it that, without
 175 |     | permission, would make you directly or secondarily liable for
 176 |     | infringement under applicable copyright law, except executing it on a
 177 |     | computer or modifying a private copy.  Propagation includes copying,
 178 |     | distribution (with or without modification), making available to the
 179 |     | public, and in some countries other activities as well.
 180 |     | 
 181 |     |   To "convey" a work means any kind of propagation that enables other
 182 |     | parties to make or receive copies.  Mere interaction with a user through
 183 |     | a computer network, with no transfer of a copy, is not conveying.
 184 |     | 
 185 |     |   An interactive user interface displays "Appropriate Legal Notices"
 186 |     | to the extent that it includes a convenient and prominently visible
 187 |     | feature that (1) displays an appropriate copyright notice, and (2)
 188 |     | tells the user that there is no warranty for the work (except to the
 189 |     | extent that warranties are provided), that licensees may convey the
 190 |     | work under this License, and how to view a copy of this License.  If
 191 |     | the interface presents a list of user commands or options, such as a
 192 |     | menu, a prominent item in the list meets this criterion.
 193 |     | 
 194 |     |   1. Source Code.
 195 |     | 
 196 |     |   The "source code" for a work means the preferred form of the work
 197 |     | for making modifications to it.  "Object code" means any non-source
 198 |     | form of a work.
 199 |     | 
 200 |     |   A "Standard Interface" means an interface that either is an official
 201 |     | standard defined by a recognized standards body, or, in the case of
 202 |     | interfaces specified for a particular programming language, one that
 203 |     | is widely used among developers working in that language.
 204 |     | 
 205 |     |   The "System Libraries" of an executable work include anything, other
 206 |     | than the work as a whole, that (a) is included in the normal form of
 207 |     | packaging a Major Component, but which is not part of that Major
 208 |     | Component, and (b) serves only to enable use of the work with that
 209 |     | Major Component, or to implement a Standard Interface for which an
 210 |     | implementation is available to the public in source code form.  A
 211 |     | "Major Component", in this context, means a major essential component
 212 |     | (kernel, window system, and so on) of the specific operating system
 213 |     | (if any) on which the executable work runs, or a compiler used to
 214 |     | produce the work, or an object code interpreter used to run it.
 215 |     | 
 216 |     |   The "Corresponding Source" for a work in object code form means all
 217 |     | the source code needed to generate, install, and (for an executable
 218 |     | work) run the object code and to modify the work, including scripts to
 219 |     | control those activities.  However, it does not include the work's
 220 |     | System Libraries, or general-purpose tools or generally available free
 221 |     | programs which are used unmodified in performing those activities but
 222 |     | which are not part of the work.  For example, Corresponding Source
 223 |     | includes interface definition files associated with source files for
 224 |     | the work, and the source code for shared libraries and dynamically
 225 |     | linked subprograms that the work is specifically designed to require,
 226 |     | such as by intimate data communication or control flow between those
 227 |     | subprograms and other parts of the work.
 228 |     | 
 229 |     |   The Corresponding Source need not include anything that users
 230 |     | can regenerate automatically from other parts of the Corresponding
 231 |     | Source.
 232 |     | 
 233 |     |   The Corresponding Source for a work in source code form is that
 234 |     | same work.
 235 |     | 
 236 |     |   2. Basic Permissions.
 237 |     | 
 238 |     |   All rights granted under this License are granted for the term of
 239 |     | copyright on the Program, and are irrevocable provided the stated
 240 |     | conditions are met.  This License explicitly affirms your unlimited
 241 |     | permission to run the unmodified Program.  The output from running a
 242 |     | covered work is covered by this License only if the output, given its
 243 |     | content, constitutes a covered work.  This License acknowledges your
 244 |     | rights of fair use or other equivalent, as provided by copyright law.
 245 |     | 
 246 |     |   You may make, run and propagate covered works that you do not
 247 |     | convey, without conditions so long as your license otherwise remains
 248 |     | in force.  You may convey covered works to others for the sole purpose
 249 |     | of having them make modifications exclusively for you, or provide you
 250 |     | with facilities for running those works, provided that you comply with
 251 |     | the terms of this License in conveying all material for which you do
 252 |     | not control copyright.  Those thus making or running the covered works
 253 |     | for you must do so exclusively on your behalf, under your direction
 254 |     | and control, on terms that prohibit them from making any copies of
 255 |     | your copyrighted material outside their relationship with you.
 256 |     | 
 257 |     |   Conveying under any other circumstances is permitted solely under
 258 |     | the conditions stated below.  Sublicensing is not allowed; section 10
 259 |     | makes it unnecessary.
 260 |     | 
 261 |     |   3. Protecting Users' Legal Rights From Anti-Circumvention Law.
 262 |     | 
 263 |     |   No covered work shall be deemed part of an effective technological
 264 |     | measure under any applicable law fulfilling obligations under article
 265 |     | 11 of the WIPO copyright treaty adopted on 20 December 1996, or
 266 |     | similar laws prohibiting or restricting circumvention of such
 267 |     | measures.
 268 |     | 
 269 |     |   When you convey a covered work, you waive any legal power to forbid
 270 |     | circumvention of technological measures to the extent such circumvention
 271 |     | is effected by exercising rights under this License with respect to
 272 |     | the covered work, and you disclaim any intention to limit operation or
 273 |     | modification of the work as a means of enforcing, against the work's
 274 |     | users, your or third parties' legal rights to forbid circumvention of
 275 |     | technological measures.
 276 |     | 
 277 |     |   4. Conveying Verbatim Copies.
 278 |     | 
 279 |     |   You may convey verbatim copies of the Program's source code as you
 280 |     | receive it, in any medium, provided that you conspicuously and
 281 |     | appropriately publish on each copy an appropriate copyright notice;
 282 |     | keep intact all notices stating that this License and any
 283 |     | non-permissive terms added in accord with section 7 apply to the code;
 284 |     | keep intact all notices of the absence of any warranty; and give all
 285 |     | recipients a copy of this License along with the Program.
 286 |     | 
 287 |     |   You may charge any price or no price for each copy that you convey,
 288 |     | and you may offer support or warranty protection for a fee.
 289 |     | 
 290 |     |   5. Conveying Modified Source Versions.
 291 |     | 
 292 |     |   You may convey a work based on the Program, or the modifications to
 293 |     | produce it from the Program, in the form of source code under the
 294 |     | terms of section 4, provided that you also meet all of these conditions:
 295 |     | 
 296 |     |     a) The work must carry prominent notices stating that you modified
 297 |     |     it, and giving a relevant date.
 298 |     | 
 299 |     |     b) The work must carry prominent notices stating that it is
 300 |     |     released under this License and any conditions added under section
 301 |     |     7.  This requirement modifies the requirement in section 4 to
 302 |     |     "keep intact all notices".
 303 |     | 
 304 |     |     c) You must license the entire work, as a whole, under this
 305 |     |     License to anyone who comes into possession of a copy.  This
 306 |     |     License will therefore apply, along with any applicable section 7
 307 |     |     additional terms, to the whole of the work, and all its parts,
 308 |     |     regardless of how they are packaged.  This License gives no
 309 |     |     permission to license the work in any other way, but it does not
 310 |     |     invalidate such permission if you have separately received it.
 311 |     | 
 312 |     |     d) If the work has interactive user interfaces, each must display
 313 |     |     Appropriate Legal Notices; however, if the Program has interactive
 314 |     |     interfaces that do not display Appropriate Legal Notices, your
 315 |     |     work need not make them do so.
 316 |     | 
 317 |     |   A compilation of a covered work with other separate and independent
 318 |     | works, which are not by their nature extensions of the covered work,
 319 |     | and which are not combined with it such as to form a larger program,
 320 |     | in or on a volume of a storage or distribution medium, is called an
 321 |     | "aggregate" if the compilation and its resulting copyright are not
 322 |     | used to limit the access or legal rights of the compilation's users
 323 |     | beyond what the individual works permit.  Inclusion of a covered work
 324 |     | in an aggregate does not cause this License to apply to the other
 325 |     | parts of the aggregate.
 326 |     | 
 327 |     |   6. Conveying Non-Source Forms.
 328 |     | 
 329 |     |   You may convey a covered work in object code form under the terms
 330 |     | of sections 4 and 5, provided that you also convey the
 331 |     | machine-readable Corresponding Source under the terms of this License,
 332 |     | in one of these ways:
 333 |     | 
 334 |     |     a) Convey the object code in, or embodied in, a physical product
 335 |     |     (including a physical distribution medium), accompanied by the
 336 |     |     Corresponding Source fixed on a durable physical medium
 337 |     |     customarily used for software interchange.
 338 |     | 
 339 |     |     b) Convey the object code in, or embodied in, a physical product
 340 |     |     (including a physical distribution medium), accompanied by a
 341 |     |     written offer, valid for at least three years and valid for as
 342 |     |     long as you offer spare parts or customer support for that product
 343 |     |     model, to give anyone who possesses the object code either (1) a
 344 |     |     copy of the Corresponding Source for all the software in the
 345 |     |     product that is covered by this License, on a durable physical
 346 |     |     medium customarily used for software interchange, for a price no
 347 |     |     more than your reasonable cost of physically performing this
 348 |     |     conveying of source, or (2) access to copy the
 349 |     |     Corresponding Source from a network server at no charge.
 350 |     | 
 351 |     |     c) Convey individual copies of the object code with a copy of the
 352 |     |     written offer to provide the Corresponding Source.  This
 353 |     |     alternative is allowed only occasionally and noncommercially, and
 354 |     |     only if you received the object code with such an offer, in accord
 355 |     |     with subsection 6b.
 356 |     | 
 357 |     |     d) Convey the object code by offering access from a designated
 358 |     |     place (gratis or for a charge), and offer equivalent access to the
 359 |     |     Corresponding Source in the same way through the same place at no
 360 |     |     further charge.  You need not require recipients to copy the
 361 |     |     Corresponding Source along with the object code.  If the place to
 362 |     |     copy the object code is a network server, the Corresponding Source
 363 |     |     may be on a different server (operated by you or a third party)
 364 |     |     that supports equivalent copying facilities, provided you maintain
 365 |     |     clear directions next to the object code saying where to find the
 366 |     |     Corresponding Source.  Regardless of what server hosts the
 367 |     |     Corresponding Source, you remain obligated to ensure that it is
 368 |     |     available for as long as needed to satisfy these requirements.
 369 |     | 
 370 |     |     e) Convey the object code using peer-to-peer transmission, provided
 371 |     |     you inform other peers where the object code and Corresponding
 372 |     |     Source of the work are being offered to the general public at no
 373 |     |     charge under subsection 6d.
 374 |     | 
 375 |     |   A separable portion of the object code, whose source code is excluded
 376 |     | from the Corresponding Source as a System Library, need not be
 377 |     | included in conveying the object code work.
 378 |     | 
 379 |     |   A "User Product" is either (1) a "consumer product", which means any
 380 |     | tangible personal property which is normally used for personal, family,
 381 |     | or household purposes, or (2) anything designed or sold for incorporation
 382 |     | into a dwelling.  In determining whether a product is a consumer product,
 383 |     | doubtful cases shall be resolved in favor of coverage.  For a particular
 384 |     | product received by a particular user, "normally used" refers to a
 385 |     | typical or common use of that class of product, regardless of the status
 386 |     | of the particular user or of the way in which the particular user
 387 |     | actually uses, or expects or is expected to use, the product.  A product
 388 |     | is a consumer product regardless of whether the product has substantial
 389 |     | commercial, industrial or non-consumer uses, unless such uses represent
 390 |     | the only significant mode of use of the product.
 391 |     | 
 392 |     |   "Installation Information" for a User Product means any methods,
 393 |     | procedures, authorization keys, or other information required to install
 394 |     | and execute modified versions of a covered work in that User Product from
 395 |     | a modified version of its Corresponding Source.  The information must
 396 |     | suffice to ensure that the continued functioning of the modified object
 397 |     | code is in no case prevented or interfered with solely because
 398 |     | modification has been made.
 399 |     | 
 400 |     |   If you convey an object code work under this section in, or with, or
 401 |     | specifically for use in, a User Product, and the conveying occurs as
 402 |     | part of a transaction in which the right of possession and use of the
 403 |     | User Product is transferred to the recipient in perpetuity or for a
 404 |     | fixed term (regardless of how the transaction is characterized), the
 405 |     | Corresponding Source conveyed under this section must be accompanied
 406 |     | by the Installation Information.  But this requirement does not apply
 407 |     | if neither you nor any third party retains the ability to install
 408 |     | modified object code on the User Product (for example, the work has
 409 |     | been installed in ROM).
 410 |     | 
 411 |     |   The requirement to provide Installation Information does not include a
 412 |     | requirement to continue to provide support service, warranty, or updates
 413 |     | for a work that has been modified or installed by the recipient, or for
 414 |     | the User Product in which it has been modified or installed.  Access to a
 415 |     | network may be denied when the modification itself materially and
 416 |     | adversely affects the operation of the network or violates the rules and
 417 |     | protocols for communication across the network.
 418 |     | 
 419 |     |   Corresponding Source conveyed, and Installation Information provided,
 420 |     | in accord with this section must be in a format that is publicly
 421 |     | documented (and with an implementation available to the public in
 422 |     | source code form), and must require no special password or key for
 423 |     | unpacking, reading or copying.
 424 |     | 
 425 |     |   7. Additional Terms.
 426 |     | 
 427 |     |   "Additional permissions" are terms that supplement the terms of this
 428 |     | License by making exceptions from one or more of its conditions.
 429 |     | Additional permissions that are applicable to the entire Program shall
 430 |     | be treated as though they were included in this License, to the extent
 431 |     | that they are valid under applicable law.  If additional permissions
 432 |     | apply only to part of the Program, that part may be used separately
 433 |     | under those permissions, but the entire Program remains governed by
 434 |     | this License without regard to the additional permissions.
 435 |     | 
 436 |     |   When you convey a copy of a covered work, you may at your option
 437 |     | remove any additional permissions from that copy, or from any part of
 438 |     | it.  (Additional permissions may be written to require their own
 439 |     | removal in certain cases when you modify the work.)  You may place
 440 |     | additional permissions on material, added by you to a covered work,
 441 |     | for which you have or can give appropriate copyright permission.
 442 |     | 
 443 |     |   Notwithstanding any other provision of this License, for material you
 444 |     | add to a covered work, you may (if authorized by the copyright holders of
 445 |     | that material) supplement the terms of this License with terms:
 446 |     | 
 447 |     |     a) Disclaiming warranty or limiting liability differently from the
 448 |     |     terms of sections 15 and 16 of this License; or
 449 |     | 
 450 |     |     b) Requiring preservation of specified reasonable legal notices or
 451 |     |     author attributions in that material or in the Appropriate Legal
 452 |     |     Notices displayed by works containing it; or
 453 |     | 
 454 |     |     c) Prohibiting misrepresentation of the origin of that material, or
 455 |     |     requiring that modified versions of such material be marked in
 456 |     |     reasonable ways as different from the original version; or
 457 |     | 
 458 |     |     d) Limiting the use for publicity purposes of names of licensors or
 459 |     |     authors of the material; or
 460 |     | 
 461 |     |     e) Declining to grant rights under trademark law for use of some
 462 |     |     trade names, trademarks, or service marks; or
 463 |     | 
 464 |     |     f) Requiring indemnification of licensors and authors of that
 465 |     |     material by anyone who conveys the material (or modified versions of
 466 |     |     it) with contractual assumptions of liability to the recipient, for
 467 |     |     any liability that these contractual assumptions directly impose on
 468 |     |     those licensors and authors.
 469 |     | 
 470 |     |   All other non-permissive additional terms are considered "further
 471 |     | restrictions" within the meaning of section 10.  If the Program as you
 472 |     | received it, or any part of it, contains a notice stating that it is
 473 |     | governed by this License along with a term that is a further
 474 |     | restriction, you may remove that term.  If a license document contains
 475 |     | a further restriction but permits relicensing or conveying under this
 476 |     | License, you may add to a covered work material governed by the terms
 477 |     | of that license document, provided that the further restriction does
 478 |     | not survive such relicensing or conveying.
 479 |     | 
 480 |     |   If you add terms to a covered work in accord with this section, you
 481 |     | must place, in the relevant source files, a statement of the
 482 |     | additional terms that apply to those files, or a notice indicating
 483 |     | where to find the applicable terms.
 484 |     | 
 485 |     |   Additional terms, permissive or non-permissive, may be stated in the
 486 |     | form of a separately written license, or stated as exceptions;
 487 |     | the above requirements apply either way.
 488 |     | 
 489 |     |   8. Termination.
 490 |     | 
 491 |     |   You may not propagate or modify a covered work except as expressly
 492 |     | provided under this License.  Any attempt otherwise to propagate or
 493 |     | modify it is void, and will automatically terminate your rights under
 494 |     | this License (including any patent licenses granted under the third
 495 |     | paragraph of section 11).
 496 |     | 
 497 |     |   However, if you cease all violation of this License, then your
 498 |     | license from a particular copyright holder is reinstated (a)
 499 |     | provisionally, unless and until the copyright holder explicitly and
 500 |     | finally terminates your license, and (b) permanently, if the copyright
 501 |     | holder fails to notify you of the violation by some reasonable means
 502 |     | prior to 60 days after the cessation.
 503 |     | 
 504 |     |   Moreover, your license from a particular copyright holder is
 505 |     | reinstated permanently if the copyright holder notifies you of the
 506 |     | violation by some reasonable means, this is the first time you have
 507 |     | received notice of violation of this License (for any work) from that
 508 |     | copyright holder, and you cure the violation prior to 30 days after
 509 |     | your receipt of the notice.
 510 |     | 
 511 |     |   Termination of your rights under this section does not terminate the
 512 |     | licenses of parties who have received copies or rights from you under
 513 |     | this License.  If your rights have been terminated and not permanently
 514 |     | reinstated, you do not qualify to receive new licenses for the same
 515 |     | material under section 10.
 516 |     | 
 517 |     |   9. Acceptance Not Required for Having Copies.
 518 |     | 
 519 |     |   You are not required to accept this License in order to receive or
 520 |     | run a copy of the Program.  Ancillary propagation of a covered work
 521 |     | occurring solely as a consequence of using peer-to-peer transmission
 522 |     | to receive a copy likewise does not require acceptance.  However,
 523 |     | nothing other than this License grants you permission to propagate or
 524 |     | modify any covered work.  These actions infringe copyright if you do
 525 |     | not accept this License.  Therefore, by modifying or propagating a
 526 |     | covered work, you indicate your acceptance of this License to do so.
 527 |     | 
 528 |     |   10. Automatic Licensing of Downstream Recipients.
 529 |     | 
 530 |     |   Each time you convey a covered work, the recipient automatically
 531 |     | receives a license from the original licensors, to run, modify and
 532 |     | propagate that work, subject to this License.  You are not responsible
 533 |     | for enforcing compliance by third parties with this License.
 534 |     | 
 535 |     |   An "entity transaction" is a transaction transferring control of an
 536 |     | organization, or substantially all assets of one, or subdividing an
 537 |     | organization, or merging organizations.  If propagation of a covered
 538 |     | work results from an entity transaction, each party to that
 539 |     | transaction who receives a copy of the work also receives whatever
 540 |     | licenses to the work the party's predecessor in interest had or could
 541 |     | give under the previous paragraph, plus a right to possession of the
 542 |     | Corresponding Source of the work from the predecessor in interest, if
 543 |     | the predecessor has it or can get it with reasonable efforts.
 544 |     | 
 545 |     |   You may not impose any further restrictions on the exercise of the
 546 |     | rights granted or affirmed under this License.  For example, you may
 547 |     | not impose a license fee, royalty, or other charge for exercise of
 548 |     | rights granted under this License, and you may not initiate litigation
 549 |     | (including a cross-claim or counterclaim in a lawsuit) alleging that
 550 |     | any patent claim is infringed by making, using, selling, offering for
 551 |     | sale, or importing the Program or any portion of it.
 552 |     | 
 553 |     |   11. Patents.
 554 |     | 
 555 |     |   A "contributor" is a copyright holder who authorizes use under this
 556 |     | License of the Program or a work on which the Program is based.  The
 557 |     | work thus licensed is called the contributor's "contributor version".
 558 |     | 
 559 |     |   A contributor's "essential patent claims" are all patent claims
 560 |     | owned or controlled by the contributor, whether already acquired or
 561 |     | hereafter acquired, that would be infringed by some manner, permitted
 562 |     | by this License, of making, using, or selling its contributor version,
 563 |     | but do not include claims that would be infringed only as a
 564 |     | consequence of further modification of the contributor version.  For
 565 |     | purposes of this definition, "control" includes the right to grant
 566 |     | patent sublicenses in a manner consistent with the requirements of
 567 |     | this License.
 568 |     | 
 569 |     |   Each contributor grants you a non-exclusive, worldwide, royalty-free
 570 |     | patent license under the contributor's essential patent claims, to
 571 |     | make, use, sell, offer for sale, import and otherwise run, modify and
 572 |     | propagate the contents of its contributor version.
 573 |     | 
 574 |     |   In the following three paragraphs, a "patent license" is any express
 575 |     | agreement or commitment, however denominated, not to enforce a patent
 576 |     | (such as an express permission to practice a patent or covenant not to
 577 |     | sue for patent infringement).  To "grant" such a patent license to a
 578 |     | party means to make such an agreement or commitment not to enforce a
 579 |     | patent against the party.
 580 |     | 
 581 |     |   If you convey a covered work, knowingly relying on a patent license,
 582 |     | and the Corresponding Source of the work is not available for anyone
 583 |     | to copy, free of charge and under the terms of this License, through a
 584 |     | publicly available network server or other readily accessible means,
 585 |     | then you must either (1) cause the Corresponding Source to be so
 586 |     | available, or (2) arrange to deprive yourself of the benefit of the
 587 |     | patent license for this particular work, or (3) arrange, in a manner
 588 |     | consistent with the requirements of this License, to extend the patent
 589 |     | license to downstream recipients.  "Knowingly relying" means you have
 590 |     | actual knowledge that, but for the patent license, your conveying the
 591 |     | covered work in a country, or your recipient's use of the covered work
 592 |     | in a country, would infringe one or more identifiable patents in that
 593 |     | country that you have reason to believe are valid.
 594 |     | 
 595 |     |   If, pursuant to or in connection with a single transaction or
 596 |     | arrangement, you convey, or propagate by procuring conveyance of, a
 597 |     | covered work, and grant a patent license to some of the parties
 598 |     | receiving the covered work authorizing them to use, propagate, modify
 599 |     | or convey a specific copy of the covered work, then the patent license
 600 |     | you grant is automatically extended to all recipients of the covered
 601 |     | work and works based on it.
 602 |     | 
 603 |     |   A patent license is "discriminatory" if it does not include within
 604 |     | the scope of its coverage, prohibits the exercise of, or is
 605 |     | conditioned on the non-exercise of one or more of the rights that are
 606 |     | specifically granted under this License.  You may not convey a covered
 607 |     | work if you are a party to an arrangement with a third party that is
 608 |     | in the business of distributing software, under which you make payment
 609 |     | to the third party based on the extent of your activity of conveying
 610 |     | the work, and under which the third party grants, to any of the
 611 |     | parties who would receive the covered work from you, a discriminatory
 612 |     | patent license (a) in connection with copies of the covered work
 613 |     | conveyed by you (or copies made from those copies), or (b) primarily
 614 |     | for and in connection with specific products or compilations that
 615 |     | contain the covered work, unless you entered into that arrangement,
 616 |     | or that patent license was granted, prior to 28 March 2007.
 617 |     | 
 618 |     |   Nothing in this License shall be construed as excluding or limiting
 619 |     | any implied license or other defenses to infringement that may
 620 |     | otherwise be available to you under applicable patent law.
 621 |     | 
 622 |     |   12. No Surrender of Others' Freedom.
 623 |     | 
 624 |     |   If conditions are imposed on you (whether by court order, agreement or
 625 |     | otherwise) that contradict the conditions of this License, they do not
 626 |     | excuse you from the conditions of this License.  If you cannot convey a
 627 |     | covered work so as to satisfy simultaneously your obligations under this
 628 |     | License and any other pertinent obligations, then as a consequence you may
 629 |     | not convey it at all.  For example, if you agree to terms that obligate you
 630 |     | to collect a royalty for further conveying from those to whom you convey
 631 |     | the Program, the only way you could satisfy both those terms and this
 632 |     | License would be to refrain entirely from conveying the Program.
 633 |     | 
 634 |     |   13. Use with the GNU Affero General Public License.
 635 |     | 
 636 |     |   Notwithstanding any other provision of this License, you have
 637 |     | permission to link or combine any covered work with a work licensed
 638 |     | under version 3 of the GNU Affero General Public License into a single
 639 |     | combined work, and to convey the resulting work.  The terms of this
 640 |     | License will continue to apply to the part which is the covered work,
 641 |     | but the special requirements of the GNU Affero General Public License,
 642 |     | section 13, concerning interaction through a network will apply to the
 643 |     | combination as such.
 644 |     | 
 645 |     |   14. Revised Versions of this License.
 646 |     | 
 647 |     |   The Free Software Foundation may publish revised and/or new versions of
 648 |     | the GNU General Public License from time to time.  Such new versions will
 649 |     | be similar in spirit to the present version, but may differ in detail to
 650 |     | address new problems or concerns.
 651 |     | 
 652 |     |   Each version is given a distinguishing version number.  If the
 653 |     | Program specifies that a certain numbered version of the GNU General
 654 |     | Public License "or any later version" applies to it, you have the
 655 |     | option of following the terms and conditions either of that numbered
 656 |     | version or of any later version published by the Free Software
 657 |     | Foundation.  If the Program does not specify a version number of the
 658 |     | GNU General Public License, you may choose any version ever published
 659 |     | by the Free Software Foundation.
 660 |     | 
 661 |     |   If the Program specifies that a proxy can decide which future
 662 |     | versions of the GNU General Public License can be used, that proxy's
 663 |     | public statement of acceptance of a version permanently authorizes you
 664 |     | to choose that version for the Program.
 665 |     | 
 666 |     |   Later license versions may give you additional or different
 667 |     | permissions.  However, no additional obligations are imposed on any
 668 |     | author or copyright holder as a result of your choosing to follow a
 669 |     | later version.
 670 |     | 
 671 |     |   15. Disclaimer of Warranty.
 672 |     | 
 673 |     |   THERE IS NO WARRANTY FOR THE PROGRAM, TO THE EXTENT PERMITTED BY
 674 |     | APPLICABLE LAW.  EXCEPT WHEN OTHERWISE STATED IN WRITING THE COPYRIGHT
 675 |     | HOLDERS AND/OR OTHER PARTIES PROVIDE THE PROGRAM "AS IS" WITHOUT WARRANTY
 676 |     | OF ANY KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING, BUT NOT LIMITED TO,
 677 |     | THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
 678 |     | PURPOSE.  THE ENTIRE RISK AS TO THE QUALITY AND PERFORMANCE OF THE PROGRAM
 679 |     | IS WITH YOU.  SHOULD THE PROGRAM PROVE DEFECTIVE, YOU ASSUME THE COST OF
 680 |     | ALL NECESSARY SERVICING, REPAIR OR CORRECTION.
 681 |     | 
 682 |     |   16. Limitation of Liability.
 683 |     | 
 684 |     |   IN NO EVENT UNLESS REQUIRED BY APPLICABLE LAW OR AGREED TO IN WRITING
 685 |     | WILL ANY COPYRIGHT HOLDER, OR ANY OTHER PARTY WHO MODIFIES AND/OR CONVEYS
 686 |     | THE PROGRAM AS PERMITTED ABOVE, BE LIABLE TO YOU FOR DAMAGES, INCLUDING ANY
 687 |     | GENERAL, SPECIAL, INCIDENTAL OR CONSEQUENTIAL DAMAGES ARISING OUT OF THE
 688 |     | USE OR INABILITY TO USE THE PROGRAM (INCLUDING BUT NOT LIMITED TO LOSS OF
 689 |     | DATA OR DATA BEING RENDERED INACCURATE OR LOSSES SUSTAINED BY YOU OR THIRD
 690 |     | PARTIES OR A FAILURE OF THE PROGRAM TO OPERATE WITH ANY OTHER PROGRAMS),
 691 |     | EVEN IF SUCH HOLDER OR OTHER PARTY HAS BEEN ADVISED OF THE POSSIBILITY OF
 692 |     | SUCH DAMAGES.
 693 |     | 
 694 |     |   17. Interpretation of Sections 15 and 16.
 695 |     | 
 696 |     |   If the disclaimer of warranty and limitation of liability provided
 697 |     | above cannot be given local legal effect according to their terms,
 698 |     | reviewing courts shall apply local law that most closely approximates
 699 |     | an absolute waiver of all civil liability in connection with the
 700 |     | Program, unless a warranty or assumption of liability accompanies a
 701 |     | copy of the Program in return for a fee.
 702 |     | 
 703 |     |                      END OF TERMS AND CONDITIONS
 704 |     | 
 705 |     |             How to Apply These Terms to Your New Programs
 706 |     | 
 707 |     |   If you develop a new program, and you want it to be of the greatest
 708 |     | possible use to the public, the best way to achieve this is to make it
 709 |     | free software which everyone can redistribute and change under these terms.
 710 |     | 
 711 |     |   To do so, attach the following notices to the program.  It is safest
 712 |     | to attach them to the start of each source file to most effectively
 713 |     | state the exclusion of warranty; and each file should have at least
 714 |     | the "copyright" line and a pointer to where the full notice is found.
 715 |     | 
 716 |     |     <one line to give the program's name and a brief idea of what it does.>
 717 |     |     Copyright (C) <year>  <name of author>
 718 |     | 
 719 |     |     This program is free software: you can redistribute it and/or modify
 720 |     |     it under the terms of the GNU General Public License as published by
 721 |     |     the Free Software Foundation, either version 3 of the License, or
 722 |     |     (at your option) any later version.
 723 |     | 
 724 |     |     This program is distributed in the hope that it will be useful,
 725 |     |     but WITHOUT ANY WARRANTY; without even the implied warranty of
 726 |     |     MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 727 |     |     GNU General Public License for more details.
 728 |     | 
 729 |     |     You should have received a copy of the GNU General Public License
 730 |     |     along with this program.  If not, see <http://www.gnu.org/licenses/>.
 731 |     | 
 732 |     | Also add information on how to contact you by electronic and paper mail.
 733 |     | 
 734 |     |   If the program does terminal interaction, make it output a short
 735 |     | notice like this when it starts in an interactive mode:
 736 |     | 
 737 |     |     <program>  Copyright (C) <year>  <name of author>
 738 |     |     This program comes with ABSOLUTELY NO WARRANTY; for details type `show w'.
 739 |     |     This is free software, and you are welcome to redistribute it
 740 |     |     under certain conditions; type `show c' for details.
 741 |     | 
 742 |     | The hypothetical commands `show w' and `show c' should show the appropriate
 743 |     | parts of the General Public License.  Of course, your program's commands
 744 |     | might be different; for a GUI interface, you would use an "about box".
 745 |     | 
 746 |     |   You should also get your employer (if you work as a programmer) or school,
 747 |     | if any, to sign a "copyright disclaimer" for the program, if necessary.
 748 |     | For more information on this, and how to apply and follow the GNU GPL, see
 749 |     | <http://www.gnu.org/licenses/>.
 750 |     | 
 751 |     |   The GNU General Public License does not permit incorporating your program
 752 |     | into proprietary programs.  If your program is a subroutine library, you
 753 |     | may consider it more useful to permit linking proprietary applications with
 754 |     | the library.  If this is what you want to do, use the GNU Lesser General
 755 |     | Public License instead of this License.  But first, please read
 756 |     | <http://www.gnu.org/philosophy/why-not-lgpl.html>.
 757 |     | 
 758 |     | */
 759 |     | 

/mnt/c/Users/Lourens/Documents/Recon-Fuzz/collabs/ebtc/packages/contracts/contracts/TestContracts/invariants/Actor.sol
  1 |     | pragma solidity 0.8.17;
  2 |     | 
  3 |     | import {IERC3156FlashBorrower} from "../../Interfaces/IERC3156FlashBorrower.sol";
  4 |     | import {IERC20} from "../../Dependencies/IERC20.sol";
  5 |     | 
  6 | *   | contract Actor is IERC3156FlashBorrower {
  7 |     |     address[] internal tokens;
  8 |     |     address[] internal callers;
  9 |     | 
 10 |     |     constructor(address[] memory _tokens, address[] memory _callers) payable {
 11 |     |         tokens = _tokens;
 12 |     |         callers = _callers;
 13 |     |         for (uint256 i = 0; i < tokens.length; i++) {
 14 |     |             IERC20(tokens[i]).approve(callers[i], type(uint256).max);
 15 |     |         }
 16 |     |     }
 17 |     | 
 18 | *   |     function proxy(
 19 |     |         address _target,
 20 |     |         bytes memory _calldata
 21 | *   |     ) public returns (bool success, bytes memory returnData) {
 22 | *   |         (success, returnData) = address(_target).call(_calldata);
 23 |     |     }
 24 |     | 
 25 |     |     function proxy(
 26 |     |         address _target,
 27 |     |         bytes memory _calldata,
 28 |     |         uint256 value
 29 |     |     ) public returns (bool success, bytes memory returnData) {
 30 |     |         (success, returnData) = address(_target).call{value: value}(_calldata);
 31 |     |     }
 32 |     | 
 33 |     |     receive() external payable {}
 34 |     | 
 35 |     |     // callback for flashloan
 36 | *   |     function onFlashLoan(
 37 |     |         address,
 38 |     |         address token,
 39 |     |         uint256 amount,
 40 |     |         uint256 fee,
 41 |     |         bytes calldata data
 42 | *   |     ) external override returns (bytes32) {
 43 |     |         bool isValidCaller = false;
 44 | *   |         for (uint256 i = 0; i < tokens.length; i++) {
 45 | *   |             if (token == tokens[i]) {
 46 | *   |                 isValidCaller = msg.sender == callers[i];
 47 | *   |                 break;
 48 |     |             }
 49 |     |         }
 50 | *   |         require(isValidCaller, "Invalid caller");
 51 |     | 
 52 | *   |         if (data.length != 0) {
 53 | *   |             (address[] memory _targets, bytes[] memory _calldatas) = abi.decode(
 54 | *   |                 data,
 55 |     |                 (address[], bytes[])
 56 |     |             );
 57 | *   |             for (uint256 i = 0; i < _targets.length; ++i) {
 58 | *   |                 (bool success, ) = address(_targets[i]).call(_calldatas[i]);
 59 | *   |                 require(success);
 60 |     |             }
 61 |     |         }
 62 |     | 
 63 | *   |         IERC20(token).approve(msg.sender, amount + fee);
 64 |     | 
 65 | *   |         return keccak256("ERC3156FlashBorrower.onFlashLoan");
 66 |     |     }
 67 |     | }
 68 |     | 

/mnt/c/Users/Lourens/Documents/Recon-Fuzz/collabs/ebtc/packages/contracts/contracts/TestContracts/invariants/Asserts.sol
   1 |     | pragma solidity 0.8.17;
   2 |     | 
   3 |     | abstract contract Asserts {
   4 |     |     event L1(uint256);
   5 |     |     event L2(uint256, uint256);
   6 |     |     event L3(uint256, uint256, uint256);
   7 |     |     event L4(uint256, uint256, uint256, uint256);
   8 |     | 
   9 |     |     function gt(uint256 a, uint256 b, string memory reason) internal virtual;
  10 |     | 
  11 |     |     function gte(uint256 a, uint256 b, string memory reason) internal virtual;
  12 |     | 
  13 |     |     function lt(uint256 a, uint256 b, string memory reason) internal virtual;
  14 |     | 
  15 |     |     function lte(uint256 a, uint256 b, string memory reason) internal virtual;
  16 |     | 
  17 |     |     function eq(uint256 a, uint256 b, string memory reason) internal virtual;
  18 |     | 
  19 |     |     function t(bool b, string memory reason) internal virtual;
  20 |     | 
  21 |     |     function between(uint256 value, uint256 low, uint256 high) internal virtual returns (uint256);
  22 |     | 
  23 |     |     function isApproximateEq(
  24 |     |         uint256 _num1,
  25 |     |         uint256 _num2,
  26 |     |         uint256 _tolerance
  27 |     |     ) internal pure returns (bool) {
  28 |     |         return diffPercent(_num1, _num2) <= _tolerance;
  29 |     |     }
  30 |     | 
  31 |     |     function diffPercent(uint256 _num1, uint256 _num2) internal pure returns (uint256) {
  32 |     |         if (_num1 == _num2) return 0;
  33 |     |         else if (_num1 > _num2) {
  34 |     |             return ((_num1 - _num2) * 1e18) / ((_num1 + _num2) / 2);
  35 |     |         } else {
  36 |     |             return ((_num2 - _num1) * 1e18) / ((_num1 + _num2) / 2);
  37 |     |         }
  38 |     |     }
  39 |     | 
  40 |     |     /// @dev compare absoulte value
  41 |     |     function _assertApproximateEq(
  42 |     |         uint256 _num1,
  43 |     |         uint256 _num2,
  44 |     |         uint256 _tolerance
  45 |     |     ) internal pure returns (bool) {
  46 |     |         if (_num1 > _num2) {
  47 |     |             return _tolerance >= (_num1 - _num2);
  48 |     |         } else {
  49 |     |             return _tolerance >= (_num2 - _num1);
  50 |     |         }
  51 |     |     }
  52 |     | 
  53 |     |     // https://ethereum.stackexchange.com/a/83577
  54 | *   |     function _getRevertMsg(bytes memory returnData) internal pure returns (string memory) {
  55 |     |         // Check that the data has the right size: 4 bytes for signature + 32 bytes for panic code
  56 | *   |         if (returnData.length == 4 + 32) {
  57 |     |             // Check that the data starts with the Panic signature
  58 |     |             bytes4 panicSignature = bytes4(keccak256(bytes("Panic(uint256)")));
  59 |     |             for (uint i = 0; i < 4; i++) {
  60 |     |                 if (returnData[i] != panicSignature[i]) return "Undefined signature";
  61 |     |             }
  62 |     | 
  63 |     |             uint256 panicCode;
  64 |     |             for (uint i = 4; i < 36; i++) {
  65 |     |                 panicCode = panicCode << 8;
  66 |     |                 panicCode |= uint8(returnData[i]);
  67 |     |             }
  68 |     | 
  69 |     |             // Now convert the panic code into its string representation
  70 |     |             if (panicCode == 17) {
  71 |     |                 return "Panic(17)";
  72 |     |             }
  73 |     | 
  74 |     |             // Add other panic codes as needed or return a generic "Unknown panic"
  75 |     |             return "Undefined panic code";
  76 |     |         }
  77 |     | 
  78 |     |         // If the returnData length is less than 68, then the transaction failed silently (without a revert message)
  79 | *   |         if (returnData.length < 68) return "Transaction reverted silently";
  80 |     | 
  81 |     |         assembly {
  82 |     |             // Slice the sighash.
  83 | *   |             returnData := add(returnData, 0x04)
  84 |     |         }
  85 | *   |         return abi.decode(returnData, (string)); // All that remains is the revert string
  86 |     |     }
  87 |     | 
  88 | *   |     function _isRevertReasonEqual(
  89 |     |         bytes memory returnData,
  90 |     |         string memory reason
  91 | *   |     ) internal pure returns (bool) {
  92 | *   |         return (keccak256(abi.encodePacked(_getRevertMsg(returnData))) ==
  93 | *   |             keccak256(abi.encodePacked(reason)));
  94 |     |     }
  95 |     | 
  96 | *   |     function max(uint256 a, uint256 b) internal pure returns (uint256) {
  97 | *   |         return a >= b ? a : b;
  98 |     |     }
  99 |     | 
 100 | *   |     function min(uint256 a, uint256 b) internal pure returns (uint256) {
 101 | *   |         return a < b ? a : b;
 102 |     |     }
 103 |     | 
 104 | *   |     function assertRevertReasonNotEqual(bytes memory returnData, string memory reason) internal {
 105 | *   |         bool isEqual = _isRevertReasonEqual(returnData, reason);
 106 | *   |         t(!isEqual, reason);
 107 |     |     }
 108 |     | 
 109 |     |     function assertRevertReasonEqual(bytes memory returnData, string memory reason) internal {
 110 |     |         bool isEqual = _isRevertReasonEqual(returnData, reason);
 111 |     |         t(isEqual, reason);
 112 |     |     }
 113 |     | 
 114 |     |     function assertRevertReasonEqual(
 115 |     |         bytes memory returnData,
 116 |     |         string memory reason1,
 117 |     |         string memory reason2
 118 |     |     ) internal {
 119 |     |         bool isEqual = _isRevertReasonEqual(returnData, reason1) ||
 120 |     |             _isRevertReasonEqual(returnData, reason2);
 121 |     |         t(isEqual, string.concat(reason1, " OR ", reason2));
 122 |     |     }
 123 |     | 
 124 |     |     function assertRevertReasonEqual(
 125 |     |         bytes memory returnData,
 126 |     |         string memory reason1,
 127 |     |         string memory reason2,
 128 |     |         string memory reason3
 129 |     |     ) internal {
 130 |     |         bool isEqual = _isRevertReasonEqual(returnData, reason1) ||
 131 |     |             _isRevertReasonEqual(returnData, reason2) ||
 132 |     |             _isRevertReasonEqual(returnData, reason3);
 133 |     |         t(isEqual, string.concat(reason1, " OR ", reason2, " OR ", reason3));
 134 |     |     }
 135 |     | 
 136 |     |     function assertRevertReasonEqual(
 137 |     |         bytes memory returnData,
 138 |     |         string memory reason1,
 139 |     |         string memory reason2,
 140 |     |         string memory reason3,
 141 |     |         string memory reason4
 142 |     |     ) internal {
 143 |     |         bool isEqual = _isRevertReasonEqual(returnData, reason1) ||
 144 |     |             _isRevertReasonEqual(returnData, reason2) ||
 145 |     |             _isRevertReasonEqual(returnData, reason3) ||
 146 |     |             _isRevertReasonEqual(returnData, reason4);
 147 |     |         t(isEqual, string.concat(reason1, " OR ", reason2, " OR ", reason3, " OR ", reason4));
 148 |     |     }
 149 |     | }
 150 |     | 

/mnt/c/Users/Lourens/Documents/Recon-Fuzz/collabs/ebtc/packages/contracts/contracts/TestContracts/invariants/BeforeAfter.sol
   1 |     | pragma solidity 0.8.17;
   2 |     | 
   3 |     | import {Pretty, Strings} from "../Pretty.sol";
   4 |     | import {BaseStorageVariables} from "../BaseStorageVariables.sol";
   5 |     | 
   6 |     | abstract contract BeforeAfter is BaseStorageVariables {
   7 |     |     using Strings for string;
   8 |     |     using Pretty for uint256;
   9 |     |     using Pretty for int256;
  10 |     |     using Pretty for bool;
  11 |     | 
  12 |     |     struct Vars {
  13 |     |         uint256 userSurplusBefore;
  14 |     |         uint256 userSurplusAfter;
  15 |     |         uint256 valueInSystemBefore;
  16 |     |         uint256 valueInSystemAfter;
  17 |     |         uint256 nicrBefore;
  18 |     |         uint256 nicrAfter;
  19 |     |         uint256 icrBefore;
  20 |     |         uint256 icrAfter;
  21 |     |         uint256 newIcrBefore;
  22 |     |         uint256 newIcrAfter;
  23 |     |         uint256 feeSplitBefore;
  24 |     |         uint256 feeSplitAfter;
  25 |     |         uint256 feeRecipientTotalCollBefore;
  26 |     |         uint256 feeRecipientTotalCollAfter;
  27 |     |         uint256 feeRecipientCollSharesBefore;
  28 |     |         uint256 feeRecipientCollSharesAfter;
  29 |     |         uint256 actorCollBefore;
  30 |     |         uint256 actorCollAfter;
  31 |     |         uint256 actorEbtcBefore;
  32 |     |         uint256 actorEbtcAfter;
  33 |     |         uint256 actorCdpCountBefore;
  34 |     |         uint256 actorCdpCountAfter;
  35 |     |         uint256 cdpCollBefore;
  36 |     |         uint256 cdpCollAfter;
  37 |     |         uint256 cdpDebtBefore;
  38 |     |         uint256 cdpDebtAfter;
  39 |     |         uint256 cdpStakeBefore;
  40 |     |         uint256 cdpStakeAfter;
  41 |     |         uint256 liquidatorRewardSharesBefore;
  42 |     |         uint256 liquidatorRewardSharesAfter;
  43 |     |         uint256 sortedCdpsSizeBefore;
  44 |     |         uint256 sortedCdpsSizeAfter;
  45 |     |         uint256 cdpStatusBefore;
  46 |     |         uint256 cdpStatusAfter;
  47 |     |         uint256 tcrBefore;
  48 |     |         uint256 tcrAfter;
  49 |     |         uint256 newTcrBefore;
  50 |     |         uint256 newTcrAfter;
  51 |     |         uint256 ebtcTotalSupplyBefore;
  52 |     |         uint256 ebtcTotalSupplyAfter;
  53 |     |         uint256 ethPerShareBefore;
  54 |     |         uint256 ethPerShareAfter;
  55 |     |         uint256 activePoolCollBefore;
  56 |     |         uint256 activePoolCollAfter;
  57 |     |         uint256 activePoolDebtBefore;
  58 |     |         uint256 activePoolDebtAfter;
  59 |     |         uint256 collSurplusPoolBefore;
  60 |     |         uint256 collSurplusPoolAfter;
  61 |     |         uint256 priceBefore;
  62 |     |         uint256 priceAfter;
  63 |     |         bool isRecoveryModeBefore;
  64 |     |         bool isRecoveryModeAfter;
  65 |     |         uint256 lastGracePeriodStartTimestampBefore;
  66 |     |         uint256 lastGracePeriodStartTimestampAfter;
  67 |     |         bool lastGracePeriodStartTimestampIsSetBefore;
  68 |     |         bool lastGracePeriodStartTimestampIsSetAfter;
  69 |     |         bool hasGracePeriodPassedBefore;
  70 |     |         bool hasGracePeriodPassedAfter;
  71 |     |         uint256 systemDebtRedistributionIndexBefore;
  72 |     |         uint256 systemDebtRedistributionIndexAfter;
  73 |     |         uint256 feeRecipientCollSharesBalBefore;
  74 |     |         uint256 feeRecipientCollSharesBalAfter;
  75 |     |         uint256 cumulativeCdpsAtTimeOfRebase;
  76 |     |         uint256 prevStEthFeeIndex;
  77 |     |         uint256 afterStEthFeeIndex;
  78 |     |         uint256 totalStakesBefore;
  79 |     |         uint256 totalStakesAfter;
  80 |     |         uint256 totalStakesSnapshotBefore;
  81 |     |         uint256 totalStakesSnapshotAfter;
  82 |     |         uint256 totalCollateralSnapshotBefore;
  83 |     |         uint256 totalCollateralSnapshotAfter;
  84 |     |     }
  85 |     | 
  86 |     |     Vars vars;
  87 |     |     struct Cdp {
  88 |     |         bytes32 id;
  89 |     |         uint256 icr;
  90 |     |     }
  91 |     | 
  92 | *   |     function _before(bytes32 _cdpId) internal {
  93 | *   |         vars.priceBefore = priceFeedMock.fetchPrice();
  94 |     | 
  95 | *   |         address ownerToCheck = sortedCdps.getOwnerAddress(_cdpId);
  96 | *   |         vars.userSurplusBefore = collSurplusPool.getSurplusCollShares(ownerToCheck);
  97 |     | 
  98 | *   |         (uint256 debtBefore, uint256 collBefore) = cdpManager.getSyncedDebtAndCollShares(_cdpId);
  99 |     | 
 100 | *   |         vars.nicrBefore = _cdpId != bytes32(0) ? crLens.quoteRealNICR(_cdpId) : 0;
 101 | *   |         vars.icrBefore = _cdpId != bytes32(0)
 102 | *   |             ? cdpManager.getCachedICR(_cdpId, vars.priceBefore)
 103 | *   |             : 0;
 104 | *   |         vars.cdpCollBefore = _cdpId != bytes32(0) ? collBefore : 0;
 105 | *   |         vars.cdpDebtBefore = _cdpId != bytes32(0) ? debtBefore : 0;
 106 | *r  |         vars.cdpStakeBefore = _cdpId != bytes32(0) ? crLens.getRealStake(_cdpId) : 0;
 107 | *   |         vars.liquidatorRewardSharesBefore = _cdpId != bytes32(0)
 108 | *   |             ? cdpManager.getCdpLiquidatorRewardShares(_cdpId)
 109 | *   |             : 0;
 110 | *   |         vars.cdpStatusBefore = _cdpId != bytes32(0) ? cdpManager.getCdpStatus(_cdpId) : 0;
 111 |     | 
 112 | *   |         vars.isRecoveryModeBefore = crLens.quoteCheckRecoveryMode() == 1; /// @audit crLens
 113 | *   |         (vars.feeSplitBefore, , ) = collateral.getPooledEthByShares(cdpManager.DECIMAL_PRECISION()) >
 114 | *   |             cdpManager.stEthIndex()
 115 | *   |             ? cdpManager.calcFeeUponStakingReward(
 116 |     |                 collateral.getPooledEthByShares(cdpManager.DECIMAL_PRECISION()),
 117 |     |                 cdpManager.stEthIndex()
 118 |     |             )
 119 | *   |             : (0, 0, 0);
 120 | *   |         vars.feeRecipientTotalCollBefore = collateral.balanceOf(activePool.feeRecipientAddress());
 121 | *   |         vars.feeRecipientCollSharesBefore = activePool.getFeeRecipientClaimableCollShares();
 122 | *   |         vars.feeRecipientCollSharesBalBefore = collateral.sharesOf(activePool.feeRecipientAddress());
 123 | *   |         vars.actorCollBefore = collateral.balanceOf(address(actor));
 124 | *   |         vars.actorEbtcBefore = eBTCToken.balanceOf(address(actor));
 125 | *   |         vars.actorCdpCountBefore = sortedCdps.cdpCountOf(address(actor));
 126 | *   |         vars.sortedCdpsSizeBefore = sortedCdps.getSize();
 127 | *   |         vars.tcrBefore = cdpManager.getCachedTCR(vars.priceBefore);
 128 | *   |         vars.ebtcTotalSupplyBefore = eBTCToken.totalSupply();
 129 | *   |         vars.ethPerShareBefore = collateral.getPooledEthByShares(1e18);
 130 | *   |         vars.activePoolDebtBefore = activePool.getSystemDebt();
 131 | *   |         vars.activePoolCollBefore = activePool.getSystemCollShares();
 132 | *   |         vars.collSurplusPoolBefore = collSurplusPool.getTotalSurplusCollShares();
 133 | *   |         vars.lastGracePeriodStartTimestampBefore = cdpManager.lastGracePeriodStartTimestamp();
 134 | *   |         vars.lastGracePeriodStartTimestampIsSetBefore =
 135 | *   |             cdpManager.lastGracePeriodStartTimestamp() != cdpManager.UNSET_TIMESTAMP();
 136 | *   |         vars.hasGracePeriodPassedBefore =
 137 | *   |             cdpManager.lastGracePeriodStartTimestamp() != cdpManager.UNSET_TIMESTAMP() &&
 138 | *   |             block.timestamp >
 139 | *   |             cdpManager.lastGracePeriodStartTimestamp() +
 140 | *   |                 cdpManager.recoveryModeGracePeriodDuration();
 141 | *   |         vars.systemDebtRedistributionIndexBefore = cdpManager.systemDebtRedistributionIndex();
 142 | *   |         vars.newTcrBefore = crLens.quoteRealTCR();
 143 | *   |         vars.newIcrBefore = _cdpId != bytes32(0) ? crLens.quoteRealICR(_cdpId) : 0;
 144 |     | 
 145 |     |         vars.valueInSystemBefore ==
 146 | *   |             (collateral.getPooledEthByShares(
 147 | *   |                 vars.activePoolCollBefore +
 148 | *   |                     vars.collSurplusPoolBefore +
 149 | *   |                     vars.feeRecipientTotalCollBefore
 150 | *   |             ) * vars.priceBefore) /
 151 | *   |                 1e18 -
 152 | *   |                 vars.activePoolDebtBefore;
 153 | *   |         vars.prevStEthFeeIndex = cdpManager.systemStEthFeePerUnitIndex();
 154 |     | 
 155 | *   |         vars.totalStakesBefore = cdpManager.totalStakes();
 156 | *   |         vars.totalStakesSnapshotBefore = cdpManager.totalStakesSnapshot();
 157 | *   |         vars.totalCollateralSnapshotBefore = cdpManager.totalCollateralSnapshot();
 158 |     |     }
 159 |     | 
 160 | *   |     function _after(bytes32 _cdpId) internal {
 161 | *   |         address ownerToCheck = sortedCdps.getOwnerAddress(_cdpId);
 162 | *   |         vars.userSurplusAfter = collSurplusPool.getSurplusCollShares(ownerToCheck);
 163 |     | 
 164 | *   |         vars.priceAfter = priceFeedMock.fetchPrice();
 165 |     | 
 166 | *   |         (, uint256 collAfter) = cdpManager.getSyncedDebtAndCollShares(_cdpId);
 167 |     | 
 168 | *   |         vars.nicrAfter = _cdpId != bytes32(0) ? crLens.quoteRealNICR(_cdpId) : 0;
 169 | *   |         vars.icrAfter = _cdpId != bytes32(0) ? cdpManager.getCachedICR(_cdpId, vars.priceAfter) : 0;
 170 | *   |         vars.cdpCollAfter = _cdpId != bytes32(0) ? collAfter : 0;
 171 | *   |         vars.cdpDebtAfter = _cdpId != bytes32(0) ? cdpManager.getCdpDebt(_cdpId) : 0;
 172 | *r  |         vars.cdpStakeAfter = _cdpId != bytes32(0) ? crLens.getRealStake(_cdpId) : 0;
 173 | *   |         vars.liquidatorRewardSharesAfter = _cdpId != bytes32(0)
 174 | *   |             ? cdpManager.getCdpLiquidatorRewardShares(_cdpId)
 175 | *   |             : 0;
 176 | *   |         vars.cdpStatusAfter = _cdpId != bytes32(0) ? cdpManager.getCdpStatus(_cdpId) : 0;
 177 |     | 
 178 | *   |         vars.isRecoveryModeAfter = cdpManager.checkRecoveryMode(vars.priceAfter); /// @audit This is fine as is because after the system is synched
 179 | *   |         (vars.feeSplitAfter, , ) = collateral.getPooledEthByShares(cdpManager.DECIMAL_PRECISION()) >
 180 | *   |             cdpManager.stEthIndex()
 181 | *   |             ? cdpManager.calcFeeUponStakingReward(
 182 |     |                 collateral.getPooledEthByShares(cdpManager.DECIMAL_PRECISION()),
 183 |     |                 cdpManager.stEthIndex()
 184 |     |             )
 185 | *   |             : (0, 0, 0);
 186 |     | 
 187 | *   |         vars.feeRecipientTotalCollAfter = collateral.balanceOf(activePool.feeRecipientAddress());
 188 | *   |         vars.feeRecipientCollSharesAfter = activePool.getFeeRecipientClaimableCollShares();
 189 | *   |         vars.feeRecipientCollSharesBalAfter = collateral.sharesOf(activePool.feeRecipientAddress());
 190 | *   |         vars.actorCollAfter = collateral.balanceOf(address(actor));
 191 | *   |         vars.actorEbtcAfter = eBTCToken.balanceOf(address(actor));
 192 | *   |         vars.actorCdpCountAfter = sortedCdps.cdpCountOf(address(actor));
 193 | *   |         vars.sortedCdpsSizeAfter = sortedCdps.getSize();
 194 | *   |         vars.tcrAfter = cdpManager.getCachedTCR(vars.priceAfter);
 195 | *   |         vars.ebtcTotalSupplyAfter = eBTCToken.totalSupply();
 196 | *   |         vars.ethPerShareAfter = collateral.getPooledEthByShares(1e18);
 197 | *   |         vars.activePoolDebtAfter = activePool.getSystemDebt();
 198 | *   |         vars.activePoolCollAfter = activePool.getSystemCollShares();
 199 | *   |         vars.collSurplusPoolAfter = collSurplusPool.getTotalSurplusCollShares();
 200 | *   |         vars.lastGracePeriodStartTimestampAfter = cdpManager.lastGracePeriodStartTimestamp();
 201 | *   |         vars.lastGracePeriodStartTimestampIsSetAfter =
 202 | *   |             cdpManager.lastGracePeriodStartTimestamp() != cdpManager.UNSET_TIMESTAMP();
 203 | *   |         vars.hasGracePeriodPassedAfter =
 204 | *   |             cdpManager.lastGracePeriodStartTimestamp() != cdpManager.UNSET_TIMESTAMP() &&
 205 | *   |             block.timestamp >
 206 | *   |             cdpManager.lastGracePeriodStartTimestamp() +
 207 | *   |                 cdpManager.recoveryModeGracePeriodDuration();
 208 | *   |         vars.systemDebtRedistributionIndexAfter = cdpManager.systemDebtRedistributionIndex();
 209 |     | 
 210 | *   |         vars.newTcrAfter = crLens.quoteRealTCR();
 211 | *   |         vars.newIcrAfter = _cdpId != bytes32(0) ? crLens.quoteRealICR(_cdpId) : 0;
 212 |     | 
 213 |     |         // Value in system after
 214 | *   |         vars.valueInSystemAfter =
 215 | *   |             (collateral.getPooledEthByShares(
 216 | *   |                 vars.activePoolCollAfter +
 217 | *   |                     vars.collSurplusPoolAfter +
 218 | *   |                     vars.feeRecipientTotalCollAfter
 219 | *   |             ) * vars.priceAfter) /
 220 | *   |             1e18 -
 221 | *   |             vars.activePoolDebtAfter;
 222 | *   |         vars.afterStEthFeeIndex = cdpManager.systemStEthFeePerUnitIndex();
 223 |     | 
 224 | *   |         if (vars.afterStEthFeeIndex > vars.prevStEthFeeIndex) {
 225 | *   |             vars.cumulativeCdpsAtTimeOfRebase += cdpManager.getActiveCdpsCount();
 226 |     |         }
 227 |     | 
 228 | *   |         vars.totalStakesAfter = cdpManager.totalStakes();
 229 | *   |         vars.totalStakesSnapshotAfter = cdpManager.totalStakesSnapshot();
 230 | *   |         vars.totalCollateralSnapshotAfter = cdpManager.totalCollateralSnapshot();
 231 |     |     }
 232 |     | 
 233 |     |     function _diff() internal view returns (string memory log) {
 234 |     |         log = string("\n\t\t\t\tBefore\t\t\tAfter\n");
 235 |     |         if (vars.activePoolCollBefore != vars.activePoolCollAfter) {
 236 |     |             log = log
 237 |     |                 .concat("activePoolColl\t\t\t")
 238 |     |                 .concat(vars.activePoolCollBefore.pretty())
 239 |     |                 .concat("\t")
 240 |     |                 .concat(vars.activePoolCollAfter.pretty())
 241 |     |                 .concat("\n");
 242 |     |         }
 243 |     |         if (vars.collSurplusPoolBefore != vars.collSurplusPoolAfter) {
 244 |     |             log = log
 245 |     |                 .concat("collSurplusPool\t\t\t")
 246 |     |                 .concat(vars.collSurplusPoolBefore.pretty())
 247 |     |                 .concat("\t")
 248 |     |                 .concat(vars.collSurplusPoolAfter.pretty())
 249 |     |                 .concat("\n");
 250 |     |         }
 251 |     |         if (vars.nicrBefore != vars.nicrAfter) {
 252 |     |             log = log
 253 |     |                 .concat("nicr\t\t\t\t")
 254 |     |                 .concat(vars.nicrBefore.pretty())
 255 |     |                 .concat("\t")
 256 |     |                 .concat(vars.nicrAfter.pretty())
 257 |     |                 .concat("\n");
 258 |     |         }
 259 |     |         if (vars.icrBefore != vars.icrAfter) {
 260 |     |             log = log
 261 |     |                 .concat("icr\t\t\t\t")
 262 |     |                 .concat(vars.icrBefore.pretty())
 263 |     |                 .concat("\t")
 264 |     |                 .concat(vars.icrAfter.pretty())
 265 |     |                 .concat("\n");
 266 |     |         }
 267 |     |         if (vars.newIcrBefore != vars.newIcrAfter) {
 268 |     |             log = log
 269 |     |                 .concat("newIcr\t\t\t\t")
 270 |     |                 .concat(vars.newIcrBefore.pretty())
 271 |     |                 .concat("\t")
 272 |     |                 .concat(vars.newIcrAfter.pretty())
 273 |     |                 .concat("\n");
 274 |     |         }
 275 |     |         if (vars.feeSplitBefore != vars.feeSplitAfter) {
 276 |     |             log = log
 277 |     |                 .concat("feeSplit\t\t\t\t")
 278 |     |                 .concat(vars.feeSplitBefore.pretty())
 279 |     |                 .concat("\t")
 280 |     |                 .concat(vars.feeSplitAfter.pretty())
 281 |     |                 .concat("\n");
 282 |     |         }
 283 |     |         if (vars.feeRecipientTotalCollBefore != vars.feeRecipientTotalCollAfter) {
 284 |     |             log = log
 285 |     |                 .concat("feeRecipientTotalColl\t")
 286 |     |                 .concat(vars.feeRecipientTotalCollBefore.pretty())
 287 |     |                 .concat("\t")
 288 |     |                 .concat(vars.feeRecipientTotalCollAfter.pretty())
 289 |     |                 .concat("\n");
 290 |     |         }
 291 |     |         if (vars.actorCollBefore != vars.actorCollAfter) {
 292 |     |             log = log
 293 |     |                 .concat("actorColl\t\t\t\t")
 294 |     |                 .concat(vars.actorCollBefore.pretty())
 295 |     |                 .concat("\t")
 296 |     |                 .concat(vars.actorCollAfter.pretty())
 297 |     |                 .concat("\n");
 298 |     |         }
 299 |     |         if (vars.actorEbtcBefore != vars.actorEbtcAfter) {
 300 |     |             log = log
 301 |     |                 .concat("actorEbtc\t\t\t\t")
 302 |     |                 .concat(vars.actorEbtcBefore.pretty())
 303 |     |                 .concat("\t")
 304 |     |                 .concat(vars.actorEbtcAfter.pretty())
 305 |     |                 .concat("\n");
 306 |     |         }
 307 |     |         if (vars.actorCdpCountBefore != vars.actorCdpCountAfter) {
 308 |     |             log = log
 309 |     |                 .concat("actorCdpCount\t\t\t")
 310 |     |                 .concat(vars.actorCdpCountBefore.pretty())
 311 |     |                 .concat("\t")
 312 |     |                 .concat(vars.actorCdpCountAfter.pretty())
 313 |     |                 .concat("\n");
 314 |     |         }
 315 |     |         if (vars.cdpCollBefore != vars.cdpCollAfter) {
 316 |     |             log = log
 317 |     |                 .concat("cdpColl\t\t\t\t")
 318 |     |                 .concat(vars.cdpCollBefore.pretty())
 319 |     |                 .concat("\t")
 320 |     |                 .concat(vars.cdpCollAfter.pretty())
 321 |     |                 .concat("\n");
 322 |     |         }
 323 |     |         if (vars.cdpDebtBefore != vars.cdpDebtAfter) {
 324 |     |             log = log
 325 |     |                 .concat("cdpDebt\t\t\t\t")
 326 |     |                 .concat(vars.cdpDebtBefore.pretty())
 327 |     |                 .concat("\t")
 328 |     |                 .concat(vars.cdpDebtAfter.pretty())
 329 |     |                 .concat("\n");
 330 |     |         }
 331 |     |         if (vars.liquidatorRewardSharesBefore != vars.liquidatorRewardSharesAfter) {
 332 |     |             log = log
 333 |     |                 .concat("liquidatorRewardShares\t\t")
 334 |     |                 .concat(vars.liquidatorRewardSharesBefore.pretty())
 335 |     |                 .concat("\t")
 336 |     |                 .concat(vars.liquidatorRewardSharesAfter.pretty())
 337 |     |                 .concat("\n");
 338 |     |         }
 339 |     |         if (vars.sortedCdpsSizeBefore != vars.sortedCdpsSizeAfter) {
 340 |     |             log = log
 341 |     |                 .concat("sortedCdpsSize\t\t\t")
 342 |     |                 .concat(vars.sortedCdpsSizeBefore.pretty(0))
 343 |     |                 .concat("\t\t\t")
 344 |     |                 .concat(vars.sortedCdpsSizeAfter.pretty(0))
 345 |     |                 .concat("\n");
 346 |     |         }
 347 |     |         if (vars.cdpStatusBefore != vars.cdpStatusAfter) {
 348 |     |             log = log
 349 |     |                 .concat("cdpStatus\t\t\t")
 350 |     |                 .concat(vars.cdpStatusBefore.pretty(0))
 351 |     |                 .concat("\t\t\t")
 352 |     |                 .concat(vars.cdpStatusAfter.pretty(0))
 353 |     |                 .concat("\n");
 354 |     |         }
 355 |     |         if (vars.tcrBefore != vars.tcrAfter) {
 356 |     |             log = log
 357 |     |                 .concat("tcr\t\t\t\t")
 358 |     |                 .concat(vars.tcrBefore.pretty())
 359 |     |                 .concat("\t")
 360 |     |                 .concat(vars.tcrAfter.pretty())
 361 |     |                 .concat("\n");
 362 |     |         }
 363 |     |         if (vars.newTcrBefore != vars.newTcrAfter) {
 364 |     |             log = log
 365 |     |                 .concat("newTcr\t\t\t\t")
 366 |     |                 .concat(vars.newTcrBefore.pretty())
 367 |     |                 .concat("\t")
 368 |     |                 .concat(vars.newTcrAfter.pretty())
 369 |     |                 .concat("\n");
 370 |     |         }
 371 |     |         if (vars.ebtcTotalSupplyBefore != vars.ebtcTotalSupplyAfter) {
 372 |     |             log = log
 373 |     |                 .concat("ebtcTotalSupply\t\t\t")
 374 |     |                 .concat(vars.ebtcTotalSupplyBefore.pretty())
 375 |     |                 .concat("\t")
 376 |     |                 .concat(vars.ebtcTotalSupplyAfter.pretty())
 377 |     |                 .concat("\n");
 378 |     |         }
 379 |     |         if (vars.ethPerShareBefore != vars.ethPerShareAfter) {
 380 |     |             log = log
 381 |     |                 .concat("ethPerShare\t\t\t")
 382 |     |                 .concat(vars.ethPerShareBefore.pretty())
 383 |     |                 .concat("\t")
 384 |     |                 .concat(vars.ethPerShareAfter.pretty())
 385 |     |                 .concat("\n");
 386 |     |         }
 387 |     |         if (vars.isRecoveryModeBefore != vars.isRecoveryModeAfter) {
 388 |     |             log = log
 389 |     |                 .concat("isRecoveryMode\t\t\t")
 390 |     |                 .concat(vars.isRecoveryModeBefore.pretty())
 391 |     |                 .concat("\t")
 392 |     |                 .concat(vars.isRecoveryModeAfter.pretty())
 393 |     |                 .concat("\n");
 394 |     |         }
 395 |     |         if (vars.lastGracePeriodStartTimestampBefore != vars.lastGracePeriodStartTimestampAfter) {
 396 |     |             log = log
 397 |     |                 .concat("lastGracePeriodStartTimestamp\t")
 398 |     |                 .concat(vars.lastGracePeriodStartTimestampBefore.pretty())
 399 |     |                 .concat("\t")
 400 |     |                 .concat(vars.lastGracePeriodStartTimestampAfter.pretty())
 401 |     |                 .concat("\n");
 402 |     |         }
 403 |     |         if (
 404 |     |             vars.lastGracePeriodStartTimestampIsSetBefore !=
 405 |     |             vars.lastGracePeriodStartTimestampIsSetAfter
 406 |     |         ) {
 407 |     |             log = log
 408 |     |                 .concat("lastGracePeriodStartTimestampIsSet\t")
 409 |     |                 .concat(vars.lastGracePeriodStartTimestampIsSetBefore.pretty())
 410 |     |                 .concat("\t")
 411 |     |                 .concat(vars.lastGracePeriodStartTimestampIsSetAfter.pretty())
 412 |     |                 .concat("\n");
 413 |     |         }
 414 |     |         if (vars.hasGracePeriodPassedBefore != vars.hasGracePeriodPassedAfter) {
 415 |     |             log = log
 416 |     |                 .concat("hasGracePeriodPassed\t\t")
 417 |     |                 .concat(vars.hasGracePeriodPassedBefore.pretty())
 418 |     |                 .concat("\t\t\t")
 419 |     |                 .concat(vars.hasGracePeriodPassedAfter.pretty())
 420 |     |                 .concat("\n");
 421 |     |         }
 422 |     |         if (vars.systemDebtRedistributionIndexBefore != vars.systemDebtRedistributionIndexAfter) {
 423 |     |             log = log
 424 |     |                 .concat("systemDebtRedistributionIndex\t\t")
 425 |     |                 .concat(vars.systemDebtRedistributionIndexBefore.pretty())
 426 |     |                 .concat("\t")
 427 |     |                 .concat(vars.systemDebtRedistributionIndexAfter.pretty())
 428 |     |                 .concat("\n");
 429 |     |         }
 430 |     |     }
 431 |     | }
 432 |     | 

/mnt/c/Users/Lourens/Documents/Recon-Fuzz/collabs/ebtc/packages/contracts/contracts/TestContracts/invariants/Properties.sol
   1 |     | pragma solidity 0.8.17;
   2 |     | 
   3 |     | import "@crytic/properties/contracts/util/PropertiesConstants.sol";
   4 |     | 
   5 |     | import {ICollateralToken} from "../../Dependencies/ICollateralToken.sol";
   6 |     | import {EbtcMath} from "../../Dependencies/EbtcMath.sol";
   7 |     | import {ActivePool} from "../../ActivePool.sol";
   8 |     | import {EBTCToken} from "../../EBTCToken.sol";
   9 |     | import {BorrowerOperations} from "../../BorrowerOperations.sol";
  10 |     | import {CdpManager} from "../../CdpManager.sol";
  11 |     | import {SortedCdps} from "../../SortedCdps.sol";
  12 |     | import {Asserts} from "./Asserts.sol";
  13 |     | import {CollSurplusPool} from "../../CollSurplusPool.sol";
  14 |     | import {PriceFeedTestnet} from "../testnet/PriceFeedTestnet.sol";
  15 |     | import {ICdpManagerData} from "../../Interfaces/ICdpManagerData.sol";
  16 |     | import {BeforeAfter} from "./BeforeAfter.sol";
  17 |     | import {PropertiesDescriptions} from "./PropertiesDescriptions.sol";
  18 |     | import {CRLens} from "../CRLens.sol";
  19 |     | import {LiquidationSequencer} from "../../LiquidationSequencer.sol";
  20 |     | import {SyncedLiquidationSequencer} from "../../SyncedLiquidationSequencer.sol";
  21 |     | 
  22 |     | abstract contract Properties is BeforeAfter, PropertiesDescriptions, Asserts, PropertiesConstants {
  23 |     |     function invariant_AP_01(
  24 |     |         ICollateralToken collateral,
  25 |     |         ActivePool activePool
  26 |     |     ) internal view returns (bool) {
  27 |     |         return (collateral.sharesOf(address(activePool)) >= activePool.getSystemCollShares());
  28 |     |     }
  29 |     | 
  30 |     |     function invariant_AP_02(
  31 |     |         CdpManager cdpManager,
  32 |     |         ActivePool activePool
  33 |     |     ) internal view returns (bool) {
  34 |     |         return cdpManager.getActiveCdpsCount() > 0 ? activePool.getSystemCollShares() > 0 : true;
  35 |     |     }
  36 |     | 
  37 |     |     function invariant_AP_03(
  38 |     |         EBTCToken eBTCToken,
  39 |     |         ActivePool activePool
  40 |     |     ) internal view returns (bool) {
  41 |     |         return (eBTCToken.totalSupply() == activePool.getSystemDebt());
  42 |     |     }
  43 |     | 
  44 |     |     function invariant_AP_04(
  45 |     |         CdpManager cdpManager,
  46 |     |         ActivePool activePool,
  47 |     |         uint256 diff_tolerance
  48 |     |     ) internal view returns (bool) {
  49 |     |         uint256 _cdpCount = cdpManager.getActiveCdpsCount();
  50 |     |         bytes32[] memory cdpIds = hintHelpers.sortedCdpsToArray();
  51 |     |         uint256 _sum;
  52 |     | 
  53 |     |         for (uint256 i = 0; i < _cdpCount; ++i) {
  54 |     |             (, uint256 _coll) = cdpManager.getSyncedDebtAndCollShares(cdpIds[i]);
  55 |     |             _sum += _coll;
  56 |     |         }
  57 |     |         uint256 _activeColl = activePool.getSystemCollShares();
  58 |     |         uint256 _diff = _sum > _activeColl ? (_sum - _activeColl) : (_activeColl - _sum);
  59 |     |         return (_diff * 1e18 <= diff_tolerance * _activeColl);
  60 |     |     }
  61 |     | 
  62 | *   |     function invariant_AP_05(
  63 |     |         CdpManager cdpManager,
  64 |     |         uint256 diff_tolerance
  65 |     |     ) internal view returns (bool) {
  66 |     |         uint256 _cdpCount = cdpManager.getActiveCdpsCount();
  67 |     |         bytes32[] memory cdpIds = hintHelpers.sortedCdpsToArray();
  68 |     |         uint256 _sum;
  69 |     | 
  70 |     |         for (uint256 i = 0; i < _cdpCount; ++i) {
  71 |     |             (uint256 _debt, ) = cdpManager.getSyncedDebtAndCollShares(cdpIds[i]);
  72 |     |             _sum += _debt;
  73 |     |         }
  74 |     | 
  75 |     |         bool oldCheck = isApproximateEq(_sum, cdpManager.getSystemDebt(), diff_tolerance);
  76 |     |         // New check ensures this is above 1000 wei
  77 |     |         bool newCheck = cdpManager.getSystemDebt() - _sum > 1_000;
  78 |     |         // @audit We have an instance of getting above 1e18 in rounding error, see `testBrokenInvariantFive`
  79 | *   |         return oldCheck || !newCheck;
  80 |     |     }
  81 |     | 
  82 |     |     function invariant_CDPM_01(
  83 |     |         CdpManager cdpManager,
  84 |     |         SortedCdps sortedCdps
  85 |     |     ) internal view returns (bool) {
  86 |     |         return (cdpManager.getActiveCdpsCount() == sortedCdps.getSize());
  87 |     |     }
  88 |     | 
  89 |     |     function invariant_CDPM_02(CdpManager cdpManager) internal view returns (bool) {
  90 |     |         uint256 _cdpCount = cdpManager.getActiveCdpsCount();
  91 |     |         bytes32[] memory cdpIds = hintHelpers.sortedCdpsToArray();
  92 |     | 
  93 |     |         uint256 _sum;
  94 |     | 
  95 |     |         for (uint256 i = 0; i < _cdpCount; ++i) {
  96 |     |             _sum += cdpManager.getCdpStake(cdpIds[i]);
  97 |     |         }
  98 |     |         return (_sum == cdpManager.totalStakes());
  99 |     |     }
 100 |     | 
 101 |     |     function invariant_CDPM_03(CdpManager cdpManager) internal view returns (bool) {
 102 |     |         uint256 _cdpCount = cdpManager.getActiveCdpsCount();
 103 |     |         bytes32[] memory cdpIds = hintHelpers.sortedCdpsToArray();
 104 |     |         uint256 systemStEthFeePerUnitIndex = cdpManager.systemStEthFeePerUnitIndex();
 105 |     |         for (uint256 i = 0; i < _cdpCount; ++i) {
 106 |     |             if (systemStEthFeePerUnitIndex < cdpManager.cdpStEthFeePerUnitIndex(cdpIds[i])) {
 107 |     |                 return false;
 108 |     |             }
 109 |     |         }
 110 |     |         return true;
 111 |     |     }
 112 |     | 
 113 |     |     /** TODO: See EchidnaToFoundry._getValue */
 114 |     |     function invariant_CDPM_04(Vars memory vars) internal view returns (bool) {
 115 |     |         return
 116 |     |             vars.valueInSystemAfter >= vars.valueInSystemBefore ||
 117 |     |             isApproximateEq(vars.valueInSystemAfter, vars.valueInSystemBefore, 0.01e18);
 118 |     |     }
 119 |     | 
 120 |     |     function invariant_CDPM_10(CdpManager cdpManager) internal view returns (bool) {
 121 |     |         if (vars.afterStEthFeeIndex > vars.prevStEthFeeIndex) {
 122 |     |             return cdpManager.totalStakesSnapshot() == cdpManager.totalStakes();
 123 |     |         }
 124 |     |         return true;
 125 |     |     }
 126 |     | 
 127 |     |     function invariant_CDPM_11(CdpManager cdpManager) internal view returns (bool) {
 128 |     |         if (vars.afterStEthFeeIndex > vars.prevStEthFeeIndex) {
 129 |     |             return cdpManager.totalCollateralSnapshot() == cdpManager.getSystemCollShares();
 130 |     |         }
 131 |     |         return true;
 132 |     |     }
 133 |     | 
 134 |     |     function invariant_CDPM_12(
 135 |     |         SortedCdps sortedCdps,
 136 |     |         Vars memory vars
 137 |     |     ) internal view returns (bool) {
 138 |     |         bytes32 currentCdp = sortedCdps.getFirst();
 139 |     | 
 140 |     |         uint256 sumStakes;
 141 |     |         while (currentCdp != bytes32(0)) {
 142 |     |             sumStakes += cdpManager.getCdpStake(currentCdp);
 143 |     |             currentCdp = sortedCdps.getNext(currentCdp);
 144 |     |         }
 145 |     | 
 146 |     |         return sumStakes == cdpManager.totalStakes();
 147 |     |     }
 148 |     | 
 149 |     |     function invariant_CSP_01(
 150 |     |         ICollateralToken collateral,
 151 |     |         CollSurplusPool collSurplusPool
 152 |     |     ) internal view returns (bool) {
 153 |     |         return
 154 |     |             collateral.sharesOf(address(collSurplusPool)) >=
 155 |     |             collSurplusPool.getTotalSurplusCollShares();
 156 |     |     }
 157 |     | 
 158 |     |     function invariant_CSP_02(CollSurplusPool collSurplusPool) internal view returns (bool) {
 159 |     |         uint256 sum;
 160 |     | 
 161 |     |         // NOTE: See PropertiesConstants
 162 |     |         // We only have 3 actors so just set these up
 163 |     |         sum += collSurplusPool.getSurplusCollShares(address(actors[USER1]));
 164 |     |         sum += collSurplusPool.getSurplusCollShares(address(actors[USER2]));
 165 |     |         sum += collSurplusPool.getSurplusCollShares(address(actors[USER3]));
 166 |     | 
 167 |     |         return sum == collSurplusPool.getTotalSurplusCollShares();
 168 |     |     }
 169 |     | 
 170 |     |     function invariant_SL_01(CdpManager cdpManager, SortedCdps sortedCdps) internal returns (bool) {
 171 |     |         bytes32 currentCdp = sortedCdps.getFirst();
 172 |     |         bytes32 nextCdp = sortedCdps.getNext(currentCdp);
 173 |     | 
 174 |     |         while (currentCdp != bytes32(0) && nextCdp != bytes32(0) && currentCdp != nextCdp) {
 175 |     |             // TODO remove tolerance once proper fix has been applied
 176 |     |             uint256 nicrNext = cdpManager.getCachedNominalICR(nextCdp);
 177 |     |             uint256 nicrCurrent = cdpManager.getCachedNominalICR(currentCdp);
 178 |     |             emit L2(nicrNext, nicrCurrent);
 179 |     |             if (nicrNext > nicrCurrent && diffPercent(nicrNext, nicrCurrent) > 0.01e18) {
 180 |     |                 return false;
 181 |     |             }
 182 |     | 
 183 |     |             currentCdp = nextCdp;
 184 |     |             nextCdp = sortedCdps.getNext(currentCdp);
 185 |     |         }
 186 |     | 
 187 |     |         return true;
 188 |     |     }
 189 |     | 
 190 |     |     function invariant_SL_02(
 191 |     |         CdpManager cdpManager,
 192 |     |         SortedCdps sortedCdps,
 193 |     |         PriceFeedTestnet priceFeedMock
 194 |     |     ) internal returns (bool) {
 195 |     |         bytes32 _first = sortedCdps.getFirst();
 196 |     |         uint256 _price = priceFeedMock.fetchPrice();
 197 |     |         uint256 _firstICR = cdpManager.getCachedICR(_first, _price);
 198 |     |         uint256 _TCR = cdpManager.getCachedTCR(_price);
 199 |     | 
 200 |     |         if (
 201 |     |             _first != sortedCdps.dummyId() &&
 202 |     |             _firstICR < _TCR &&
 203 |     |             diffPercent(_firstICR, _TCR) > 0.01e18
 204 |     |         ) {
 205 |     |             return false;
 206 |     |         }
 207 |     |         return true;
 208 |     |     }
 209 |     | 
 210 |     |     function invariant_SL_03(
 211 |     |         CdpManager cdpManager,
 212 |     |         PriceFeedTestnet priceFeedMock,
 213 |     |         SortedCdps sortedCdps
 214 |     |     ) internal returns (bool) {
 215 |     |         bytes32 currentCdp = sortedCdps.getFirst();
 216 |     | 
 217 |     |         uint256 _price = priceFeedMock.fetchPrice();
 218 |     |         if (_price == 0) return true;
 219 |     | 
 220 |     |         while (currentCdp != bytes32(0)) {
 221 |     |             // Status
 222 |     |             if (
 223 |     |                 ICdpManagerData.Status(cdpManager.getCdpStatus(currentCdp)) !=
 224 |     |                 ICdpManagerData.Status.active
 225 |     |             ) {
 226 |     |                 return false;
 227 |     |             }
 228 |     | 
 229 |     |             // Stake > 0
 230 |     |             if (cdpManager.getCdpStake(currentCdp) == 0) {
 231 |     |                 return false;
 232 |     |             }
 233 |     | 
 234 |     |             currentCdp = sortedCdps.getNext(currentCdp);
 235 |     |         }
 236 |     |         return true;
 237 |     |     }
 238 |     | 
 239 |     |     uint256 NICR_ERROR_THRESHOLD = 1e18; // NOTE: 1e20 is basically 1/1 so it's completely safe as a threshold
 240 |     | 
 241 |     |     function invariant_SL_05(CRLens crLens, SortedCdps sortedCdps) internal returns (bool) {
 242 |     |         bytes32 currentCdp = sortedCdps.getFirst();
 243 |     | 
 244 |     |         uint256 newIcrPrevious = type(uint256).max;
 245 |     | 
 246 |     |         while (currentCdp != bytes32(0)) {
 247 |     |             uint256 newIcr = crLens.quoteRealICR(currentCdp);
 248 |     |             if (newIcr > newIcrPrevious) {
 249 |     |                 /// @audit Precision Threshold to flag very scary scenarios
 250 |     |                 /// Innoquous scenario illustrated here: https://github.com/Badger-Finance/ebtc-fuzz-review/issues/15
 251 |     |                 if (newIcr - newIcrPrevious > NICR_ERROR_THRESHOLD) {
 252 |     |                     return false;
 253 |     |                 }
 254 |     |             }
 255 |     |             newIcrPrevious = newIcr;
 256 |     | 
 257 |     |             currentCdp = sortedCdps.getNext(currentCdp);
 258 |     |         }
 259 |     |         return true;
 260 |     |     }
 261 |     | 
 262 |     |     function invariant_GENERAL_01(Vars memory vars) internal view returns (bool) {
 263 |     |         return !vars.isRecoveryModeBefore ? !vars.isRecoveryModeAfter : true;
 264 |     |     }
 265 |     | 
 266 |     |     function invariant_GENERAL_02(
 267 |     |         CdpManager cdpManager,
 268 |     |         PriceFeedTestnet priceFeedMock,
 269 |     |         EBTCToken eBTCToken,
 270 |     |         ICollateralToken collateral
 271 |     |     ) internal returns (bool) {
 272 |     |         // TODO how to calculate "the dollar value of eBTC"?
 273 |     |         // TODO how do we take into account underlying/shares into this calculation?
 274 |     |         return
 275 |     |             cdpManager.getCachedTCR(priceFeedMock.fetchPrice()) > 1e18
 276 |     |                 ? (collateral.getPooledEthByShares(cdpManager.getSystemCollShares()) *
 277 |     |                     priceFeedMock.fetchPrice()) /
 278 |     |                     1e18 >=
 279 |     |                     eBTCToken.totalSupply()
 280 |     |                 : (collateral.getPooledEthByShares(cdpManager.getSystemCollShares()) *
 281 |     |                     priceFeedMock.fetchPrice()) /
 282 |     |                     1e18 <
 283 |     |                     eBTCToken.totalSupply();
 284 |     |     }
 285 |     | 
 286 |     |     function invariant_GENERAL_03(
 287 |     |         CdpManager cdpManager,
 288 |     |         BorrowerOperations borrowerOperations,
 289 |     |         EBTCToken eBTCToken,
 290 |     |         ICollateralToken collateral
 291 |     |     ) internal view returns (bool) {
 292 |     |         return
 293 |     |             collateral.balanceOf(address(cdpManager)) == 0 &&
 294 |     |             eBTCToken.balanceOf(address(cdpManager)) == 0 &&
 295 |     |             collateral.balanceOf(address(borrowerOperations)) == 0 &&
 296 |     |             eBTCToken.balanceOf(address(borrowerOperations)) == 0;
 297 |     |     }
 298 |     | 
 299 |     |     function invariant_GENERAL_05(
 300 |     |         ActivePool activePool,
 301 |     |         CdpManager cdpManager,
 302 |     |         ICollateralToken collateral
 303 |     |     ) internal view returns (bool) {
 304 |     |         uint256 totalStipendShares;
 305 |     | 
 306 |     |         // Iterate over CDPs add the stipendShares
 307 |     |         bytes32 currentCdp = sortedCdps.getFirst();
 308 |     |         while (currentCdp != bytes32(0)) {
 309 |     |             totalStipendShares += cdpManager.getCdpLiquidatorRewardShares(currentCdp);
 310 |     | 
 311 |     |             currentCdp = sortedCdps.getNext(currentCdp);
 312 |     |         }
 313 |     | 
 314 |     |         return
 315 |     |             collateral.sharesOf(address(activePool)) >=
 316 |     |             (activePool.getSystemCollShares() +
 317 |     |                 activePool.getFeeRecipientClaimableCollShares() +
 318 |     |                 totalStipendShares);
 319 |     |     }
 320 |     | 
 321 |     |     function invariant_GENERAL_05_B(
 322 |     |         CollSurplusPool surplusPool,
 323 |     |         ICollateralToken collateral
 324 |     |     ) internal view returns (bool) {
 325 |     |         return
 326 |     |             collateral.sharesOf(address(surplusPool)) >= (surplusPool.getTotalSurplusCollShares());
 327 |     |     }
 328 |     | 
 329 |     |     function invariant_GENERAL_06(
 330 |     |         EBTCToken eBTCToken,
 331 |     |         CdpManager cdpManager,
 332 |     |         SortedCdps sortedCdps
 333 |     |     ) internal view returns (bool) {
 334 |     |         uint256 totalSupply = eBTCToken.totalSupply();
 335 |     | 
 336 |     |         bytes32 currentCdp = sortedCdps.getFirst();
 337 |     |         uint256 cdpsBalance;
 338 |     |         while (currentCdp != bytes32(0)) {
 339 |     |             (uint256 entireDebt, uint256 entireColl) = cdpManager.getSyncedDebtAndCollShares(
 340 |     |                 currentCdp
 341 |     |             );
 342 |     |             cdpsBalance += entireDebt;
 343 |     |             currentCdp = sortedCdps.getNext(currentCdp);
 344 |     |         }
 345 |     | 
 346 |     |         return totalSupply >= cdpsBalance;
 347 |     |     }
 348 |     | 
 349 |     |     function invariant_GENERAL_17(
 350 |     |         CdpManager cdpManager,
 351 |     |         SortedCdps sortedCdps,
 352 |     |         PriceFeedTestnet priceFeedTestnet,
 353 |     |         ICollateralToken collateral
 354 |     |     ) internal view returns (bool) {
 355 |     |         bytes32 currentCdp = sortedCdps.getFirst();
 356 |     | 
 357 |     |         uint256 sumOfDebt;
 358 |     |         while (currentCdp != bytes32(0)) {
 359 |     |             uint256 entireDebt = cdpManager.getSyncedCdpDebt(currentCdp);
 360 |     |             sumOfDebt += entireDebt;
 361 |     |             currentCdp = sortedCdps.getNext(currentCdp);
 362 |     |         }
 363 |     |         sumOfDebt += cdpManager.lastEBTCDebtErrorRedistribution() / 1e18; // TODO: We need to add 1 wei for all CDPs at their time of redistribution
 364 |     |         uint256 _systemDebt = activePool.getSystemDebt();
 365 |     | 
 366 |     |         if (cdpManager.lastEBTCDebtErrorRedistribution() % 1e18 > 0) sumOfDebt += 1; // Round up debt
 367 |     | 
 368 |     |         // SumOfDebt can have rounding error
 369 |     |         // And rounding error is capped by:
 370 |     |         // 1 wei of rounding error in lastEBTCDebtErrorRedistribution
 371 |     |         // 1 wei for each cdp at each redistribution (as their index may round down causing them to lose 1 wei of debt)
 372 |     |         return sumOfDebt <= _systemDebt && sumOfDebt + totalCdpDustMaxCap >= _systemDebt;
 373 |     |     }
 374 |     | 
 375 |     |     function invariant_GENERAL_18(
 376 |     |         CdpManager cdpManager,
 377 |     |         SortedCdps sortedCdps,
 378 |     |         PriceFeedTestnet priceFeedTestnet,
 379 |     |         ICollateralToken collateral
 380 |     |     ) internal view returns (bool) {
 381 |     |         bytes32 currentCdp = sortedCdps.getFirst();
 382 |     | 
 383 |     |         uint256 sumOfColl;
 384 |     |         while (currentCdp != bytes32(0)) {
 385 |     |             uint256 entireColl = cdpManager.getSyncedCdpCollShares(currentCdp);
 386 |     |             sumOfColl += entireColl;
 387 |     |             currentCdp = sortedCdps.getNext(currentCdp);
 388 |     |         }
 389 |     | 
 390 |     |         if (sumOfColl == 0) {
 391 |     |             return sumOfColl == cdpManager.getSyncedSystemCollShares();
 392 |     |         }
 393 |     | 
 394 |     |         sumOfColl -= cdpManager.systemStEthFeePerUnitIndexError() / 1e18;
 395 |     |         uint256 _systemCollShares = cdpManager.getSyncedSystemCollShares();
 396 |     | 
 397 |     |         if (cdpManager.systemStEthFeePerUnitIndexError() % 1e18 > 0) sumOfColl -= 1; // Round down coll
 398 |     |         // sumOfColl can have rounding error
 399 |     |         // And rounding error is capped by:
 400 |     |         // 1 wei of rounding error in systemStEthFeePerUnitIndexError
 401 |     |         // 1 wei for each cdp at each index change (as their index may round down causing them to lose 1 wei of fee split)
 402 |     |         return
 403 |     |             sumOfColl <= _systemCollShares &&
 404 |     |             sumOfColl + vars.cumulativeCdpsAtTimeOfRebase >= _systemCollShares;
 405 |     |     }
 406 |     | 
 407 |     |     function invariant_GENERAL_19(ActivePool activePool) internal view returns (bool) {
 408 |     |         return !activePool.twapDisabled();
 409 |     |     }
 410 |     | 
 411 |     |     function invariant_GENERAL_08(
 412 |     |         CdpManager cdpManager,
 413 |     |         SortedCdps sortedCdps,
 414 |     |         PriceFeedTestnet priceFeedTestnet,
 415 |     |         ICollateralToken collateral
 416 |     |     ) internal returns (bool) {
 417 |     |         uint256 curentPrice = priceFeedTestnet.fetchPrice();
 418 |     | 
 419 |     |         bytes32 currentCdp = sortedCdps.getFirst();
 420 |     | 
 421 |     |         uint256 sumOfColl;
 422 |     |         uint256 sumOfDebt;
 423 |     |         while (currentCdp != bytes32(0)) {
 424 |     |             uint256 entireColl = cdpManager.getSyncedCdpCollShares(currentCdp);
 425 |     |             uint256 entireDebt = cdpManager.getSyncedCdpDebt(currentCdp);
 426 |     |             sumOfColl += entireColl;
 427 |     |             sumOfDebt += entireDebt;
 428 |     |             currentCdp = sortedCdps.getNext(currentCdp);
 429 |     |         }
 430 |     | 
 431 |     |         uint256 _systemCollShares = cdpManager.getSyncedSystemCollShares();
 432 |     |         uint256 _systemDebt = activePool.getSystemDebt();
 433 |     |         uint256 tcrFromSystem = cdpManager.getSyncedTCR(curentPrice);
 434 |     | 
 435 |     |         uint256 tcrFromSums = EbtcMath._computeCR(
 436 |     |             collateral.getPooledEthByShares(sumOfColl),
 437 |     |             sumOfDebt,
 438 |     |             curentPrice
 439 |     |         );
 440 |     | 
 441 |     |         bool _acceptedTcrDiff = _assertApproximateEq(tcrFromSystem, tcrFromSums, 1e8);
 442 |     | 
 443 |     |         // add generic diff function (original, second, diff) - all at once
 444 |     | 
 445 |     |         /// @audit 1e8 precision in absoulte value (not the percent)
 446 |     |         //return  isApproximateEq(tcrFromSystem, tcrFromSums, 1e8); // Up to 1e8 precision is accepted
 447 |     |         bool _acceptedCollDiff = _assertApproximateEq(_systemCollShares, sumOfColl, 1e8);
 448 |     |         bool _acceptedDebtDiff = _assertApproximateEq(_systemDebt, sumOfDebt, 1e8);
 449 |     |         return (_acceptedCollDiff && _acceptedDebtDiff);
 450 |     |     }
 451 |     | 
 452 | *   |     function invariant_GENERAL_09(
 453 |     |         CdpManager cdpManager,
 454 |     |         Vars memory vars
 455 |     |     ) internal view returns (bool) {
 456 | *   |         if (vars.isRecoveryModeBefore) {
 457 |     |             if (vars.cdpDebtAfter > vars.cdpDebtBefore) return (vars.icrAfter > cdpManager.MCR());
 458 |     |             else return true;
 459 |     |         } else {
 460 |     |             return (vars.icrAfter > cdpManager.MCR());
 461 |     |         }
 462 |     |     }
 463 |     | 
 464 |     |     function invariant_GENERAL_12(
 465 |     |         CdpManager cdpManager,
 466 |     |         PriceFeedTestnet priceFeedMock,
 467 |     |         CRLens crLens
 468 |     |     ) internal returns (bool) {
 469 |     |         uint256 curentPrice = priceFeedMock.fetchPrice();
 470 |     |         return crLens.quoteRealTCR() == cdpManager.getSyncedTCR(curentPrice);
 471 |     |     }
 472 |     | 
 473 |     |     function invariant_GENERAL_13(
 474 |     |         CRLens crLens,
 475 |     |         CdpManager cdpManager,
 476 |     |         PriceFeedTestnet priceFeedMock,
 477 |     |         SortedCdps sortedCdps
 478 |     |     ) internal returns (bool) {
 479 |     |         bytes32 currentCdp = sortedCdps.getFirst();
 480 |     | 
 481 |     |         uint256 _price = priceFeedMock.fetchPrice();
 482 |     | 
 483 |     |         // Compare synched with quote for all Cdps
 484 |     |         while (currentCdp != bytes32(0)) {
 485 |     |             uint256 newIcr = crLens.quoteRealICR(currentCdp);
 486 |     |             uint256 synchedICR = cdpManager.getSyncedICR(currentCdp, _price);
 487 |     | 
 488 |     |             if (newIcr != synchedICR) {
 489 |     |                 return false;
 490 |     |             }
 491 |     | 
 492 |     |             currentCdp = sortedCdps.getNext(currentCdp);
 493 |     |         }
 494 |     |         return true;
 495 |     |     }
 496 |     | 
 497 |     |     function invariant_GENERAL_14(
 498 |     |         CRLens crLens,
 499 |     |         CdpManager cdpManager,
 500 |     |         SortedCdps sortedCdps
 501 |     |     ) internal returns (bool) {
 502 |     |         bytes32 currentCdp = sortedCdps.getFirst();
 503 |     | 
 504 |     |         uint256 newIcrPrevious = type(uint256).max;
 505 |     | 
 506 |     |         // Compare synched with quote for all Cdps
 507 |     |         while (currentCdp != bytes32(0)) {
 508 |     |             uint256 newNICR = crLens.quoteRealNICR(currentCdp);
 509 |     |             uint256 synchedNICR = cdpManager.getSyncedNominalICR(currentCdp); // Uses cached stETH index -> It's not the "real NICR"
 510 |     | 
 511 |     |             if (newNICR != synchedNICR) {
 512 |     |                 return false;
 513 |     |             }
 514 |     | 
 515 |     |             currentCdp = sortedCdps.getNext(currentCdp);
 516 |     |         }
 517 |     |         return true;
 518 |     |     }
 519 |     | 
 520 |     |     function invariant_GENERAL_15() internal returns (bool) {
 521 |     |         return
 522 |     |             crLens.quoteAnything(simulator.simulateRepayEverythingAndCloseCdps) == simulator.TRUE();
 523 |     |     }
 524 |     | 
 525 | *   |     function invariant_LS_01(
 526 |     |         CdpManager cdpManager,
 527 |     |         LiquidationSequencer ls,
 528 |     |         SyncedLiquidationSequencer syncedLs,
 529 |     |         PriceFeedTestnet priceFeedTestnet
 530 |     |     ) internal returns (bool) {
 531 |     |         // Or just compare max lenght since that's the one with all of them
 532 |     |         uint256 n = cdpManager.getActiveCdpsCount();
 533 |     | 
 534 |     |         // Get
 535 |     |         uint256 price = priceFeedTestnet.fetchPrice();
 536 |     | 
 537 |     |         // Get lists
 538 |     |         bytes32[] memory cdpsFromCurrent = ls.sequenceLiqToBatchLiqWithPrice(n, price);
 539 |     |         bytes32[] memory cdpsSynced = syncedLs.sequenceLiqToBatchLiqWithPrice(n, price);
 540 |     | 
 541 |     |         uint256 length = cdpsFromCurrent.length;
 542 |     |         if (length != cdpsSynced.length) {
 543 |     |             return false;
 544 |     |         }
 545 |     | 
 546 |     |         // Compare Lists
 547 |     |         for (uint256 i; i < length; i++) {
 548 |     |             // Find difference = broken
 549 |     |             if (cdpsFromCurrent[i] != cdpsSynced[i]) {
 550 |     |                 return false;
 551 |     |             }
 552 |     |         }
 553 |     | 
 554 |     |         // Implies we're good
 555 |     |         return true;
 556 |     |     }
 557 |     | 
 558 |     |     function invariant_DUMMY_01(PriceFeedTestnet priceFeedTestnet) internal returns (bool) {
 559 |     |         return priceFeedTestnet.fetchPrice() > 0;
 560 |     |     }
 561 |     | 
 562 |     |     function invariant_BO_09(
 563 |     |         CdpManager cdpManager,
 564 |     |         uint256 price,
 565 |     |         bytes32 cdpId
 566 |     |     ) internal view returns (bool) {
 567 |     |         uint256 _icr = cdpManager.getSyncedICR(cdpId, price);
 568 |     |         if (cdpManager.checkRecoveryMode(price)) {
 569 |     |             return _icr >= cdpManager.CCR();
 570 |     |         } else {
 571 |     |             return _icr >= cdpManager.MCR();
 572 |     |         }
 573 |     |     }
 574 |     | }
 575 |     | 

/mnt/c/Users/Lourens/Documents/Recon-Fuzz/collabs/ebtc/packages/contracts/contracts/TestContracts/invariants/PropertiesDescriptions.sol
   1 |     | pragma solidity 0.8.17;
   2 |     | 
   3 |     | abstract contract PropertiesDescriptions {
   4 |     |     ///////////////////////////////////////////////////////
   5 |     |     // Active Pool
   6 |     |     ///////////////////////////////////////////////////////
   7 |     | 
   8 |     |     string constant AP_01 =
   9 |     |         "AP-01: The collateral balance in the active pool is greater than or equal to its accounting number";
  10 |     |     string constant AP_02 =
  11 |     |         "AP-02: The collateral balance of the ActivePool is positive if there is at least one CDP open";
  12 |     |     string constant AP_03 =
  13 |     |         "AP-03: The eBTC debt accounting number in active pool is greater than or equal to its accounting number";
  14 |     |     string constant AP_04 =
  15 |     |         "AP-04: The total collateral in active pool should be equal to the sum of all individual CDP collateral";
  16 |     |     string constant AP_05 =
  17 |     |         "AP-05: The sum of debt accounting in active pool should be equal to sum of debt accounting of individual CDPs";
  18 |     | 
  19 |     |     ///////////////////////////////////////////////////////
  20 |     |     // Cdp Manager
  21 |     |     ///////////////////////////////////////////////////////
  22 |     | 
  23 |     |     string constant CDPM_01 =
  24 |     |         "CDPM-01: The count of active CDPs is equal to the SortedCdp list length";
  25 |     |     string constant CDPM_02 = "CDPM-02: The sum of active CDPs stake is equal to totalStakes";
  26 |     |     string constant CDPM_03 =
  27 |     |         "CDPM-03: The stFeePerUnit tracker for individual CDP is equal to or less than the global variable";
  28 |     |     string constant CDPM_04 = "CDPM-04: The total system value does not decrease during redemptions";
  29 |     |     string constant CDPM_05 = "CDPM-05: Redemptions do not increase the total system debt";
  30 |     |     string constant CDPM_06 = "CDPM-06: Redemptions do not increase the total system debt";
  31 |     |     string constant CDPM_07 = "CDPM-07: Stake decreases when collShares decreases for a CDP";
  32 |     |     string constant CDPM_08 = "CDPM-08: Stake increases when collShares increases for a CDP";
  33 |     |     string constant CDPM_09 =
  34 |     |         "CDPM-09: expectedStake = coll * totalStakesSnapshot / totalCollateralSnapshot after every operation involving a CDP";
  35 |     |     string constant CDPM_10 =
  36 |     |         "CDPM-10: totalStakesSnapshot matches totalStakes after an operation, if rebase index changed during the OP";
  37 |     |     string constant CDPM_11 =
  38 |     |         "CDPM-11: totalCollateralSnapshot matches activePool.systemCollShares after an operation, if rebase index changed during the OP";
  39 |     |     string constant CDPM_12 =
  40 |     |         "CDPM-12: Sum of all individual CDP stakes should equal to totalStakes";
  41 |     | 
  42 |     |     ///////////////////////////////////////////////////////
  43 |     |     // Collateral Surplus Pool
  44 |     |     ///////////////////////////////////////////////////////
  45 |     | 
  46 |     |     string constant CSP_01 =
  47 |     |         "CSP-01: The collateral balance in the collSurplus pool is greater than or equal to its accounting number";
  48 |     |     string constant CSP_02 =
  49 |     |         "CSP-02: The sum of all surpluses is equal to the value of getTotalSurplusCollShares";
  50 |     | 
  51 |     |     ///////////////////////////////////////////////////////
  52 |     |     // Sorted List
  53 |     |     ///////////////////////////////////////////////////////
  54 |     | 
  55 |     |     string constant SL_01 =
  56 |     |         "SL-01: The NICR ranking in the sorted list should follow descending order";
  57 |     |     string constant SL_02 =
  58 |     |         "SL-02: The the first(highest) ICR in the sorted list should be greater or equal to TCR (with tolerance due to rounding errors)";
  59 |     |     string constant SL_03 = "SL-03: All CDPs have status active and stake greater than zero";
  60 |     |     string constant SL_05 =
  61 |     |         "SL-05: The CDPs should be sorted in descending order of new ICR (accrued)";
  62 |     | 
  63 |     |     ///////////////////////////////////////////////////////
  64 |     |     // Borrower Operations
  65 |     |     ///////////////////////////////////////////////////////
  66 |     | 
  67 |     |     string constant BO_01 = "BO-01: Users can only open CDPs with healthy ICR";
  68 |     |     string constant BO_02 = "BO-02: Users must repay all debt to close a CDP";
  69 |     |     string constant BO_03 = "BO-03: Adding collateral doesn't reduce Nominal ICR";
  70 |     |     string constant BO_04 = "BO-04: Removing collateral does not increase the Nominal ICR";
  71 |     |     string constant BO_05 =
  72 |     |         "BO-05: When a borrower closes their active CDP, the gas compensation is refunded to the user";
  73 |     |     string constant BO_07 = "BO-07: eBTC tokens are burned upon repayment of a CDP's debt";
  74 |     |     string constant BO_08 = "BO-08: TCR must increase after a repayment";
  75 |     |     string constant BO_09 = "BO-09: Borrower can not open a CDP that is immediately liquidatable";
  76 |     | 
  77 |     |     ///////////////////////////////////////////////////////
  78 |     |     // General
  79 |     |     ///////////////////////////////////////////////////////
  80 |     |     string constant GENERAL_01 =
  81 |     |         "GENERAL-01: After any operation, the system should not enter in Recovery Mode";
  82 |     |     string constant GENERAL_02 =
  83 |     |         "GENERAL-02: The dollar value of the locked stETH exceeds the dollar value of the issued eBTC if TCR is greater than 100%";
  84 |     |     string constant GENERAL_03 =
  85 |     |         "GENERAL-03: CdpManager and BorrowerOperations do not hold value terms of stETH and eBTC unless there are donations";
  86 |     |     string constant GENERAL_05 =
  87 |     |         "GENERAL-05: At all times, the total stETH shares of the system exceeds the deposits if there is no negative rebasing events"; /// NOTE this holds even with rebases
  88 |     |     string constant GENERAL_06 =
  89 |     |         "GENERAL-06: At all times, the total debt is greater than the sum of all debts from all CDPs";
  90 |     |     string constant GENERAL_08 =
  91 |     |         "GENERAL-08: At all times TCR = SUM(COLL)  * price / SUM(DEBT) of all CDPs";
  92 |     |     string constant GENERAL_09 =
  93 |     |         "GENERAL-09: After any operation, the ICR of a CDP must be above the MCR in Normal Mode, and after debt increase in Recovery Mode the ICR must be above the CCR";
  94 |     |     string constant GENERAL_10 = "GENERAL-10: All CDPs should maintain a minimum collateral size";
  95 |     |     string constant GENERAL_11 =
  96 |     |         "GENERAL-11: The TCR pre-computed (TCRNotified) is the same as the one after all calls";
  97 |     |     string constant GENERAL_12 =
  98 |     |         "GENERAL-12: The synchedTCR matches the TCR after accrual (as returned by CrLens)";
  99 |     |     string constant GENERAL_13 =
 100 |     |         "GENERAL-13: The SynchedICR of every CDP in the Linked List Matches the ICR the CDPs will have the call (as returned by CrLens)";
 101 |     |     string constant GENERAL_14 =
 102 |     |         "GENERAL-14: The NominalICR from `getNominalICR` matches `quoteRealNICR` (as returned by CrLens)";
 103 |     |     string constant GENERAL_15 =
 104 |     |         "GENERAL-15: CDP debt should always be greater than MIN_CHANGE (1000 Wei)";
 105 |     |     string constant GENERAL_16 =
 106 |     |         "GENERAL-16: Collateral and debt change amounts should always be greater than MIN_CHANGE (1000 Wei)";
 107 |     |     string constant GENERAL_17 =
 108 |     |         "GENERAL-17: Sum of synced debt values of all Cdps + the stored debt redistribution error accumulator should never be more than the total system debt + 1";
 109 |     |     string constant GENERAL_18 =
 110 |     |         "GENERAL-18: Sum of synced coll shares of all Cdps - cumulative errors should never be more than _systemCollShares";
 111 |     |     string constant GENERAL_19 = "GENERAL-19: TWAP should never be disabled";
 112 |     | 
 113 |     |     ///////////////////////////////////////////////////////
 114 |     |     // Redemptions
 115 |     |     ///////////////////////////////////////////////////////
 116 |     | 
 117 |     |     string constant R_07 = "R-07: TCR should not decrease after redemptions";
 118 |     |     string constant R_08 = "R-08: The user eBTC balance should be used to pay the system debt";
 119 |     | 
 120 |     |     ///////////////////////////////////////////////////////
 121 |     |     // Liquidations
 122 |     |     ///////////////////////////////////////////////////////
 123 |     | 
 124 |     |     string constant L_01 =
 125 |     |         "L-01: Liquidation only succeeds if ICR < 110% in Normal Mode, or if ICR < 125% in Recovery Mode";
 126 |     |     string constant L_09 =
 127 |     |         "L-09: Undercollateralized liquidations are also incentivized with the Gas Stipend";
 128 |     |     string constant L_12 =
 129 |     |         "L-12: TCR must increase after liquidation with no redistributions if the liquidated CDP's ICR is less than TCR before liquidation";
 130 |     |     string constant L_14 =
 131 |     |         "If the RM grace period is set and we're in recovery mode, new actions that keep the system in recovery mode should not change the cooldown timestamp";
 132 |     |     string constant L_15 =
 133 |     |         "L-15: The RM grace period should set if a BO/liquidation/redistribution makes the TCR below CCR";
 134 |     |     string constant L_16 =
 135 |     |         "L-16: The RM grace period should reset if a BO/liquidation/redistribution makes the TCR above CCR";
 136 |     |     string constant L_17 =
 137 |     |         "L-17: Debt Redistribution Error Accumulator should be less than Total Stakes immediately after a bad debt redistribution";
 138 |     | 
 139 |     |     ///////////////////////////////////////////////////////
 140 |     |     // eBTC
 141 |     |     ///////////////////////////////////////////////////////
 142 |     | 
 143 |     |     string constant EBTC_02 =
 144 |     |         "EBTC-02: Any eBTC holder (whether or not they have an active CDP) may redeem their eBTC unless TCR is below MCR";
 145 |     | 
 146 |     |     ///////////////////////////////////////////////////////
 147 |     |     // Fee Recipient
 148 |     |     ///////////////////////////////////////////////////////
 149 |     | 
 150 |     |     string constant F_01 = "F-01: `claimFeeRecipientCollShares` allows to claim at any time";
 151 |     |     string constant F_02 = "F-02: Fees From Redemptions are added to `claimFeeRecipientCollShares`";
 152 |     |     string constant F_03 = "F-03: Fees From FlashLoans are sent to the fee Recipient";
 153 |     |     string constant F_04 =
 154 |     |         "F-04: `claimFeeRecipientCollShares` claiming increases the balance of the fee recipient";
 155 |     | 
 156 |     |     ///////////////////////////////////////////////////////
 157 |     |     // Price Feed
 158 |     |     ///////////////////////////////////////////////////////
 159 |     | 
 160 |     |     string constant PF_01 = "PF-01: The price feed must never revert";
 161 |     |     string constant PF_02 = "PF-02: The price feed must follow valid status transitions";
 162 |     |     string constant PF_03 = "PF-03: The price feed must never deadlock";
 163 |     |     string constant PF_04 =
 164 |     |         "PF-04: The price feed should never report an outdated price if chainlink is Working";
 165 |     |     string constant PF_05 =
 166 |     |         "PF-05: The price feed should never use the fallback if chainlink is Working";
 167 |     |     string constant PF_06 = "PF-06: The system never tries to use the fallback if it is not set";
 168 |     |     string constant PF_07 =
 169 |     |         "PF-07: The price feed should return the primary oracle price if it is working";
 170 |     |     string constant PF_08 =
 171 |     |         "PF-08: The price feed should return the secondary oracle price if the primary oracle is not working";
 172 |     |     string constant PF_09 =
 173 |     |         "PF-09: The price feed should return the last good price if both oracles are not working";
 174 |     |     string constant PF_10 =
 175 |     |         "PF-10: The price feed should never return different prices when called multiple times in a single tx";
 176 |     | }
 177 |     | 

/mnt/c/Users/Lourens/Documents/Recon-Fuzz/collabs/ebtc/packages/contracts/contracts/TestContracts/invariants/Simulator.sol
  1 |     | pragma solidity 0.8.17;
  2 |     | 
  3 |     | import {BorrowerOperations} from "../../BorrowerOperations.sol";
  4 |     | import {CdpManager} from "../../CdpManager.sol";
  5 |     | import {SortedCdps} from "../../SortedCdps.sol";
  6 |     | import {Actor} from "./Actor.sol";
  7 |     | 
  8 |     | contract Simulator {
  9 |     |     uint256 public constant TRUE = uint256(keccak256(abi.encodePacked("TRUE")));
 10 |     |     event Log(string);
 11 |     | 
 12 |     |     Actor[] private actors;
 13 |     |     CdpManager private cdpManager;
 14 |     |     SortedCdps private sortedCdps;
 15 |     |     BorrowerOperations private borrowerOperations;
 16 |     | 
 17 |     |     constructor(
 18 |     |         Actor[] memory _actors,
 19 |     |         CdpManager _cdpManager,
 20 |     |         SortedCdps _sortedCdps,
 21 |     |         BorrowerOperations _borrowerOperations
 22 |     |     ) {
 23 |     |         actors = _actors;
 24 |     |         cdpManager = _cdpManager;
 25 |     |         sortedCdps = _sortedCdps;
 26 |     |         borrowerOperations = _borrowerOperations;
 27 |     |     }
 28 |     | 
 29 |     |     function simulateRepayEverythingAndCloseCdps() external {
 30 |     |         bool success;
 31 |     | 
 32 |     |         bytes32 currentCdp = sortedCdps.getFirst();
 33 |     |         while (currentCdp != bytes32(0) && sortedCdps.getSize() > 1) {
 34 |     |             Actor actor = Actor(payable(sortedCdps.getOwnerAddress(currentCdp)));
 35 |     |             (uint256 entireDebt, ) = cdpManager.getSyncedDebtAndCollShares(currentCdp);
 36 |     | 
 37 |     |             (success, ) = actor.proxy(
 38 |     |                 address(borrowerOperations),
 39 |     |                 abi.encodeWithSelector(BorrowerOperations.closeCdp.selector, currentCdp)
 40 |     |             );
 41 |     |             require(success);
 42 |     | 
 43 |     |             currentCdp = sortedCdps.getNext(currentCdp);
 44 |     |         }
 45 |     | 
 46 |     |         _success();
 47 |     |     }
 48 |     | 
 49 |     |     function _success() private {
 50 |     |         uint256 ans = TRUE;
 51 |     |         assembly {
 52 |     |             let ptr := mload(0x40)
 53 |     |             mstore(ptr, ans)
 54 |     |             revert(ptr, 32)
 55 |     |         }
 56 |     |     }
 57 |     | }
 58 |     | 

/mnt/c/Users/Lourens/Documents/Recon-Fuzz/collabs/ebtc/packages/contracts/contracts/TestContracts/invariants/TargetContractSetup.sol
   1 |     | pragma solidity 0.8.17;
   2 |     | 
   3 |     | import "@crytic/properties/contracts/util/PropertiesConstants.sol";
   4 |     | import "@crytic/properties/contracts/util/Hevm.sol";
   5 |     | 
   6 |     | import "../../Dependencies/SafeMath.sol";
   7 |     | import "../../CdpManager.sol";
   8 |     | import "../AccruableCdpManager.sol";
   9 |     | import "../../LiquidationLibrary.sol";
  10 |     | import "../../BorrowerOperations.sol";
  11 |     | import "../../ActivePool.sol";
  12 |     | import "../../CollSurplusPool.sol";
  13 |     | import "../../SortedCdps.sol";
  14 |     | import "../../HintHelpers.sol";
  15 |     | import "../../FeeRecipient.sol";
  16 |     | import "../../EbtcFeed.sol";
  17 |     | import "../testnet/PriceFeedTestnet.sol";
  18 |     | import "../CollateralTokenTester.sol";
  19 |     | import "../EBTCTokenTester.sol";
  20 |     | import "../../Governor.sol";
  21 |     | import "../../EBTCDeployer.sol";
  22 |     | 
  23 |     | import "./Properties.sol";
  24 |     | import "./Actor.sol";
  25 |     | import "../BaseStorageVariables.sol";
  26 |     | 
  27 |     | abstract contract TargetContractSetup is BaseStorageVariables, PropertiesConstants {
  28 |     |     using SafeMath for uint;
  29 |     | 
  30 |     |     bytes4 internal constant BURN_SIG = bytes4(keccak256(bytes("burn(address,uint256)")));
  31 |     | 
  32 |     |     uint internal numberOfCdps;
  33 |     | 
  34 |     |     struct CDPChange {
  35 |     |         uint collAddition;
  36 |     |         uint collReduction;
  37 |     |         uint debtAddition;
  38 |     |         uint debtReduction;
  39 |     |     }
  40 |     | 
  41 |     |     function _setUp() internal {
  42 |     |         defaultGovernance = address(this);
  43 |     |         ebtcDeployer = new EBTCDeployer();
  44 |     | 
  45 |     |         // Default governance is deployer
  46 |     |         // vm.prank(defaultGovernance);
  47 |     |         collateral = new CollateralTokenTester();
  48 |     | 
  49 |     |         EBTCDeployer.EbtcAddresses memory addr = ebtcDeployer.getFutureEbtcAddresses();
  50 |     | 
  51 |     |         {
  52 |     |             bytes memory creationCode;
  53 |     |             bytes memory args;
  54 |     | 
  55 |     |             // Use EBTCDeployer to deploy all contracts at determistic addresses
  56 |     | 
  57 |     |             // Authority
  58 |     |             creationCode = type(Governor).creationCode;
  59 |     |             args = abi.encode(address(this));
  60 |     | 
  61 |     |             authority = Governor(
  62 |     |                 ebtcDeployer.deploy(ebtcDeployer.AUTHORITY(), abi.encodePacked(creationCode, args))
  63 |     |             );
  64 |     | 
  65 |     |             // Liquidation Library
  66 |     |             creationCode = type(LiquidationLibrary).creationCode;
  67 |     |             args = abi.encode(
  68 |     |                 addr.borrowerOperationsAddress,
  69 |     |                 addr.collSurplusPoolAddress,
  70 |     |                 addr.ebtcTokenAddress,
  71 |     |                 addr.sortedCdpsAddress,
  72 |     |                 addr.activePoolAddress,
  73 |     |                 addr.priceFeedAddress,
  74 |     |                 address(collateral)
  75 |     |             );
  76 |     | 
  77 |     |             liqudationLibrary = LiquidationLibrary(
  78 |     |                 ebtcDeployer.deploy(
  79 |     |                     ebtcDeployer.LIQUIDATION_LIBRARY(),
  80 |     |                     abi.encodePacked(creationCode, args)
  81 |     |                 )
  82 |     |             );
  83 |     | 
  84 |     |             // CDP Manager
  85 |     |             /// @audit NOTE: This is the TEST contract!!!
  86 |     |             creationCode = type(AccruableCdpManager).creationCode;
  87 |     |             args = abi.encode(
  88 |     |                 addr.liquidationLibraryAddress,
  89 |     |                 addr.authorityAddress,
  90 |     |                 addr.borrowerOperationsAddress,
  91 |     |                 addr.collSurplusPoolAddress,
  92 |     |                 addr.ebtcTokenAddress,
  93 |     |                 addr.sortedCdpsAddress,
  94 |     |                 addr.activePoolAddress,
  95 |     |                 addr.priceFeedAddress,
  96 |     |                 address(collateral)
  97 |     |             );
  98 |     | 
  99 |     |             cdpManager = CdpManager(
 100 |     |                 ebtcDeployer.deploy(ebtcDeployer.CDP_MANAGER(), abi.encodePacked(creationCode, args))
 101 |     |             );
 102 |     | 
 103 |     |             // Borrower Operations
 104 |     |             creationCode = type(BorrowerOperations).creationCode;
 105 |     |             args = abi.encode(
 106 |     |                 addr.cdpManagerAddress,
 107 |     |                 addr.activePoolAddress,
 108 |     |                 addr.collSurplusPoolAddress,
 109 |     |                 addr.priceFeedAddress,
 110 |     |                 addr.sortedCdpsAddress,
 111 |     |                 addr.ebtcTokenAddress,
 112 |     |                 addr.feeRecipientAddress,
 113 |     |                 address(collateral)
 114 |     |             );
 115 |     | 
 116 |     |             borrowerOperations = BorrowerOperations(
 117 |     |                 ebtcDeployer.deploy(
 118 |     |                     ebtcDeployer.BORROWER_OPERATIONS(),
 119 |     |                     abi.encodePacked(creationCode, args)
 120 |     |                 )
 121 |     |             );
 122 |     | 
 123 |     |             priceFeedMock = new PriceFeedTestnet(addr.authorityAddress);
 124 |     | 
 125 |     |             // Price Feed Mock
 126 |     |             creationCode = type(EbtcFeed).creationCode;
 127 |     |             args = abi.encode(addr.authorityAddress, address(priceFeedMock), address(0));
 128 |     | 
 129 |     |             ebtcFeed = EbtcFeed(
 130 |     |                 ebtcDeployer.deploy(ebtcDeployer.PRICE_FEED(), abi.encodePacked(creationCode, args))
 131 |     |             );
 132 |     | 
 133 |     |             // Sorted CDPS
 134 |     |             creationCode = type(SortedCdps).creationCode;
 135 |     |             args = abi.encode(
 136 |     |                 type(uint256).max,
 137 |     |                 addr.cdpManagerAddress,
 138 |     |                 addr.borrowerOperationsAddress
 139 |     |             );
 140 |     | 
 141 |     |             sortedCdps = SortedCdps(
 142 |     |                 ebtcDeployer.deploy(ebtcDeployer.SORTED_CDPS(), abi.encodePacked(creationCode, args))
 143 |     |             );
 144 |     | 
 145 |     |             // Active Pool
 146 |     |             creationCode = type(ActivePool).creationCode;
 147 |     |             args = abi.encode(
 148 |     |                 addr.borrowerOperationsAddress,
 149 |     |                 addr.cdpManagerAddress,
 150 |     |                 address(collateral),
 151 |     |                 addr.collSurplusPoolAddress,
 152 |     |                 addr.feeRecipientAddress
 153 |     |             );
 154 |     | 
 155 |     |             activePool = ActivePool(
 156 |     |                 ebtcDeployer.deploy(ebtcDeployer.ACTIVE_POOL(), abi.encodePacked(creationCode, args))
 157 |     |             );
 158 |     | 
 159 |     |             // Coll Surplus Pool
 160 |     |             creationCode = type(CollSurplusPool).creationCode;
 161 |     |             args = abi.encode(
 162 |     |                 addr.borrowerOperationsAddress,
 163 |     |                 addr.cdpManagerAddress,
 164 |     |                 addr.activePoolAddress,
 165 |     |                 address(collateral)
 166 |     |             );
 167 |     | 
 168 |     |             collSurplusPool = CollSurplusPool(
 169 |     |                 ebtcDeployer.deploy(
 170 |     |                     ebtcDeployer.COLL_SURPLUS_POOL(),
 171 |     |                     abi.encodePacked(creationCode, args)
 172 |     |                 )
 173 |     |             );
 174 |     | 
 175 |     |             // Hint Helpers
 176 |     |             creationCode = type(HintHelpers).creationCode;
 177 |     |             args = abi.encode(
 178 |     |                 addr.sortedCdpsAddress,
 179 |     |                 addr.cdpManagerAddress,
 180 |     |                 address(collateral),
 181 |     |                 addr.activePoolAddress,
 182 |     |                 addr.priceFeedAddress
 183 |     |             );
 184 |     | 
 185 |     |             hintHelpers = HintHelpers(
 186 |     |                 ebtcDeployer.deploy(
 187 |     |                     ebtcDeployer.HINT_HELPERS(),
 188 |     |                     abi.encodePacked(creationCode, args)
 189 |     |                 )
 190 |     |             );
 191 |     | 
 192 |     |             // eBTC Token
 193 |     |             creationCode = type(EBTCTokenTester).creationCode;
 194 |     |             args = abi.encode(
 195 |     |                 addr.cdpManagerAddress,
 196 |     |                 addr.borrowerOperationsAddress,
 197 |     |                 addr.authorityAddress
 198 |     |             );
 199 |     | 
 200 |     |             eBTCToken = EBTCTokenTester(
 201 |     |                 ebtcDeployer.deploy(ebtcDeployer.EBTC_TOKEN(), abi.encodePacked(creationCode, args))
 202 |     |             );
 203 |     | 
 204 |     |             // Fee Recipieint
 205 |     |             creationCode = type(FeeRecipient).creationCode;
 206 |     |             args = abi.encode(
 207 |     |                 addr.ebtcTokenAddress,
 208 |     |                 addr.cdpManagerAddress,
 209 |     |                 addr.borrowerOperationsAddress,
 210 |     |                 addr.activePoolAddress,
 211 |     |                 address(collateral)
 212 |     |             );
 213 |     | 
 214 |     |             feeRecipient = FeeRecipient(
 215 |     |                 ebtcDeployer.deploy(
 216 |     |                     ebtcDeployer.FEE_RECIPIENT(),
 217 |     |                     abi.encodePacked(creationCode, args)
 218 |     |                 )
 219 |     |             );
 220 |     | 
 221 |     |             // Configure authority
 222 |     |             authority.setRoleName(0, "Admin");
 223 |     |             authority.setRoleName(1, "eBTCToken: mint");
 224 |     |             authority.setRoleName(2, "eBTCToken: burn");
 225 |     |             authority.setRoleName(3, "CDPManager: all");
 226 |     |             authority.setRoleName(4, "PriceFeed: setTellorCaller");
 227 |     |             authority.setRoleName(5, "BorrowerOperations: all");
 228 |     | 
 229 |     |             authority.setRoleCapability(1, address(eBTCToken), eBTCToken.mint.selector, true);
 230 |     | 
 231 |     |             authority.setRoleCapability(2, address(eBTCToken), BURN_SIG, true);
 232 |     | 
 233 |     |             authority.setRoleCapability(
 234 |     |                 3,
 235 |     |                 address(cdpManager),
 236 |     |                 cdpManager.setStakingRewardSplit.selector,
 237 |     |                 true
 238 |     |             );
 239 |     |             authority.setRoleCapability(
 240 |     |                 3,
 241 |     |                 address(cdpManager),
 242 |     |                 cdpManager.setRedemptionFeeFloor.selector,
 243 |     |                 true
 244 |     |             );
 245 |     |             authority.setRoleCapability(
 246 |     |                 3,
 247 |     |                 address(cdpManager),
 248 |     |                 cdpManager.setMinuteDecayFactor.selector,
 249 |     |                 true
 250 |     |             );
 251 |     |             authority.setRoleCapability(3, address(cdpManager), cdpManager.setBeta.selector, true);
 252 |     |             authority.setRoleCapability(
 253 |     |                 3,
 254 |     |                 address(cdpManager),
 255 |     |                 cdpManager.setGracePeriod.selector,
 256 |     |                 true
 257 |     |             );
 258 |     |             authority.setRoleCapability(
 259 |     |                 3,
 260 |     |                 address(cdpManager),
 261 |     |                 cdpManager.setRedemptionsPaused.selector,
 262 |     |                 true
 263 |     |             );
 264 |     | 
 265 |     |             authority.setRoleCapability(
 266 |     |                 4,
 267 |     |                 address(priceFeedMock),
 268 |     |                 priceFeedMock.setFallbackCaller.selector,
 269 |     |                 true
 270 |     |             );
 271 |     |             authority.setRoleCapability(
 272 |     |                 4,
 273 |     |                 address(ebtcFeed),
 274 |     |                 ebtcFeed.setPrimaryOracle.selector,
 275 |     |                 true
 276 |     |             );
 277 |     |             authority.setRoleCapability(
 278 |     |                 4,
 279 |     |                 address(ebtcFeed),
 280 |     |                 ebtcFeed.setSecondaryOracle.selector,
 281 |     |                 true
 282 |     |             );
 283 |     | 
 284 |     |             authority.setRoleCapability(
 285 |     |                 5,
 286 |     |                 address(borrowerOperations),
 287 |     |                 borrowerOperations.setFeeBps.selector,
 288 |     |                 true
 289 |     |             );
 290 |     |             authority.setRoleCapability(
 291 |     |                 5,
 292 |     |                 address(borrowerOperations),
 293 |     |                 borrowerOperations.setFlashLoansPaused.selector,
 294 |     |                 true
 295 |     |             );
 296 |     | 
 297 |     |             authority.setRoleCapability(5, address(activePool), activePool.setFeeBps.selector, true);
 298 |     |             authority.setRoleCapability(
 299 |     |                 5,
 300 |     |                 address(activePool),
 301 |     |                 activePool.setFlashLoansPaused.selector,
 302 |     |                 true
 303 |     |             );
 304 |     |             authority.setRoleCapability(
 305 |     |                 5,
 306 |     |                 address(activePool),
 307 |     |                 activePool.claimFeeRecipientCollShares.selector,
 308 |     |                 true
 309 |     |             );
 310 |     | 
 311 |     |             authority.setUserRole(defaultGovernance, 0, true);
 312 |     |             authority.setUserRole(defaultGovernance, 1, true);
 313 |     |             authority.setUserRole(defaultGovernance, 2, true);
 314 |     |             authority.setUserRole(defaultGovernance, 3, true);
 315 |     |             authority.setUserRole(defaultGovernance, 4, true);
 316 |     |             authority.setUserRole(defaultGovernance, 5, true);
 317 |     | 
 318 |     |             crLens = new CRLens(
 319 |     |                 address(cdpManager),
 320 |     |                 address(borrowerOperations),
 321 |     |                 address(priceFeedMock)
 322 |     |             );
 323 |     | 
 324 |     |             liquidationSequencer = new LiquidationSequencer(
 325 |     |                 address(cdpManager),
 326 |     |                 address(cdpManager.sortedCdps()),
 327 |     |                 address(priceFeedMock),
 328 |     |                 address(activePool),
 329 |     |                 address(collateral)
 330 |     |             );
 331 |     |             syncedLiquidationSequencer = new SyncedLiquidationSequencer(
 332 |     |                 address(cdpManager),
 333 |     |                 address(cdpManager.sortedCdps()),
 334 |     |                 address(priceFeedMock),
 335 |     |                 address(activePool),
 336 |     |                 address(collateral)
 337 |     |             );
 338 |     |         }
 339 |     |     }
 340 |     | 
 341 |     |     event Log(string);
 342 |     | 
 343 |     |     function _setUpFork() internal {
 344 |     |         // NOTE: Addresses from: https://gist.github.com/GalloDaSballo/75d77f8d0837821156fe061d0d8687e1
 345 |     |         defaultGovernance = address(0xaDDeE229Bd103bb5B10C3CdB595A01c425dd3264);
 346 |     |         ebtcDeployer = EBTCDeployer(0x5c42faC7eEa7e724986bB5e4F3B12912F046120a);
 347 |     |         collateral = CollateralTokenTester(payable(0xae7ab96520DE3A18E5e111B5EaAb095312D7fE84)); // stETH
 348 |     |         {
 349 |     |             authority = Governor(0x2A095d44831C26cFB6aCb806A6531AE3CA32DBc1);
 350 |     |             liqudationLibrary = LiquidationLibrary(0x4Ae990C3b2F7C3961c51483eFba20760946a7681);
 351 |     |             cdpManager = CdpManager(0xc4cbaE499bb4Ca41E78f52F07f5d98c375711774);
 352 |     |             borrowerOperations = BorrowerOperations(0xd366e016Ae0677CdCE93472e603b75051E022AD0);
 353 |     |             eBTCToken = EBTCTokenTester(0x661c70333AA1850CcDBAe82776Bb436A0fCfeEfB);
 354 |     |             priceFeedMock = PriceFeedTestnet(address(0xa9a65B1B1dDa8376527E89985b221B6bfCA1Dc9a)); // eBTC Price Feed
 355 |     |             activePool = ActivePool(0x6dBDB6D420c110290431E863A1A978AE53F69ebC);
 356 |     |             collSurplusPool = CollSurplusPool(0x335982DaE827049d35f09D5ec927De2bc38df3De);
 357 |     |             sortedCdps = SortedCdps(0x591AcB5AE192c147948c12651a0a5f24f0529BE3);
 358 |     |             hintHelpers = HintHelpers(0x2591554c5EE0b62B8E2725556Cc27744D8C2E7eB);
 359 |     |             feeRecipient = FeeRecipient(0xD4D1e77C69E7AA63D0E66a06df89A2AA5d3b1d9E);
 360 |     |             // multiCdpGetter
 361 |     | 
 362 |     |             crLens = new CRLens(
 363 |     |                 address(cdpManager),
 364 |     |                 address(borrowerOperations),
 365 |     |                 address(priceFeedMock)
 366 |     |             );
 367 |     | 
 368 |     |             // TODO: Contracts ar enot working on forked state
 369 |     |             // Liq should now be working correctly in forked state
 370 |     |             liquidationSequencer = new LiquidationSequencer(
 371 |     |                 address(cdpManager),
 372 |     |                 address(cdpManager.sortedCdps()),
 373 |     |                 address(priceFeedMock),
 374 |     |                 address(activePool),
 375 |     |                 address(collateral)
 376 |     |             );
 377 |     | 
 378 |     |             syncedLiquidationSequencer = new SyncedLiquidationSequencer(
 379 |     |                 address(cdpManager),
 380 |     |                 address(cdpManager.sortedCdps()),
 381 |     |                 address(priceFeedMock),
 382 |     |                 address(activePool),
 383 |     |                 address(collateral)
 384 |     |             );
 385 |     |         }
 386 |     |     }
 387 |     | 
 388 |     |     function _setUpActors() internal {
 389 |     |         bool success;
 390 |     |         address[] memory tokens = new address[](2);
 391 |     |         tokens[0] = address(eBTCToken);
 392 |     |         tokens[1] = address(collateral);
 393 |     |         address[] memory callers = new address[](2);
 394 |     |         callers[0] = address(borrowerOperations);
 395 |     |         callers[1] = address(activePool);
 396 |     |         address[] memory addresses = new address[](3);
 397 |     |         addresses[0] = USER1;
 398 |     |         addresses[1] = USER2;
 399 |     |         addresses[2] = USER3;
 400 |     |         Actor[] memory actorsArray = new Actor[](NUMBER_OF_ACTORS);
 401 |     |         for (uint i = 0; i < NUMBER_OF_ACTORS; i++) {
 402 |     |             actors[addresses[i]] = new Actor(tokens, callers);
 403 |     |             (success, ) = address(actors[addresses[i]]).call{value: INITIAL_ETH_BALANCE}("");
 404 |     |             assert(success);
 405 |     |             (success, ) = actors[addresses[i]].proxy(
 406 |     |                 address(collateral),
 407 |     |                 abi.encodeWithSelector(CollateralTokenTester.deposit.selector, ""),
 408 |     |                 INITIAL_COLL_BALANCE
 409 |     |             );
 410 |     |             assert(success);
 411 |     |             assert(collateral.balanceOf(address(actors[addresses[i]])) > 0);
 412 |     |             actorsArray[i] = actors[addresses[i]];
 413 |     |         }
 414 |     |         simulator = new Simulator(actorsArray, cdpManager, sortedCdps, borrowerOperations);
 415 |     |     }
 416 |     | 
 417 |     |     function _setUpActorsFork() internal {
 418 |     |         bool success;
 419 |     |         address[] memory tokens = new address[](2);
 420 |     |         tokens[0] = address(eBTCToken);
 421 |     |         tokens[1] = address(collateral);
 422 |     |         address[] memory callers = new address[](2);
 423 |     |         callers[0] = address(borrowerOperations);
 424 |     |         callers[1] = address(activePool);
 425 |     |         address[] memory addresses = new address[](3);
 426 |     |         addresses[0] = USER1;
 427 |     |         addresses[1] = USER2;
 428 |     |         addresses[2] = USER3;
 429 |     |         Actor[] memory actorsArray = new Actor[](NUMBER_OF_ACTORS);
 430 |     |         for (uint i = 0; i < NUMBER_OF_ACTORS; i++) {
 431 |     |             actors[addresses[i]] = new Actor(tokens, callers);
 432 |     |             (success, ) = address(actors[addresses[i]]).call{value: INITIAL_ETH_BALANCE}("");
 433 |     |             assert(success);
 434 |     |             (success, ) = actors[addresses[i]].proxy(
 435 |     |                 address(collateral),
 436 |     |                 abi.encodeWithSignature("submit(address)", address(0)),
 437 |     |                 INITIAL_COLL_BALANCE
 438 |     |             );
 439 |     |             assert(success);
 440 |     |             assert(collateral.balanceOf(address(actors[addresses[i]])) > 0);
 441 |     |             actorsArray[i] = actors[addresses[i]];
 442 |     |         }
 443 |     |         simulator = new Simulator(actorsArray, cdpManager, sortedCdps, borrowerOperations);
 444 |     | 
 445 |     |         actor = actorsArray[0];
 446 |     |     }
 447 |     | 
 448 |     |     // Simple canaries for fork health
 449 |     |     function _setUpCanaries() internal {
 450 |     |         try cdpManager.totalStakes() {} catch {
 451 |     |             assert(false);
 452 |     |         }
 453 |     | 
 454 |     |         assert(cdpManager.getSystemDebt() > 0);
 455 |     |     }
 456 |     | 
 457 |     |     function _syncSystemDebtTwapToSpotValue() internal {
 458 |     |         hevm.warp(block.timestamp + activePool.PERIOD());
 459 |     |         activePool.update();
 460 |     |     }
 461 |     | 
 462 |     |     function _openWhaleCdpAndTransferEBTC() internal {
 463 |     |         bool success;
 464 |     |         Actor actor = actors[USER3]; // USER3 is the whale CDP holder
 465 |     |         uint256 _col = INITIAL_COLL_BALANCE / 2; // 50% of their initial collateral balance
 466 |     | 
 467 |     |         uint256 price = priceFeedMock.getPrice();
 468 |     |         uint256 _EBTCAmount = (_col * price) / cdpManager.CCR();
 469 |     | 
 470 |     |         (success, ) = actor.proxy(
 471 |     |             address(collateral),
 472 |     |             abi.encodeWithSelector(
 473 |     |                 CollateralTokenTester.approve.selector,
 474 |     |                 address(borrowerOperations),
 475 |     |                 _col
 476 |     |             )
 477 |     |         );
 478 |     |         assert(success);
 479 |     |         (success, ) = actor.proxy(
 480 |     |             address(borrowerOperations),
 481 |     |             abi.encodeWithSelector(
 482 |     |                 BorrowerOperations.openCdp.selector,
 483 |     |                 _EBTCAmount,
 484 |     |                 bytes32(0),
 485 |     |                 bytes32(0),
 486 |     |                 _col
 487 |     |             )
 488 |     |         );
 489 |     |         assert(success);
 490 |     |         address[] memory addresses = new address[](2);
 491 |     |         addresses[0] = USER1;
 492 |     |         addresses[1] = USER2;
 493 |     |         for (uint i = 0; i < addresses.length; i++) {
 494 |     |             (success, ) = actor.proxy(
 495 |     |                 address(eBTCToken),
 496 |     |                 abi.encodeWithSelector(
 497 |     |                     eBTCToken.transfer.selector,
 498 |     |                     actors[addresses[i]],
 499 |     |                     _EBTCAmount / 3
 500 |     |                 )
 501 |     |             );
 502 |     |             assert(success);
 503 |     |         }
 504 |     |     }
 505 |     | }
 506 |     | 

/mnt/c/Users/Lourens/Documents/Recon-Fuzz/collabs/ebtc/packages/contracts/contracts/TestContracts/invariants/TargetFunctions.sol
    1 |     | // SPDX-License-Identifier: MIT
    2 |     | 
    3 |     | pragma solidity 0.8.17;
    4 |     | 
    5 |     | import "@crytic/properties/contracts/util/Hevm.sol";
    6 |     | 
    7 |     | import "../../Interfaces/ICdpManagerData.sol";
    8 |     | import "../../Dependencies/SafeMath.sol";
    9 |     | import "../../CdpManager.sol";
   10 |     | import "../../LiquidationLibrary.sol";
   11 |     | import "../../BorrowerOperations.sol";
   12 |     | import "../../ActivePool.sol";
   13 |     | import "../../CollSurplusPool.sol";
   14 |     | import "../../SortedCdps.sol";
   15 |     | import "../../HintHelpers.sol";
   16 |     | import "../../FeeRecipient.sol";
   17 |     | import "../testnet/PriceFeedTestnet.sol";
   18 |     | import "../CollateralTokenTester.sol";
   19 |     | import "../EBTCTokenTester.sol";
   20 |     | import "../../Governor.sol";
   21 |     | import "../../EBTCDeployer.sol";
   22 |     | 
   23 |     | import "./Properties.sol";
   24 |     | import "./Actor.sol";
   25 |     | import "./BeforeAfter.sol";
   26 |     | import "./TargetContractSetup.sol";
   27 |     | import "./Asserts.sol";
   28 |     | import "../BaseStorageVariables.sol";
   29 |     | 
   30 |     | abstract contract TargetFunctions is Properties {
   31 |     |     modifier setup() virtual {
   32 | *   |         actor = actors[msg.sender];
   33 |     |         _;
   34 |     |     }
   35 |     | 
   36 |     |     ///////////////////////////////////////////////////////
   37 |     |     // Helper functions
   38 |     |     ///////////////////////////////////////////////////////
   39 |     | 
   40 |     |     function _totalCdpsBelowMcr() internal returns (uint256) {
   41 |     |         uint256 ans;
   42 |     |         bytes32 currentCdp = sortedCdps.getFirst();
   43 |     | 
   44 |     |         uint256 _price = priceFeedMock.fetchPrice();
   45 |     | 
   46 |     |         while (currentCdp != bytes32(0)) {
   47 |     |             if (cdpManager.getCachedICR(currentCdp, _price) < cdpManager.MCR()) {
   48 |     |                 ++ans;
   49 |     |             }
   50 |     | 
   51 |     |             currentCdp = sortedCdps.getNext(currentCdp);
   52 |     |         }
   53 |     | 
   54 |     |         return ans;
   55 |     |     }
   56 |     | 
   57 | *   |     function _getCdpIdsAndICRs() internal returns (Cdp[] memory ans) {
   58 | *   |         ans = new Cdp[](sortedCdps.getSize());
   59 | *   |         uint256 i = 0;
   60 | *   |         bytes32 currentCdp = sortedCdps.getFirst();
   61 |     | 
   62 | *   |         uint256 _price = priceFeedMock.fetchPrice();
   63 |     | 
   64 | *   |         while (currentCdp != bytes32(0)) {
   65 | *   |             uint256 _currentCdpDebt = cdpManager.getSyncedCdpDebt(currentCdp);
   66 | *   |             ans[i++] = Cdp({id: currentCdp, icr: cdpManager.getSyncedICR(currentCdp, _price)}); /// @audit NOTE: Synced to ensure it's realistic
   67 |     | 
   68 | *   |             currentCdp = sortedCdps.getNext(currentCdp);
   69 |     |         }
   70 |     |     }
   71 |     | 
   72 | *   |     function _cdpIdsAndICRsDiff(
   73 |     |         Cdp[] memory superset,
   74 |     |         Cdp[] memory subset
   75 | *   |     ) internal returns (Cdp[] memory ans) {
   76 | *   |         ans = new Cdp[](superset.length - subset.length);
   77 | *   |         uint256 index = 0;
   78 | *   |         for (uint256 i = 0; i < superset.length; i++) {
   79 | *   |             bool duplicate = false;
   80 | *   |             for (uint256 j = 0; j < subset.length; j++) {
   81 | *   |                 if (superset[i].id == subset[j].id) {
   82 | *   |                     duplicate = true;
   83 |     |                 }
   84 |     |             }
   85 | *   |             if (!duplicate) {
   86 | *   |                 ans[index++] = superset[i];
   87 |     |             }
   88 |     |         }
   89 |     |     }
   90 |     | 
   91 | *   |     function _getRandomCdp(uint _i) internal view returns (bytes32) {
   92 | *   |         uint _cdpIdx = _i % cdpManager.getActiveCdpsCount();
   93 | *   |         bytes32[] memory cdpIds = hintHelpers.sortedCdpsToArray();
   94 | *   |         return cdpIds[_cdpIdx];
   95 |     |     }
   96 |     | 
   97 |     |     event FlashLoanAction(uint, uint);
   98 |     | 
   99 | *   |     function _getFlashLoanActions(uint256 value) internal returns (bytes memory) {
  100 | *   |         uint256 _actions = between(value, 1, MAX_FLASHLOAN_ACTIONS);
  101 | *   |         uint256 _EBTCAmount = between(value, 1, eBTCToken.totalSupply() / 2);
  102 | *   |         uint256 _col = between(value, 1, cdpManager.getSystemCollShares() / 2);
  103 | *   |         uint256 _n = between(value, 1, cdpManager.getActiveCdpsCount());
  104 |     | 
  105 | *   |         uint256 numberOfCdps = sortedCdps.cdpCountOf(address(actor));
  106 | *   |         require(numberOfCdps > 0, "Actor must have at least one CDP open");
  107 | *   |         uint256 _i = between(value, 0, numberOfCdps - 1);
  108 | *   |         bytes32 _cdpId = sortedCdps.cdpOfOwnerByIndex(address(actor), _i);
  109 | *   |         t(_cdpId != bytes32(0), "CDP ID must not be null if the index is valid");
  110 |     | 
  111 | *   |         address[] memory _targets = new address[](_actions);
  112 | *   |         bytes[] memory _calldatas = new bytes[](_actions);
  113 |     | 
  114 | *   |         address[] memory _allTargets = new address[](6);
  115 | *   |         bytes[] memory _allCalldatas = new bytes[](6);
  116 |     | 
  117 | *   |         _allTargets[0] = address(borrowerOperations);
  118 | *   |         _allCalldatas[0] = abi.encodeWithSelector(
  119 |     |             BorrowerOperations.openCdp.selector,
  120 |     |             _EBTCAmount,
  121 | *   |             bytes32(0),
  122 |     |             bytes32(0),
  123 |     |             _col
  124 |     |         );
  125 |     | 
  126 | *   |         _allTargets[1] = address(borrowerOperations);
  127 | *   |         _allCalldatas[1] = abi.encodeWithSelector(BorrowerOperations.closeCdp.selector, _cdpId);
  128 |     | 
  129 | *   |         _allTargets[2] = address(borrowerOperations);
  130 | *   |         _allCalldatas[2] = abi.encodeWithSelector(
  131 |     |             BorrowerOperations.addColl.selector,
  132 |     |             _cdpId,
  133 |     |             _cdpId,
  134 |     |             _cdpId,
  135 |     |             _col
  136 |     |         );
  137 |     | 
  138 | *   |         _allTargets[3] = address(borrowerOperations);
  139 | *   |         _allCalldatas[3] = abi.encodeWithSelector(
  140 |     |             BorrowerOperations.withdrawColl.selector,
  141 |     |             _cdpId,
  142 |     |             _col,
  143 |     |             _cdpId,
  144 |     |             _cdpId
  145 |     |         );
  146 |     | 
  147 | *   |         _allTargets[4] = address(borrowerOperations);
  148 | *   |         _allCalldatas[4] = abi.encodeWithSelector(
  149 |     |             BorrowerOperations.withdrawDebt.selector,
  150 |     |             _cdpId,
  151 |     |             _EBTCAmount,
  152 |     |             _cdpId,
  153 |     |             _cdpId
  154 |     |         );
  155 |     | 
  156 | *   |         _allTargets[5] = address(borrowerOperations);
  157 | *   |         _allCalldatas[5] = abi.encodeWithSelector(
  158 |     |             BorrowerOperations.repayDebt.selector,
  159 |     |             _cdpId,
  160 |     |             _EBTCAmount,
  161 |     |             _cdpId,
  162 |     |             _cdpId
  163 |     |         );
  164 |     | 
  165 | *   |         for (uint256 _j = 0; _j < _actions; ++_j) {
  166 | *   |             _i = uint256(keccak256(abi.encodePacked(value, _j, _i))) % _allTargets.length;
  167 | *   |             emit FlashLoanAction(_j, _i);
  168 |     | 
  169 | *   |             _targets[_j] = _allTargets[_i];
  170 | *   |             _calldatas[_j] = _allCalldatas[_i];
  171 |     |         }
  172 |     | 
  173 | *   |         return abi.encode(_targets, _calldatas);
  174 |     |     }
  175 |     | 
  176 | *   |     function _getFirstCdpWithIcrGteMcr() internal returns (bytes32) {
  177 | *   |         bytes32 _cId = sortedCdps.getLast();
  178 | *   |         address currentBorrower = sortedCdps.getOwnerAddress(_cId);
  179 |     |         // Find the first cdp with ICR >= MCR
  180 | *   |         while (
  181 | *   |             currentBorrower != address(0) &&
  182 | *   |             cdpManager.getCachedICR(_cId, priceFeedMock.fetchPrice()) < cdpManager.MCR()
  183 |     |         ) {
  184 | *   |             _cId = sortedCdps.getPrev(_cId);
  185 | *   |             currentBorrower = sortedCdps.getOwnerAddress(_cId);
  186 |     |         }
  187 | *   |         return _cId;
  188 |     |     }
  189 |     | 
  190 | *   |     function _atLeastOneCdpIsLiquidatable(
  191 |     |         Cdp[] memory cdps,
  192 |     |         bool isRecoveryModeBefore
  193 | *   |     ) internal view returns (bool atLeastOneCdpIsLiquidatable) {
  194 | *   |         for (uint256 i = 0; i < cdps.length; ++i) {
  195 | *   |             if (
  196 | *   |                 cdps[i].icr < cdpManager.MCR() ||
  197 | *   |                 (cdps[i].icr < cdpManager.CCR() && isRecoveryModeBefore)
  198 |     |             ) {
  199 | *   |                 atLeastOneCdpIsLiquidatable = true;
  200 | *   |                 break;
  201 |     |             }
  202 |     |         }
  203 |     |     }
  204 |     | 
  205 |     |     ///////////////////////////////////////////////////////
  206 |     |     // CdpManager
  207 |     |     ///////////////////////////////////////////////////////
  208 |     | 
  209 | *   |     function _checkL_15IfRecoveryMode() internal {
  210 | *   |         if (vars.isRecoveryModeAfter) {
  211 | *   |             t(vars.lastGracePeriodStartTimestampIsSetAfter, L_15);
  212 |     |         }
  213 |     |     }
  214 |     | 
  215 | *   |     function liquidate(uint _i) public setup {
  216 |     |         bool success;
  217 | *   |         bytes memory returnData;
  218 |     | 
  219 | *   |         require(cdpManager.getActiveCdpsCount() > 1, "Cannot liquidate last CDP");
  220 |     | 
  221 | *   |         bytes32 _cdpId = _getRandomCdp(_i);
  222 |     | 
  223 | *   |         (uint256 entireDebt, ) = cdpManager.getSyncedDebtAndCollShares(_cdpId);
  224 | *   |         require(entireDebt > 0, "CDP must have debt");
  225 |     | 
  226 | *   |         _before(_cdpId);
  227 |     | 
  228 |     |         uint256 _icrToLiq = cdpManager.getSyncedICR(_cdpId, priceFeedMock.getPrice());
  229 |     | 
  230 |     |         (success, returnData) = actor.proxy(
  231 |     |             address(cdpManager),
  232 |     |             abi.encodeWithSelector(CdpManager.liquidate.selector, _cdpId)
  233 |     |         );
  234 |     | 
  235 |     |         _after(_cdpId);
  236 |     | 
  237 |     |         if (success) {
  238 |     |             // SURPLUS-CHECK-1 | The surplus is capped at 4 wei | NOTE: Proxy of growth, storage var would further refine
  239 |     |             if (_icrToLiq <= cdpManager.MCR()) {
  240 | *   |                 gte(
  241 | *   |                     vars.collSurplusPoolBefore + 12,
  242 | *   |                     vars.collSurplusPoolAfter,
  243 |     |                     "SURPLUS-CHECK-1_12"
  244 |     |                 );
  245 |     |                 gte(vars.userSurplusBefore + 12, vars.userSurplusAfter, "SURPLUS-CHECK-2_12");
  246 |     | 
  247 | *   |                 gte(vars.collSurplusPoolBefore + 8, vars.collSurplusPoolAfter, "SURPLUS-CHECK-1_8");
  248 |     |                 gte(vars.userSurplusBefore + 8, vars.userSurplusAfter, "SURPLUS-CHECK-2_8");
  249 |     | 
  250 | *   |                 gte(vars.collSurplusPoolBefore + 4, vars.collSurplusPoolAfter, "SURPLUS-CHECK-1_4");
  251 |     |                 gte(vars.userSurplusBefore + 4, vars.userSurplusAfter, "SURPLUS-CHECK-2_4");
  252 |     |             }
  253 |     | 
  254 |     |             // if ICR >= TCR then we ignore
  255 |     |             // We could check that Liquidated is not above TCR
  256 |     |             if (
  257 |     |                 vars.newIcrBefore >= cdpManager.LICR() // 103% else liquidating locks in bad debt
  258 |     |             ) {
  259 |     |                 // https://github.com/Badger-Finance/ebtc-fuzz-review/issues/5
  260 |     |                 if (vars.newIcrBefore <= vars.newTcrBefore) {
  261 |     |                     gte(vars.newTcrAfter, vars.newTcrBefore, L_12);
  262 |     |                 }
  263 |     |             }
  264 |     |             // https://github.com/Badger-Finance/ebtc-fuzz-review/issues/12
  265 | *   |             t(
  266 |     |                 vars.newIcrBefore < cdpManager.MCR() ||
  267 | *   |                     (vars.newIcrBefore < cdpManager.CCR() && vars.isRecoveryModeBefore),
  268 | *   |                 L_01
  269 |     |             );
  270 |     |             if (
  271 |     |                 vars.lastGracePeriodStartTimestampIsSetBefore &&
  272 |     |                 vars.isRecoveryModeBefore &&
  273 |     |                 vars.isRecoveryModeAfter
  274 |     |             ) {
  275 |     |                 eq(
  276 |     |                     vars.lastGracePeriodStartTimestampBefore,
  277 |     |                     vars.lastGracePeriodStartTimestampAfter,
  278 |     |                     L_14
  279 |     |                 );
  280 |     |             }
  281 |     | 
  282 |     |             _checkL_15IfRecoveryMode();
  283 |     | 
  284 |     |             if (vars.isRecoveryModeBefore && !vars.isRecoveryModeAfter) {
  285 |     |                 t(!vars.lastGracePeriodStartTimestampIsSetAfter, L_16);
  286 |     |             }
  287 |     | 
  288 |     |             gte(
  289 |     |                 vars.actorCollAfter,
  290 |     |                 vars.actorCollBefore +
  291 |     |                     collateral.getPooledEthByShares(vars.liquidatorRewardSharesBefore),
  292 |     |                 L_09
  293 |     |             );
  294 |     | 
  295 |     |             if (_icrToLiq <= cdpManager.LICR()) {
  296 |     |                 //bad debt to redistribute
  297 | *   |                 lt(cdpManager.lastEBTCDebtErrorRedistribution(), cdpManager.totalStakes(), L_17);
  298 |     |                 totalCdpDustMaxCap += cdpManager.getActiveCdpsCount();
  299 |     |             }
  300 |     | 
  301 |     |             _checkStakeInvariants();
  302 |     |         } else if (vars.sortedCdpsSizeBefore > _i) {
  303 |     |             assertRevertReasonNotEqual(returnData, "Panic(17)");
  304 |     |         }
  305 |     |     }
  306 |     | 
  307 | *   |     function partialLiquidate(uint _i, uint _partialAmount) public setup {
  308 |     |         bool success;
  309 | *   |         bytes memory returnData;
  310 |     | 
  311 | *   |         require(cdpManager.getActiveCdpsCount() > 1, "Cannot liquidate last CDP");
  312 |     | 
  313 | *   |         bytes32 _cdpId = _getRandomCdp(_i);
  314 |     | 
  315 | *   |         (uint256 entireDebt, ) = cdpManager.getSyncedDebtAndCollShares(_cdpId);
  316 | *   |         require(entireDebt > 0, "CDP must have debt");
  317 |     | 
  318 | *   |         _partialAmount = between(_partialAmount, 0, entireDebt);
  319 |     | 
  320 | *   |         _before(_cdpId);
  321 |     | 
  322 |     |         (success, returnData) = actor.proxy(
  323 |     |             address(cdpManager),
  324 |     |             abi.encodeWithSelector(
  325 |     |                 CdpManager.partiallyLiquidate.selector,
  326 |     |                 _cdpId,
  327 |     |                 _partialAmount,
  328 |     |                 _cdpId,
  329 |     |                 _cdpId
  330 |     |             )
  331 |     |         );
  332 |     | 
  333 |     |         _after(_cdpId);
  334 |     | 
  335 |     |         if (success) {
  336 |     |             lt(vars.cdpDebtAfter, vars.cdpDebtBefore, "Partial liquidation must reduce CDP debt");
  337 |     | 
  338 |     |             if (
  339 |     |                 vars.newIcrBefore >= cdpManager.LICR() // 103% else liquidating locks in bad debt
  340 |     |             ) {
  341 |     |                 // https://github.com/Badger-Finance/ebtc-fuzz-review/issues/5
  342 |     |                 if (vars.newIcrBefore <= vars.newTcrBefore) {
  343 |     |                     gte(vars.newTcrAfter, vars.newTcrBefore, L_12);
  344 |     |                 }
  345 |     |             }
  346 |     |             // https://github.com/Badger-Finance/ebtc-fuzz-review/issues/12
  347 |     |             t(
  348 |     |                 vars.newIcrBefore < cdpManager.MCR() ||
  349 |     |                     (vars.newIcrBefore < cdpManager.CCR() && vars.isRecoveryModeBefore),
  350 |     |                 L_01
  351 |     |             );
  352 |     | 
  353 |     |             eq(
  354 |     |                 vars.sortedCdpsSizeAfter,
  355 |     |                 vars.sortedCdpsSizeBefore,
  356 |     |                 "L-17 : Partial Liquidations do not close Cdps"
  357 |     |             );
  358 |     | 
  359 |     |             // https://github.com/Badger-Finance/ebtc-fuzz-review/issues/4
  360 |     |             if (vars.sortedCdpsSizeAfter == vars.sortedCdpsSizeBefore) {
  361 |     |                 // CDP was not fully liquidated
  362 |     |                 gte(
  363 |     |                     collateral.getPooledEthByShares(cdpManager.getCdpCollShares(_cdpId)),
  364 |     |                     borrowerOperations.MIN_NET_STETH_BALANCE(),
  365 |     |                     GENERAL_10
  366 |     |                 );
  367 |     |             }
  368 |     | 
  369 |     |             if (
  370 |     |                 vars.lastGracePeriodStartTimestampIsSetBefore &&
  371 |     |                 vars.isRecoveryModeBefore &&
  372 |     |                 vars.isRecoveryModeAfter
  373 |     |             ) {
  374 |     |                 eq(
  375 |     |                     vars.lastGracePeriodStartTimestampBefore,
  376 |     |                     vars.lastGracePeriodStartTimestampAfter,
  377 |     |                     L_14
  378 |     |                 );
  379 |     |             }
  380 |     | 
  381 |     |             _checkL_15IfRecoveryMode();
  382 |     | 
  383 |     |             if (vars.isRecoveryModeBefore && !vars.isRecoveryModeAfter) {
  384 |     |                 t(!vars.lastGracePeriodStartTimestampIsSetAfter, L_16);
  385 |     |             }
  386 |     | 
  387 |     |             gte(_partialAmount, borrowerOperations.MIN_CHANGE(), GENERAL_16);
  388 |     |             gte(vars.cdpDebtAfter, borrowerOperations.MIN_CHANGE(), GENERAL_15);
  389 |     |         } else {
  390 |     |             assertRevertReasonNotEqual(returnData, "Panic(17)");
  391 |     |         }
  392 |     |     }
  393 |     | 
  394 | *   |     function _checkStakeInvariants() private {
  395 | *   |         if (vars.cdpCollAfter < vars.cdpCollBefore) {
  396 | *   |             lt(vars.cdpStakeAfter, vars.cdpStakeBefore, CDPM_07);
  397 |     |         }
  398 |     | 
  399 | *   |         if (vars.cdpCollAfter > vars.cdpCollBefore) {
  400 | *   |             gt(vars.cdpStakeAfter, vars.cdpStakeBefore, CDPM_08);
  401 |     |         }
  402 |     | 
  403 | *   |         if (vars.totalCollateralSnapshotAfter > 0) {
  404 | *   |             eq(
  405 | *   |                 vars.cdpStakeAfter,
  406 | *   |                 (vars.cdpCollAfter * vars.totalStakesSnapshotAfter) /
  407 | *   |                     vars.totalCollateralSnapshotAfter,
  408 | *   |                 CDPM_09
  409 |     |             );
  410 |     |         } else {
  411 |     |             eq(vars.cdpStakeAfter, vars.cdpCollAfter, CDPM_09);
  412 |     |         }
  413 |     |     }
  414 |     | 
  415 |     |     /** Active Pool TWAP Revert Checks */
  416 | *   |     function observe() public {
  417 |     |         // We verify that any observation will never revert
  418 | *   |         try activePool.observe() {} catch {
  419 |     |             t(false, "Observe Should Never Revert");
  420 |     |         }
  421 |     |     }
  422 |     | 
  423 | *   |     function update() public {
  424 |     |         // We verify that any observation will never revert
  425 | *   |         try activePool.update() {} catch {
  426 |     |             t(false, "Update Should Never Revert");
  427 |     |         }
  428 |     |     }
  429 |     | 
  430 |     |     // NOTE: Added a bunch of stuff in other function to check against overflow reverts
  431 |     | 
  432 |     |     /** END Active Pool TWAP Revert Checks */
  433 |     | 
  434 | *   |     function liquidateCdps(uint _n) public setup {
  435 |     |         bool success;
  436 | *   |         bytes memory returnData;
  437 |     | 
  438 | *   |         require(cdpManager.getActiveCdpsCount() > 1, "Cannot liquidate last CDP");
  439 |     | 
  440 | *   |         _n = between(_n, 1, cdpManager.getActiveCdpsCount());
  441 |     | 
  442 | *   |         Cdp[] memory cdpsBefore = _getCdpIdsAndICRs();
  443 |     | 
  444 | *   |         _before(bytes32(0));
  445 |     | 
  446 | *   |         bytes32[] memory batch = liquidationSequencer.sequenceLiqToBatchLiqWithPrice(
  447 | *   |             _n,
  448 | *   |             vars.priceBefore
  449 |     |         );
  450 |     | 
  451 | *   |         bool _badDebtToRedistribute = false;
  452 | *   |         for (uint i; i < batch.length; i++) {
  453 | *   |             bytes32 _idToLiq = batch[i];
  454 |     |         }
  455 |     | 
  456 | *   |         (success, returnData) = actor.proxy(
  457 | *   |             address(cdpManager),
  458 | *   |             abi.encodeWithSelector(CdpManager.batchLiquidateCdps.selector, batch)
  459 |     |         );
  460 |     | 
  461 | *   |         _after(bytes32(0));
  462 |     | 
  463 | *   |         if (success) {
  464 | *   |             Cdp[] memory cdpsAfter = _getCdpIdsAndICRs();
  465 |     | 
  466 | *   |             Cdp[] memory cdpsLiquidated = _cdpIdsAndICRsDiff(cdpsBefore, cdpsAfter);
  467 | *   |             gte(
  468 | *   |                 cdpsLiquidated.length,
  469 | *   |                 1,
  470 |     |                 "liquidateCdps must liquidate at least 1 CDP when successful"
  471 |     |             );
  472 | *   |             lte(cdpsLiquidated.length, _n, "liquidateCdps must not liquidate more than n CDPs");
  473 | *   |             for (uint256 i = 0; i < cdpsLiquidated.length; ++i) {
  474 |     |                 // https://github.com/Badger-Finance/ebtc-fuzz-review/issues/12
  475 | *   |                 t(
  476 | *   |                     cdpsLiquidated[i].icr < cdpManager.MCR() ||
  477 |     |                         (cdpsLiquidated[i].icr < cdpManager.CCR() && vars.isRecoveryModeBefore),
  478 |     |                     L_01
  479 |     |                 );
  480 | *   |                 if (cdpsLiquidated[i].icr <= cdpManager.LICR()) {
  481 | *   |                     _badDebtToRedistribute = true;
  482 |     |                 }
  483 |     |             }
  484 |     | 
  485 |     |             // SURPLUS-CHECK-1 | The surplus is capped at 4 wei | NOTE: We use Liquidate for the exact CDP check
  486 | *   |             bool hasCdpWithSurplus;
  487 | *   |             for (uint256 i = 0; i < cdpsLiquidated.length; ++i) {
  488 | *   |                 if (cdpsLiquidated[i].icr > cdpManager.MCR()) {
  489 |     |                     hasCdpWithSurplus = true;
  490 |     |                     break;
  491 |     |                 }
  492 |     |             }
  493 |     |             // At most, each liquidate cdp must generate 4 wei of rounding error in the surplus
  494 | *   |             if (!hasCdpWithSurplus) {
  495 | *   |                 gte(
  496 | *   |                     vars.collSurplusPoolBefore + 12 * cdpsLiquidated.length,
  497 |     |                     vars.collSurplusPoolAfter,
  498 |     |                     "SURPLUS-CHECK-1_12"
  499 |     |                 );
  500 | *   |                 gte(
  501 | *   |                     vars.collSurplusPoolBefore + 8 * cdpsLiquidated.length,
  502 |     |                     vars.collSurplusPoolAfter,
  503 |     |                     "SURPLUS-CHECK-1_8"
  504 |     |                 );
  505 | *   |                 gte(
  506 | *   |                     vars.collSurplusPoolBefore + 4 * cdpsLiquidated.length,
  507 |     |                     vars.collSurplusPoolAfter,
  508 |     |                     "SURPLUS-CHECK-1_4"
  509 |     |                 );
  510 |     |             }
  511 |     | 
  512 | *   |             if (
  513 | *   |                 vars.lastGracePeriodStartTimestampIsSetBefore &&
  514 | *   |                 vars.isRecoveryModeBefore &&
  515 | *   |                 vars.isRecoveryModeAfter
  516 |     |             ) {
  517 | *   |                 eq(
  518 | *   |                     vars.lastGracePeriodStartTimestampBefore,
  519 | *   |                     vars.lastGracePeriodStartTimestampAfter,
  520 | *   |                     L_14
  521 |     |                 );
  522 |     |             }
  523 |     | 
  524 | *   |             _checkL_15IfRecoveryMode();
  525 |     | 
  526 | *   |             if (vars.isRecoveryModeBefore && !vars.isRecoveryModeAfter) {
  527 | *   |                 t(!vars.lastGracePeriodStartTimestampIsSetAfter, L_16);
  528 |     |             }
  529 | *   |             if (_badDebtToRedistribute) {
  530 | *   |                 lt(cdpManager.lastEBTCDebtErrorRedistribution(), cdpManager.totalStakes(), L_17);
  531 | *   |                 totalCdpDustMaxCap += cdpManager.getActiveCdpsCount();
  532 |     |             }
  533 |     | 
  534 | *   |             _checkStakeInvariants();
  535 | *   |         } else if (vars.sortedCdpsSizeBefore > _n) {
  536 | *   |             if (_atLeastOneCdpIsLiquidatable(cdpsBefore, vars.isRecoveryModeBefore)) {
  537 | *   |                 assertRevertReasonNotEqual(returnData, "Panic(17)");
  538 |     |             }
  539 |     |         }
  540 |     |     }
  541 |     | 
  542 | *   |     function redeemCollateral(
  543 |     |         uint _EBTCAmount,
  544 |     |         uint _partialRedemptionHintNICR,
  545 |     |         uint _maxFeePercentage,
  546 |     |         uint _maxIterations
  547 |     |     ) public setup {
  548 | *   |         _redeemCollateral(
  549 | *   |             _EBTCAmount,
  550 |     |             bytes32(0),
  551 | *   |             _partialRedemptionHintNICR,
  552 |     |             false,
  553 |     |             false,
  554 |     |             false,
  555 | *   |             _maxFeePercentage,
  556 | *   |             _maxIterations
  557 |     |         );
  558 |     |     }
  559 |     | 
  560 | *   |     function redeemCollateral(
  561 |     |         uint _EBTCAmount,
  562 |     |         bytes32 _firstRedemptionHintFromMedusa,
  563 |     |         uint256 _partialRedemptionHintNICRFromMedusa,
  564 |     |         bool useProperFirstHint,
  565 |     |         bool useProperPartialHint,
  566 |     |         bool failPartialRedemption,
  567 |     |         uint _maxFeePercentage,
  568 |     |         uint _maxIterations
  569 |     |     ) public setup {
  570 | *   |         _redeemCollateral(
  571 | *   |             _EBTCAmount,
  572 | *   |             _firstRedemptionHintFromMedusa,
  573 | *   |             _partialRedemptionHintNICRFromMedusa,
  574 | *   |             useProperFirstHint,
  575 | *   |             useProperPartialHint,
  576 | *   |             failPartialRedemption,
  577 | *   |             _maxFeePercentage,
  578 | *   |             _maxIterations
  579 |     |         );
  580 |     |     }
  581 |     | 
  582 | *   |     function _redeemCollateral(
  583 |     |         uint _EBTCAmount,
  584 |     |         bytes32 _firstRedemptionHintFromMedusa,
  585 |     |         uint256 _partialRedemptionHintNICRFromMedusa,
  586 |     |         bool useProperFirstHint,
  587 |     |         bool useProperPartialHint,
  588 |     |         bool failPartialRedemption,
  589 |     |         uint _maxFeePercentage,
  590 |     |         uint _maxIterations
  591 |     |     ) internal {
  592 | *   |         require(cdpManager.getActiveCdpsCount() > 1, "Cannot redeem last CDP");
  593 |     | 
  594 | *   |         _EBTCAmount = between(_EBTCAmount, 0, eBTCToken.balanceOf(address(actor)));
  595 |     | 
  596 | *   |         _maxIterations = between(_maxIterations, 0, 10);
  597 |     | 
  598 | *   |         _maxFeePercentage = between(
  599 | *   |             _maxFeePercentage,
  600 | *   |             cdpManager.redemptionFeeFloor(),
  601 | *   |             cdpManager.DECIMAL_PRECISION()
  602 |     |         );
  603 |     | 
  604 | *   |         bytes32 _cdpId = _getFirstCdpWithIcrGteMcr();
  605 |     | 
  606 | *   |         _before(_cdpId);
  607 |     | 
  608 |     |         {
  609 |     |             uint price = priceFeedMock.fetchPrice();
  610 |     | 
  611 |     |             (bytes32 firstRedemptionHintVal, uint256 partialRedemptionHintNICR, , ) = hintHelpers
  612 |     |                 .getRedemptionHints(_EBTCAmount, price, _maxIterations);
  613 |     | 
  614 |     |             _firstRedemptionHintFromMedusa = useProperFirstHint
  615 |     |                 ? firstRedemptionHintVal
  616 |     |                 : _firstRedemptionHintFromMedusa;
  617 |     | 
  618 |     |             _partialRedemptionHintNICRFromMedusa = useProperPartialHint
  619 |     |                 ? partialRedemptionHintNICR
  620 |     |                 : _partialRedemptionHintNICRFromMedusa;
  621 |     |         }
  622 |     | 
  623 |     |         _syncAPDebtTwapToSpotValue();
  624 |     | 
  625 |     |         {
  626 |     |             bool success;
  627 |     | 
  628 |     |             (success, ) = actor.proxy(
  629 |     |                 address(cdpManager),
  630 |     |                 abi.encodeWithSelector(
  631 |     |                     CdpManager.redeemCollateral.selector,
  632 |     |                     _EBTCAmount,
  633 |     |                     _firstRedemptionHintFromMedusa,
  634 |     |                     bytes32(0),
  635 |     |                     bytes32(0),
  636 |     |                     failPartialRedemption ? 0 : _partialRedemptionHintNICRFromMedusa,
  637 |     |                     _maxIterations,
  638 |     |                     _maxFeePercentage
  639 |     |                 )
  640 |     |             );
  641 |     | 
  642 |     |             require(success);
  643 |     |         }
  644 |     | 
  645 |     |         _after(_cdpId);
  646 |     | 
  647 |     |         gt(vars.tcrBefore, cdpManager.MCR(), EBTC_02);
  648 |     |         if (_maxIterations == 1) {
  649 |     |             gte(vars.activePoolDebtBefore, vars.activePoolDebtAfter, CDPM_05);
  650 |     |             gte(vars.cdpDebtBefore, vars.cdpDebtAfter, CDPM_06);
  651 |     |             // TODO: CHECK THIS
  652 |     |             // https://github.com/Badger-Finance/ebtc-fuzz-review/issues/10#issuecomment-1702685732
  653 |     |             if (vars.sortedCdpsSizeBefore == vars.sortedCdpsSizeAfter) {
  654 |     |                 // Redemptions do not reduce TCR
  655 |     |                 // If redemptions do not close any CDP that was healthy (low debt, high coll)
  656 |     |                 gt(vars.newTcrAfter, vars.newTcrBefore, R_07);
  657 |     |             }
  658 |     |             t(invariant_CDPM_04(vars), CDPM_04);
  659 |     |         }
  660 |     |         gt(vars.actorEbtcBefore, vars.actorEbtcAfter, R_08);
  661 |     | 
  662 |     |         // Verify Fee Recipient Received the Fee
  663 |     |         gte(vars.feeRecipientCollSharesAfter, vars.feeRecipientCollSharesBefore, F_02);
  664 |     | 
  665 |     |         if (
  666 |     |             vars.lastGracePeriodStartTimestampIsSetBefore &&
  667 |     |             vars.isRecoveryModeBefore &&
  668 |     |             vars.isRecoveryModeAfter
  669 |     |         ) {
  670 |     |             eq(
  671 |     |                 vars.lastGracePeriodStartTimestampBefore,
  672 |     |                 vars.lastGracePeriodStartTimestampAfter,
  673 |     |                 L_14
  674 |     |             );
  675 |     |         }
  676 |     | 
  677 |     |         _checkL_15IfRecoveryMode();
  678 |     | 
  679 |     |         if (vars.isRecoveryModeBefore && !vars.isRecoveryModeAfter) {
  680 |     |             t(!vars.lastGracePeriodStartTimestampIsSetAfter, L_16);
  681 |     |         }
  682 |     | 
  683 |     |         _checkStakeInvariants();
  684 |     |     }
  685 |     | 
  686 |     |     ///////////////////////////////////////////////////////
  687 |     |     // ActivePool
  688 |     |     ///////////////////////////////////////////////////////
  689 |     | 
  690 |     |     function _syncAPDebtTwapToSpotValue() internal {
  691 |     |         hevm.warp(block.timestamp + activePool.PERIOD());
  692 |     |         activePool.update();
  693 |     |     }
  694 |     | 
  695 | *   |     function flashLoanColl(uint _amount) public setup {
  696 |     |         bool success;
  697 | *   |         bytes memory returnData;
  698 |     | 
  699 | *   |         _amount = between(_amount, 0, activePool.maxFlashLoan(address(collateral)));
  700 | *   |         uint _fee = activePool.flashFee(address(collateral), _amount);
  701 |     | 
  702 | *   |         _before(bytes32(0));
  703 |     | 
  704 |     |         // take the flashloan which should always cost the fee paid by caller
  705 | *   |         uint _balBefore = collateral.sharesOf(activePool.feeRecipientAddress());
  706 | *   |         (success, returnData) = actor.proxy(
  707 | *   |             address(activePool),
  708 | *   |             abi.encodeWithSelector(
  709 | *   |                 ActivePool.flashLoan.selector,
  710 |     |                 IERC3156FlashBorrower(address(actor)),
  711 | *   |                 address(collateral),
  712 | *   |                 _amount,
  713 | *   |                 _getFlashLoanActions(_amount)
  714 |     |             )
  715 |     |         );
  716 |     | 
  717 | *r  |         require(success);
  718 |     | 
  719 | *   |         _after(bytes32(0));
  720 |     | 
  721 | *   |         uint _balAfter = collateral.sharesOf(activePool.feeRecipientAddress());
  722 | *   |         eq(_balAfter - _balBefore, collateral.getSharesByPooledEth(_fee), F_03);
  723 |     | 
  724 | *   |         if (
  725 | *   |             vars.lastGracePeriodStartTimestampIsSetBefore &&
  726 | *   |             vars.isRecoveryModeBefore &&
  727 | *   |             vars.isRecoveryModeAfter
  728 |     |         ) {
  729 | *   |             eq(
  730 | *   |                 vars.lastGracePeriodStartTimestampBefore,
  731 | *   |                 vars.lastGracePeriodStartTimestampAfter,
  732 | *   |                 L_14
  733 |     |             );
  734 |     |         }
  735 |     | 
  736 | *   |         _checkL_15IfRecoveryMode();
  737 |     | 
  738 | *   |         if (vars.isRecoveryModeBefore && !vars.isRecoveryModeAfter) {
  739 | *   |             t(!vars.lastGracePeriodStartTimestampIsSetAfter, L_16);
  740 |     |         }
  741 |     | 
  742 | *   |         _checkStakeInvariants();
  743 |     |     }
  744 |     | 
  745 |     |     ///////////////////////////////////////////////////////
  746 |     |     // BorrowerOperations
  747 |     |     ///////////////////////////////////////////////////////
  748 |     | 
  749 | *   |     function flashLoanEBTC(uint _amount) public setup {
  750 |     |         bool success;
  751 | *   |         bytes memory returnData;
  752 |     | 
  753 | *   |         _amount = between(_amount, 0, borrowerOperations.maxFlashLoan(address(eBTCToken)));
  754 |     | 
  755 | *   |         uint _fee = borrowerOperations.flashFee(address(eBTCToken), _amount);
  756 |     | 
  757 | *   |         _before(bytes32(0));
  758 |     | 
  759 |     |         // take the flashloan which should always cost the fee paid by caller
  760 | *   |         uint _balBefore = eBTCToken.balanceOf(borrowerOperations.feeRecipientAddress());
  761 | *   |         (success, returnData) = actor.proxy(
  762 | *   |             address(borrowerOperations),
  763 | *   |             abi.encodeWithSelector(
  764 | *   |                 BorrowerOperations.flashLoan.selector,
  765 |     |                 IERC3156FlashBorrower(address(actor)),
  766 | *   |                 address(eBTCToken),
  767 | *   |                 _amount,
  768 | *   |                 _getFlashLoanActions(_amount)
  769 |     |             )
  770 |     |         );
  771 |     | 
  772 |     |         // BorrowerOperations.flashLoan may revert due to reentrancy
  773 | *r  |         require(success);
  774 |     | 
  775 | *   |         _after(bytes32(0));
  776 |     | 
  777 | *   |         uint _balAfter = eBTCToken.balanceOf(borrowerOperations.feeRecipientAddress());
  778 | *   |         eq(_balAfter - _balBefore, _fee, F_03);
  779 |     | 
  780 |     |         if (
  781 |     |             vars.lastGracePeriodStartTimestampIsSetBefore &&
  782 |     |             vars.isRecoveryModeBefore &&
  783 |     |             vars.isRecoveryModeAfter
  784 |     |         ) {
  785 |     |             eq(
  786 |     |                 vars.lastGracePeriodStartTimestampBefore,
  787 |     |                 vars.lastGracePeriodStartTimestampAfter,
  788 |     |                 L_14
  789 |     |             );
  790 |     |         }
  791 |     | 
  792 |     |         _checkL_15IfRecoveryMode();
  793 |     | 
  794 |     |         if (vars.isRecoveryModeBefore && !vars.isRecoveryModeAfter) {
  795 |     |             t(!vars.lastGracePeriodStartTimestampIsSetAfter, L_16);
  796 |     |         }
  797 |     | 
  798 |     |         _checkStakeInvariants();
  799 |     |     }
  800 |     | 
  801 | *   |     function openCdp(uint256 _col, uint256 _EBTCAmount) public setup returns (bytes32 _cdpId) {
  802 |     |         bool success;
  803 | *   |         bytes memory returnData;
  804 |     | 
  805 |     |         // we pass in CCR instead of MCR in case it's the first one
  806 | *   |         uint price = priceFeedMock.fetchPrice();
  807 |     | 
  808 | *   |         uint256 requiredCollAmount = (_EBTCAmount * cdpManager.CCR()) / (price);
  809 | *   |         uint256 minCollAmount = max(
  810 | *   |             cdpManager.MIN_NET_STETH_BALANCE() + borrowerOperations.LIQUIDATOR_REWARD(),
  811 | *   |             requiredCollAmount
  812 |     |         );
  813 | *   |         uint256 maxCollAmount = min(2 * minCollAmount, INITIAL_COLL_BALANCE / 10);
  814 | *   |         _col = between(requiredCollAmount, minCollAmount, maxCollAmount);
  815 |     | 
  816 | *   |         (success, ) = actor.proxy(
  817 | *   |             address(collateral),
  818 | *   |             abi.encodeWithSelector(
  819 | *   |                 CollateralTokenTester.approve.selector,
  820 | *   |                 address(borrowerOperations),
  821 |     |                 _col
  822 |     |             )
  823 |     |         );
  824 | *   |         t(success, "Approve never fails");
  825 |     | 
  826 | *   |         _before(bytes32(0));
  827 |     | 
  828 | *   |         (success, returnData) = actor.proxy(
  829 | *   |             address(borrowerOperations),
  830 | *   |             abi.encodeWithSelector(
  831 |     |                 BorrowerOperations.openCdp.selector,
  832 |     |                 _EBTCAmount,
  833 |     |                 bytes32(0),
  834 |     |                 bytes32(0),
  835 |     |                 _col
  836 |     |             )
  837 |     |         );
  838 |     | 
  839 | *   |         if (success) {
  840 | *   |             _cdpId = abi.decode(returnData, (bytes32));
  841 | *   |             _after(_cdpId);
  842 |     | 
  843 |     |             (invariant_GENERAL_01(vars), GENERAL_01);
  844 |     |             gt(vars.icrAfter, cdpManager.MCR(), BO_01);
  845 |     | 
  846 |     |             eq(vars.newTcrAfter, vars.tcrAfter, GENERAL_11);
  847 |     | 
  848 |     |             // https://github.com/Badger-Finance/ebtc-fuzz-review/issues/3
  849 |     |             t(invariant_GENERAL_09(cdpManager, vars), GENERAL_09);
  850 |     |             // https://github.com/Badger-Finance/ebtc-fuzz-review/issues/4
  851 |     |             gte(
  852 |     |                 collateral.getPooledEthByShares(cdpManager.getCdpCollShares(_cdpId)),
  853 |     |                 borrowerOperations.MIN_NET_STETH_BALANCE(),
  854 |     |                 GENERAL_10
  855 |     |             );
  856 |     |             eq(
  857 |     |                 vars.sortedCdpsSizeBefore + 1,
  858 |     |                 vars.sortedCdpsSizeAfter,
  859 |     |                 "CDPs count must have increased"
  860 |     |             );
  861 |     |             if (
  862 |     |                 vars.lastGracePeriodStartTimestampIsSetBefore &&
  863 |     |                 vars.isRecoveryModeBefore &&
  864 |     |                 vars.isRecoveryModeAfter
  865 |     |             ) {
  866 |     |                 eq(
  867 |     |                     vars.lastGracePeriodStartTimestampBefore,
  868 |     |                     vars.lastGracePeriodStartTimestampAfter,
  869 |     |                     L_14
  870 |     |                 );
  871 |     |             }
  872 |     | 
  873 |     |             _checkL_15IfRecoveryMode();
  874 |     | 
  875 |     |             if (vars.isRecoveryModeBefore && !vars.isRecoveryModeAfter) {
  876 |     |                 t(!vars.lastGracePeriodStartTimestampIsSetAfter, L_16);
  877 |     |             }
  878 |     | 
  879 |     |             gte(_EBTCAmount, borrowerOperations.MIN_CHANGE(), GENERAL_16);
  880 |     |             gte(vars.cdpDebtAfter, borrowerOperations.MIN_CHANGE(), GENERAL_15);
  881 |     |             require(invariant_BO_09(cdpManager, priceFeedMock.getPrice(), _cdpId), BO_09);
  882 |     | 
  883 |     |             _checkStakeInvariants();
  884 |     |         } else {
  885 | *   |             assertRevertReasonNotEqual(returnData, "Panic(17)"); /// Done
  886 |     |         }
  887 |     |     }
  888 |     | 
  889 | *   |     function addColl(uint _coll, uint256 _i) public setup {
  890 |     |         bool success;
  891 | *   |         bytes memory returnData;
  892 |     | 
  893 | *   |         uint256 numberOfCdps = sortedCdps.cdpCountOf(address(actor));
  894 | *   |         require(numberOfCdps > 0, "Actor must have at least one CDP open");
  895 |     | 
  896 | *   |         _i = between(_i, 0, numberOfCdps - 1);
  897 | *   |         bytes32 _cdpId = sortedCdps.cdpOfOwnerByIndex(address(actor), _i);
  898 | *   |         t(_cdpId != bytes32(0), "CDP ID must not be null if the index is valid");
  899 |     | 
  900 | *   |         _coll = between(_coll, 0, INITIAL_COLL_BALANCE / 10);
  901 |     | 
  902 | *   |         if (collateral.balanceOf(address(actor)) < _coll) {
  903 |     |             (success, ) = actor.proxy(
  904 |     |                 address(collateral),
  905 |     |                 abi.encodeWithSelector(CollateralTokenTester.deposit.selector, ""),
  906 |     |                 (_coll - collateral.balanceOf(address(actor)))
  907 |     |             );
  908 |     |             require(success);
  909 | *   |             require(
  910 |     |                 collateral.balanceOf(address(actor)) > _coll,
  911 |     |                 "Actor has high enough balance to add"
  912 |     |             );
  913 |     |         }
  914 |     | 
  915 | *   |         (success, ) = actor.proxy(
  916 | *   |             address(collateral),
  917 | *   |             abi.encodeWithSelector(
  918 | *   |                 CollateralTokenTester.approve.selector,
  919 | *   |                 address(borrowerOperations),
  920 | *   |                 _coll
  921 |     |             )
  922 |     |         );
  923 | *   |         t(success, "Approve never fails");
  924 |     | 
  925 | *   |         _before(_cdpId);
  926 |     | 
  927 |     |         (success, returnData) = actor.proxy(
  928 |     |             address(borrowerOperations),
  929 |     |             abi.encodeWithSelector(
  930 |     |                 BorrowerOperations.addColl.selector,
  931 |     |                 _cdpId,
  932 |     |                 _cdpId,
  933 |     |                 _cdpId,
  934 |     |                 _coll
  935 |     |             )
  936 |     |         );
  937 |     | 
  938 |     |         _after(_cdpId);
  939 |     | 
  940 |     |         if (success) {
  941 |     |             emit L3(
  942 |     |                 vars.isRecoveryModeBefore ? 1 : 0,
  943 |     |                 vars.hasGracePeriodPassedBefore ? 1 : 0,
  944 |     |                 vars.icrAfter
  945 |     |             );
  946 |     |             emit L3(
  947 |     |                 block.timestamp,
  948 |     |                 cdpManager.lastGracePeriodStartTimestamp(),
  949 |     |                 cdpManager.recoveryModeGracePeriodDuration()
  950 |     |             );
  951 |     | 
  952 |     |             eq(vars.newTcrAfter, vars.tcrAfter, GENERAL_11);
  953 |     |             gte(vars.nicrAfter, vars.nicrBefore, BO_03);
  954 |     |             // https://github.com/Badger-Finance/ebtc-fuzz-review/issues/3
  955 |     |             t(invariant_GENERAL_09(cdpManager, vars), GENERAL_09);
  956 |     |             // https://github.com/Badger-Finance/ebtc-fuzz-review/issues/4
  957 |     |             gte(
  958 |     |                 collateral.getPooledEthByShares(cdpManager.getCdpCollShares(_cdpId)),
  959 |     |                 borrowerOperations.MIN_NET_STETH_BALANCE(),
  960 |     |                 GENERAL_10
  961 |     |             );
  962 |     | 
  963 |     |             t(invariant_GENERAL_01(vars), GENERAL_01);
  964 |     | 
  965 |     |             if (
  966 |     |                 vars.lastGracePeriodStartTimestampIsSetBefore &&
  967 |     |                 vars.isRecoveryModeBefore &&
  968 |     |                 vars.isRecoveryModeAfter
  969 |     |             ) {
  970 |     |                 eq(
  971 |     |                     vars.lastGracePeriodStartTimestampBefore,
  972 |     |                     vars.lastGracePeriodStartTimestampAfter,
  973 |     |                     L_14
  974 |     |                 );
  975 |     |             }
  976 |     | 
  977 |     |             _checkL_15IfRecoveryMode();
  978 |     | 
  979 |     |             if (vars.isRecoveryModeBefore && !vars.isRecoveryModeAfter) {
  980 |     |                 t(!vars.lastGracePeriodStartTimestampIsSetAfter, L_16);
  981 |     |             }
  982 |     | 
  983 |     |             gte(_coll, borrowerOperations.MIN_CHANGE(), GENERAL_16);
  984 |     | 
  985 |     |             _checkStakeInvariants();
  986 |     |         } else {
  987 |     |             assertRevertReasonNotEqual(returnData, "Panic(17)");
  988 |     |         }
  989 |     |     }
  990 |     | 
  991 | *   |     function withdrawColl(uint _amount, uint256 _i) public setup {
  992 |     |         bool success;
  993 | *   |         bytes memory returnData;
  994 |     | 
  995 | *   |         uint256 numberOfCdps = sortedCdps.cdpCountOf(address(actor));
  996 | *   |         require(numberOfCdps > 0, "Actor must have at least one CDP open");
  997 |     | 
  998 | *   |         _i = between(_i, 0, numberOfCdps - 1);
  999 | *   |         bytes32 _cdpId = sortedCdps.cdpOfOwnerByIndex(address(actor), _i);
 1000 | *   |         t(_cdpId != bytes32(0), "CDP ID must not be null if the index is valid");
 1001 |     | 
 1002 |     |         // Can only withdraw up to CDP collateral amount, otherwise will revert with assert
 1003 | *   |         _amount = between(
 1004 | *   |             _amount,
 1005 | *   |             0,
 1006 | *   |             collateral.getPooledEthByShares(cdpManager.getCdpCollShares(_cdpId))
 1007 |     |         );
 1008 |     | 
 1009 | *   |         _before(_cdpId);
 1010 |     | 
 1011 |     |         (success, returnData) = actor.proxy(
 1012 |     |             address(borrowerOperations),
 1013 |     |             abi.encodeWithSelector(
 1014 |     |                 BorrowerOperations.withdrawColl.selector,
 1015 |     |                 _cdpId,
 1016 |     |                 _amount,
 1017 |     |                 _cdpId,
 1018 |     |                 _cdpId
 1019 |     |             )
 1020 |     |         );
 1021 |     | 
 1022 |     |         _after(_cdpId);
 1023 |     | 
 1024 |     |         if (success) {
 1025 |     |             eq(vars.newTcrAfter, vars.tcrAfter, GENERAL_11);
 1026 |     |             lte(vars.nicrAfter, vars.nicrBefore, BO_04);
 1027 |     |             // https://github.com/Badger-Finance/ebtc-fuzz-review/issues/3
 1028 |     |             t(invariant_GENERAL_09(cdpManager, vars), GENERAL_09);
 1029 |     |             t(invariant_GENERAL_01(vars), GENERAL_01);
 1030 |     |             // https://github.com/Badger-Finance/ebtc-fuzz-review/issues/4
 1031 |     |             gte(
 1032 |     |                 collateral.getPooledEthByShares(cdpManager.getCdpCollShares(_cdpId)),
 1033 |     |                 borrowerOperations.MIN_NET_STETH_BALANCE(),
 1034 |     |                 GENERAL_10
 1035 |     |             );
 1036 |     | 
 1037 |     |             if (
 1038 |     |                 vars.lastGracePeriodStartTimestampIsSetBefore &&
 1039 |     |                 vars.isRecoveryModeBefore &&
 1040 |     |                 vars.isRecoveryModeAfter
 1041 |     |             ) {
 1042 |     |                 eq(
 1043 |     |                     vars.lastGracePeriodStartTimestampBefore,
 1044 |     |                     vars.lastGracePeriodStartTimestampAfter,
 1045 |     |                     L_14
 1046 |     |                 );
 1047 |     |             }
 1048 |     | 
 1049 |     |             _checkL_15IfRecoveryMode();
 1050 |     | 
 1051 |     |             if (vars.isRecoveryModeBefore && !vars.isRecoveryModeAfter) {
 1052 |     |                 t(!vars.lastGracePeriodStartTimestampIsSetAfter, L_16);
 1053 |     |             }
 1054 |     | 
 1055 |     |             gte(_amount, borrowerOperations.MIN_CHANGE(), GENERAL_16);
 1056 |     | 
 1057 |     |             _checkStakeInvariants();
 1058 |     |         } else {
 1059 |     |             assertRevertReasonNotEqual(returnData, "Panic(17)");
 1060 |     |         }
 1061 |     |     }
 1062 |     | 
 1063 | *   |     function withdrawDebt(uint _amount, uint256 _i) public setup {
 1064 |     |         bool success;
 1065 | *   |         bytes memory returnData;
 1066 |     | 
 1067 | *   |         uint256 numberOfCdps = sortedCdps.cdpCountOf(address(actor));
 1068 | *   |         require(numberOfCdps > 0, "Actor must have at least one CDP open");
 1069 |     | 
 1070 | *   |         _i = between(_i, 0, numberOfCdps - 1);
 1071 | *   |         bytes32 _cdpId = sortedCdps.cdpOfOwnerByIndex(address(actor), _i);
 1072 | *   |         t(_cdpId != bytes32(0), "CDP ID must not be null if the index is valid");
 1073 |     | 
 1074 |     |         // TODO verify the assumption below, maybe there's a more sensible (or Governance-defined/hardcoded) limit for the maximum amount of minted eBTC at a single operation
 1075 |     |         // Can only withdraw up to type(uint128).max eBTC, so that `BorrwerOperations._getNewCdpAmounts` does not overflow
 1076 | *   |         _amount = between(_amount, 0, type(uint128).max); /// NOTE: Implicitly testing for caps
 1077 |     | 
 1078 | *   |         _before(_cdpId);
 1079 |     | 
 1080 |     |         (success, returnData) = actor.proxy(
 1081 |     |             address(borrowerOperations),
 1082 |     |             abi.encodeWithSelector(
 1083 |     |                 BorrowerOperations.withdrawDebt.selector,
 1084 |     |                 _cdpId,
 1085 |     |                 _amount,
 1086 |     |                 _cdpId,
 1087 |     |                 _cdpId
 1088 |     |             )
 1089 |     |         );
 1090 |     | 
 1091 |     |         // Require(success) -> If success, we check same stuff
 1092 |     |         // Else we ony verify no overflow
 1093 |     |         if (success) {
 1094 |     |             _after(_cdpId);
 1095 |     | 
 1096 |     |             eq(vars.newTcrAfter, vars.tcrAfter, GENERAL_11);
 1097 |     |             gte(vars.cdpDebtAfter, vars.cdpDebtBefore, "withdrawDebt must not decrease debt");
 1098 |     |             eq(
 1099 |     |                 vars.actorEbtcAfter,
 1100 |     |                 vars.actorEbtcBefore + _amount,
 1101 |     |                 "withdrawDebt must increase debt by requested amount"
 1102 |     |             );
 1103 |     |             // https://github.com/Badger-Finance/ebtc-fuzz-review/issues/4
 1104 |     |             gte(
 1105 |     |                 collateral.getPooledEthByShares(cdpManager.getCdpCollShares(_cdpId)),
 1106 |     |                 borrowerOperations.MIN_NET_STETH_BALANCE(),
 1107 |     |                 GENERAL_10
 1108 |     |             );
 1109 |     | 
 1110 |     |             if (
 1111 |     |                 vars.lastGracePeriodStartTimestampIsSetBefore &&
 1112 |     |                 vars.isRecoveryModeBefore &&
 1113 |     |                 vars.isRecoveryModeAfter
 1114 |     |             ) {
 1115 |     |                 eq(
 1116 |     |                     vars.lastGracePeriodStartTimestampBefore,
 1117 |     |                     vars.lastGracePeriodStartTimestampAfter,
 1118 |     |                     L_14
 1119 |     |                 );
 1120 |     |             }
 1121 |     | 
 1122 |     |             _checkL_15IfRecoveryMode();
 1123 |     | 
 1124 |     |             if (vars.isRecoveryModeBefore && !vars.isRecoveryModeAfter) {
 1125 |     |                 t(!vars.lastGracePeriodStartTimestampIsSetAfter, L_16);
 1126 |     |             }
 1127 |     | 
 1128 |     |             gte(_amount, borrowerOperations.MIN_CHANGE(), GENERAL_16);
 1129 |     |             gte(vars.cdpDebtAfter, borrowerOperations.MIN_CHANGE(), GENERAL_15);
 1130 |     | 
 1131 |     |             _checkStakeInvariants();
 1132 |     |         } else {
 1133 |     |             assertRevertReasonNotEqual(returnData, "Panic(17)");
 1134 |     |         }
 1135 |     |     }
 1136 |     | 
 1137 | *   |     function repayDebt(uint _amount, uint256 _i) public setup {
 1138 |     |         bool success;
 1139 | *   |         bytes memory returnData;
 1140 |     | 
 1141 | *   |         uint256 numberOfCdps = sortedCdps.cdpCountOf(address(actor));
 1142 | *r  |         require(numberOfCdps > 0, "Actor must have at least one CDP open");
 1143 |     | 
 1144 | *   |         _i = between(_i, 0, numberOfCdps - 1);
 1145 | *   |         bytes32 _cdpId = sortedCdps.cdpOfOwnerByIndex(address(actor), _i);
 1146 | *   |         t(_cdpId != bytes32(0), "CDP ID must not be null if the index is valid");
 1147 |     | 
 1148 | *   |         (uint256 entireDebt, ) = cdpManager.getSyncedDebtAndCollShares(_cdpId);
 1149 |     | 
 1150 | *   |         _amount = between(_amount, 0, entireDebt);
 1151 |     | 
 1152 | *   |         _before(_cdpId);
 1153 |     | 
 1154 |     |         (success, returnData) = actor.proxy(
 1155 |     |             address(borrowerOperations),
 1156 |     |             abi.encodeWithSelector(
 1157 |     |                 BorrowerOperations.repayDebt.selector,
 1158 |     |                 _cdpId,
 1159 |     |                 _amount,
 1160 |     |                 _cdpId,
 1161 |     |                 _cdpId
 1162 |     |             )
 1163 |     |         );
 1164 |     |         if (success) {
 1165 |     |             _after(_cdpId);
 1166 |     | 
 1167 |     |             eq(vars.newTcrAfter, vars.tcrAfter, GENERAL_11);
 1168 |     | 
 1169 |     |             // https://github.com/Badger-Finance/ebtc-fuzz-review/issues/3
 1170 |     |             gte(vars.newTcrAfter, vars.newTcrBefore, BO_08);
 1171 |     | 
 1172 |     |             eq(vars.ebtcTotalSupplyBefore - _amount, vars.ebtcTotalSupplyAfter, BO_07);
 1173 |     |             eq(vars.actorEbtcBefore - _amount, vars.actorEbtcAfter, BO_07);
 1174 |     |             // https://github.com/Badger-Finance/ebtc-fuzz-review/issues/3
 1175 |     |             t(invariant_GENERAL_09(cdpManager, vars), GENERAL_09);
 1176 |     |             t(invariant_GENERAL_01(vars), GENERAL_01);
 1177 |     |             // https://github.com/Badger-Finance/ebtc-fuzz-review/issues/4
 1178 |     |             gte(
 1179 |     |                 collateral.getPooledEthByShares(cdpManager.getCdpCollShares(_cdpId)),
 1180 |     |                 borrowerOperations.MIN_NET_STETH_BALANCE(),
 1181 |     |                 GENERAL_10
 1182 |     |             );
 1183 |     | 
 1184 |     |             if (
 1185 |     |                 vars.lastGracePeriodStartTimestampIsSetBefore &&
 1186 |     |                 vars.isRecoveryModeBefore &&
 1187 |     |                 vars.isRecoveryModeAfter
 1188 |     |             ) {
 1189 |     |                 eq(
 1190 |     |                     vars.lastGracePeriodStartTimestampBefore,
 1191 |     |                     vars.lastGracePeriodStartTimestampAfter,
 1192 |     |                     L_14
 1193 |     |                 );
 1194 |     |             }
 1195 |     | 
 1196 |     |             _checkL_15IfRecoveryMode();
 1197 |     | 
 1198 |     |             if (vars.isRecoveryModeBefore && !vars.isRecoveryModeAfter) {
 1199 |     |                 t(!vars.lastGracePeriodStartTimestampIsSetAfter, L_16);
 1200 |     |             }
 1201 |     | 
 1202 |     |             gte(_amount, borrowerOperations.MIN_CHANGE(), GENERAL_16);
 1203 |     |             gte(vars.cdpDebtAfter, borrowerOperations.MIN_CHANGE(), GENERAL_15);
 1204 |     | 
 1205 |     |             _checkStakeInvariants();
 1206 |     |         } else {
 1207 |     |             assertRevertReasonNotEqual(returnData, "Panic(17)");
 1208 |     |         }
 1209 |     |     }
 1210 |     | 
 1211 | *   |     function closeCdp(uint _i) public setup {
 1212 |     |         bool success;
 1213 | *   |         bytes memory returnData;
 1214 |     | 
 1215 | *   |         require(cdpManager.getActiveCdpsCount() > 1, "Cannot close last CDP");
 1216 |     | 
 1217 | *   |         uint256 numberOfCdps = sortedCdps.cdpCountOf(address(actor));
 1218 | *   |         require(numberOfCdps > 0, "Actor must have at least one CDP open");
 1219 |     | 
 1220 | *   |         _i = between(_i, 0, numberOfCdps - 1);
 1221 | *   |         bytes32 _cdpId = sortedCdps.cdpOfOwnerByIndex(address(actor), _i);
 1222 | *   |         t(_cdpId != bytes32(0), "CDP ID must not be null if the index is valid");
 1223 |     | 
 1224 | *   |         _before(_cdpId);
 1225 |     | 
 1226 |     |         (success, returnData) = actor.proxy(
 1227 |     |             address(borrowerOperations),
 1228 |     |             abi.encodeWithSelector(BorrowerOperations.closeCdp.selector, _cdpId)
 1229 |     |         );
 1230 |     | 
 1231 |     |         _after(_cdpId);
 1232 |     | 
 1233 |     |         if (success) {
 1234 |     |             eq(vars.newTcrAfter, vars.tcrAfter, GENERAL_11);
 1235 |     |             eq(vars.cdpDebtAfter, 0, BO_02);
 1236 |     |             eq(
 1237 |     |                 vars.sortedCdpsSizeBefore - 1,
 1238 |     |                 vars.sortedCdpsSizeAfter,
 1239 |     |                 "closeCdp reduces list size by 1"
 1240 |     |             );
 1241 |     |             gt(
 1242 |     |                 vars.actorCollAfter,
 1243 |     |                 vars.actorCollBefore,
 1244 |     |                 "closeCdp increases the collateral balance of the user"
 1245 |     |             );
 1246 |     |             // https://github.com/Badger-Finance/ebtc-fuzz-review/issues/3
 1247 |     |             t(invariant_GENERAL_09(cdpManager, vars), GENERAL_09);
 1248 |     |             emit L4(
 1249 |     |                 vars.actorCollBefore,
 1250 |     |                 vars.cdpCollBefore,
 1251 |     |                 vars.liquidatorRewardSharesBefore,
 1252 |     |                 vars.actorCollAfter
 1253 |     |             );
 1254 |     |             gt(
 1255 |     |                 // https://github.com/Badger-Finance/ebtc-fuzz-review/issues/11
 1256 |     |                 // Note: not checking for strict equality since split fee is difficult to calculate a-priori, so the CDP collateral value may not be sent back to the user in full
 1257 |     |                 vars.actorCollAfter,
 1258 |     |                 vars.actorCollBefore +
 1259 |     |                     // ActivePool transfer SHARES not ETH directly
 1260 |     |                     collateral.getPooledEthByShares(vars.liquidatorRewardSharesBefore),
 1261 |     |                 BO_05
 1262 |     |             );
 1263 |     |             t(invariant_GENERAL_01(vars), GENERAL_01);
 1264 |     | 
 1265 |     |             if (
 1266 |     |                 vars.lastGracePeriodStartTimestampIsSetBefore &&
 1267 |     |                 vars.isRecoveryModeBefore &&
 1268 |     |                 vars.isRecoveryModeAfter
 1269 |     |             ) {
 1270 |     |                 eq(
 1271 |     |                     vars.lastGracePeriodStartTimestampBefore,
 1272 |     |                     vars.lastGracePeriodStartTimestampAfter,
 1273 |     |                     L_14
 1274 |     |                 );
 1275 |     |             }
 1276 |     | 
 1277 |     |             _checkL_15IfRecoveryMode();
 1278 |     | 
 1279 |     |             if (vars.isRecoveryModeBefore && !vars.isRecoveryModeAfter) {
 1280 |     |                 t(!vars.lastGracePeriodStartTimestampIsSetAfter, L_16);
 1281 |     |             }
 1282 |     | 
 1283 |     |             _checkStakeInvariants();
 1284 |     |         } else {
 1285 |     |             assertRevertReasonNotEqual(returnData, "Panic(17)");
 1286 |     |         }
 1287 |     |     }
 1288 |     | 
 1289 | *   |     function adjustCdp(
 1290 |     |         uint _i,
 1291 |     |         uint _collWithdrawal,
 1292 |     |         uint _EBTCChange,
 1293 |     |         bool _isDebtIncrease
 1294 |     |     ) public setup {
 1295 |     |         bool success;
 1296 | *   |         bytes memory returnData;
 1297 |     | 
 1298 | *   |         uint256 numberOfCdps = sortedCdps.cdpCountOf(address(actor));
 1299 | *   |         require(numberOfCdps > 0, "Actor must have at least one CDP open");
 1300 |     | 
 1301 | *   |         _i = between(_i, 0, numberOfCdps - 1);
 1302 | *   |         bytes32 _cdpId = sortedCdps.cdpOfOwnerByIndex(address(actor), _i);
 1303 | *   |         t(_cdpId != bytes32(0), "CDP ID must not be null if the index is valid");
 1304 |     | 
 1305 | *   |         (uint256 entireDebt, uint256 entireColl) = cdpManager.getSyncedDebtAndCollShares(_cdpId);
 1306 | *   |         _collWithdrawal = between(_collWithdrawal, 0, entireColl);
 1307 | *   |         _EBTCChange = between(_EBTCChange, 0, entireDebt);
 1308 |     | 
 1309 | *   |         _before(_cdpId);
 1310 |     | 
 1311 |     |         (success, returnData) = actor.proxy(
 1312 |     |             address(borrowerOperations),
 1313 |     |             abi.encodeWithSelector(
 1314 |     |                 BorrowerOperations.adjustCdp.selector,
 1315 |     |                 _cdpId,
 1316 |     |                 _collWithdrawal,
 1317 |     |                 _EBTCChange,
 1318 |     |                 _isDebtIncrease,
 1319 |     |                 _cdpId,
 1320 |     |                 _cdpId
 1321 |     |             )
 1322 |     |         );
 1323 |     | 
 1324 |     |         require(success);
 1325 |     | 
 1326 |     |         _after(_cdpId);
 1327 |     | 
 1328 |     |         eq(vars.newTcrAfter, vars.tcrAfter, GENERAL_11);
 1329 |     |         // https://github.com/Badger-Finance/ebtc-fuzz-review/issues/3
 1330 |     |         t(invariant_GENERAL_09(cdpManager, vars), GENERAL_09);
 1331 |     | 
 1332 |     |         t(invariant_GENERAL_01(vars), GENERAL_01);
 1333 |     |         // https://github.com/Badger-Finance/ebtc-fuzz-review/issues/4
 1334 |     |         gte(
 1335 |     |             collateral.getPooledEthByShares(cdpManager.getCdpCollShares(_cdpId)),
 1336 |     |             borrowerOperations.MIN_NET_STETH_BALANCE(),
 1337 |     |             GENERAL_10
 1338 |     |         );
 1339 |     | 
 1340 |     |         if (
 1341 |     |             vars.lastGracePeriodStartTimestampIsSetBefore &&
 1342 |     |             vars.isRecoveryModeBefore &&
 1343 |     |             vars.isRecoveryModeAfter
 1344 |     |         ) {
 1345 |     |             eq(
 1346 |     |                 vars.lastGracePeriodStartTimestampBefore,
 1347 |     |                 vars.lastGracePeriodStartTimestampAfter,
 1348 |     |                 L_14
 1349 |     |             );
 1350 |     |         }
 1351 |     | 
 1352 |     |         _checkL_15IfRecoveryMode();
 1353 |     | 
 1354 |     |         if (vars.isRecoveryModeBefore && !vars.isRecoveryModeAfter) {
 1355 |     |             t(!vars.lastGracePeriodStartTimestampIsSetAfter, L_16);
 1356 |     |         }
 1357 |     | 
 1358 |     |         if (_collWithdrawal > 0) {
 1359 |     |             gte(_collWithdrawal, borrowerOperations.MIN_CHANGE(), GENERAL_16);
 1360 |     |         }
 1361 |     | 
 1362 |     |         if (_isDebtIncrease) {
 1363 |     |             gte(_EBTCChange, borrowerOperations.MIN_CHANGE(), GENERAL_16);
 1364 |     |         } else {
 1365 |     |             // it's ok for _EBTCChange to be 0 if we are not increasing debt (coll only operation)
 1366 |     |             if (_EBTCChange > 0) {
 1367 |     |                 gte(_EBTCChange, borrowerOperations.MIN_CHANGE(), GENERAL_16);
 1368 |     |             }
 1369 |     |         }
 1370 |     |         gte(vars.cdpDebtAfter, borrowerOperations.MIN_CHANGE(), GENERAL_15);
 1371 |     | 
 1372 |     |         _checkStakeInvariants();
 1373 |     |     }
 1374 |     | 
 1375 |     |     ///////////////////////////////////////////////////////
 1376 |     |     // Collateral Token (Test)
 1377 |     |     ///////////////////////////////////////////////////////
 1378 |     | 
 1379 |     |     // Example for real world slashing: https://twitter.com/LidoFinance/status/1646505631678107649
 1380 |     |     // > There are 11 slashing ongoing with the RockLogic GmbH node operator in Lido.
 1381 |     |     // > the total projected impact is around 20 ETH,
 1382 |     |     // > or about 3% of average daily protocol rewards/0.0004% of TVL.
 1383 |     |     function setEthPerShare(uint256 _newEthPerShare) public virtual {
 1384 |     |         uint256 currentEthPerShare = collateral.getEthPerShare();
 1385 |     |         _newEthPerShare = between(
 1386 |     |             _newEthPerShare,
 1387 |     |             (currentEthPerShare * 1e18) / MAX_REBASE_PERCENT,
 1388 |     |             (currentEthPerShare * MAX_REBASE_PERCENT) / 1e18
 1389 |     |         );
 1390 |     |         vars.prevStEthFeeIndex = cdpManager.systemStEthFeePerUnitIndex();
 1391 |     |         collateral.setEthPerShare(_newEthPerShare);
 1392 |     |         AccruableCdpManager(address(cdpManager)).syncGlobalAccountingInternal();
 1393 |     |         vars.afterStEthFeeIndex = cdpManager.systemStEthFeePerUnitIndex();
 1394 |     | 
 1395 |     |         if (vars.afterStEthFeeIndex > vars.prevStEthFeeIndex) {
 1396 |     |             vars.cumulativeCdpsAtTimeOfRebase += cdpManager.getActiveCdpsCount();
 1397 |     |         }
 1398 |     |     }
 1399 |     | 
 1400 |     |     ///////////////////////////////////////////////////////
 1401 |     |     // PriceFeed
 1402 |     |     ///////////////////////////////////////////////////////
 1403 |     | 
 1404 |     |     function setPrice(uint256 _newPrice) public virtual {
 1405 |     |         uint256 currentPrice = priceFeedMock.fetchPrice();
 1406 |     |         _newPrice = between(
 1407 |     |             _newPrice,
 1408 |     |             (currentPrice * 1e18) / MAX_PRICE_CHANGE_PERCENT,
 1409 |     |             (currentPrice * MAX_PRICE_CHANGE_PERCENT) / 1e18
 1410 |     |         );
 1411 |     |         priceFeedMock.setPrice(_newPrice);
 1412 |     |     }
 1413 |     | 
 1414 |     |     ///////////////////////////////////////////////////////
 1415 |     |     // Governance
 1416 |     |     ///////////////////////////////////////////////////////
 1417 |     | 
 1418 |     |     function setGovernanceParameters(uint256 parameter, uint256 value) public virtual {
 1419 |     |         parameter = between(parameter, 0, 6);
 1420 |     | 
 1421 |     |         if (parameter == 0) {
 1422 |     |             value = between(value, cdpManager.MINIMUM_GRACE_PERIOD(), type(uint128).max);
 1423 |     |             hevm.prank(defaultGovernance);
 1424 |     |             cdpManager.setGracePeriod(uint128(value));
 1425 |     |         } else if (parameter == 1) {
 1426 |     |             value = between(value, 0, activePool.getFeeRecipientClaimableCollShares());
 1427 |     |             _before(bytes32(0));
 1428 |     |             hevm.prank(defaultGovernance);
 1429 |     |             activePool.claimFeeRecipientCollShares(value);
 1430 |     |             _after(bytes32(0));
 1431 |     |             // If there was something to claim
 1432 |     |             if (value > 0) {
 1433 |     |                 // https://github.com/Badger-Finance/ebtc-fuzz-review/issues/22
 1434 |     |                 // Claiming will increase the balance
 1435 |     |                 // Strictly GT
 1436 |     |                 gt(vars.feeRecipientCollSharesBalAfter, vars.feeRecipientCollSharesBalBefore, F_01);
 1437 |     |                 gte(vars.feeRecipientTotalCollAfter, vars.feeRecipientTotalCollBefore, F_01);
 1438 |     |             }
 1439 |     |         } else if (parameter == 2) {
 1440 |     |             value = between(value, 0, cdpManager.MAX_REWARD_SPLIT());
 1441 |     |             hevm.prank(defaultGovernance);
 1442 |     |             cdpManager.setStakingRewardSplit(value);
 1443 |     |         } else if (parameter == 3) {
 1444 |     |             value = between(
 1445 |     |                 value,
 1446 |     |                 cdpManager.MIN_REDEMPTION_FEE_FLOOR(),
 1447 |     |                 cdpManager.DECIMAL_PRECISION()
 1448 |     |             );
 1449 |     |             hevm.prank(defaultGovernance);
 1450 |     |             cdpManager.setRedemptionFeeFloor(value);
 1451 |     |         } else if (parameter == 4) {
 1452 |     |             value = between(
 1453 |     |                 value,
 1454 |     |                 cdpManager.MIN_MINUTE_DECAY_FACTOR(),
 1455 |     |                 cdpManager.MAX_MINUTE_DECAY_FACTOR()
 1456 |     |             );
 1457 |     |             hevm.prank(defaultGovernance);
 1458 |     |             cdpManager.setMinuteDecayFactor(value);
 1459 |     |         } else if (parameter == 5) {
 1460 |     |             value = between(value, 0, cdpManager.DECIMAL_PRECISION());
 1461 |     |             hevm.prank(defaultGovernance);
 1462 |     |             cdpManager.setBeta(value);
 1463 |     |         } else if (parameter == 6) {
 1464 |     |             value = between(value, 0, 1);
 1465 |     |             hevm.prank(defaultGovernance);
 1466 |     |             cdpManager.setRedemptionsPaused(value == 1 ? true : false);
 1467 |     |         }
 1468 |     |     }
 1469 |     | }

/mnt/c/Users/Lourens/Documents/Recon-Fuzz/collabs/ebtc/packages/contracts/contracts/TestContracts/invariants/echidna/EchidnaAsserts.sol
  1 |     | pragma solidity 0.8.17;
  2 |     | 
  3 |     | import "@crytic/properties/contracts/util/PropertiesHelper.sol";
  4 |     | import "../Asserts.sol";
  5 |     | 
  6 |     | abstract contract EchidnaAsserts is PropertiesAsserts, Asserts {
  7 | *   |     function gt(uint256 a, uint256 b, string memory message) internal override {
  8 | *   |         assertGt(a, b, message);
  9 |     |     }
 10 |     | 
 11 | *   |     function lt(uint256 a, uint256 b, string memory message) internal override {
 12 | *   |         assertLt(a, b, message);
 13 |     |     }
 14 |     | 
 15 | *   |     function gte(uint256 a, uint256 b, string memory message) internal override {
 16 | *   |         assertGte(a, b, message);
 17 |     |     }
 18 |     | 
 19 | *   |     function lte(uint256 a, uint256 b, string memory message) internal override {
 20 | *   |         assertLte(a, b, message);
 21 |     |     }
 22 |     | 
 23 | *   |     function eq(uint256 a, uint256 b, string memory message) internal override {
 24 | *   |         assertEq(a, b, message);
 25 |     |     }
 26 |     | 
 27 | *   |     function t(bool a, string memory message) internal override {
 28 | *   |         assertWithMsg(a, message);
 29 |     |     }
 30 |     | 
 31 | *   |     function between(uint256 value, uint256 low, uint256 high) internal override returns (uint256) {
 32 | *   |         return clampBetween(value, low, high);
 33 |     |     }
 34 |     | }
 35 |     | 

/mnt/c/Users/Lourens/Documents/Recon-Fuzz/collabs/ebtc/packages/contracts/contracts/TestContracts/invariants/echidna/EchidnaForkAssertions.sol
   1 |     | pragma solidity 0.8.17;
   2 |     | 
   3 |     | import {TargetContractSetup} from "../TargetContractSetup.sol";
   4 |     | import {Properties} from "../Properties.sol";
   5 |     | 
   6 |     | abstract contract EchidnaForkAssertions is TargetContractSetup, Properties {
   7 |     |     function echidna_canary_price() public {
   8 |     |         t(invariant_DUMMY_01(priceFeedMock), "Failed");
   9 |     |     }
  10 |     | 
  11 |     |     function echidna_active_pool_invariant_1() public {
  12 |     |         t(invariant_AP_01(collateral, activePool), "Failed");
  13 |     |     }
  14 |     | 
  15 |     |     function echidna_active_pool_invariant_2() public {
  16 |     |         t(invariant_AP_02(cdpManager, activePool), "Failed");
  17 |     |     }
  18 |     | 
  19 |     |     function echidna_active_pool_invariant_3() public {
  20 |     |         t(invariant_AP_03(eBTCToken, activePool), "Failed");
  21 |     |     }
  22 |     | 
  23 |     |     function echidna_active_pool_invariant_4() public {
  24 |     |         t(invariant_AP_04(cdpManager, activePool, diff_tolerance), "Failed");
  25 |     |     }
  26 |     | 
  27 |     |     function echidna_active_pool_invariant_5() public {
  28 |     |         t(invariant_AP_05(cdpManager, diff_tolerance), "Failed");
  29 |     |     }
  30 |     | 
  31 |     |     function echidna_cdp_manager_invariant_1() public {
  32 |     |         t(invariant_CDPM_01(cdpManager, sortedCdps), "Failed");
  33 |     |     }
  34 |     | 
  35 |     |     function echidna_cdp_manager_invariant_2() public {
  36 |     |         t(invariant_CDPM_02(cdpManager), "Failed");
  37 |     |     }
  38 |     | 
  39 | *   |     function echidna_cdp_manager_invariant_3() public {
  40 | *   |         t(invariant_CDPM_03(cdpManager), "Failed");
  41 |     |     }
  42 |     | 
  43 |     |     function echidna_cdp_manager_invariant_10() public {
  44 |     |         t(invariant_CDPM_10(cdpManager), "Failed");
  45 |     |     }
  46 |     | 
  47 |     |     function echidna_cdp_manager_invariant_11() public {
  48 |     |         t(invariant_CDPM_11(cdpManager), "Failed");
  49 |     |     }
  50 |     | 
  51 |     |     function echidna_cdp_manager_invariant_12() public {
  52 |     |         t(invariant_CDPM_12(sortedCdps, vars), "Failed");
  53 |     |     }
  54 |     | 
  55 |     |     // CDPM_04 is a vars invariant
  56 |     | 
  57 |     |     function echidna_coll_surplus_pool_invariant_1() public {
  58 |     |         t(invariant_CSP_01(collateral, collSurplusPool), "Failed");
  59 |     |     }
  60 |     | 
  61 |     |     function echidna_coll_surplus_pool_invariant_2() public {
  62 |     |         t(invariant_CSP_02(collSurplusPool), "Failed");
  63 |     |     }
  64 |     | 
  65 |     |     function echidna_sorted_list_invariant_1() public {
  66 |     |         t(invariant_SL_01(cdpManager, sortedCdps), "Failed");
  67 |     |     }
  68 |     | 
  69 |     |     function echidna_sorted_list_invariant_2() public {
  70 |     |         t(invariant_SL_02(cdpManager, sortedCdps, priceFeedMock), "Failed");
  71 |     |     }
  72 |     | 
  73 |     |     function echidna_sorted_list_invariant_3() public {
  74 |     |         t(invariant_SL_03(cdpManager, priceFeedMock, sortedCdps), "Failed");
  75 |     |     }
  76 |     | 
  77 |     |     // https://github.com/Badger-Finance/ebtc-fuzz-review/issues/15
  78 |     |     function echidna_sorted_list_invariant_5() public {
  79 |     |         t(invariant_SL_05(crLens, sortedCdps), "Failed");
  80 |     |     }
  81 |     | 
  82 |     |     // invariant_GENERAL_01 is a vars invariant
  83 |     | 
  84 |     |     function echidna_GENERAL_02() public {
  85 |     |         t(invariant_GENERAL_02(cdpManager, priceFeedMock, eBTCToken, collateral), "Failed");
  86 |     |     }
  87 |     | 
  88 |     |     function echidna_GENERAL_03() public {
  89 |     |         t(invariant_GENERAL_03(cdpManager, borrowerOperations, eBTCToken, collateral), "Failed");
  90 |     |     }
  91 |     | 
  92 |     |     function echidna_GENERAL_05() public {
  93 |     |         t(invariant_GENERAL_05(activePool, cdpManager, collateral), "Failed");
  94 |     |     }
  95 |     | 
  96 |     |     function echidna_GENERAL_05_B() public {
  97 |     |         t(invariant_GENERAL_05_B(collSurplusPool, collateral), "Failed");
  98 |     |     }
  99 |     | 
 100 |     |     function echidna_GENERAL_06() public {
 101 |     |         t(invariant_GENERAL_06(eBTCToken, cdpManager, sortedCdps), "Failed");
 102 |     |     }
 103 |     | 
 104 |     |     function echidna_GENERAL_08() public {
 105 |     |         t(invariant_GENERAL_08(cdpManager, sortedCdps, priceFeedMock, collateral), "Failed");
 106 |     |     }
 107 |     | 
 108 |     |     // invariant_GENERAL_09 is a vars
 109 |     | 
 110 |     |     function echidna_GENERAL_12() public {
 111 |     |         t(invariant_GENERAL_12(cdpManager, priceFeedMock, crLens), "Failed");
 112 |     |     }
 113 |     | 
 114 |     |     function echidna_GENERAL_13() public {
 115 |     |         t(invariant_GENERAL_13(crLens, cdpManager, priceFeedMock, sortedCdps), "Failed");
 116 |     |     }
 117 |     | 
 118 |     |     function echidna_GENERAL_14() public {
 119 |     |         t(invariant_GENERAL_14(crLens, cdpManager, sortedCdps), "Failed");
 120 |     |     }
 121 |     | 
 122 |     |     // function echidna_GENERAL_15() public {
 123 |     |     //     t(invariant_GENERAL_15(), "Failed");
 124 |     |     // }
 125 |     | 
 126 |     |     function echidna_GENERAL_17() public {
 127 |     |         t(invariant_GENERAL_17(cdpManager, sortedCdps, priceFeedMock, collateral), "Failed");
 128 |     |     }
 129 |     | 
 130 |     |     // @audit Not testable on fork
 131 |     |     // function echidna_GENERAL_18() public {
 132 |     |     //    t(invariant_GENERAL_18(cdpManager, sortedCdps, priceFeedMock, collateral), "Failed");
 133 |     |     //}
 134 |     | 
 135 |     |     function echidna_GENERAL_19() public {
 136 |     |         t(invariant_GENERAL_19(activePool), "Failed");
 137 |     |     }
 138 |     | 
 139 |     |     function echidna_LS_01() public {
 140 |     |         t(invariant_LS_01(
 141 |     |                 cdpManager,
 142 |     |                 liquidationSequencer,
 143 |     |                 syncedLiquidationSequencer,
 144 |     |                 priceFeedMock
 145 |     |             ), "Failed");
 146 |     |     }
 147 |     | }
 148 |     | 

/mnt/c/Users/Lourens/Documents/Recon-Fuzz/collabs/ebtc/packages/contracts/contracts/TestContracts/invariants/echidna/EchidnaRedemptionForkTester.sol
   1 |     | // SPDX-License-Identifier: MIT
   2 |     | 
   3 |     | pragma solidity 0.8.17;
   4 |     | 
   5 |     | import "./EchidnaAsserts.sol";
   6 |     | import "./EchidnaForkAssertions.sol";
   7 |     | import "../TargetFunctions.sol";
   8 |     | 
   9 |     | // Run locally with: `echidna contracts/TestContracts/invariants/echidna/EchidnaRedemptionForkTester.sol --contract EchidnaRedemptionForkTester --test-mode property --rpc-url YOUR_RPC_URL --config fuzzTests/echidna_config.yaml`
  10 | *r  | contract EchidnaRedemptionForkTester is EchidnaAsserts, EchidnaForkAssertions, TargetFunctions {
  11 |     |     constructor() payable {
  12 |     |         // We perform this check at a specific time
  13 |     |         // 6/27/2024 @ 08:22:47
  14 |     |         hevm.warp(1719476567);
  15 |     |         hevm.roll(20181802);
  16 |     | 
  17 |     |         // https://etherscan.io/tx/0xca4f2e9a7e8cc82969e435091576dbd8c8bfcc008e89906857056481e0542f23
  18 |     |         _setUpFork();
  19 |     |         _setUpActorsFork();
  20 |     | 
  21 |     |         // If the accounting hasn't been synced since the last rebase
  22 |     |         bytes32 currentCdp = sortedCdps.getFirst();
  23 |     | 
  24 |     |         while (currentCdp != bytes32(0)) {
  25 |     |             hevm.prank(address(borrowerOperations));
  26 |     |             cdpManager.syncAccounting(currentCdp);
  27 |     |             currentCdp = sortedCdps.getNext(currentCdp);
  28 |     |         }
  29 |     | 
  30 |     |         // Previous cumulative CDPs per each rebase
  31 |     |         // Will need to be adjusted
  32 |     |         // @audit Need to add the explanation for this - it will definitely not hold forever and is not accurate
  33 |     |         // Affects `invariant_GENERAL_18`
  34 |     |         // This is not going to be reliably testable on fork tests in any case
  35 |     |         vars.cumulativeCdpsAtTimeOfRebase = 200;
  36 |     | 
  37 |     |         // These are the fuzzed parameters
  38 |     |         // @audit We could do a version where the proposed gov transaction is provided and we do it as a low-level call
  39 |     |         hevm.prank(defaultGovernance);
  40 |     |         // First we set the Redemption Fee Floor
  41 |     |         try cdpManager.setRedemptionFeeFloor(25e15) {} catch {
  42 |     |             t(false, "SetRedemptionFeeFloor failed");
  43 |     |         }
  44 |     | 
  45 |     |         hevm.prank(defaultGovernance);
  46 |     |         // We unpause the redemptions 
  47 |     |         try cdpManager.setRedemptionsPaused(false) {} catch {
  48 |     |             t(false, "Redemptions did not unpause successfully");
  49 |     |         }
  50 |     | 
  51 |     |         bool success;
  52 |     |         bytes memory returnData;
  53 |     | 
  54 |     |         // we pass in CCR instead of MCR in case it's the first one
  55 |     |         uint price = priceFeedMock.fetchPrice();
  56 |     | 
  57 |     |         (success, ) = actor.proxy(
  58 |     |             address(collateral),
  59 |     |             abi.encodeWithSelector(
  60 |     |                 CollateralTokenTester.approve.selector,
  61 |     |                 address(borrowerOperations),
  62 |     |                 18e18
  63 |     |             )
  64 |     |         );
  65 |     | 
  66 |     |         t(success, "Approve never fails");
  67 |     | 
  68 |     |         (success, returnData) = actor.proxy(
  69 |     |             address(borrowerOperations),
  70 |     |             abi.encodeWithSelector(
  71 |     |                 BorrowerOperations.openCdp.selector,
  72 |     |                 5e17,
  73 |     |                 bytes32(0),
  74 |     |                 bytes32(0),
  75 |     |                 18e18
  76 |     |             )
  77 |     |         );
  78 |     | 
  79 |     | 
  80 |     |         t(eBTCToken.balanceOf(address(actor)) > 0, "CDP not opened");
  81 |     |     }
  82 |     | 
  83 |     |     // This overrides the PriceOracle's last good price
  84 | *   |     function setPrice(uint256 newPrice) public override {
  85 | *   |         _before(bytes32(0));
  86 |     | 
  87 | *   |         hevm.store(
  88 | *   |             address(priceFeedMock),
  89 | *   |             0x0000000000000000000000000000000000000000000000000000000000000002,
  90 |     |             bytes32(0)
  91 |     |         );
  92 |     | 
  93 |     |         // Load last good price
  94 | *   |         uint256 oldPrice = uint256(
  95 | *   |             hevm.load(
  96 | *   |                 address(priceFeedMock),
  97 |     |                 0x0000000000000000000000000000000000000000000000000000000000000001
  98 |     |             )
  99 |     |         );
 100 |     |         // New Price
 101 | *   |         newPrice = between(
 102 | *   |             newPrice,
 103 | *   |             (oldPrice * 1e18) / MAX_PRICE_CHANGE_PERCENT,
 104 | *   |             (oldPrice * MAX_PRICE_CHANGE_PERCENT) / 1e18
 105 |     |         );
 106 |     | 
 107 |     |         // Set new price by etching last good price
 108 | *   |         hevm.store(
 109 | *   |             address(priceFeedMock),
 110 |     |             0x0000000000000000000000000000000000000000000000000000000000000001,
 111 |     |             bytes32(newPrice)
 112 |     |         );
 113 |     | 
 114 | *   |         cdpManager.syncGlobalAccountingAndGracePeriod();
 115 |     | 
 116 | *   |         _after(bytes32(0));
 117 |     |     }
 118 |     | 
 119 |     |     // Don't need to etch storage, mocking it as a call from default governance should be enough
 120 |     |     // as the timelock logic happens in the TimelockController, and governance params only care about who is the caller
 121 | *   |     function setGovernanceParameters(uint256 parameter, uint256 value) public override {
 122 | *   |         parameter = between(parameter, 0, 6);
 123 |     | 
 124 | *   |         if (parameter == 0) {
 125 | *   |             value = between(value, cdpManager.MINIMUM_GRACE_PERIOD(), type(uint128).max);
 126 | *   |             hevm.prank(defaultGovernance);
 127 | *r  |             cdpManager.setGracePeriod(uint128(value));
 128 | *   |         } else if (parameter == 1) {
 129 | *   |             value = between(value, 0, activePool.getFeeRecipientClaimableCollShares());
 130 | *   |             _before(bytes32(0));
 131 | *   |             hevm.prank(defaultGovernance);
 132 | *   |             activePool.claimFeeRecipientCollShares(value);
 133 | *   |             _after(bytes32(0));
 134 |     |             // If there was something to claim
 135 | *   |             if (value > 0) {
 136 |     |                 // https://github.com/Badger-Finance/ebtc-fuzz-review/issues/22
 137 |     |                 // Claiming will increase the balance
 138 |     |                 // Strictly GT
 139 | *   |                 gt(vars.feeRecipientCollSharesBalAfter, vars.feeRecipientCollSharesBalBefore, F_01);
 140 | *   |                 gte(vars.feeRecipientTotalCollAfter, vars.feeRecipientTotalCollBefore, F_01);
 141 |     |             }
 142 | *   |         } else if (parameter == 2) {
 143 | *   |             value = between(value, 0, cdpManager.MAX_REWARD_SPLIT());
 144 | *   |             hevm.prank(defaultGovernance);
 145 | *   |             cdpManager.setStakingRewardSplit(value);
 146 | *   |         } else if (parameter == 3) {
 147 |     |             // Do not change redemption floor again
 148 | *   |         } else if (parameter == 4) {
 149 | *   |             value = between(
 150 | *   |                 value,
 151 | *   |                 cdpManager.MIN_MINUTE_DECAY_FACTOR(),
 152 | *   |                 cdpManager.MAX_MINUTE_DECAY_FACTOR()
 153 |     |             );
 154 | *   |             hevm.prank(defaultGovernance);
 155 | *   |             cdpManager.setMinuteDecayFactor(value);
 156 | *   |         } else if (parameter == 5) {
 157 | *   |             value = between(value, 0, cdpManager.DECIMAL_PRECISION());
 158 | *   |             hevm.prank(defaultGovernance);
 159 | *   |             cdpManager.setBeta(value);
 160 |     |         } else if (parameter == 6) {
 161 |     |             // Do not set redemptions false again
 162 |     |         }
 163 |     |     }
 164 |     | 
 165 | *   |     function setEthPerShare(uint256 newValue) public override {
 166 | *   |         _before(bytes32(0));
 167 |     |         // Our approach is to to increase the amount of ether without increasing the number of shares
 168 |     |         // We load the bulk share of staked ether, then modify it, then change the value in the slot directly.
 169 | *   |         uint256 oldValue = uint256(
 170 | *   |             hevm.load(
 171 | *   |                 address(collateral),
 172 | *   |                 0xa66d35f054e68143c18f32c990ed5cb972bb68a68f500cd2dd3a16bbf3686483
 173 |     |             )
 174 |     |         );
 175 |     | 
 176 | *   |         newValue = between(
 177 | *   |             newValue,
 178 | *   |             (oldValue * 1e18) / MAX_REBASE_PERCENT,
 179 | *   |             (oldValue * MAX_REBASE_PERCENT) / 1e18
 180 |     |         );
 181 |     | 
 182 | *   |         hevm.store(
 183 | *   |             address(collateral),
 184 | *   |             0xa66d35f054e68143c18f32c990ed5cb972bb68a68f500cd2dd3a16bbf3686483,
 185 |     |             bytes32(newValue)
 186 |     |         );
 187 |     |         cdpManager.syncGlobalAccountingAndGracePeriod();
 188 |     | 
 189 |     |         _after(bytes32(0));
 190 |     |     }
 191 |     | }
 192 |     | 

/mnt/c/Users/Lourens/Documents/Recon-Fuzz/collabs/ebtc/packages/contracts/contracts/TestContracts/testnet/PriceFeedTestnet.sol
   1 |     | // SPDX-License-Identifier: MIT
   2 |     | 
   3 |     | pragma solidity 0.8.17;
   4 |     | 
   5 |     | import "../../Interfaces/IPriceFeed.sol";
   6 |     | import "../../Interfaces/IFallbackCaller.sol";
   7 |     | import "../../Dependencies/Ownable.sol";
   8 |     | import "../../Dependencies/AuthNoOwner.sol";
   9 |     | 
  10 |     | /*
  11 |     |  * PriceFeed placeholder for testnet and development. The price can be manually input or fetched from
  12 |     |    the Fallback's TestNet implementation. Backwards compatible with local test environment as it defaults to use
  13 |     |    the manual price.
  14 |     |  */
  15 |     | contract PriceFeedTestnet is IPriceFeed, Ownable, AuthNoOwner {
  16 |     |     // --- variables ---
  17 |     | 
  18 |     |     uint256 private _price = 7428 * 1e13; // stETH/BTC price == ~15.8118 ETH per BTC
  19 |     |     bool public _useFallback;
  20 |     |     IFallbackCaller public fallbackCaller; // Wrapper contract that calls the Fallback system
  21 |     | 
  22 |     |     constructor(address _authorityAddress) {
  23 |     |         _initializeAuthority(_authorityAddress);
  24 |     |     }
  25 |     | 
  26 |     |     // --- Dependency setters ---
  27 |     | 
  28 |     |     function setAddresses(
  29 |     |         address _priceAggregatorAddress, // Not used but kept for compatibility with deployment script
  30 |     |         address _fallbackCallerAddress,
  31 |     |         address _authorityAddress
  32 |     |     ) external onlyOwner {
  33 |     |         fallbackCaller = IFallbackCaller(_fallbackCallerAddress);
  34 |     | 
  35 |     |         _initializeAuthority(_authorityAddress);
  36 |     | 
  37 |     |         renounceOwnership();
  38 |     |     }
  39 |     | 
  40 |     |     // --- Functions ---
  41 |     | 
  42 |     |     // View price getter for simplicity in tests
  43 |     |     function getPrice() external view returns (uint256) {
  44 |     |         return _price;
  45 |     |     }
  46 |     | 
  47 |     |     function fetchPrice() external override returns (uint256) {
  48 |     |         // Fire an event just like the mainnet version would.
  49 |     |         // This lets the subgraph rely on events to get the latest price even when developing locally.
  50 |     |         if (_useFallback) {
  51 |     |             FallbackResponse memory fallbackResponse = _getCurrentFallbackResponse();
  52 |     |             if (fallbackResponse.success) {
  53 |     |                 _price = fallbackResponse.answer;
  54 |     |             }
  55 |     |         }
  56 |     |         emit LastGoodPriceUpdated(_price);
  57 |     |         return _price;
  58 |     |     }
  59 |     | 
  60 |     |     // Manual external price setter.
  61 |     |     function setPrice(uint256 price) external returns (bool) {
  62 |     |         _price = price;
  63 |     |         return true;
  64 |     |     }
  65 |     | 
  66 |     |     // Manual toggle use of Tellor testnet feed
  67 |     |     function toggleUseFallback() external returns (bool) {
  68 |     |         _useFallback = !_useFallback;
  69 |     |         return _useFallback;
  70 |     |     }
  71 |     | 
  72 |     |     function setFallbackCaller(address _fallbackCaller) external requiresAuth {
  73 |     |         address oldFallbackCaller = address(fallbackCaller);
  74 |     |         fallbackCaller = IFallbackCaller(_fallbackCaller);
  75 |     |         emit FallbackCallerChanged(oldFallbackCaller, _fallbackCaller);
  76 |     |     }
  77 |     | 
  78 |     |     // --- Oracle response wrapper functions ---
  79 |     |     /*
  80 |     |      * "_getCurrentFallbackResponse" fetches stETH/BTC from the Fallback, and returns it as a
  81 |     |      * FallbackResponse struct.
  82 |     |      */
  83 |     |     function _getCurrentFallbackResponse()
  84 |     |         internal
  85 |     |         view
  86 |     |         returns (FallbackResponse memory fallbackResponse)
  87 |     |     {
  88 |     |         uint256 stEthBtcValue;
  89 |     |         uint256 stEthBtcTimestamp;
  90 |     |         bool stEthBtcRetrieved;
  91 |     | 
  92 |     |         // Attempt to get the Fallback's stETH/BTC price
  93 |     |         try fallbackCaller.getFallbackResponse() returns (
  94 |     |             uint256 answer,
  95 |     |             uint256 timestampRetrieved,
  96 |     |             bool success
  97 |     |         ) {
  98 |     |             fallbackResponse.answer = answer;
  99 |     |             fallbackResponse.timestamp = timestampRetrieved;
 100 |     |             fallbackResponse.success = success;
 101 |     |         } catch {
 102 |     |             return (fallbackResponse);
 103 |     |         }
 104 |     |         return (fallbackResponse);
 105 |     |     }
 106 |     | }
 107 |     | 

/mnt/c/Users/Lourens/Documents/Recon-Fuzz/collabs/ebtc/packages/contracts/node_modules/@crytic/properties/contracts/util/Hevm.sol
  1 |     | // SPDX-License-Identifier: Unlicense
  2 |     | pragma solidity ^0.8.0;
  3 |     | 
  4 |     | interface IHevm {
  5 |     |     // Set block.timestamp to newTimestamp
  6 |     |     function warp(uint256 newTimestamp) external;
  7 |     | 
  8 |     |     // Set block.number to newNumber
  9 |     |     function roll(uint256 newNumber) external;
 10 |     | 
 11 |     |     // Loads a storage slot from an address
 12 |     |     function load(address where, bytes32 slot) external returns (bytes32);
 13 |     | 
 14 |     |     // Stores a value to an address' storage slot
 15 |     |     function store(address where, bytes32 slot, bytes32 value) external;
 16 |     | 
 17 |     |     // Signs data (privateKey, digest) => (r, v, s)
 18 |     |     function sign(
 19 |     |         uint256 privateKey,
 20 |     |         bytes32 digest
 21 |     |     ) external returns (uint8 r, bytes32 v, bytes32 s);
 22 |     | 
 23 |     |     // Gets address for a given private key
 24 |     |     function addr(uint256 privateKey) external returns (address addr);
 25 |     | 
 26 |     |     // Performs a foreign function call via terminal
 27 |     |     function ffi(
 28 |     |         string[] calldata inputs
 29 |     |     ) external returns (bytes memory result);
 30 |     | 
 31 |     |     // Performs the next smart contract call with specified `msg.sender`
 32 |     |     function prank(address newSender) external;
 33 |     | }
 34 |     | 
 35 | *   | IHevm constant hevm = IHevm(0x7109709ECfa91a80626fF3989D68f67F5b1DD12D);
 36 |     | 

/mnt/c/Users/Lourens/Documents/Recon-Fuzz/collabs/ebtc/packages/contracts/node_modules/@crytic/properties/contracts/util/PropertiesConstants.sol
  1 |     | pragma solidity ^0.8.0;
  2 |     | 
  3 |     | abstract contract PropertiesConstants {
  4 |     |     // Constant echidna addresses
  5 |     |     address constant USER1 = address(0x10000);
  6 |     |     address constant USER2 = address(0x20000);
  7 |     |     address constant USER3 = address(0x30000);
  8 |     |     uint256 constant INITIAL_BALANCE = 1000e18;
  9 |     | }
 10 |     | 

/mnt/c/Users/Lourens/Documents/Recon-Fuzz/collabs/ebtc/packages/contracts/node_modules/@crytic/properties/contracts/util/PropertiesHelper.sol
   1 |     | pragma solidity ^0.8.0;
   2 |     | 
   3 |     | abstract contract PropertiesAsserts {
   4 |     |     event LogUint256(string, uint256);
   5 |     |     event LogAddress(string, address);
   6 |     |     event LogString(string);
   7 |     | 
   8 |     |     event AssertFail(string);
   9 |     |     event AssertEqFail(string);
  10 |     |     event AssertNeqFail(string);
  11 |     |     event AssertGteFail(string);
  12 |     |     event AssertGtFail(string);
  13 |     |     event AssertLteFail(string);
  14 |     |     event AssertLtFail(string);
  15 |     | 
  16 | *   |     function assertWithMsg(bool b, string memory reason) internal {
  17 | *   |         if (!b) {
  18 |     |             emit AssertFail(reason);
  19 |     |             assert(false);
  20 |     |         }
  21 |     |     }
  22 |     | 
  23 |     |     /// @notice asserts that a is equal to b. Violations are logged using reason.
  24 | *   |     function assertEq(uint256 a, uint256 b, string memory reason) internal {
  25 | *   |         if (a != b) {
  26 |     |             string memory aStr = PropertiesLibString.toString(a);
  27 |     |             string memory bStr = PropertiesLibString.toString(b);
  28 |     |             bytes memory assertMsg = abi.encodePacked(
  29 |     |                 "Invalid: ",
  30 |     |                 aStr,
  31 |     |                 "!=",
  32 |     |                 bStr,
  33 |     |                 ", reason: ",
  34 |     |                 reason
  35 |     |             );
  36 |     |             emit AssertEqFail(string(assertMsg));
  37 |     |             assert(false);
  38 |     |         }
  39 |     |     }
  40 |     | 
  41 |     |     /// @notice int256 version of assertEq
  42 |     |     function assertEq(int256 a, int256 b, string memory reason) internal {
  43 |     |         if (a != b) {
  44 |     |             string memory aStr = PropertiesLibString.toString(a);
  45 |     |             string memory bStr = PropertiesLibString.toString(b);
  46 |     |             bytes memory assertMsg = abi.encodePacked(
  47 |     |                 "Invalid: ",
  48 |     |                 aStr,
  49 |     |                 "!=",
  50 |     |                 bStr,
  51 |     |                 ", reason: ",
  52 |     |                 reason
  53 |     |             );
  54 |     |             emit AssertEqFail(string(assertMsg));
  55 |     |             assert(false);
  56 |     |         }
  57 |     |     }
  58 |     | 
  59 |     |     /// @notice asserts that a is not equal to b. Violations are logged using reason.
  60 |     |     function assertNeq(uint256 a, uint256 b, string memory reason) internal {
  61 |     |         if (a == b) {
  62 |     |             string memory aStr = PropertiesLibString.toString(a);
  63 |     |             string memory bStr = PropertiesLibString.toString(b);
  64 |     |             bytes memory assertMsg = abi.encodePacked(
  65 |     |                 "Invalid: ",
  66 |     |                 aStr,
  67 |     |                 "==",
  68 |     |                 bStr,
  69 |     |                 ", reason: ",
  70 |     |                 reason
  71 |     |             );
  72 |     |             emit AssertNeqFail(string(assertMsg));
  73 |     |             assert(false);
  74 |     |         }
  75 |     |     }
  76 |     | 
  77 |     |     /// @notice int256 version of assertNeq
  78 |     |     function assertNeq(int256 a, int256 b, string memory reason) internal {
  79 |     |         if (a == b) {
  80 |     |             string memory aStr = PropertiesLibString.toString(a);
  81 |     |             string memory bStr = PropertiesLibString.toString(b);
  82 |     |             bytes memory assertMsg = abi.encodePacked(
  83 |     |                 "Invalid: ",
  84 |     |                 aStr,
  85 |     |                 "==",
  86 |     |                 bStr,
  87 |     |                 ", reason: ",
  88 |     |                 reason
  89 |     |             );
  90 |     |             emit AssertNeqFail(string(assertMsg));
  91 |     |             assert(false);
  92 |     |         }
  93 |     |     }
  94 |     | 
  95 |     |     /// @notice asserts that a is greater than or equal to b. Violations are logged using reason.
  96 | *   |     function assertGte(uint256 a, uint256 b, string memory reason) internal {
  97 | *   |         if (!(a >= b)) {
  98 |     |             string memory aStr = PropertiesLibString.toString(a);
  99 |     |             string memory bStr = PropertiesLibString.toString(b);
 100 |     |             bytes memory assertMsg = abi.encodePacked(
 101 |     |                 "Invalid: ",
 102 |     |                 aStr,
 103 |     |                 "<",
 104 |     |                 bStr,
 105 |     |                 " failed, reason: ",
 106 |     |                 reason
 107 |     |             );
 108 |     |             emit AssertGteFail(string(assertMsg));
 109 |     |             assert(false);
 110 |     |         }
 111 |     |     }
 112 |     | 
 113 |     |     /// @notice int256 version of assertGte
 114 |     |     function assertGte(int256 a, int256 b, string memory reason) internal {
 115 |     |         if (!(a >= b)) {
 116 |     |             string memory aStr = PropertiesLibString.toString(a);
 117 |     |             string memory bStr = PropertiesLibString.toString(b);
 118 |     |             bytes memory assertMsg = abi.encodePacked(
 119 |     |                 "Invalid: ",
 120 |     |                 aStr,
 121 |     |                 "<",
 122 |     |                 bStr,
 123 |     |                 " failed, reason: ",
 124 |     |                 reason
 125 |     |             );
 126 |     |             emit AssertGteFail(string(assertMsg));
 127 |     |             assert(false);
 128 |     |         }
 129 |     |     }
 130 |     | 
 131 |     |     /// @notice asserts that a is greater than b. Violations are logged using reason.
 132 | *   |     function assertGt(uint256 a, uint256 b, string memory reason) internal {
 133 | *   |         if (!(a > b)) {
 134 |     |             string memory aStr = PropertiesLibString.toString(a);
 135 |     |             string memory bStr = PropertiesLibString.toString(b);
 136 |     |             bytes memory assertMsg = abi.encodePacked(
 137 |     |                 "Invalid: ",
 138 |     |                 aStr,
 139 |     |                 "<=",
 140 |     |                 bStr,
 141 |     |                 " failed, reason: ",
 142 |     |                 reason
 143 |     |             );
 144 |     |             emit AssertGtFail(string(assertMsg));
 145 |     |             assert(false);
 146 |     |         }
 147 |     |     }
 148 |     | 
 149 |     |     /// @notice int256 version of assertGt
 150 |     |     function assertGt(int256 a, int256 b, string memory reason) internal {
 151 |     |         if (!(a > b)) {
 152 |     |             string memory aStr = PropertiesLibString.toString(a);
 153 |     |             string memory bStr = PropertiesLibString.toString(b);
 154 |     |             bytes memory assertMsg = abi.encodePacked(
 155 |     |                 "Invalid: ",
 156 |     |                 aStr,
 157 |     |                 "<=",
 158 |     |                 bStr,
 159 |     |                 " failed, reason: ",
 160 |     |                 reason
 161 |     |             );
 162 |     |             emit AssertGtFail(string(assertMsg));
 163 |     |             assert(false);
 164 |     |         }
 165 |     |     }
 166 |     | 
 167 |     |     /// @notice asserts that a is less than or equal to b. Violations are logged using reason.
 168 | *   |     function assertLte(uint256 a, uint256 b, string memory reason) internal {
 169 | *   |         if (!(a <= b)) {
 170 |     |             string memory aStr = PropertiesLibString.toString(a);
 171 |     |             string memory bStr = PropertiesLibString.toString(b);
 172 |     |             bytes memory assertMsg = abi.encodePacked(
 173 |     |                 "Invalid: ",
 174 |     |                 aStr,
 175 |     |                 ">",
 176 |     |                 bStr,
 177 |     |                 " failed, reason: ",
 178 |     |                 reason
 179 |     |             );
 180 |     |             emit AssertLteFail(string(assertMsg));
 181 |     |             assert(false);
 182 |     |         }
 183 |     |     }
 184 |     | 
 185 |     |     /// @notice int256 version of assertLte
 186 |     |     function assertLte(int256 a, int256 b, string memory reason) internal {
 187 |     |         if (!(a <= b)) {
 188 |     |             string memory aStr = PropertiesLibString.toString(a);
 189 |     |             string memory bStr = PropertiesLibString.toString(b);
 190 |     |             bytes memory assertMsg = abi.encodePacked(
 191 |     |                 "Invalid: ",
 192 |     |                 aStr,
 193 |     |                 ">",
 194 |     |                 bStr,
 195 |     |                 " failed, reason: ",
 196 |     |                 reason
 197 |     |             );
 198 |     |             emit AssertLteFail(string(assertMsg));
 199 |     |             assert(false);
 200 |     |         }
 201 |     |     }
 202 |     | 
 203 |     |     /// @notice asserts that a is less than b. Violations are logged using reason.
 204 | *   |     function assertLt(uint256 a, uint256 b, string memory reason) internal {
 205 | *   |         if (!(a < b)) {
 206 |     |             string memory aStr = PropertiesLibString.toString(a);
 207 |     |             string memory bStr = PropertiesLibString.toString(b);
 208 |     |             bytes memory assertMsg = abi.encodePacked(
 209 |     |                 "Invalid: ",
 210 |     |                 aStr,
 211 |     |                 ">=",
 212 |     |                 bStr,
 213 |     |                 " failed, reason: ",
 214 |     |                 reason
 215 |     |             );
 216 |     |             emit AssertLtFail(string(assertMsg));
 217 |     |             assert(false);
 218 |     |         }
 219 |     |     }
 220 |     | 
 221 |     |     /// @notice int256 version of assertLt
 222 |     |     function assertLt(int256 a, int256 b, string memory reason) internal {
 223 |     |         if (!(a < b)) {
 224 |     |             string memory aStr = PropertiesLibString.toString(a);
 225 |     |             string memory bStr = PropertiesLibString.toString(b);
 226 |     |             bytes memory assertMsg = abi.encodePacked(
 227 |     |                 "Invalid: ",
 228 |     |                 aStr,
 229 |     |                 ">=",
 230 |     |                 bStr,
 231 |     |                 " failed, reason: ",
 232 |     |                 reason
 233 |     |             );
 234 |     |             emit AssertLtFail(string(assertMsg));
 235 |     |             assert(false);
 236 |     |         }
 237 |     |     }
 238 |     | 
 239 |     |     /// @notice Clamps value to be between low and high, both inclusive
 240 | *   |     function clampBetween(
 241 |     |         uint256 value,
 242 |     |         uint256 low,
 243 |     |         uint256 high
 244 | *   |     ) internal returns (uint256) {
 245 | *   |         if (value < low || value > high) {
 246 | *   |             uint ans = low + (value % (high - low + 1));
 247 | *   |             string memory valueStr = PropertiesLibString.toString(value);
 248 | *   |             string memory ansStr = PropertiesLibString.toString(ans);
 249 | *   |             bytes memory message = abi.encodePacked(
 250 |     |                 "Clamping value ",
 251 | *   |                 valueStr,
 252 |     |                 " to ",
 253 | *   |                 ansStr
 254 |     |             );
 255 | *   |             emit LogString(string(message));
 256 | *   |             return ans;
 257 |     |         }
 258 | *   |         return value;
 259 |     |     }
 260 |     | 
 261 |     |     /// @notice int256 version of clampBetween
 262 |     |     function clampBetween(
 263 |     |         int256 value,
 264 |     |         int256 low,
 265 |     |         int256 high
 266 |     |     ) internal returns (int256) {
 267 |     |         if (value < low || value > high) {
 268 |     |             int range = high - low + 1;
 269 |     |             int clamped = (value - low) % (range);
 270 |     |             if (clamped < 0) clamped += range;
 271 |     |             int ans = low + clamped;
 272 |     |             string memory valueStr = PropertiesLibString.toString(value);
 273 |     |             string memory ansStr = PropertiesLibString.toString(ans);
 274 |     |             bytes memory message = abi.encodePacked(
 275 |     |                 "Clamping value ",
 276 |     |                 valueStr,
 277 |     |                 " to ",
 278 |     |                 ansStr
 279 |     |             );
 280 |     |             emit LogString(string(message));
 281 |     |             return ans;
 282 |     |         }
 283 |     |         return value;
 284 |     |     }
 285 |     | 
 286 |     |     /// @notice clamps a to be less than b
 287 |     |     function clampLt(uint256 a, uint256 b) internal returns (uint256) {
 288 |     |         if (!(a < b)) {
 289 |     |             assertNeq(
 290 |     |                 b,
 291 |     |                 0,
 292 |     |                 "clampLt cannot clamp value a to be less than zero. Check your inputs/assumptions."
 293 |     |             );
 294 |     |             uint256 value = a % b;
 295 |     |             string memory aStr = PropertiesLibString.toString(a);
 296 |     |             string memory valueStr = PropertiesLibString.toString(value);
 297 |     |             bytes memory message = abi.encodePacked(
 298 |     |                 "Clamping value ",
 299 |     |                 aStr,
 300 |     |                 " to ",
 301 |     |                 valueStr
 302 |     |             );
 303 |     |             emit LogString(string(message));
 304 |     |             return value;
 305 |     |         }
 306 |     |         return a;
 307 |     |     }
 308 |     | 
 309 |     |     /// @notice int256 version of clampLt
 310 |     |     function clampLt(int256 a, int256 b) internal returns (int256) {
 311 |     |         if (!(a < b)) {
 312 |     |             int256 value = b - 1;
 313 |     |             string memory aStr = PropertiesLibString.toString(a);
 314 |     |             string memory valueStr = PropertiesLibString.toString(value);
 315 |     |             bytes memory message = abi.encodePacked(
 316 |     |                 "Clamping value ",
 317 |     |                 aStr,
 318 |     |                 " to ",
 319 |     |                 valueStr
 320 |     |             );
 321 |     |             emit LogString(string(message));
 322 |     |             return value;
 323 |     |         }
 324 |     |         return a;
 325 |     |     }
 326 |     | 
 327 |     |     /// @notice clamps a to be less than or equal to b
 328 |     |     function clampLte(uint256 a, uint256 b) internal returns (uint256) {
 329 |     |         if (!(a <= b)) {
 330 |     |             uint256 value = a % (b + 1);
 331 |     |             string memory aStr = PropertiesLibString.toString(a);
 332 |     |             string memory valueStr = PropertiesLibString.toString(value);
 333 |     |             bytes memory message = abi.encodePacked(
 334 |     |                 "Clamping value ",
 335 |     |                 aStr,
 336 |     |                 " to ",
 337 |     |                 valueStr
 338 |     |             );
 339 |     |             emit LogString(string(message));
 340 |     |             return value;
 341 |     |         }
 342 |     |         return a;
 343 |     |     }
 344 |     | 
 345 |     |     /// @notice int256 version of clampLte
 346 |     |     function clampLte(int256 a, int256 b) internal returns (int256) {
 347 |     |         if (!(a <= b)) {
 348 |     |             int256 value = b;
 349 |     |             string memory aStr = PropertiesLibString.toString(a);
 350 |     |             string memory valueStr = PropertiesLibString.toString(value);
 351 |     |             bytes memory message = abi.encodePacked(
 352 |     |                 "Clamping value ",
 353 |     |                 aStr,
 354 |     |                 " to ",
 355 |     |                 valueStr
 356 |     |             );
 357 |     |             emit LogString(string(message));
 358 |     |             return value;
 359 |     |         }
 360 |     |         return a;
 361 |     |     }
 362 |     | 
 363 |     |     /// @notice clamps a to be greater than b
 364 |     |     function clampGt(uint256 a, uint256 b) internal returns (uint256) {
 365 |     |         if (!(a > b)) {
 366 |     |             assertNeq(
 367 |     |                 b,
 368 |     |                 type(uint256).max,
 369 |     |                 "clampGt cannot clamp value a to be larger than uint256.max. Check your inputs/assumptions."
 370 |     |             );
 371 |     |             uint256 value = b + 1;
 372 |     |             string memory aStr = PropertiesLibString.toString(a);
 373 |     |             string memory valueStr = PropertiesLibString.toString(value);
 374 |     |             bytes memory message = abi.encodePacked(
 375 |     |                 "Clamping value ",
 376 |     |                 aStr,
 377 |     |                 " to ",
 378 |     |                 valueStr
 379 |     |             );
 380 |     |             emit LogString(string(message));
 381 |     |             return value;
 382 |     |         } else {
 383 |     |             return a;
 384 |     |         }
 385 |     |     }
 386 |     | 
 387 |     |     /// @notice int256 version of clampGt
 388 |     |     function clampGt(int256 a, int256 b) internal returns (int256) {
 389 |     |         if (!(a > b)) {
 390 |     |             int256 value = b + 1;
 391 |     |             string memory aStr = PropertiesLibString.toString(a);
 392 |     |             string memory valueStr = PropertiesLibString.toString(value);
 393 |     |             bytes memory message = abi.encodePacked(
 394 |     |                 "Clamping value ",
 395 |     |                 aStr,
 396 |     |                 " to ",
 397 |     |                 valueStr
 398 |     |             );
 399 |     |             emit LogString(string(message));
 400 |     |             return value;
 401 |     |         } else {
 402 |     |             return a;
 403 |     |         }
 404 |     |     }
 405 |     | 
 406 |     |     /// @notice clamps a to be greater than or equal to b
 407 |     |     function clampGte(uint256 a, uint256 b) internal returns (uint256) {
 408 |     |         if (!(a > b)) {
 409 |     |             uint256 value = b;
 410 |     |             string memory aStr = PropertiesLibString.toString(a);
 411 |     |             string memory valueStr = PropertiesLibString.toString(value);
 412 |     |             bytes memory message = abi.encodePacked(
 413 |     |                 "Clamping value ",
 414 |     |                 aStr,
 415 |     |                 " to ",
 416 |     |                 valueStr
 417 |     |             );
 418 |     |             emit LogString(string(message));
 419 |     |             return value;
 420 |     |         }
 421 |     |         return a;
 422 |     |     }
 423 |     | 
 424 |     |     /// @notice int256 version of clampGte
 425 |     |     function clampGte(int256 a, int256 b) internal returns (int256) {
 426 |     |         if (!(a > b)) {
 427 |     |             int256 value = b;
 428 |     |             string memory aStr = PropertiesLibString.toString(a);
 429 |     |             string memory valueStr = PropertiesLibString.toString(value);
 430 |     |             bytes memory message = abi.encodePacked(
 431 |     |                 "Clamping value ",
 432 |     |                 aStr,
 433 |     |                 " to ",
 434 |     |                 valueStr
 435 |     |             );
 436 |     |             emit LogString(string(message));
 437 |     |             return value;
 438 |     |         }
 439 |     |         return a;
 440 |     |     }
 441 |     | }
 442 |     | 
 443 |     | /// @notice Efficient library for creating string representations of integers.
 444 |     | /// @author Solmate (https://github.com/transmissions11/solmate/blob/main/src/utils/LibString.sol)
 445 |     | /// @author Modified from Solady (https://github.com/Vectorized/solady/blob/main/src/utils/LibString.sol)
 446 |     | /// @dev Name of the library is modified to prevent collisions with contract-under-test uses of LibString
 447 |     | library PropertiesLibString {
 448 |     |     function toString(int256 value) internal pure returns (string memory str) {
 449 |     |         uint256 absValue = value >= 0 ? uint256(value) : uint256(-value);
 450 |     |         str = toString(absValue);
 451 |     | 
 452 |     |         if (value < 0) {
 453 |     |             str = string(abi.encodePacked("-", str));
 454 |     |         }
 455 |     |     }
 456 |     | 
 457 | *   |     function toString(uint256 value) internal pure returns (string memory str) {
 458 |     |         /// @solidity memory-safe-assembly
 459 |     |         assembly {
 460 |     |             // The maximum value of a uint256 contains 78 digits (1 byte per digit), but we allocate 160 bytes
 461 |     |             // to keep the free memory pointer word aligned. We'll need 1 word for the length, 1 word for the
 462 |     |             // trailing zeros padding, and 3 other words for a max of 78 digits. In total: 5 * 32 = 160 bytes.
 463 | *   |             let newFreeMemoryPointer := add(mload(0x40), 160)
 464 |     | 
 465 |     |             // Update the free memory pointer to avoid overriding our string.
 466 | *   |             mstore(0x40, newFreeMemoryPointer)
 467 |     | 
 468 |     |             // Assign str to the end of the zone of newly allocated memory.
 469 | *   |             str := sub(newFreeMemoryPointer, 32)
 470 |     | 
 471 |     |             // Clean the last word of memory it may not be overwritten.
 472 | *   |             mstore(str, 0)
 473 |     | 
 474 |     |             // Cache the end of the memory to calculate the length later.
 475 | *   |             let end := str
 476 |     | 
 477 |     |             // We write the string from rightmost digit to leftmost digit.
 478 |     |             // The following is essentially a do-while loop that also handles the zero case.
 479 |     |             // prettier-ignore
 480 | *   |             for { let temp := value } 1 {} {
 481 |     |                 // Move the pointer 1 byte to the left.
 482 | *   |                 str := sub(str, 1)
 483 |     | 
 484 |     |                 // Write the character to the pointer.
 485 |     |                 // The ASCII index of the '0' character is 48.
 486 | *   |                 mstore8(str, add(48, mod(temp, 10)))
 487 |     | 
 488 |     |                 // Keep dividing temp until zero.
 489 | *   |                 temp := div(temp, 10)
 490 |     | 
 491 |     |                  // prettier-ignore
 492 | *   |                 if iszero(temp) { break }
 493 |     |             }
 494 |     | 
 495 |     |             // Compute and cache the final total length of the string.
 496 | *   |             let length := sub(end, str)
 497 |     | 
 498 |     |             // Move the pointer 32 bytes leftwards to make room for the length.
 499 | *   |             str := sub(str, 32)
 500 |     | 
 501 |     |             // Store the string's length at the start of memory allocated for our string.
 502 | *   |             mstore(str, length)
 503 |     |         }
 504 |     |     }
 505 |     | 
 506 |     |     function toString(address value) internal pure returns (string memory str) {
 507 |     |         bytes memory s = new bytes(40);
 508 |     |         for (uint i = 0; i < 20; i++) {
 509 |     |             bytes1 b = bytes1(
 510 |     |                 uint8(uint(uint160(value)) / (2 ** (8 * (19 - i))))
 511 |     |             );
 512 |     |             bytes1 hi = bytes1(uint8(b) / 16);
 513 |     |             bytes1 lo = bytes1(uint8(b) - 16 * uint8(hi));
 514 |     |             s[2 * i] = char(hi);
 515 |     |             s[2 * i + 1] = char(lo);
 516 |     |         }
 517 |     |         return string(s);
 518 |     |     }
 519 |     | 
 520 |     |     function char(bytes1 b) internal pure returns (bytes1 c) {
 521 |     |         if (uint8(b) < 10) return bytes1(uint8(b) + 0x30);
 522 |     |         else return bytes1(uint8(b) + 0x57);
 523 |     |     }
 524 |     | }
 525 |     | 

